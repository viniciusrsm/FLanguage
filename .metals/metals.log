2024.07.18 23:23:34 INFO  Started: Metals version 1.3.3 in folders 'C:\Users\Vinicius\UnB\FLanguage' for client Visual Studio Code 1.91.1.
SLF4J(W): Class path contains multiple SLF4J providers.
SLF4J(W): Found provider [scribe.slf4j.ScribeServiceProvider@34f4b768]
SLF4J(W): Found provider [ch.qos.logback.classic.spi.LogbackServiceProvider@2f88e80a]
SLF4J(W): See https://www.slf4j.org/codes.html#multiple_bindings for an explanation.
SLF4J(I): Actual provider is of type [scribe.slf4j.ScribeServiceProvider@34f4b768]
2024.07.18 23:23:35 WARN  Flyway upgrade recommended: H2 2.2.224 is newer than this version of Flyway and support has not been tested. The latest supported version of H2 is 2.2.220.
2024.07.18 23:24:55 INFO  no build target found for C:\Users\Vinicius\UnB\FLanguage\src\main\scala\br\unb\cic\flang\Substitution.scala. Using presentation compiler with project's scala-library version: 3.3.3
jul. 18, 2024 11:24:56 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
ADVERTÊNCIA: Unmatched cancel notification for request id 1
jul. 18, 2024 11:24:56 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
ADVERTÊNCIA: Unmatched cancel notification for request id 5
2024.07.18 23:24:56 INFO  no build target found for C:\Users\Vinicius\UnB\FLanguage\src\main\scala\br\unb\cic\flang\Substitution.scala. Using presentation compiler with project's scala-library version: 3.3.3
2024.07.18 23:24:56 INFO  no build target found for C:\Users\Vinicius\UnB\FLanguage\src\main\scala\br\unb\cic\flang\Monad.scala. Using presentation compiler with project's scala-library version: 3.3.3
jul. 18, 2024 11:24:56 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
ADVERTÊNCIA: Unmatched cancel notification for request id 10
jul. 18, 2024 11:24:56 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
ADVERTÊNCIA: Unmatched cancel notification for request id 7
2024.07.18 23:24:56 INFO  no build target found for C:\Users\Vinicius\UnB\FLanguage\src\main\scala\br\unb\cic\flang\Monad.scala. Using presentation compiler with project's scala-library version: 3.3.3
2024.07.18 23:24:56 INFO  no build target found for C:\Users\Vinicius\UnB\FLanguage\src\main\scala\br\unb\cic\flang\Substitution.scala. Using presentation compiler with project's scala-library version: 3.3.3
2024.07.18 23:24:56 INFO  no build target found for C:\Users\Vinicius\UnB\FLanguage\src\main\scala\br\unb\cic\flang\Substitution.scala. Using presentation compiler with project's scala-library version: 3.3.3
2024.07.18 23:24:57 INFO  no build target found for C:\Users\Vinicius\UnB\FLanguage\src\main\scala\br\unb\cic\flang\Monad.scala. Using presentation compiler with project's scala-library version: 3.3.3
2024.07.18 23:25:36 INFO  no build target found for C:\Users\Vinicius\UnB\FLanguage\src\main\scala\br\unb\cic\flang\Monad.scala. Using presentation compiler with project's scala-library version: 3.3.3
2024.07.18 23:25:37 INFO  no build target found for C:\Users\Vinicius\UnB\FLanguage\src\main\scala\br\unb\cic\flang\Monad.scala. Using presentation compiler with project's scala-library version: 3.3.3
2024.07.18 23:25:38 INFO  no build target found for C:\Users\Vinicius\UnB\FLanguage\src\main\scala\br\unb\cic\flang\Monad.scala. Using presentation compiler with project's scala-library version: 3.3.3
2024.07.18 23:25:48 INFO  no build target found for C:\Users\Vinicius\UnB\FLanguage\src\main\scala\br\unb\cic\flang\Monad.scala. Using presentation compiler with project's scala-library version: 3.3.3
2024.07.18 23:25:49 INFO  no build target found for C:\Users\Vinicius\UnB\FLanguage\src\main\scala\br\unb\cic\flang\Monad.scala. Using presentation compiler with project's scala-library version: 3.3.3
2024.07.18 23:25:49 INFO  no build target found for C:\Users\Vinicius\UnB\FLanguage\src\main\scala\br\unb\cic\flang\Monad.scala. Using presentation compiler with project's scala-library version: 3.3.3
2024.07.18 23:25:49 INFO  no build target found for C:\Users\Vinicius\UnB\FLanguage\src\main\scala\br\unb\cic\flang\Monad.scala. Using presentation compiler with project's scala-library version: 3.3.3
2024.07.18 23:25:49 INFO  no build target found for C:\Users\Vinicius\UnB\FLanguage\src\main\scala\br\unb\cic\flang\Monad.scala. Using presentation compiler with project's scala-library version: 3.3.3
2024.07.18 23:25:50 INFO  no build target found for C:\Users\Vinicius\UnB\FLanguage\src\main\scala\br\unb\cic\flang\Monad.scala. Using presentation compiler with project's scala-library version: 3.3.3
2024.07.18 23:25:50 INFO  no build target found for C:\Users\Vinicius\UnB\FLanguage\src\main\scala\br\unb\cic\flang\Monad.scala. Using presentation compiler with project's scala-library version: 3.3.3
2024.07.18 23:25:50 INFO  no build target found for C:\Users\Vinicius\UnB\FLanguage\src\main\scala\br\unb\cic\flang\Monad.scala. Using presentation compiler with project's scala-library version: 3.3.3
2024.07.18 23:25:50 INFO  no build target found for C:\Users\Vinicius\UnB\FLanguage\src\main\scala\br\unb\cic\flang\Monad.scala. Using presentation compiler with project's scala-library version: 3.3.3
2024.07.18 23:25:52 INFO  no build target found for C:\Users\Vinicius\UnB\FLanguage\src\main\scala\br\unb\cic\flang\Monad.scala. Using presentation compiler with project's scala-library version: 3.3.3
2024.07.18 23:25:52 INFO  no build target found for C:\Users\Vinicius\UnB\FLanguage\src\main\scala\br\unb\cic\flang\Monad.scala. Using presentation compiler with project's scala-library version: 3.3.3
2024.07.18 23:25:52 INFO  no build target found for C:\Users\Vinicius\UnB\FLanguage\src\main\scala\br\unb\cic\flang\Monad.scala. Using presentation compiler with project's scala-library version: 3.3.3
2024.07.18 23:25:52 WARN  no build target for: C:\Users\Vinicius\UnB\FLanguage\src\main\scala\br\unb\cic\flang\Monad.scala
2024.07.18 23:25:52 INFO  no build target found for C:\Users\Vinicius\UnB\FLanguage\src\main\scala\br\unb\cic\flang\Monad.scala. Using presentation compiler with project's scala-library version: 3.3.3
2024.07.18 23:25:52 INFO  no build target found for C:\Users\Vinicius\UnB\FLanguage\src\main\scala\br\unb\cic\flang\Monad.scala. Using presentation compiler with project's scala-library version: 3.3.3
2024.07.18 23:25:54 INFO  no build target found for C:\Users\Vinicius\UnB\FLanguage\src\main\scala\br\unb\cic\flang\Monad.scala. Using presentation compiler with project's scala-library version: 3.3.3
2024.07.18 23:26:01 INFO  no build target found for C:\Users\Vinicius\UnB\FLanguage\src\main\scala\br\unb\cic\flang\Monad.scala. Using presentation compiler with project's scala-library version: 3.3.3
2024.07.18 23:26:12 INFO  no build target found for C:\Users\Vinicius\UnB\FLanguage\src\main\scala\br\unb\cic\flang\Monad.scala. Using presentation compiler with project's scala-library version: 3.3.3
2024.07.18 23:26:12 INFO  no build target found for C:\Users\Vinicius\UnB\FLanguage\src\main\scala\br\unb\cic\flang\Monad.scala. Using presentation compiler with project's scala-library version: 3.3.3
2024.07.18 23:26:12 WARN  Using indexes to guess the definition of runState
2024.07.18 23:26:12 INFO  no build target found for C:\Users\Vinicius\UnB\FLanguage\src\main\scala\br\unb\cic\flang\Monad.scala. Using presentation compiler with project's scala-library version: 3.3.3
2024.07.18 23:26:13 INFO  no build target found for C:\Users\Vinicius\UnB\FLanguage\src\main\scala\br\unb\cic\flang\Monad.scala. Using presentation compiler with project's scala-library version: 3.3.3
2024.07.18 23:26:13 INFO  no build target found for C:\Users\Vinicius\UnB\FLanguage\src\main\scala\br\unb\cic\flang\Monad.scala. Using presentation compiler with project's scala-library version: 3.3.3
2024.07.18 23:26:13 INFO  no build target found for C:\Users\Vinicius\UnB\FLanguage\src\main\scala\br\unb\cic\flang\Monad.scala. Using presentation compiler with project's scala-library version: 3.3.3
2024.07.18 23:26:14 INFO  no build target found for C:\Users\Vinicius\UnB\FLanguage\src\main\scala\br\unb\cic\flang\Monad.scala. Using presentation compiler with project's scala-library version: 3.3.3
2024.07.18 23:26:17 INFO  no build target found for C:\Users\Vinicius\UnB\FLanguage\src\main\scala\br\unb\cic\flang\Monad.scala. Using presentation compiler with project's scala-library version: 3.3.3
2024.07.18 23:26:18 INFO  no build target found for C:\Users\Vinicius\UnB\FLanguage\src\main\scala\br\unb\cic\flang\Monad.scala. Using presentation compiler with project's scala-library version: 3.3.3
2024.07.18 23:26:19 INFO  no build target found for C:\Users\Vinicius\UnB\FLanguage\src\main\scala\br\unb\cic\flang\Monad.scala. Using presentation compiler with project's scala-library version: 3.3.3
2024.07.18 23:26:19 INFO  no build target found for C:\Users\Vinicius\UnB\FLanguage\src\main\scala\br\unb\cic\flang\Monad.scala. Using presentation compiler with project's scala-library version: 3.3.3
2024.07.18 23:26:20 INFO  no build target found for C:\Users\Vinicius\UnB\FLanguage\src\main\scala\br\unb\cic\flang\Monad.scala. Using presentation compiler with project's scala-library version: 3.3.3
2024.07.18 23:26:20 INFO  no build target found for C:\Users\Vinicius\UnB\FLanguage\src\main\scala\br\unb\cic\flang\Monad.scala. Using presentation compiler with project's scala-library version: 3.3.3
2024.07.18 23:26:20 INFO  no build target found for C:\Users\Vinicius\UnB\FLanguage\src\main\scala\br\unb\cic\flang\Monad.scala. Using presentation compiler with project's scala-library version: 3.3.3
2024.07.18 23:26:20 INFO  no build target found for C:\Users\Vinicius\UnB\FLanguage\src\main\scala\br\unb\cic\flang\Monad.scala. Using presentation compiler with project's scala-library version: 3.3.3
2024.07.18 23:26:22 INFO  no build target found for C:\Users\Vinicius\UnB\FLanguage\src\main\scala\br\unb\cic\flang\Monad.scala. Using presentation compiler with project's scala-library version: 3.3.3
2024.07.18 23:26:22 INFO  no build target found for C:\Users\Vinicius\UnB\FLanguage\src\main\scala\br\unb\cic\flang\Monad.scala. Using presentation compiler with project's scala-library version: 3.3.3
2024.07.18 23:26:22 INFO  no build target found for C:\Users\Vinicius\UnB\FLanguage\src\main\scala\br\unb\cic\flang\Monad.scala. Using presentation compiler with project's scala-library version: 3.3.3
2024.07.18 23:26:22 INFO  no build target found for C:\Users\Vinicius\UnB\FLanguage\src\main\scala\br\unb\cic\flang\Monad.scala. Using presentation compiler with project's scala-library version: 3.3.3
2024.07.18 23:26:23 INFO  no build target found for C:\Users\Vinicius\UnB\FLanguage\src\main\scala\br\unb\cic\flang\Monad.scala. Using presentation compiler with project's scala-library version: 3.3.3
2024.07.18 23:26:23 INFO  no build target found for C:\Users\Vinicius\UnB\FLanguage\src\main\scala\br\unb\cic\flang\Monad.scala. Using presentation compiler with project's scala-library version: 3.3.3
2024.07.18 23:26:23 WARN  no build target for: C:\Users\Vinicius\UnB\FLanguage\src\main\scala\br\unb\cic\flang\Monad.scala
2024.07.18 23:26:24 INFO  no build target found for C:\Users\Vinicius\UnB\FLanguage\src\main\scala\br\unb\cic\flang\Monad.scala. Using presentation compiler with project's scala-library version: 3.3.3
2024.07.18 23:26:24 INFO  no build target found for C:\Users\Vinicius\UnB\FLanguage\src\main\scala\br\unb\cic\flang\Monad.scala. Using presentation compiler with project's scala-library version: 3.3.3
2024.07.18 23:26:26 INFO  no build target found for C:\Users\Vinicius\UnB\FLanguage\src\main\scala\br\unb\cic\flang\Monad.scala. Using presentation compiler with project's scala-library version: 3.3.3
2024.07.18 23:26:26 INFO  no build target found for C:\Users\Vinicius\UnB\FLanguage\src\main\scala\br\unb\cic\flang\Monad.scala. Using presentation compiler with project's scala-library version: 3.3.3
2024.07.18 23:26:26 INFO  no build target found for C:\Users\Vinicius\UnB\FLanguage\src\main\scala\br\unb\cic\flang\Monad.scala. Using presentation compiler with project's scala-library version: 3.3.3
2024.07.18 23:26:26 INFO  no build target found for C:\Users\Vinicius\UnB\FLanguage\src\main\scala\br\unb\cic\flang\Monad.scala. Using presentation compiler with project's scala-library version: 3.3.3
2024.07.18 23:26:28 INFO  no build target found for C:\Users\Vinicius\UnB\FLanguage\src\main\scala\br\unb\cic\flang\Monad.scala. Using presentation compiler with project's scala-library version: 3.3.3
2024.07.18 23:26:28 INFO  no build target found for C:\Users\Vinicius\UnB\FLanguage\src\main\scala\br\unb\cic\flang\Monad.scala. Using presentation compiler with project's scala-library version: 3.3.3
2024.07.18 23:26:28 INFO  no build target found for C:\Users\Vinicius\UnB\FLanguage\src\main\scala\br\unb\cic\flang\Monad.scala. Using presentation compiler with project's scala-library version: 3.3.3
2024.07.18 23:26:28 INFO  no build target found for C:\Users\Vinicius\UnB\FLanguage\src\main\scala\br\unb\cic\flang\Monad.scala. Using presentation compiler with project's scala-library version: 3.3.3
2024.07.18 23:26:28 INFO  no build target found for C:\Users\Vinicius\UnB\FLanguage\src\main\scala\br\unb\cic\flang\Monad.scala. Using presentation compiler with project's scala-library version: 3.3.3
2024.07.18 23:26:29 INFO  no build target found for C:\Users\Vinicius\UnB\FLanguage\src\main\scala\br\unb\cic\flang\Monad.scala. Using presentation compiler with project's scala-library version: 3.3.3
2024.07.18 23:26:28 WARN  no build target for: C:\Users\Vinicius\UnB\FLanguage\src\main\scala\br\unb\cic\flang\Monad.scala
2024.07.18 23:26:29 INFO  no build target found for C:\Users\Vinicius\UnB\FLanguage\src\main\scala\br\unb\cic\flang\Monad.scala. Using presentation compiler with project's scala-library version: 3.3.3
2024.07.18 23:26:29 INFO  no build target found for C:\Users\Vinicius\UnB\FLanguage\src\main\scala\br\unb\cic\flang\Monad.scala. Using presentation compiler with project's scala-library version: 3.3.3
2024.07.18 23:26:57 INFO  no build target found for C:\Users\Vinicius\UnB\FLanguage\src\main\scala\br\unb\cic\flang\Monad.scala. Using presentation compiler with project's scala-library version: 3.3.3
2024.07.18 23:26:57 INFO  no build target found for C:\Users\Vinicius\UnB\FLanguage\src\main\scala\br\unb\cic\flang\Monad.scala. Using presentation compiler with project's scala-library version: 3.3.3
2024.07.18 23:26:58 INFO  no build target found for C:\Users\Vinicius\UnB\FLanguage\src\main\scala\br\unb\cic\flang\Monad.scala. Using presentation compiler with project's scala-library version: 3.3.3
2024.07.18 23:26:57 INFO  no build target found for C:\Users\Vinicius\UnB\FLanguage\src\main\scala\br\unb\cic\flang\Monad.scala. Using presentation compiler with project's scala-library version: 3.3.3
2024.07.18 23:26:57 INFO  no build target found for C:\Users\Vinicius\UnB\FLanguage\src\main\scala\br\unb\cic\flang\Monad.scala. Using presentation compiler with project's scala-library version: 3.3.3
2024.07.18 23:26:57 INFO  no build target found for C:\Users\Vinicius\UnB\FLanguage\src\main\scala\br\unb\cic\flang\Monad.scala. Using presentation compiler with project's scala-library version: 3.3.3
2024.07.18 23:26:58 INFO  no build target found for C:\Users\Vinicius\UnB\FLanguage\src\main\scala\br\unb\cic\flang\Monad.scala. Using presentation compiler with project's scala-library version: 3.3.3
2024.07.18 23:26:58 INFO  no build target found for C:\Users\Vinicius\UnB\FLanguage\src\main\scala\br\unb\cic\flang\Monad.scala. Using presentation compiler with project's scala-library version: 3.3.3
2024.07.18 23:26:58 INFO  no build target found for C:\Users\Vinicius\UnB\FLanguage\src\main\scala\br\unb\cic\flang\Monad.scala. Using presentation compiler with project's scala-library version: 3.3.3
2024.07.18 23:26:59 INFO  no build target found for C:\Users\Vinicius\UnB\FLanguage\src\main\scala\br\unb\cic\flang\Monad.scala. Using presentation compiler with project's scala-library version: 3.3.3
2024.07.18 23:26:58 INFO  no build target found for C:\Users\Vinicius\UnB\FLanguage\src\main\scala\br\unb\cic\flang\Monad.scala. Using presentation compiler with project's scala-library version: 3.3.3
2024.07.18 23:26:58 INFO  no build target found for C:\Users\Vinicius\UnB\FLanguage\src\main\scala\br\unb\cic\flang\Monad.scala. Using presentation compiler with project's scala-library version: 3.3.3
2024.07.18 23:26:58 INFO  no build target found for C:\Users\Vinicius\UnB\FLanguage\src\main\scala\br\unb\cic\flang\Monad.scala. Using presentation compiler with project's scala-library version: 3.3.3
2024.07.18 23:26:59 INFO  no build target found for C:\Users\Vinicius\UnB\FLanguage\src\main\scala\br\unb\cic\flang\Monad.scala. Using presentation compiler with project's scala-library version: 3.3.3
2024.07.18 23:26:58 INFO  no build target found for C:\Users\Vinicius\UnB\FLanguage\src\main\scala\br\unb\cic\flang\Monad.scala. Using presentation compiler with project's scala-library version: 3.3.3
2024.07.18 23:26:59 INFO  no build target found for C:\Users\Vinicius\UnB\FLanguage\src\main\scala\br\unb\cic\flang\Monad.scala. Using presentation compiler with project's scala-library version: 3.3.3
2024.07.18 23:26:59 INFO  no build target found for C:\Users\Vinicius\UnB\FLanguage\src\main\scala\br\unb\cic\flang\Monad.scala. Using presentation compiler with project's scala-library version: 3.3.3
2024.07.18 23:26:59 INFO  no build target found for C:\Users\Vinicius\UnB\FLanguage\src\main\scala\br\unb\cic\flang\Monad.scala. Using presentation compiler with project's scala-library version: 3.3.3
2024.07.18 23:27:00 INFO  no build target found for C:\Users\Vinicius\UnB\FLanguage\src\main\scala\br\unb\cic\flang\Monad.scala. Using presentation compiler with project's scala-library version: 3.3.3
2024.07.18 23:27:01 INFO  no build target found for C:\Users\Vinicius\UnB\FLanguage\src\main\scala\br\unb\cic\flang\Monad.scala. Using presentation compiler with project's scala-library version: 3.3.3
2024.07.18 23:27:01 INFO  no build target found for C:\Users\Vinicius\UnB\FLanguage\src\main\scala\br\unb\cic\flang\Monad.scala. Using presentation compiler with project's scala-library version: 3.3.3
2024.07.18 23:27:01 WARN  no build target for: C:\Users\Vinicius\UnB\FLanguage\src\main\scala\br\unb\cic\flang\Monad.scala
2024.07.18 23:27:01 INFO  no build target found for C:\Users\Vinicius\UnB\FLanguage\src\main\scala\br\unb\cic\flang\Monad.scala. Using presentation compiler with project's scala-library version: 3.3.3
2024.07.18 23:27:01 INFO  no build target found for C:\Users\Vinicius\UnB\FLanguage\src\main\scala\br\unb\cic\flang\Monad.scala. Using presentation compiler with project's scala-library version: 3.3.3
2024.07.18 23:27:01 INFO  no build target found for C:\Users\Vinicius\UnB\FLanguage\src\main\scala\br\unb\cic\flang\Monad.scala. Using presentation compiler with project's scala-library version: 3.3.3
2024.07.18 23:27:49 INFO  no build target found for C:\Users\Vinicius\UnB\FLanguage\src\main\scala\br\unb\cic\flang\Monad.scala. Using presentation compiler with project's scala-library version: 3.3.3
2024.07.18 23:28:01 INFO  no build target found for C:\Users\Vinicius\UnB\FLanguage\src\main\scala\br\unb\cic\flang\Monad.scala. Using presentation compiler with project's scala-library version: 3.3.3
2024.07.18 23:28:08 INFO  no build target found for C:\Users\Vinicius\UnB\FLanguage\src\main\scala\br\unb\cic\flang\Monad.scala. Using presentation compiler with project's scala-library version: 3.3.3
2024.07.18 23:28:41 INFO  no build target found for C:\Users\Vinicius\UnB\FLanguage\src\main\scala\br\unb\cic\flang\Monad.scala. Using presentation compiler with project's scala-library version: 3.3.3
2024.07.18 23:28:41 INFO  no build target found for C:\Users\Vinicius\UnB\FLanguage\src\main\scala\br\unb\cic\flang\Monad.scala. Using presentation compiler with project's scala-library version: 3.3.3
2024.07.18 23:28:42 INFO  no build target found for C:\Users\Vinicius\UnB\FLanguage\src\main\scala\br\unb\cic\flang\Monad.scala. Using presentation compiler with project's scala-library version: 3.3.3
2024.07.18 23:28:42 INFO  no build target found for C:\Users\Vinicius\UnB\FLanguage\src\main\scala\br\unb\cic\flang\Monad.scala. Using presentation compiler with project's scala-library version: 3.3.3
2024.07.18 23:28:42 INFO  no build target found for C:\Users\Vinicius\UnB\FLanguage\src\main\scala\br\unb\cic\flang\Monad.scala. Using presentation compiler with project's scala-library version: 3.3.3
2024.07.18 23:28:42 INFO  no build target found for C:\Users\Vinicius\UnB\FLanguage\src\main\scala\br\unb\cic\flang\Monad.scala. Using presentation compiler with project's scala-library version: 3.3.3
2024.07.18 23:28:42 INFO  no build target found for C:\Users\Vinicius\UnB\FLanguage\src\main\scala\br\unb\cic\flang\Monad.scala. Using presentation compiler with project's scala-library version: 3.3.3
2024.07.18 23:28:44 INFO  no build target found for C:\Users\Vinicius\UnB\FLanguage\src\main\scala\br\unb\cic\flang\Monad.scala. Using presentation compiler with project's scala-library version: 3.3.3
2024.07.18 23:28:44 INFO  no build target found for C:\Users\Vinicius\UnB\FLanguage\src\main\scala\br\unb\cic\flang\Monad.scala. Using presentation compiler with project's scala-library version: 3.3.3
2024.07.18 23:28:44 WARN  no build target for: C:\Users\Vinicius\UnB\FLanguage\src\main\scala\br\unb\cic\flang\Monad.scala
2024.07.18 23:28:44 INFO  no build target found for C:\Users\Vinicius\UnB\FLanguage\src\main\scala\br\unb\cic\flang\Monad.scala. Using presentation compiler with project's scala-library version: 3.3.3
2024.07.18 23:28:44 INFO  no build target found for C:\Users\Vinicius\UnB\FLanguage\src\main\scala\br\unb\cic\flang\Monad.scala. Using presentation compiler with project's scala-library version: 3.3.3
2024.07.18 23:28:45 INFO  no build target found for C:\Users\Vinicius\UnB\FLanguage\src\main\scala\br\unb\cic\flang\Monad.scala. Using presentation compiler with project's scala-library version: 3.3.3
2024.07.18 23:28:47 INFO  no build target found for C:\Users\Vinicius\UnB\FLanguage\src\main\scala\br\unb\cic\flang\Monad.scala. Using presentation compiler with project's scala-library version: 3.3.3
2024.07.18 23:28:54 INFO  no build target found for C:\Users\Vinicius\UnB\FLanguage\src\main\scala\br\unb\cic\flang\Monad.scala. Using presentation compiler with project's scala-library version: 3.3.3
2024.07.18 23:28:55 INFO  no build target found for C:\Users\Vinicius\UnB\FLanguage\src\main\scala\br\unb\cic\flang\Monad.scala. Using presentation compiler with project's scala-library version: 3.3.3
2024.07.18 23:29:06 INFO  no build target found for C:\Users\Vinicius\UnB\FLanguage\src\main\scala\br\unb\cic\flang\Monad.scala. Using presentation compiler with project's scala-library version: 3.3.3
2024.07.18 23:29:08 INFO  no build target found for C:\Users\Vinicius\UnB\FLanguage\src\main\scala\br\unb\cic\flang\Monad.scala. Using presentation compiler with project's scala-library version: 3.3.3
2024.07.18 23:29:08 INFO  no build target found for C:\Users\Vinicius\UnB\FLanguage\src\main\scala\br\unb\cic\flang\Monad.scala. Using presentation compiler with project's scala-library version: 3.3.3
2024.07.18 23:29:08 INFO  no build target found for C:\Users\Vinicius\UnB\FLanguage\src\main\scala\br\unb\cic\flang\Monad.scala. Using presentation compiler with project's scala-library version: 3.3.3
2024.07.18 23:29:08 INFO  no build target found for C:\Users\Vinicius\UnB\FLanguage\src\main\scala\br\unb\cic\flang\Monad.scala. Using presentation compiler with project's scala-library version: 3.3.3
2024.07.18 23:29:08 INFO  no build target found for C:\Users\Vinicius\UnB\FLanguage\src\main\scala\br\unb\cic\flang\Monad.scala. Using presentation compiler with project's scala-library version: 3.3.3
2024.07.18 23:29:09 INFO  no build target found for C:\Users\Vinicius\UnB\FLanguage\src\main\scala\br\unb\cic\flang\Monad.scala. Using presentation compiler with project's scala-library version: 3.3.3
2024.07.18 23:29:09 INFO  no build target found for C:\Users\Vinicius\UnB\FLanguage\src\main\scala\br\unb\cic\flang\Monad.scala. Using presentation compiler with project's scala-library version: 3.3.3
2024.07.18 23:29:09 INFO  no build target found for C:\Users\Vinicius\UnB\FLanguage\src\main\scala\br\unb\cic\flang\Monad.scala. Using presentation compiler with project's scala-library version: 3.3.3
2024.07.18 23:29:10 INFO  no build target found for C:\Users\Vinicius\UnB\FLanguage\src\main\scala\br\unb\cic\flang\Monad.scala. Using presentation compiler with project's scala-library version: 3.3.3
2024.07.18 23:29:09 INFO  no build target found for C:\Users\Vinicius\UnB\FLanguage\src\main\scala\br\unb\cic\flang\Monad.scala. Using presentation compiler with project's scala-library version: 3.3.3
2024.07.18 23:29:09 INFO  no build target found for C:\Users\Vinicius\UnB\FLanguage\src\main\scala\br\unb\cic\flang\Monad.scala. Using presentation compiler with project's scala-library version: 3.3.3
2024.07.18 23:29:10 INFO  no build target found for C:\Users\Vinicius\UnB\FLanguage\src\main\scala\br\unb\cic\flang\Monad.scala. Using presentation compiler with project's scala-library version: 3.3.3
2024.07.18 23:29:10 INFO  no build target found for C:\Users\Vinicius\UnB\FLanguage\src\main\scala\br\unb\cic\flang\Monad.scala. Using presentation compiler with project's scala-library version: 3.3.3
2024.07.18 23:29:11 INFO  no build target found for C:\Users\Vinicius\UnB\FLanguage\src\main\scala\br\unb\cic\flang\Monad.scala. Using presentation compiler with project's scala-library version: 3.3.3
2024.07.18 23:29:10 INFO  no build target found for C:\Users\Vinicius\UnB\FLanguage\src\main\scala\br\unb\cic\flang\Monad.scala. Using presentation compiler with project's scala-library version: 3.3.3
2024.07.18 23:29:10 INFO  no build target found for C:\Users\Vinicius\UnB\FLanguage\src\main\scala\br\unb\cic\flang\Monad.scala. Using presentation compiler with project's scala-library version: 3.3.3
2024.07.18 23:29:10 INFO  no build target found for C:\Users\Vinicius\UnB\FLanguage\src\main\scala\br\unb\cic\flang\Monad.scala. Using presentation compiler with project's scala-library version: 3.3.3
2024.07.18 23:29:10 INFO  no build target found for C:\Users\Vinicius\UnB\FLanguage\src\main\scala\br\unb\cic\flang\Monad.scala. Using presentation compiler with project's scala-library version: 3.3.3
2024.07.18 23:29:10 INFO  no build target found for C:\Users\Vinicius\UnB\FLanguage\src\main\scala\br\unb\cic\flang\Monad.scala. Using presentation compiler with project's scala-library version: 3.3.3
2024.07.18 23:29:10 INFO  no build target found for C:\Users\Vinicius\UnB\FLanguage\src\main\scala\br\unb\cic\flang\Monad.scala. Using presentation compiler with project's scala-library version: 3.3.3
2024.07.18 23:29:11 INFO  no build target found for C:\Users\Vinicius\UnB\FLanguage\src\main\scala\br\unb\cic\flang\Monad.scala. Using presentation compiler with project's scala-library version: 3.3.3
2024.07.18 23:29:11 INFO  no build target found for C:\Users\Vinicius\UnB\FLanguage\src\main\scala\br\unb\cic\flang\Monad.scala. Using presentation compiler with project's scala-library version: 3.3.3
2024.07.18 23:29:11 INFO  no build target found for C:\Users\Vinicius\UnB\FLanguage\src\main\scala\br\unb\cic\flang\Monad.scala. Using presentation compiler with project's scala-library version: 3.3.3
2024.07.18 23:29:11 INFO  no build target found for C:\Users\Vinicius\UnB\FLanguage\src\main\scala\br\unb\cic\flang\Monad.scala. Using presentation compiler with project's scala-library version: 3.3.3
2024.07.18 23:29:11 INFO  no build target found for C:\Users\Vinicius\UnB\FLanguage\src\main\scala\br\unb\cic\flang\Monad.scala. Using presentation compiler with project's scala-library version: 3.3.3
2024.07.18 23:29:11 INFO  no build target found for C:\Users\Vinicius\UnB\FLanguage\src\main\scala\br\unb\cic\flang\Monad.scala. Using presentation compiler with project's scala-library version: 3.3.3
2024.07.18 23:29:11 INFO  no build target found for C:\Users\Vinicius\UnB\FLanguage\src\main\scala\br\unb\cic\flang\Monad.scala. Using presentation compiler with project's scala-library version: 3.3.3
2024.07.18 23:29:12 INFO  no build target found for C:\Users\Vinicius\UnB\FLanguage\src\main\scala\br\unb\cic\flang\Monad.scala. Using presentation compiler with project's scala-library version: 3.3.3
2024.07.18 23:29:12 INFO  no build target found for C:\Users\Vinicius\UnB\FLanguage\src\main\scala\br\unb\cic\flang\Monad.scala. Using presentation compiler with project's scala-library version: 3.3.3
2024.07.18 23:29:12 INFO  no build target found for C:\Users\Vinicius\UnB\FLanguage\src\main\scala\br\unb\cic\flang\Monad.scala. Using presentation compiler with project's scala-library version: 3.3.3
2024.07.18 23:29:13 INFO  no build target found for C:\Users\Vinicius\UnB\FLanguage\src\main\scala\br\unb\cic\flang\Monad.scala. Using presentation compiler with project's scala-library version: 3.3.3
2024.07.18 23:29:13 WARN  no build target for: C:\Users\Vinicius\UnB\FLanguage\src\main\scala\br\unb\cic\flang\Monad.scala
2024.07.18 23:29:13 INFO  no build target found for C:\Users\Vinicius\UnB\FLanguage\src\main\scala\br\unb\cic\flang\Monad.scala. Using presentation compiler with project's scala-library version: 3.3.3
2024.07.18 23:29:13 INFO  no build target found for C:\Users\Vinicius\UnB\FLanguage\src\main\scala\br\unb\cic\flang\Monad.scala. Using presentation compiler with project's scala-library version: 3.3.3
2024.07.18 23:29:15 INFO  no build target found for C:\Users\Vinicius\UnB\FLanguage\src\main\scala\br\unb\cic\flang\Monad.scala. Using presentation compiler with project's scala-library version: 3.3.3
2024.07.18 23:29:20 INFO  no build target found for C:\Users\Vinicius\UnB\FLanguage\src\main\scala\br\unb\cic\flang\Monad.scala. Using presentation compiler with project's scala-library version: 3.3.3
2024.07.18 23:29:38 INFO  no build target found for C:\Users\Vinicius\UnB\FLanguage\src\main\scala\br\unb\cic\flang\Monad.scala. Using presentation compiler with project's scala-library version: 3.3.3
2024.07.18 23:29:43 INFO  no build target found for C:\Users\Vinicius\UnB\FLanguage\src\main\scala\br\unb\cic\flang\Monad.scala. Using presentation compiler with project's scala-library version: 3.3.3
2024.07.18 23:29:43 INFO  no build target found for C:\Users\Vinicius\UnB\FLanguage\src\main\scala\br\unb\cic\flang\Monad.scala. Using presentation compiler with project's scala-library version: 3.3.3
2024.07.18 23:29:43 INFO  no build target found for C:\Users\Vinicius\UnB\FLanguage\src\main\scala\br\unb\cic\flang\Monad.scala. Using presentation compiler with project's scala-library version: 3.3.3
2024.07.18 23:29:44 INFO  no build target found for C:\Users\Vinicius\UnB\FLanguage\src\main\scala\br\unb\cic\flang\Monad.scala. Using presentation compiler with project's scala-library version: 3.3.3
2024.07.18 23:29:44 INFO  no build target found for C:\Users\Vinicius\UnB\FLanguage\src\main\scala\br\unb\cic\flang\Monad.scala. Using presentation compiler with project's scala-library version: 3.3.3
2024.07.18 23:29:44 INFO  no build target found for C:\Users\Vinicius\UnB\FLanguage\src\main\scala\br\unb\cic\flang\Monad.scala. Using presentation compiler with project's scala-library version: 3.3.3
2024.07.18 23:29:44 INFO  no build target found for C:\Users\Vinicius\UnB\FLanguage\src\main\scala\br\unb\cic\flang\Monad.scala. Using presentation compiler with project's scala-library version: 3.3.3
2024.07.18 23:29:44 INFO  no build target found for C:\Users\Vinicius\UnB\FLanguage\src\main\scala\br\unb\cic\flang\Monad.scala. Using presentation compiler with project's scala-library version: 3.3.3
2024.07.18 23:29:44 INFO  no build target found for C:\Users\Vinicius\UnB\FLanguage\src\main\scala\br\unb\cic\flang\Monad.scala. Using presentation compiler with project's scala-library version: 3.3.3
2024.07.18 23:29:45 INFO  no build target found for C:\Users\Vinicius\UnB\FLanguage\src\main\scala\br\unb\cic\flang\Monad.scala. Using presentation compiler with project's scala-library version: 3.3.3
2024.07.18 23:29:45 INFO  no build target found for C:\Users\Vinicius\UnB\FLanguage\src\main\scala\br\unb\cic\flang\Monad.scala. Using presentation compiler with project's scala-library version: 3.3.3
2024.07.18 23:29:44 WARN  no build target for: C:\Users\Vinicius\UnB\FLanguage\src\main\scala\br\unb\cic\flang\Monad.scala
2024.07.18 23:29:45 INFO  no build target found for C:\Users\Vinicius\UnB\FLanguage\src\main\scala\br\unb\cic\flang\Monad.scala. Using presentation compiler with project's scala-library version: 3.3.3
2024.07.18 23:29:45 INFO  no build target found for C:\Users\Vinicius\UnB\FLanguage\src\main\scala\br\unb\cic\flang\Monad.scala. Using presentation compiler with project's scala-library version: 3.3.3
2024.07.18 23:29:46 WARN  no build target for: C:\Users\Vinicius\UnB\FLanguage\src\main\scala\br\unb\cic\flang\Monad.scala
2024.07.18 23:29:46 INFO  no build target found for C:\Users\Vinicius\UnB\FLanguage\src\main\scala\br\unb\cic\flang\Monad.scala. Using presentation compiler with project's scala-library version: 3.3.3
2024.07.18 23:29:47 INFO  no build target found for C:\Users\Vinicius\UnB\FLanguage\src\main\scala\br\unb\cic\flang\Monad.scala. Using presentation compiler with project's scala-library version: 3.3.3
2024.07.18 23:30:19 INFO  no build target found for C:\Users\Vinicius\UnB\FLanguage\src\main\scala\br\unb\cic\flang\Monad.scala. Using presentation compiler with project's scala-library version: 3.3.3
2024.07.18 23:30:19 INFO  no build target found for C:\Users\Vinicius\UnB\FLanguage\src\main\scala\br\unb\cic\flang\Monad.scala. Using presentation compiler with project's scala-library version: 3.3.3
2024.07.18 23:30:24 INFO  no build target found for C:\Users\Vinicius\UnB\FLanguage\src\main\scala\br\unb\cic\flang\Monad.scala. Using presentation compiler with project's scala-library version: 3.3.3
2024.07.18 23:30:27 INFO  running 'C:\Users\Vinicius\AppData\Local\Coursier\cache\arc\https\github.com\adoptium\temurin17-binaries\releases\download\jdk-17%252B35\OpenJDK17-jdk_x64_windows_hotspot_17_35.zip\jdk-17+35\bin\java.exe -Djline.terminal=jline.UnsupportedTerminal -Dsbt.log.noformat=true -Dfile.encoding=UTF-8 -jar C:\Users\Vinicius\AppData\Local\Temp\metals12222502702780067096\sbt-launch.jar -Dbloop.export-jar-classifiers=sources bloopInstall'
2024.07.18 23:30:31 INFO  no build target found for C:\Users\Vinicius\UnB\FLanguage\src\main\scala\br\unb\cic\flang\Monad.scala. Using presentation compiler with project's scala-library version: 3.3.3
2024.07.18 23:30:31 INFO  [info] welcome to sbt 1.10.0 (Eclipse Adoptium Java 17)
2024.07.18 23:30:34 INFO  [info] loading settings for project flanguage-build-build-build from metals.sbt ...
2024.07.18 23:30:34 INFO  [info] loading project definition from C:\Users\Vinicius\UnB\FLanguage\project\project\project
2024.07.18 23:30:37 INFO  [info] loading settings for project flanguage-build-build from metals.sbt ...
2024.07.18 23:30:37 INFO  [info] loading project definition from C:\Users\Vinicius\UnB\FLanguage\project\project
2024.07.18 23:30:39 INFO  no build target found for C:\Users\Vinicius\UnB\FLanguage\src\main\scala\br\unb\cic\flang\Monad.scala. Using presentation compiler with project's scala-library version: 3.3.3
2024.07.18 23:30:42 INFO  [success] Generated .bloop\flanguage-build-build.json
2024.07.18 23:30:42 INFO  [success] Total time: 5 s, completed 18 de jul. de 2024 23:30:42
2024.07.18 23:30:44 INFO  [info] loading settings for project flanguage-build from metals.sbt,plugins.sbt ...
2024.07.18 23:30:44 INFO  [info] loading project definition from C:\Users\Vinicius\UnB\FLanguage\project
2024.07.18 23:30:47 INFO  [success] Generated .bloop\flanguage-build.json
2024.07.18 23:30:47 INFO  [success] Total time: 3 s, completed 18 de jul. de 2024 23:30:47
2024.07.18 23:30:49 INFO  [info] loading settings for project root from build.sbt ...
2024.07.18 23:30:49 INFO  [info] set current project to FLanguage (in build file:/C:/Users/Vinicius/UnB/FLanguage/)
2024.07.18 23:30:50 INFO  [success] Generated .bloop\root-test.json
2024.07.18 23:30:50 INFO  [success] Generated .bloop\root.json
2024.07.18 23:30:50 INFO  [success] Total time: 1 s, completed 18 de jul. de 2024 23:30:50
2024.07.18 23:30:50 INFO  time: ran 'sbt bloopInstall' in 22s
2024.07.18 23:30:50 INFO  Attempting to connect to the build server...
2024.07.18 23:30:50 INFO  tracing is disabled for protocol BSP, to enable tracing of incoming and outgoing JSON messages create an empty file at C:\Users\Vinicius\UnB\FLanguage\.metals\bsp.trace.json or C:\Users\Vinicius\AppData\Local\scalameta\metals\cache\bsp.trace.json
2024.07.18 23:30:50 INFO  Attempting to connect to the build server...
2024.07.18 23:30:50 INFO  Attempting to connect to the build server...
2024.07.18 23:30:50 INFO  tracing is disabled for protocol BSP, to enable tracing of incoming and outgoing JSON messages create an empty file at C:\Users\Vinicius\UnB\FLanguage\project\.metals\bsp.trace.json or C:\Users\Vinicius\AppData\Local\scalameta\metals\cache\bsp.trace.json
2024.07.18 23:30:50 INFO  tracing is disabled for protocol BSP, to enable tracing of incoming and outgoing JSON messages create an empty file at C:\Users\Vinicius\UnB\FLanguage\project\project\.metals\bsp.trace.json or C:\Users\Vinicius\AppData\Local\scalameta\metals\cache\bsp.trace.json
2024.07.18 23:30:50 INFO  time: Connected to build server in 0.29s
2024.07.18 23:30:50 INFO  Connected to Build server: Bloop v1.6.0
2024.07.18 23:30:50 INFO  running doctor check
2024.07.18 23:30:50 INFO  java targets: root-test, flanguage-build-build, root, flanguage-build
2024.07.18 23:30:54 WARN  Flyway upgrade recommended: H2 2.2.224 is newer than this version of Flyway and support has not been tested. The latest supported version of H2 is 2.2.220.
2024.07.18 23:31:02 INFO  time: indexed workspace in 11s
2024.07.18 23:31:24 INFO  compiling root (4 scala sources)
2024.07.18 23:31:25 INFO  compiling root-test (1 scala source)
2024.07.18 23:31:25 INFO  time: compiled root in 1.61s
2024.07.18 23:31:25 INFO  time: compiled root-test in 0.54s
2024.07.18 23:31:37 INFO  compiling root (1 scala source)
2024.07.18 23:31:37 INFO  time: compiled root in 0.23s
jul. 18, 2024 11:31:37 PM scala.meta.internal.pc.CompilerAccess retryWithCleanCompiler
INFORMAÇÕES: compiler crashed due to an error in the Scala compiler, retrying with new compiler instance.
jul. 18, 2024 11:31:38 PM scala.meta.internal.pc.CompilerAccess handleError
GRAVE: A severe compiler error occurred, full details of the error can be found in the error report C:\Users\Vinicius\UnB\FLanguage\.metals\.reports\metals-full\2024-07-18\r_compiler-error_(root)_23-31-38-118.md
jul. 18, 2024 11:31:39 PM scala.meta.internal.pc.CompilerAccess retryWithCleanCompiler
INFORMAÇÕES: compiler crashed due to an error in the Scala compiler, retrying with new compiler instance.
jul. 18, 2024 11:31:39 PM scala.meta.internal.pc.CompilerAccess handleError
GRAVE: A severe compiler error occurred, full details of the error can be found in the error report C:\Users\Vinicius\UnB\FLanguage\.metals\.reports\metals-full\2024-07-18\r_compiler-error_(root)_23-31-39-436.md
2024.07.18 23:31:40 INFO  Can not organize imports if file has error
2024.07.18 23:32:00 INFO  compiling root (1 scala source)
2024.07.18 23:32:00 INFO  time: compiled root in 0.89s
2024.07.18 23:32:14 INFO  compiling root (1 scala source)
2024.07.18 23:32:14 INFO  time: compiled root in 0.91s
2024.07.18 23:32:19 INFO  compiling root (5 scala sources)
2024.07.18 23:32:19 INFO  time: compiled root in 0.33s
2024.07.18 23:32:19 INFO  compiling root (5 scala sources)
2024.07.18 23:32:20 WARN  Could not load snapshot text for C:\Users\Vinicius\UnB\FLanguage\src\main\scala\br\unb\cic\flang\Monad.scala
2024.07.18 23:32:19 INFO  time: compiled root in 0.39s
2024.07.18 23:32:21 WARN  Could not load snapshot text for C:\Users\Vinicius\UnB\FLanguage\src\main\scala\br\unb\cic\flang\Monad.scala
2024.07.18 23:32:22 WARN  Could not load snapshot text for C:\Users\Vinicius\UnB\FLanguage\src\main\scala\br\unb\cic\flang\Monad.scala
2024.07.18 23:32:22 WARN  Could not load snapshot text for C:\Users\Vinicius\UnB\FLanguage\src\main\scala\br\unb\cic\flang\Monad.scala
2024.07.18 23:32:22 WARN  Could not load snapshot text for C:\Users\Vinicius\UnB\FLanguage\src\main\scala\br\unb\cic\flang\Monad.scala
2024.07.18 23:32:22 INFO  Can not organize imports if file has error
2024.07.18 23:32:23 INFO  compiling root (5 scala sources)
2024.07.18 23:32:23 INFO  time: compiled root in 0.24s
2024.07.18 23:32:23 WARN  Could not load snapshot text for C:\Users\Vinicius\UnB\FLanguage\src\main\scala\br\unb\cic\flang\Monad.scala
2024.07.18 23:32:26 WARN  Could not load snapshot text for C:\Users\Vinicius\UnB\FLanguage\src\main\scala\br\unb\cic\flang\Interpreter.scala
2024.07.18 23:32:28 WARN  Could not load snapshot text for C:\Users\Vinicius\UnB\FLanguage\src\main\scala\br\unb\cic\flang\Monad.scala
2024.07.18 23:32:34 INFO  time: code lens generation in 2.45s
2024.07.18 23:32:34 INFO  time: code lens generation in 3.73s
2024.07.18 23:32:34 ERROR SemanticDB not found: build.sbt
scala.meta.internal.metals.ScalafixProvider$ScalafixRunException: SemanticDB not found: build.sbt
	at scala.meta.internal.metals.ScalafixProvider.$anonfun$runScalafixRules$2(ScalafixProvider.scala:130)
	at scala.concurrent.impl.Promise$Transformation.run(Promise.scala:470)
	at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.lang.Thread.run(Thread.java:833)

2024.07.18 23:32:36 INFO  compiling root (5 scala sources)
2024.07.18 23:32:36 WARN  Could not load snapshot text for C:\Users\Vinicius\UnB\FLanguage\src\main\scala\br\unb\cic\flang\Monad.scala
2024.07.18 23:32:36 INFO  time: compiled root in 0.29s
2024.07.18 23:32:37 WARN  Could not load snapshot text for C:\Users\Vinicius\UnB\FLanguage\src\main\scala\br\unb\cic\flang\Monad.scala
2024.07.18 23:32:58 INFO  compiling root (5 scala sources)
2024.07.18 23:32:58 WARN  Could not load snapshot text for C:\Users\Vinicius\UnB\FLanguage\src\main\scala\br\unb\cic\flang\Monad.scala
2024.07.18 23:32:58 INFO  time: compiled root in 0.31s
2024.07.18 23:32:59 WARN  Could not load snapshot text for C:\Users\Vinicius\UnB\FLanguage\src\main\scala\br\unb\cic\flang\Monad.scala
2024.07.18 23:33:01 INFO  compiling root (5 scala sources)
2024.07.18 23:33:01 WARN  Could not load snapshot text for C:\Users\Vinicius\UnB\FLanguage\src\main\scala\br\unb\cic\flang\Monad.scala
2024.07.18 23:33:01 INFO  time: compiled root in 0.34s
jul. 18, 2024 11:33:01 PM scala.meta.internal.pc.CompilerAccess retryWithCleanCompiler
INFORMAÇÕES: compiler crashed due to an error in the Scala compiler, retrying with new compiler instance.
2024.07.18 23:33:02 WARN  Could not load snapshot text for C:\Users\Vinicius\UnB\FLanguage\src\main\scala\br\unb\cic\flang\Monad.scala
2024.07.18 23:33:02 INFO  Can not organize imports if file has error
2024.07.18 23:33:02 INFO  compiling root (5 scala sources)
2024.07.18 23:33:02 INFO  time: compiled root in 0.23s
2024.07.18 23:33:02 WARN  Could not load snapshot text for C:\Users\Vinicius\UnB\FLanguage\src\main\scala\br\unb\cic\flang\Monad.scala
2024.07.18 23:33:11 WARN  Could not load snapshot text for C:\Users\Vinicius\UnB\FLanguage\src\main\scala\br\unb\cic\flang\Monad.scala
2024.07.18 23:34:20 INFO  compiling root (5 scala sources)
2024.07.18 23:34:21 WARN  Could not load snapshot text for C:\Users\Vinicius\UnB\FLanguage\src\main\scala\br\unb\cic\flang\Monad.scala
2024.07.18 23:34:20 INFO  time: compiled root in 0.34s
2024.07.18 23:34:21 WARN  Could not load snapshot text for C:\Users\Vinicius\UnB\FLanguage\src\main\scala\br\unb\cic\flang\Monad.scala
2024.07.18 23:34:22 WARN  Could not load snapshot text for C:\Users\Vinicius\UnB\FLanguage\src\main\scala\br\unb\cic\flang\Monad.scala
2024.07.18 23:34:25 INFO  Shutting down server
2024.07.18 23:34:25 INFO  shutting down Metals
2024.07.18 23:34:25 INFO  Shut down connection with build server.
2024.07.18 23:34:25 INFO  Shut down connection with build server.
2024.07.18 23:34:25 INFO  Shut down connection with build server.
2024.07.18 23:34:25 INFO  Exiting server
2024.07.18 23:34:25 ERROR Unexpected error initializing server: 
org.eclipse.lsp4j.jsonrpc.ResponseErrorException: Request window/showMessageRequest failed with message: Canceled
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleResponse(RemoteEndpoint.java:220)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:204)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:185)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:97)
	at org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:114)
	at java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:539)
	at java.util.concurrent.FutureTask.run(FutureTask.java:264)
	at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.lang.Thread.run(Thread.java:833)

2024.07.18 23:34:44 INFO  Started: Metals version 1.3.3 in folders 'C:\Users\Vinicius\UnB\FLanguage' for client Visual Studio Code 1.91.1.
SLF4J(W): Class path contains multiple SLF4J providers.
SLF4J(W): Found provider [scribe.slf4j.ScribeServiceProvider@3e702ce1]
SLF4J(W): Found provider [ch.qos.logback.classic.spi.LogbackServiceProvider@3151a7de]
SLF4J(W): See https://www.slf4j.org/codes.html#multiple_bindings for an explanation.
SLF4J(I): Actual provider is of type [scribe.slf4j.ScribeServiceProvider@3e702ce1]
2024.07.18 23:34:44 WARN  Flyway upgrade recommended: H2 2.2.224 is newer than this version of Flyway and support has not been tested. The latest supported version of H2 is 2.2.220.
2024.07.18 23:34:46 INFO  no build target found for C:\Users\Vinicius\UnB\FLanguage\src\main\scala\br\unb\cic\flang\Monad.scala. Using presentation compiler with project's scala-library version: 3.3.3
2024.07.18 23:34:46 INFO  Attempting to connect to the build server...
2024.07.18 23:34:46 INFO  tracing is disabled for protocol BSP, to enable tracing of incoming and outgoing JSON messages create an empty file at C:\Users\Vinicius\UnB\FLanguage\.metals\bsp.trace.json or C:\Users\Vinicius\AppData\Local\scalameta\metals\cache\bsp.trace.json
2024.07.18 23:34:46 INFO  Attempting to connect to the build server...
2024.07.18 23:34:46 INFO  Attempting to connect to the build server...
2024.07.18 23:34:46 INFO  tracing is disabled for protocol BSP, to enable tracing of incoming and outgoing JSON messages create an empty file at C:\Users\Vinicius\UnB\FLanguage\project\project\.metals\bsp.trace.json or C:\Users\Vinicius\AppData\Local\scalameta\metals\cache\bsp.trace.json
2024.07.18 23:34:47 INFO  tracing is disabled for protocol BSP, to enable tracing of incoming and outgoing JSON messages create an empty file at C:\Users\Vinicius\UnB\FLanguage\project\.metals\bsp.trace.json or C:\Users\Vinicius\AppData\Local\scalameta\metals\cache\bsp.trace.json
2024.07.18 23:34:47 INFO  time: Connected to build server in 0.64s
2024.07.18 23:34:47 INFO  Connected to Build server: Bloop v1.6.0
2024.07.18 23:34:47 INFO  time: Imported build in 0.19s
2024.07.18 23:34:47 INFO  running doctor check
2024.07.18 23:34:47 INFO  java targets: root-test, flanguage-build-build, root, flanguage-build
2024.07.18 23:34:50 WARN  Flyway upgrade recommended: H2 2.2.224 is newer than this version of Flyway and support has not been tested. The latest supported version of H2 is 2.2.220.
2024.07.18 23:34:52 INFO  time: indexed workspace in 4.83s
2024.07.18 23:35:15 INFO  compiling root (5 scala sources)
2024.07.18 23:35:15 INFO  time: compiled root in 0.34s
2024.07.18 23:35:15 INFO  compiling root (5 scala sources)
2024.07.18 23:35:16 WARN  Could not load snapshot text for C:\Users\Vinicius\UnB\FLanguage\src\main\scala\br\unb\cic\flang\Monad.scala
2024.07.18 23:35:16 WARN  Could not load snapshot text for C:\Users\Vinicius\UnB\FLanguage\src\main\scala\br\unb\cic\flang\Monad.scala
2024.07.18 23:35:16 INFO  time: compiled root in 0.4s
2024.07.18 23:35:16 INFO  compiling root (5 scala sources)
2024.07.18 23:35:16 INFO  time: compiled root in 0.3s
2024.07.18 23:35:46 INFO  compiling root (5 scala sources)
2024.07.18 23:35:46 INFO  time: compiled root in 0.38s
2024.07.18 23:35:46 INFO  compiling root (5 scala sources)
2024.07.18 23:35:46 INFO  time: compiled root in 0.25s
2024.07.18 23:35:50 INFO  compiling root (3 scala sources)
2024.07.18 23:35:50 INFO  time: compiled root in 0.29s
2024.07.18 23:35:53 INFO  skipping build import with status 'Installed'
2024.07.18 23:35:53 INFO  Disconnecting from Bloop session...
2024.07.18 23:35:53 INFO  Shut down connection with build server.
2024.07.18 23:35:53 INFO  Shut down connection with build server.
2024.07.18 23:35:53 INFO  Shut down connection with build server.
2024.07.18 23:35:53 INFO  Attempting to connect to the build server...
2024.07.18 23:35:53 INFO  tracing is disabled for protocol BSP, to enable tracing of incoming and outgoing JSON messages create an empty file at C:\Users\Vinicius\UnB\FLanguage\.metals\bsp.trace.json or C:\Users\Vinicius\AppData\Local\scalameta\metals\cache\bsp.trace.json
2024.07.18 23:35:53 INFO  Attempting to connect to the build server...
2024.07.18 23:35:53 INFO  Attempting to connect to the build server...
2024.07.18 23:35:53 INFO  tracing is disabled for protocol BSP, to enable tracing of incoming and outgoing JSON messages create an empty file at C:\Users\Vinicius\UnB\FLanguage\project\.metals\bsp.trace.json or C:\Users\Vinicius\AppData\Local\scalameta\metals\cache\bsp.trace.json
2024.07.18 23:35:53 INFO  tracing is disabled for protocol BSP, to enable tracing of incoming and outgoing JSON messages create an empty file at C:\Users\Vinicius\UnB\FLanguage\project\project\.metals\bsp.trace.json or C:\Users\Vinicius\AppData\Local\scalameta\metals\cache\bsp.trace.json
2024.07.18 23:35:53 INFO  time: Connected to build server in 0.12s
2024.07.18 23:35:53 INFO  Connected to Build server: Bloop v1.6.0
2024.07.18 23:35:53 INFO  running doctor check
2024.07.18 23:35:53 INFO  java targets: root-test, flanguage-build-build, root, flanguage-build
2024.07.18 23:35:57 INFO  time: indexed workspace in 3.24s
2024.07.18 23:36:21 INFO  compiling root (1 scala source)
2024.07.18 23:36:21 INFO  time: compiled root in 0.69s
2024.07.18 23:36:33 INFO  compiling root (1 scala source)
2024.07.18 23:36:33 INFO  time: compiled root in 0.57s
2024.07.18 23:36:39 INFO  compiling root (1 scala source)
2024.07.18 23:36:39 INFO  time: compiled root in 0.49s
jul. 18, 2024 11:36:52 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
ADVERTÊNCIA: Unmatched cancel notification for request id 133
2024.07.18 23:37:43 INFO  compiling root (1 scala source)
2024.07.18 23:37:43 INFO  time: compiled root in 0.61s
2024.07.18 23:37:48 INFO  compiling root (1 scala source)
2024.07.18 23:37:48 INFO  time: compiled root in 0.57s
2024.07.18 23:40:00 INFO  compiling root (1 scala source)
2024.07.18 23:40:00 INFO  time: compiled root in 0.99s
2024.07.18 23:40:06 INFO  compiling root (1 scala source)
2024.07.18 23:40:06 INFO  time: compiled root in 0.91s
jul. 18, 2024 11:40:36 PM org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint notify
INFORMAÇÕES: Unsupported notification method: $/setTrace
2024.07.18 23:40:43 WARN  Target root C:\Users\Vinicius\UnB\FLanguage\.bloop\root\bloop-bsp-clients-classes\classes-Metals-yMfZZnAkRXm36fSHvusOdA== does not exist
2024.07.18 23:40:57 WARN  Target root C:\Users\Vinicius\UnB\FLanguage\.bloop\root\bloop-bsp-clients-classes\classes-Metals-yMfZZnAkRXm36fSHvusOdA== does not exist
2024.07.18 23:41:07 WARN  Target root C:\Users\Vinicius\UnB\FLanguage\.bloop\root\bloop-bsp-clients-classes\classes-Metals-yMfZZnAkRXm36fSHvusOdA== does not exist
2024.07.18 23:41:32 WARN  Target root C:\Users\Vinicius\UnB\FLanguage\.bloop\root\bloop-bsp-clients-classes\classes-Metals-yMfZZnAkRXm36fSHvusOdA== does not exist
2024.07.18 23:41:36 WARN  Target root C:\Users\Vinicius\UnB\FLanguage\.bloop\root\bloop-bsp-clients-classes\classes-Metals-yMfZZnAkRXm36fSHvusOdA== does not exist
2024.07.18 23:41:39 WARN  Target root C:\Users\Vinicius\UnB\FLanguage\.bloop\root\bloop-bsp-clients-classes\classes-Metals-yMfZZnAkRXm36fSHvusOdA== does not exist
2024.07.18 23:41:51 WARN  Target root C:\Users\Vinicius\UnB\FLanguage\.bloop\root\bloop-bsp-clients-classes\classes-Metals-yMfZZnAkRXm36fSHvusOdA== does not exist
2024.07.18 23:41:53 WARN  Target root C:\Users\Vinicius\UnB\FLanguage\.bloop\root\bloop-bsp-clients-classes\classes-Metals-yMfZZnAkRXm36fSHvusOdA== does not exist
2024.07.18 23:42:58 WARN  Target root C:\Users\Vinicius\UnB\FLanguage\.bloop\root\bloop-bsp-clients-classes\classes-Metals-yMfZZnAkRXm36fSHvusOdA== does not exist
2024.07.18 23:45:40 WARN  Target root C:\Users\Vinicius\UnB\FLanguage\.bloop\root\bloop-bsp-clients-classes\classes-Metals-yMfZZnAkRXm36fSHvusOdA== does not exist
2024.07.18 23:45:40 WARN  Target root C:\Users\Vinicius\UnB\FLanguage\.bloop\root\bloop-bsp-clients-classes\classes-Metals-yMfZZnAkRXm36fSHvusOdA== does not exist
2024.07.18 23:45:41 WARN  Target root C:\Users\Vinicius\UnB\FLanguage\.bloop\root\bloop-bsp-clients-classes\classes-Metals-yMfZZnAkRXm36fSHvusOdA== does not exist
jul. 18, 2024 11:45:42 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
ADVERTÊNCIA: Unmatched cancel notification for request id 333
2024.07.18 23:45:42 WARN  Target root C:\Users\Vinicius\UnB\FLanguage\.bloop\root\bloop-bsp-clients-classes\classes-Metals-yMfZZnAkRXm36fSHvusOdA== does not exist
2024.07.18 23:45:43 WARN  Target root C:\Users\Vinicius\UnB\FLanguage\.bloop\root\bloop-bsp-clients-classes\classes-Metals-yMfZZnAkRXm36fSHvusOdA== does not exist
2024.07.18 23:45:43 WARN  Target root C:\Users\Vinicius\UnB\FLanguage\.bloop\root\bloop-bsp-clients-classes\classes-Metals-yMfZZnAkRXm36fSHvusOdA== does not exist
2024.07.18 23:45:43 WARN  Target root C:\Users\Vinicius\UnB\FLanguage\.bloop\root\bloop-bsp-clients-classes\classes-Metals-yMfZZnAkRXm36fSHvusOdA== does not exist
2024.07.18 23:45:44 WARN  Target root C:\Users\Vinicius\UnB\FLanguage\.bloop\root\bloop-bsp-clients-classes\classes-Metals-yMfZZnAkRXm36fSHvusOdA== does not exist
2024.07.18 23:45:47 WARN  Target root C:\Users\Vinicius\UnB\FLanguage\.bloop\root\bloop-bsp-clients-classes\classes-Metals-yMfZZnAkRXm36fSHvusOdA== does not exist
2024.07.18 23:45:48 WARN  Target root C:\Users\Vinicius\UnB\FLanguage\.bloop\root\bloop-bsp-clients-classes\classes-Metals-yMfZZnAkRXm36fSHvusOdA== does not exist
2024.07.18 23:45:53 INFO  running 'C:\Users\Vinicius\AppData\Local\Coursier\cache\arc\https\github.com\adoptium\temurin17-binaries\releases\download\jdk-17%252B35\OpenJDK17-jdk_x64_windows_hotspot_17_35.zip\jdk-17+35\bin\java.exe -Djline.terminal=jline.UnsupportedTerminal -Dsbt.log.noformat=true -Dfile.encoding=UTF-8 -jar C:\Users\Vinicius\AppData\Local\Temp\metals13275290974818000773\sbt-launch.jar -Dbloop.export-jar-classifiers=sources bloopInstall'
2024.07.18 23:45:53 WARN  Target root C:\Users\Vinicius\UnB\FLanguage\.bloop\root\bloop-bsp-clients-classes\classes-Metals-yMfZZnAkRXm36fSHvusOdA== does not exist
2024.07.18 23:45:55 INFO  [info] welcome to sbt 1.10.0 (Eclipse Adoptium Java 17)
2024.07.18 23:45:56 INFO  [info] loading settings for project flanguage-build-build-build from metals.sbt ...
2024.07.18 23:45:56 INFO  [info] loading project definition from C:\Users\Vinicius\UnB\FLanguage\project\project\project
2024.07.18 23:45:58 INFO  [info] loading settings for project flanguage-build-build from metals.sbt ...
2024.07.18 23:45:58 INFO  [info] loading project definition from C:\Users\Vinicius\UnB\FLanguage\project\project
2024.07.18 23:46:01 INFO  [success] Generated .bloop\flanguage-build-build.json
2024.07.18 23:46:01 INFO  [success] Total time: 3 s, completed 18 de jul. de 2024 23:46:01
2024.07.18 23:46:01 INFO  [info] loading settings for project flanguage-build from metals.sbt,plugins.sbt ...
2024.07.18 23:46:01 INFO  [info] loading project definition from C:\Users\Vinicius\UnB\FLanguage\project
2024.07.18 23:46:03 INFO  [success] Generated .bloop\flanguage-build.json
2024.07.18 23:46:03 INFO  [success] Total time: 2 s, completed 18 de jul. de 2024 23:46:03
2024.07.18 23:46:03 INFO  [info] loading settings for project root from build.sbt ...
2024.07.18 23:46:03 INFO  [info] set current project to FLanguage (in build file:/C:/Users/Vinicius/UnB/FLanguage/)
2024.07.18 23:46:05 INFO  [success] Generated .bloop\root.json
2024.07.18 23:46:05 INFO  [success] Generated .bloop\root-test.json
2024.07.18 23:46:05 INFO  [success] Total time: 1 s, completed 18 de jul. de 2024 23:46:05
2024.07.18 23:46:05 INFO  time: ran 'sbt bloopInstall' in 11s
2024.07.18 23:46:05 INFO  Disconnecting from Bloop session...
2024.07.18 23:46:05 INFO  Shut down connection with build server.
2024.07.18 23:46:05 INFO  Shut down connection with build server.
2024.07.18 23:46:05 INFO  Shut down connection with build server.
2024.07.18 23:46:05 INFO  Attempting to connect to the build server...
2024.07.18 23:46:05 INFO  tracing is disabled for protocol BSP, to enable tracing of incoming and outgoing JSON messages create an empty file at C:\Users\Vinicius\UnB\FLanguage\.metals\bsp.trace.json or C:\Users\Vinicius\AppData\Local\scalameta\metals\cache\bsp.trace.json
2024.07.18 23:46:05 INFO  Attempting to connect to the build server...
2024.07.18 23:46:05 INFO  Attempting to connect to the build server...
2024.07.18 23:46:05 INFO  tracing is disabled for protocol BSP, to enable tracing of incoming and outgoing JSON messages create an empty file at C:\Users\Vinicius\UnB\FLanguage\project\project\.metals\bsp.trace.json or C:\Users\Vinicius\AppData\Local\scalameta\metals\cache\bsp.trace.json
2024.07.18 23:46:05 INFO  tracing is disabled for protocol BSP, to enable tracing of incoming and outgoing JSON messages create an empty file at C:\Users\Vinicius\UnB\FLanguage\project\.metals\bsp.trace.json or C:\Users\Vinicius\AppData\Local\scalameta\metals\cache\bsp.trace.json
2024.07.18 23:46:05 INFO  time: Connected to build server in 0.11s
2024.07.18 23:46:05 INFO  Connected to Build server: Bloop v1.6.0
2024.07.18 23:46:05 INFO  running doctor check
2024.07.18 23:46:05 INFO  java targets: root-test, flanguage-build-build, root, flanguage-build
2024.07.18 23:46:08 INFO  time: indexed workspace in 2.9s
2024.07.18 23:46:08 INFO  compiling root (5 scala sources)
2024.07.18 23:46:08 INFO  time: compiled root in 0.26s
jul. 19, 2024 12:04:44 AM scala.meta.internal.pc.CompilerAccess retryWithCleanCompiler
INFORMAÇÕES: compiler crashed due to an error in the Scala compiler, retrying with new compiler instance.
2024.07.19 00:04:50 INFO  Can not organize imports if file has error
2024.07.19 00:04:50 INFO  compiling root (5 scala sources)
2024.07.19 00:04:50 INFO  time: compiled root in 0.22s
2024.07.19 00:04:54 INFO  Can not organize imports if file has error
2024.07.19 00:04:54 INFO  compiling root (5 scala sources)
2024.07.19 00:04:54 INFO  time: compiled root in 0.23s
2024.07.19 00:05:22 INFO  running 'C:\Users\Vinicius\AppData\Local\Coursier\cache\arc\https\github.com\adoptium\temurin17-binaries\releases\download\jdk-17%252B35\OpenJDK17-jdk_x64_windows_hotspot_17_35.zip\jdk-17+35\bin\java.exe -Djline.terminal=jline.UnsupportedTerminal -Dsbt.log.noformat=true -Dfile.encoding=UTF-8 -jar C:\Users\Vinicius\AppData\Local\Temp\metals12172068721441870091\sbt-launch.jar -Dbloop.export-jar-classifiers=sources bloopInstall'
2024.07.19 00:05:24 INFO  [info] welcome to sbt 1.10.0 (Eclipse Adoptium Java 17)
2024.07.19 00:05:25 INFO  [info] loading settings for project flanguage-build-build-build from metals.sbt ...
2024.07.19 00:05:25 INFO  [info] loading project definition from C:\Users\Vinicius\UnB\FLanguage\project\project\project
2024.07.19 00:05:27 INFO  [info] loading settings for project flanguage-build-build from metals.sbt ...
2024.07.19 00:05:27 INFO  [info] loading project definition from C:\Users\Vinicius\UnB\FLanguage\project\project
2024.07.19 00:05:30 INFO  [success] Generated .bloop\flanguage-build-build.json
2024.07.19 00:05:30 INFO  [success] Total time: 3 s, completed 19 de jul. de 2024 00:05:30
2024.07.19 00:05:30 INFO  [info] loading settings for project flanguage-build from metals.sbt,plugins.sbt ...
2024.07.19 00:05:30 INFO  [info] loading project definition from C:\Users\Vinicius\UnB\FLanguage\project
2024.07.19 00:05:32 INFO  [success] Generated .bloop\flanguage-build.json
2024.07.19 00:05:32 INFO  [success] Total time: 2 s, completed 19 de jul. de 2024 00:05:32
2024.07.19 00:05:35 INFO  [info] loading settings for project root from build.sbt ...
2024.07.19 00:05:35 INFO  [info] set current project to FLanguage (in build file:/C:/Users/Vinicius/UnB/FLanguage/)
2024.07.19 00:05:35 INFO  [success] Generated .bloop\root.json
2024.07.19 00:05:35 INFO  [success] Generated .bloop\root-test.json
2024.07.19 00:05:35 INFO  [success] Total time: 1 s, completed 19 de jul. de 2024 00:05:36
2024.07.19 00:05:36 INFO  time: ran 'sbt bloopInstall' in 14s
2024.07.19 00:05:36 INFO  Disconnecting from Bloop session...
2024.07.19 00:05:36 INFO  Shut down connection with build server.
2024.07.19 00:05:36 INFO  Shut down connection with build server.
2024.07.19 00:05:36 INFO  Shut down connection with build server.
2024.07.19 00:05:36 INFO  Attempting to connect to the build server...
2024.07.19 00:05:36 INFO  tracing is disabled for protocol BSP, to enable tracing of incoming and outgoing JSON messages create an empty file at C:\Users\Vinicius\UnB\FLanguage\.metals\bsp.trace.json or C:\Users\Vinicius\AppData\Local\scalameta\metals\cache\bsp.trace.json
2024.07.19 00:05:36 INFO  Attempting to connect to the build server...
2024.07.19 00:05:36 INFO  Attempting to connect to the build server...
2024.07.19 00:05:36 INFO  tracing is disabled for protocol BSP, to enable tracing of incoming and outgoing JSON messages create an empty file at C:\Users\Vinicius\UnB\FLanguage\project\project\.metals\bsp.trace.json or C:\Users\Vinicius\AppData\Local\scalameta\metals\cache\bsp.trace.json
2024.07.19 00:05:36 INFO  tracing is disabled for protocol BSP, to enable tracing of incoming and outgoing JSON messages create an empty file at C:\Users\Vinicius\UnB\FLanguage\project\.metals\bsp.trace.json or C:\Users\Vinicius\AppData\Local\scalameta\metals\cache\bsp.trace.json
2024.07.19 00:05:36 INFO  time: Connected to build server in 91ms
2024.07.19 00:05:36 INFO  Connected to Build server: Bloop v1.6.0
2024.07.19 00:05:36 INFO  running doctor check
2024.07.19 00:05:36 INFO  java targets: root-test, flanguage-build-build, root, flanguage-build
2024.07.19 00:05:41 INFO  compiling root (5 scala sources)
2024.07.19 00:05:41 INFO  time: indexed workspace in 4.45s
2024.07.19 00:05:41 INFO  Deduplicating compilation of root from bsp client 'Metals 1.3.3' (since 4.612s)
2024.07.19 00:05:41 INFO  compiling root (5 scala sources)
2024.07.19 00:05:41 INFO  time: compiled root in 0.14s
2024.07.19 00:05:49 INFO  Can not organize imports if file has error
2024.07.19 00:05:49 INFO  compiling root (5 scala sources)
2024.07.19 00:05:51 INFO  time: compiled root in 2.88s
2024.07.19 00:06:22 INFO  compiling root (1 scala source)
2024.07.19 00:06:22 INFO  time: compiled root in 0.78s
2024.07.19 00:07:23 INFO  compiling root (1 scala source)
2024.07.19 00:07:23 INFO  time: compiled root in 0.79s
2024.07.19 00:07:45 INFO  compiling root (1 scala source)
2024.07.19 00:07:45 INFO  time: compiled root in 0.21s
2024.07.19 00:07:54 INFO  Can not organize imports if file has error
2024.07.19 00:07:54 INFO  compiling root (1 scala source)
2024.07.19 00:07:54 INFO  time: compiled root in 0.2s
2024.07.19 00:07:58 INFO  Can not organize imports if file has error
2024.07.19 00:07:58 INFO  compiling root (1 scala source)
2024.07.19 00:07:58 INFO  time: compiled root in 0.19s
2024.07.19 00:08:28 ERROR Failed to tokenize input for semantic tokens for C:\Users\Vinicius\UnB\FLanguage\src\main\scala\br\unb\cic\flang\MonadState.scala
scala.meta.tokenizers.TokenizeException: <input>:12: error: unclosed character literal
    a.run(List(('')))
                ^
	at scala.meta.internal.tokenizers.Reporter.syntaxError(Reporter.scala:23)
	at scala.meta.internal.tokenizers.Reporter.syntaxError$(Reporter.scala:23)
	at scala.meta.internal.tokenizers.Reporter$$anon$1.syntaxError(Reporter.scala:32)
	at scala.meta.internal.tokenizers.Reporter.syntaxError(Reporter.scala:25)
	at scala.meta.internal.tokenizers.Reporter.syntaxError$(Reporter.scala:25)
	at scala.meta.internal.tokenizers.Reporter$$anon$1.syntaxError(Reporter.scala:32)
	at scala.meta.internal.tokenizers.LegacyScanner.fetchSingleQuote$1(LegacyScanner.scala:391)
	at scala.meta.internal.tokenizers.LegacyScanner.fetchToken(LegacyScanner.scala:395)
	at scala.meta.internal.tokenizers.LegacyScanner.nextToken(LegacyScanner.scala:201)
	at scala.meta.internal.tokenizers.LegacyScanner.foreach(LegacyScanner.scala:912)
	at scala.meta.internal.tokenizers.ScalametaTokenizer.uncachedTokenize(ScalametaTokenizer.scala:23)
	at scala.meta.internal.tokenizers.ScalametaTokenizer.$anonfun$tokenize$1(ScalametaTokenizer.scala:17)
	at scala.collection.concurrent.TrieMap.getOrElseUpdate(TrieMap.scala:960)
	at scala.meta.internal.tokenizers.ScalametaTokenizer.tokenize(ScalametaTokenizer.scala:17)
	at scala.meta.internal.tokenizers.ScalametaTokenizer$$anon$2.apply(ScalametaTokenizer.scala:322)
	at scala.meta.tokenizers.Api$XtensionTokenizeDialectInput.tokenize(Api.scala:22)
	at scala.meta.tokenizers.Api$XtensionTokenizeInputLike.tokenize(Api.scala:13)
	at scala.meta.internal.metals.SemanticTokensProvider$.getTokens(SemanticTokensProvider.scala:30)
	at scala.meta.internal.metals.SemanticTokensProvider$.provide(SemanticTokensProvider.scala:89)
	at scala.meta.internal.metals.Compilers.$anonfun$semanticTokens$3(Compilers.scala:545)
	at scala.concurrent.impl.Promise$Transformation.run(Promise.scala:467)
	at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.lang.Thread.run(Thread.java:833)

2024.07.19 00:08:32 INFO  Can not organize imports if file has error
2024.07.19 00:08:32 INFO  compiling root (1 scala source)
2024.07.19 00:08:32 INFO  time: compiled root in 0.82s
2024.07.19 00:08:42 INFO  compiling root-test (1 scala source)
2024.07.19 00:08:44 INFO  time: compiled root-test in 1.52s
2024.07.19 00:08:59 INFO  compiling root-test (1 scala source)
2024.07.19 00:08:59 INFO  time: compiled root-test in 0.47s
2024.07.19 00:09:01 INFO  compiling root-test (1 scala source)
2024.07.19 00:09:02 INFO  time: compiled root-test in 1.08s
jul. 19, 2024 12:09:13 AM scala.meta.internal.pc.CompilerAccess handleError
GRAVE: A severe compiler error occurred, full details of the error can be found in the error report C:\Users\Vinicius\UnB\FLanguage\.metals\.reports\metals-full\2024-07-19\r_compiler-error_(root-test)_00-09-13-195.md
2024.07.19 00:09:13 ERROR TextDocument.uri not found: src/test/scala/br/unb/cic/flang/MonadTest.scala
scala.meta.internal.metals.ScalafixProvider$ScalafixRunException: TextDocument.uri not found: src/test/scala/br/unb/cic/flang/MonadTest.scala
	at scala.meta.internal.metals.ScalafixProvider.$anonfun$runScalafixRules$2(ScalafixProvider.scala:130)
	at scala.concurrent.impl.Promise$Transformation.run(Promise.scala:470)
	at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.lang.Thread.run(Thread.java:833)

jul. 19, 2024 12:09:13 AM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint fallbackResponseError
GRAVE: Internal error: scala.meta.internal.metals.ScalafixProvider$ScalafixRunException: TextDocument.uri not found: src/test/scala/br/unb/cic/flang/MonadTest.scala
java.util.concurrent.CompletionException: scala.meta.internal.metals.ScalafixProvider$ScalafixRunException: TextDocument.uri not found: src/test/scala/br/unb/cic/flang/MonadTest.scala
	at java.base/java.util.concurrent.CompletableFuture.encodeThrowable(CompletableFuture.java:332)
	at java.base/java.util.concurrent.CompletableFuture.completeThrowable(CompletableFuture.java:347)
	at java.base/java.util.concurrent.CompletableFuture$UniAccept.tryFire(CompletableFuture.java:708)
	at java.base/java.util.concurrent.CompletableFuture.postComplete(CompletableFuture.java:510)
	at java.base/java.util.concurrent.CompletableFuture.completeExceptionally(CompletableFuture.java:2162)
	at scala.meta.internal.metals.CancelTokens$.$anonfun$future$1(CancelTokens.scala:40)
	at scala.meta.internal.metals.CancelTokens$.$anonfun$future$1$adapted(CancelTokens.scala:38)
	at scala.concurrent.impl.Promise$Transformation.run(Promise.scala:484)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.base/java.lang.Thread.run(Thread.java:833)
Caused by: scala.meta.internal.metals.ScalafixProvider$ScalafixRunException: TextDocument.uri not found: src/test/scala/br/unb/cic/flang/MonadTest.scala
	at scala.meta.internal.metals.ScalafixProvider.$anonfun$runScalafixRules$2(ScalafixProvider.scala:130)
	at scala.concurrent.impl.Promise$Transformation.run(Promise.scala:470)
	... 3 more

2024.07.19 00:09:13 INFO  compiling root-test (2 scala sources)
2024.07.19 00:09:13 INFO  time: compiled root-test in 0.15s
2024.07.19 00:09:14 WARN  Could not load snapshot text for C:\Users\Vinicius\UnB\FLanguage\src\test\scala\br\unb\cic\flang\MonadTest.scala
2024.07.19 00:09:14 WARN  Could not load snapshot text for C:\Users\Vinicius\UnB\FLanguage\src\test\scala\br\unb\cic\flang\MonadTest.scala
2024.07.19 00:09:14 WARN  Could not load snapshot text for C:\Users\Vinicius\UnB\FLanguage\src\test\scala\br\unb\cic\flang\MonadTest.scala
2024.07.19 00:09:15 WARN  Could not load snapshot text for C:\Users\Vinicius\UnB\FLanguage\src\test\scala\br\unb\cic\flang\MonadTest.scala
2024.07.19 00:09:15 WARN  Could not load snapshot text for C:\Users\Vinicius\UnB\FLanguage\src\test\scala\br\unb\cic\flang\MonadTest.scala
2024.07.19 00:09:15 WARN  Could not load snapshot text for C:\Users\Vinicius\UnB\FLanguage\src\test\scala\br\unb\cic\flang\MonadTest.scala
2024.07.19 00:09:16 WARN  Could not load snapshot text for C:\Users\Vinicius\UnB\FLanguage\src\test\scala\br\unb\cic\flang\MonadTest.scala
2024.07.19 00:09:16 INFO  Can not organize imports if file has error
2024.07.19 00:09:16 INFO  compiling root-test (2 scala sources)
2024.07.19 00:09:16 INFO  time: compiled root-test in 0.16s
2024.07.19 00:09:17 WARN  Could not load snapshot text for C:\Users\Vinicius\UnB\FLanguage\src\test\scala\br\unb\cic\flang\MonadTest.scala
2024.07.19 00:09:21 WARN  Could not load snapshot text for C:\Users\Vinicius\UnB\FLanguage\src\test\scala\br\unb\cic\flang\MonadTest.scala
2024.07.19 00:09:21 INFO  Can not organize imports if file has error
2024.07.19 00:09:21 INFO  compiling root-test (2 scala sources)
2024.07.19 00:09:21 INFO  time: compiled root-test in 0.19s
2024.07.19 00:09:22 WARN  Could not load snapshot text for C:\Users\Vinicius\UnB\FLanguage\src\test\scala\br\unb\cic\flang\MonadTest.scala
2024.07.19 00:09:24 WARN  Could not load snapshot text for C:\Users\Vinicius\UnB\FLanguage\src\test\scala\br\unb\cic\flang\MonadTest.scala
2024.07.19 00:09:24 WARN  Could not load snapshot text for C:\Users\Vinicius\UnB\FLanguage\src\test\scala\br\unb\cic\flang\MonadTest.scala
2024.07.19 00:09:25 INFO  Can not organize imports if file has error
2024.07.19 00:09:25 INFO  compiling root-test (2 scala sources)
2024.07.19 00:09:25 INFO  time: compiled root-test in 0.27s
2024.07.19 00:09:25 WARN  Could not load snapshot text for C:\Users\Vinicius\UnB\FLanguage\src\test\scala\br\unb\cic\flang\MonadTest.scala
jul. 19, 2024 12:09:30 AM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
ADVERTÊNCIA: Unmatched cancel notification for request id 1054
2024.07.19 00:09:30 INFO  compiling root-test (2 scala sources)
2024.07.19 00:09:30 WARN  Could not load snapshot text for C:\Users\Vinicius\UnB\FLanguage\src\test\scala\br\unb\cic\flang\MonadTest.scala
2024.07.19 00:09:30 WARN  Could not find semantic tokens for: file:///C:/Users/Vinicius/UnB/FLanguage/src/test/scala/br/unb/cic/flang/MonadTest.scala
2024.07.19 00:09:30 INFO  time: compiled root-test in 0.33s
2024.07.19 00:09:30 WARN  Could not load snapshot text for C:\Users\Vinicius\UnB\FLanguage\src\test\scala\br\unb\cic\flang\MonadTest.scala
jul. 19, 2024 12:09:31 AM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
ADVERTÊNCIA: Unmatched cancel notification for request id 1065
jul. 19, 2024 12:09:32 AM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
ADVERTÊNCIA: Unmatched cancel notification for request id 1073
jul. 19, 2024 12:09:33 AM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
ADVERTÊNCIA: Unmatched cancel notification for request id 1082
jul. 19, 2024 12:09:33 AM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
ADVERTÊNCIA: Unmatched cancel notification for request id 1090
jul. 19, 2024 12:09:34 AM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
ADVERTÊNCIA: Unmatched cancel notification for request id 1098
jul. 19, 2024 12:09:35 AM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
ADVERTÊNCIA: Unmatched cancel notification for request id 1106
jul. 19, 2024 12:09:36 AM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
ADVERTÊNCIA: Unmatched cancel notification for request id 1114
2024.07.19 00:09:38 INFO  compiling root (1 scala source)
2024.07.19 00:09:38 INFO  time: compiled root in 0.85s
jul. 19, 2024 12:09:40 AM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
ADVERTÊNCIA: Unmatched cancel notification for request id 1140
2024.07.19 00:09:40 INFO  compiling root-test (2 scala sources)
2024.07.19 00:09:40 WARN  Could not load snapshot text for C:\Users\Vinicius\UnB\FLanguage\src\test\scala\br\unb\cic\flang\MonadTest.scala
2024.07.19 00:09:40 INFO  time: compiled root-test in 0.28s
2024.07.19 00:09:40 WARN  Could not load snapshot text for C:\Users\Vinicius\UnB\FLanguage\src\test\scala\br\unb\cic\flang\MonadTest.scala
2024.07.19 00:09:44 WARN  Could not load snapshot text for C:\Users\Vinicius\UnB\FLanguage\src\test\scala\br\unb\cic\flang\MonadTest.scala
2024.07.19 00:10:01 INFO  compiling root-test (2 scala sources)
2024.07.19 00:10:01 WARN  Could not load snapshot text for C:\Users\Vinicius\UnB\FLanguage\src\test\scala\br\unb\cic\flang\MonadTest.scala
2024.07.19 00:10:01 INFO  time: compiled root-test in 0.35s
2024.07.19 00:10:02 WARN  Could not load snapshot text for C:\Users\Vinicius\UnB\FLanguage\src\test\scala\br\unb\cic\flang\MonadTest.scala
2024.07.19 00:10:18 INFO  compiling root-test (2 scala sources)
2024.07.19 00:10:18 WARN  Could not load snapshot text for C:\Users\Vinicius\UnB\FLanguage\src\test\scala\br\unb\cic\flang\MonadTest.scala
2024.07.19 00:10:18 INFO  time: compiled root-test in 0.43s
2024.07.19 00:10:19 WARN  Could not load snapshot text for C:\Users\Vinicius\UnB\FLanguage\src\test\scala\br\unb\cic\flang\MonadTest.scala
2024.07.19 00:10:20 WARN  Could not load snapshot text for C:\Users\Vinicius\UnB\FLanguage\src\test\scala\br\unb\cic\flang\MonadTest.scala
2024.07.19 00:10:38 INFO  compiling root-test (2 scala sources)
2024.07.19 00:10:38 WARN  Could not load snapshot text for C:\Users\Vinicius\UnB\FLanguage\src\test\scala\br\unb\cic\flang\MonadTest.scala
2024.07.19 00:10:38 INFO  time: compiled root-test in 0.41s
2024.07.19 00:10:39 WARN  Could not load snapshot text for C:\Users\Vinicius\UnB\FLanguage\src\test\scala\br\unb\cic\flang\MonadTest.scala
2024.07.19 00:10:38 WARN  Could not load snapshot text for C:\Users\Vinicius\UnB\FLanguage\src\test\scala\br\unb\cic\flang\MonadTest.scala
jul. 19, 2024 12:10:41 AM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
ADVERTÊNCIA: Unmatched cancel notification for request id 1286
jul. 19, 2024 12:10:42 AM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
ADVERTÊNCIA: Unmatched cancel notification for request id 1294
2024.07.19 00:10:42 INFO  compiling root-test (2 scala sources)
2024.07.19 00:10:42 WARN  Could not load snapshot text for C:\Users\Vinicius\UnB\FLanguage\src\test\scala\br\unb\cic\flang\MonadTest.scala
2024.07.19 00:10:42 INFO  time: compiled root-test in 0.38s
2024.07.19 00:10:43 WARN  Could not load snapshot text for C:\Users\Vinicius\UnB\FLanguage\src\test\scala\br\unb\cic\flang\MonadTest.scala
2024.07.19 00:10:45 WARN  Could not load snapshot text for C:\Users\Vinicius\UnB\FLanguage\src\test\scala\br\unb\cic\flang\MonadTest.scala
2024.07.19 00:10:48 WARN  Could not load snapshot text for C:\Users\Vinicius\UnB\FLanguage\src\test\scala\br\unb\cic\flang\MonadTest.scala
2024.07.19 00:10:49 INFO  Can not organize imports if file has error
2024.07.19 00:10:49 INFO  compiling root-test (2 scala sources)
2024.07.19 00:10:49 INFO  time: compiled root-test in 0.29s
2024.07.19 00:10:49 WARN  Could not load snapshot text for C:\Users\Vinicius\UnB\FLanguage\src\test\scala\br\unb\cic\flang\MonadTest.scala
2024.07.19 00:10:50 WARN  Could not load snapshot text for C:\Users\Vinicius\UnB\FLanguage\src\test\scala\br\unb\cic\flang\MonadTest.scala
2024.07.19 00:10:51 WARN  Could not load snapshot text for C:\Users\Vinicius\UnB\FLanguage\src\test\scala\br\unb\cic\flang\MonadTest.scala
2024.07.19 00:10:52 WARN  Could not load snapshot text for C:\Users\Vinicius\UnB\FLanguage\src\test\scala\br\unb\cic\flang\MonadTest.scala
2024.07.19 00:10:53 WARN  Could not load snapshot text for C:\Users\Vinicius\UnB\FLanguage\src\test\scala\br\unb\cic\flang\MonadTest.scala
2024.07.19 00:10:54 WARN  Could not load snapshot text for C:\Users\Vinicius\UnB\FLanguage\src\test\scala\br\unb\cic\flang\MonadTest.scala
2024.07.19 00:10:55 WARN  Could not load snapshot text for C:\Users\Vinicius\UnB\FLanguage\src\test\scala\br\unb\cic\flang\MonadTest.scala
jul. 19, 2024 12:10:56 AM scala.meta.internal.pc.CompilerAccess retryWithCleanCompiler
INFORMAÇÕES: compiler crashed due to an error in the Scala compiler, retrying with new compiler instance.
2024.07.19 00:10:56 WARN  Could not load snapshot text for C:\Users\Vinicius\UnB\FLanguage\src\test\scala\br\unb\cic\flang\MonadTest.scala
2024.07.19 00:10:57 INFO  Can not organize imports if file has error
jul. 19, 2024 12:10:57 AM scala.meta.internal.pc.CompilerAccess retryWithCleanCompiler
INFORMAÇÕES: compiler crashed due to an error in the Scala compiler, retrying with new compiler instance.
2024.07.19 00:10:57 INFO  compiling root-test (2 scala sources)
jul. 19, 2024 12:10:57 AM scala.meta.internal.pc.CompilerAccess handleError
GRAVE: A severe compiler error occurred, full details of the error can be found in the error report C:\Users\Vinicius\UnB\FLanguage\.metals\.reports\metals-full\2024-07-19\r_compiler-error_(root-test)_00-10-57-464.md
2024.07.19 00:10:57 INFO  time: compiled root-test in 0.33s
2024.07.19 00:10:58 WARN  Could not load snapshot text for C:\Users\Vinicius\UnB\FLanguage\src\test\scala\br\unb\cic\flang\MonadTest.scala
2024.07.19 00:11:02 WARN  Could not load snapshot text for C:\Users\Vinicius\UnB\FLanguage\src\test\scala\br\unb\cic\flang\MonadTest.scala
2024.07.19 00:11:02 INFO  Can not organize imports if file has error
2024.07.19 00:11:02 INFO  compiling root-test (2 scala sources)
2024.07.19 00:11:03 INFO  time: compiled root-test in 1.09s
jul. 19, 2024 12:11:24 AM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
ADVERTÊNCIA: Unmatched cancel notification for request id 1536
jul. 19, 2024 12:11:24 AM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
ADVERTÊNCIA: Unmatched cancel notification for request id 1541
jul. 19, 2024 12:11:24 AM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
ADVERTÊNCIA: Unmatched cancel notification for request id 1550
jul. 19, 2024 12:11:24 AM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
ADVERTÊNCIA: Unmatched cancel notification for request id 1551
2024.07.19 00:11:36 WARN  Using indexes to guess the definition of a
2024.07.19 00:11:37 WARN  Using indexes to guess the definition of a
2024.07.19 00:11:38 INFO  compiling root (1 scala source)
jul. 19, 2024 12:11:39 AM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
ADVERTÊNCIA: Unmatched cancel notification for request id 1611
2024.07.19 00:11:40 INFO  time: compiled root in 1.53s
2024.07.19 00:12:18 INFO  compiling root-test (1 scala source)
2024.07.19 00:12:18 INFO  time: compiled root-test in 0.9s
jul. 19, 2024 12:13:10 AM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
ADVERTÊNCIA: Unmatched cancel notification for request id 1930
jul. 19, 2024 12:13:10 AM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
ADVERTÊNCIA: Unmatched cancel notification for request id 1932
2024.07.19 00:13:10 INFO  compiling root-test (1 scala source)
2024.07.19 00:13:11 INFO  time: compiled root-test in 1.14s
2024.07.19 00:13:21 INFO  compiling root (1 scala source)
2024.07.19 00:13:22 INFO  time: compiled root in 1.19s
jul. 19, 2024 12:13:31 AM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
ADVERTÊNCIA: Unmatched cancel notification for request id 1962
2024.07.19 00:13:47 INFO  compiling root-test (1 scala source)
2024.07.19 00:13:47 INFO  time: compiled root-test in 0.96s
jul. 19, 2024 12:13:57 AM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
ADVERTÊNCIA: Unmatched cancel notification for request id 2030
jul. 19, 2024 12:14:00 AM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
ADVERTÊNCIA: Unmatched cancel notification for request id 2038
jul. 19, 2024 12:15:21 AM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
ADVERTÊNCIA: Unmatched cancel notification for request id 2171
jul. 19, 2024 12:15:22 AM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
ADVERTÊNCIA: Unmatched cancel notification for request id 2179
jul. 19, 2024 12:15:23 AM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
ADVERTÊNCIA: Unmatched cancel notification for request id 2187
jul. 19, 2024 12:15:24 AM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
ADVERTÊNCIA: Unmatched cancel notification for request id 2195
jul. 19, 2024 12:15:26 AM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
ADVERTÊNCIA: Unmatched cancel notification for request id 2203
jul. 19, 2024 12:15:26 AM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
ADVERTÊNCIA: Unmatched cancel notification for request id 2211
jul. 19, 2024 12:15:28 AM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
ADVERTÊNCIA: Unmatched cancel notification for request id 2228
jul. 19, 2024 12:15:30 AM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
ADVERTÊNCIA: Unmatched cancel notification for request id 2236
jul. 19, 2024 12:15:31 AM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
ADVERTÊNCIA: Unmatched cancel notification for request id 2244
jul. 19, 2024 12:15:32 AM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
ADVERTÊNCIA: Unmatched cancel notification for request id 2252
jul. 19, 2024 12:15:32 AM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
ADVERTÊNCIA: Unmatched cancel notification for request id 2260
jul. 19, 2024 12:15:33 AM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
ADVERTÊNCIA: Unmatched cancel notification for request id 2268
jul. 19, 2024 12:15:34 AM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
ADVERTÊNCIA: Unmatched cancel notification for request id 2284
jul. 19, 2024 12:15:35 AM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
ADVERTÊNCIA: Unmatched cancel notification for request id 2292
2024.07.19 00:17:43 INFO  compiling root (1 scala source)
2024.07.19 00:17:43 INFO  time: compiled root in 0.2s
2024.07.19 00:18:01 INFO  Can not organize imports if file has error
2024.07.19 00:18:01 INFO  compiling root (1 scala source)
2024.07.19 00:18:01 INFO  time: compiled root in 0.17s
2024.07.19 00:18:13 INFO  Can not organize imports if file has error
2024.07.19 00:18:13 INFO  compiling root (1 scala source)
2024.07.19 00:18:13 INFO  time: compiled root in 0.85s
2024.07.19 00:19:09 INFO  compiling root (1 scala source)
2024.07.19 00:19:09 INFO  time: compiled root in 0.18s
2024.07.19 00:19:10 INFO  Can not organize imports if file has error
2024.07.19 00:19:24 INFO  compiling root (1 scala source)
2024.07.19 00:19:24 INFO  time: compiled root in 0.19s
2024.07.19 00:19:26 INFO  Can not organize imports if file has error
2024.07.19 00:19:27 INFO  compiling root (1 scala source)
2024.07.19 00:19:27 INFO  time: compiled root in 0.16s
2024.07.19 00:19:29 INFO  Can not organize imports if file has error
2024.07.19 00:20:28 INFO  compiling root (1 scala source)
2024.07.19 00:20:28 INFO  time: compiled root in 0.77s
2024.07.19 00:20:40 INFO  compiling root (1 scala source)
2024.07.19 00:20:40 INFO  time: compiled root in 0.21s
2024.07.19 00:20:42 INFO  Can not organize imports if file has error
2024.07.19 00:20:42 INFO  compiling root (1 scala source)
2024.07.19 00:20:42 INFO  time: compiled root in 0.17s
2024.07.19 00:20:48 INFO  Can not organize imports if file has error
2024.07.19 00:20:48 INFO  compiling root (1 scala source)
2024.07.19 00:20:48 INFO  time: compiled root in 0.18s
2024.07.19 00:20:48 INFO  Can not organize imports if file has error
jul. 19, 2024 12:20:48 AM scala.meta.internal.pc.CompilerAccess retryWithCleanCompiler
INFORMAÇÕES: compiler crashed due to an error in the Scala compiler, retrying with new compiler instance.
2024.07.19 00:20:48 INFO  compiling root (1 scala source)
2024.07.19 00:20:48 INFO  time: compiled root in 0.18s
jul. 19, 2024 12:20:49 AM scala.meta.internal.pc.CompilerAccess handleError
GRAVE: A severe compiler error occurred, full details of the error can be found in the error report C:\Users\Vinicius\UnB\FLanguage\.metals\.reports\metals-full\2024-07-19\r_compiler-error_(root)_00-20-49-442.md
jul. 19, 2024 12:20:49 AM scala.meta.internal.pc.CompilerAccess retryWithCleanCompiler
INFORMAÇÕES: compiler crashed due to an error in the Scala compiler, retrying with new compiler instance.
jul. 19, 2024 12:20:50 AM scala.meta.internal.pc.CompilerAccess retryWithCleanCompiler
INFORMAÇÕES: compiler crashed due to an error in the Scala compiler, retrying with new compiler instance.
jul. 19, 2024 12:20:52 AM scala.meta.internal.pc.CompilerAccess retryWithCleanCompiler
INFORMAÇÕES: compiler crashed due to an error in the Scala compiler, retrying with new compiler instance.
jul. 19, 2024 12:20:52 AM scala.meta.internal.pc.CompilerAccess handleError
GRAVE: A severe compiler error occurred, full details of the error can be found in the error report C:\Users\Vinicius\UnB\FLanguage\.metals\.reports\metals-full\2024-07-19\r_compiler-error_(root)_00-20-52-917.md
jul. 19, 2024 12:20:53 AM scala.meta.internal.pc.CompilerAccess retryWithCleanCompiler
INFORMAÇÕES: compiler crashed due to an error in the Scala compiler, retrying with new compiler instance.
2024.07.19 00:20:54 INFO  Can not organize imports if file has error
2024.07.19 00:20:54 INFO  compiling root (1 scala source)
jul. 19, 2024 12:20:54 AM scala.meta.internal.pc.CompilerAccess retryWithCleanCompiler
INFORMAÇÕES: compiler crashed due to an error in the Scala compiler, retrying with new compiler instance.
2024.07.19 00:20:54 INFO  time: compiled root in 0.23s
2024.07.19 00:21:04 INFO  Can not organize imports if file has error
2024.07.19 00:21:04 INFO  compiling root (1 scala source)
2024.07.19 00:21:04 INFO  time: compiled root in 0.18s
2024.07.19 00:21:35 INFO  Can not organize imports if file has error
2024.07.19 00:21:36 INFO  compiling root (1 scala source)
2024.07.19 00:21:36 INFO  time: compiled root in 0.17s
2024.07.19 00:21:39 INFO  Can not organize imports if file has error
2024.07.19 00:21:40 INFO  compiling root (1 scala source)
2024.07.19 00:21:40 INFO  time: compiled root in 0.22s
2024.07.19 00:22:09 INFO  Can not organize imports if file has error
2024.07.19 00:22:09 INFO  compiling root (1 scala source)
2024.07.19 00:22:09 INFO  time: compiled root in 0.19s
2024.07.19 00:22:13 INFO  Can not organize imports if file has error
2024.07.19 00:22:13 INFO  compiling root (1 scala source)
2024.07.19 00:22:13 INFO  time: compiled root in 0.19s
2024.07.19 00:22:24 INFO  Can not organize imports if file has error
2024.07.19 00:22:24 INFO  compiling root (1 scala source)
2024.07.19 00:22:24 INFO  time: compiled root in 0.19s
2024.07.19 00:22:32 INFO  Can not organize imports if file has error
2024.07.19 00:22:32 INFO  compiling root (1 scala source)
2024.07.19 00:22:32 INFO  time: compiled root in 0.19s
2024.07.19 00:25:39 INFO  Can not organize imports if file has error
2024.07.19 00:25:39 INFO  compiling root (1 scala source)
2024.07.19 00:25:39 INFO  time: compiled root in 0.22s
2024.07.19 00:25:41 INFO  Can not organize imports if file has error
2024.07.19 00:25:41 INFO  compiling root (1 scala source)
2024.07.19 00:25:41 INFO  time: compiled root in 0.19s
2024.07.19 00:25:56 INFO  Can not organize imports if file has error
2024.07.19 00:25:56 INFO  compiling root (1 scala source)
2024.07.19 00:25:56 INFO  time: compiled root in 0.2s
2024.07.19 00:27:52 INFO  Can not organize imports if file has error
2024.07.19 00:27:52 INFO  compiling root (1 scala source)
2024.07.19 00:27:52 INFO  time: compiled root in 0.81s
2024.07.19 00:28:24 INFO  compiling root (1 scala source)
2024.07.19 00:28:24 INFO  time: compiled root in 0.19s
2024.07.19 00:28:30 INFO  Can not organize imports if file has error
2024.07.19 00:28:31 INFO  compiling root (1 scala source)
2024.07.19 00:28:31 INFO  time: compiled root in 0.84s
jul. 19, 2024 12:31:14 AM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
ADVERTÊNCIA: Unmatched cancel notification for request id 3497
jul. 19, 2024 12:31:15 AM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
ADVERTÊNCIA: Unmatched cancel notification for request id 3505
2024.07.19 00:31:21 INFO  compiling root-test (1 scala source)
2024.07.19 00:31:21 INFO  time: compiled root-test in 0.3s
2024.07.19 00:31:34 INFO  Can not organize imports if file has error
2024.07.19 00:31:34 INFO  compiling root-test (1 scala source)
2024.07.19 00:31:35 INFO  time: compiled root-test in 1.31s
jul. 19, 2024 12:32:22 AM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
ADVERTÊNCIA: Unmatched cancel notification for request id 3586
jul. 19, 2024 12:32:22 AM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
ADVERTÊNCIA: Unmatched cancel notification for request id 3592
jul. 19, 2024 12:32:45 AM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
ADVERTÊNCIA: Unmatched cancel notification for request id 3600
2024.07.19 00:32:52 INFO  compiling root-test (1 scala source)
2024.07.19 00:32:53 INFO  time: compiled root-test in 1.01s
2024.07.19 00:33:09 INFO  compiling root-test (1 scala source)
2024.07.19 00:33:09 INFO  time: compiled root-test in 0.98s
2024.07.19 00:33:23 INFO  compiling root-test (1 scala source)
2024.07.19 00:33:24 INFO  time: compiled root-test in 1s
2024.07.19 00:33:26 INFO  compiling root-test (1 scala source)
2024.07.19 00:33:26 INFO  time: compiled root-test in 0.98s
2024.07.19 00:35:06 INFO  compiling root (1 scala source)
2024.07.19 00:35:06 INFO  time: compiled root in 0.44s
jul. 19, 2024 12:36:06 AM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
ADVERTÊNCIA: Unmatched cancel notification for request id 4159
jul. 19, 2024 12:36:06 AM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
ADVERTÊNCIA: Unmatched cancel notification for request id 4160
jul. 19, 2024 12:36:28 AM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
ADVERTÊNCIA: Unmatched cancel notification for request id 4300
jul. 19, 2024 12:36:29 AM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
ADVERTÊNCIA: Unmatched cancel notification for request id 4308
2024.07.19 00:37:57 INFO  compiling root (1 scala source)
2024.07.19 00:37:57 INFO  time: compiled root in 0.79s
jul. 19, 2024 12:38:12 AM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
ADVERTÊNCIA: Unmatched cancel notification for request id 4452
jul. 19, 2024 12:38:13 AM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
ADVERTÊNCIA: Unmatched cancel notification for request id 4456
jul. 19, 2024 12:38:49 AM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
ADVERTÊNCIA: Unmatched cancel notification for request id 4484
jul. 19, 2024 12:38:51 AM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
ADVERTÊNCIA: Unmatched cancel notification for request id 4492
jul. 19, 2024 12:38:56 AM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
ADVERTÊNCIA: Unmatched cancel notification for request id 4501
jul. 19, 2024 12:39:19 AM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
ADVERTÊNCIA: Unmatched cancel notification for request id 4511
jul. 19, 2024 12:39:32 AM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
ADVERTÊNCIA: Unmatched cancel notification for request id 4554
jul. 19, 2024 12:39:32 AM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
ADVERTÊNCIA: Unmatched cancel notification for request id 4562
jul. 19, 2024 12:39:34 AM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
ADVERTÊNCIA: Unmatched cancel notification for request id 4571
jul. 19, 2024 12:39:35 AM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
ADVERTÊNCIA: Unmatched cancel notification for request id 4579
jul. 19, 2024 12:39:47 AM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
ADVERTÊNCIA: Unmatched cancel notification for request id 4593
jul. 19, 2024 12:39:48 AM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
ADVERTÊNCIA: Unmatched cancel notification for request id 4602
jul. 19, 2024 12:39:48 AM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
ADVERTÊNCIA: Unmatched cancel notification for request id 4610
jul. 19, 2024 12:39:51 AM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
ADVERTÊNCIA: Unmatched cancel notification for request id 4623
jul. 19, 2024 12:39:54 AM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
ADVERTÊNCIA: Unmatched cancel notification for request id 4634
jul. 19, 2024 12:39:56 AM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
ADVERTÊNCIA: Unmatched cancel notification for request id 4642
jul. 19, 2024 12:39:59 AM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
ADVERTÊNCIA: Unmatched cancel notification for request id 4652
jul. 19, 2024 12:40:31 AM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
ADVERTÊNCIA: Unmatched cancel notification for request id 4663
jul. 19, 2024 12:41:31 AM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
ADVERTÊNCIA: Unmatched cancel notification for request id 4781
2024.07.19 00:41:34 ERROR Failed to tokenize input for semantic tokens for C:\Users\Vinicius\UnB\FLanguage\src\main\scala\br\unb\cic\flang\Monad.scala
scala.meta.tokenizers.TokenizeException: <input>:14: error: unclosed character literal
      println('')
              ^
	at scala.meta.internal.tokenizers.Reporter.syntaxError(Reporter.scala:23)
	at scala.meta.internal.tokenizers.Reporter.syntaxError$(Reporter.scala:23)
	at scala.meta.internal.tokenizers.Reporter$$anon$1.syntaxError(Reporter.scala:32)
	at scala.meta.internal.tokenizers.Reporter.syntaxError(Reporter.scala:25)
	at scala.meta.internal.tokenizers.Reporter.syntaxError$(Reporter.scala:25)
	at scala.meta.internal.tokenizers.Reporter$$anon$1.syntaxError(Reporter.scala:32)
	at scala.meta.internal.tokenizers.LegacyScanner.fetchSingleQuote$1(LegacyScanner.scala:391)
	at scala.meta.internal.tokenizers.LegacyScanner.fetchToken(LegacyScanner.scala:395)
	at scala.meta.internal.tokenizers.LegacyScanner.nextToken(LegacyScanner.scala:201)
	at scala.meta.internal.tokenizers.LegacyScanner.foreach(LegacyScanner.scala:912)
	at scala.meta.internal.tokenizers.ScalametaTokenizer.uncachedTokenize(ScalametaTokenizer.scala:23)
	at scala.meta.internal.tokenizers.ScalametaTokenizer.$anonfun$tokenize$1(ScalametaTokenizer.scala:17)
	at scala.collection.concurrent.TrieMap.getOrElseUpdate(TrieMap.scala:960)
	at scala.meta.internal.tokenizers.ScalametaTokenizer.tokenize(ScalametaTokenizer.scala:17)
	at scala.meta.internal.tokenizers.ScalametaTokenizer$$anon$2.apply(ScalametaTokenizer.scala:322)
	at scala.meta.tokenizers.Api$XtensionTokenizeDialectInput.tokenize(Api.scala:22)
	at scala.meta.tokenizers.Api$XtensionTokenizeInputLike.tokenize(Api.scala:13)
	at scala.meta.internal.metals.SemanticTokensProvider$.getTokens(SemanticTokensProvider.scala:30)
	at scala.meta.internal.metals.SemanticTokensProvider$.provide(SemanticTokensProvider.scala:89)
	at scala.meta.internal.metals.Compilers.$anonfun$semanticTokens$3(Compilers.scala:545)
	at scala.concurrent.impl.Promise$Transformation.run(Promise.scala:467)
	at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.lang.Thread.run(Thread.java:833)

2024.07.19 00:41:36 INFO  compiling root (1 scala source)
2024.07.19 00:41:37 INFO  time: compiled root in 1.26s
jul. 19, 2024 12:41:56 AM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
ADVERTÊNCIA: Unmatched cancel notification for request id 4872
2024.07.19 00:41:57 INFO  compiling root (1 scala source)
2024.07.19 00:41:57 INFO  time: compiled root in 0.95s
jul. 19, 2024 12:42:31 AM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
ADVERTÊNCIA: Unmatched cancel notification for request id 4971
2024.07.19 00:42:31 INFO  compiling root (1 scala source)
2024.07.19 00:42:31 INFO  time: compiled root in 0.18s
jul. 19, 2024 12:42:34 AM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
ADVERTÊNCIA: Unmatched cancel notification for request id 4996
2024.07.19 00:42:34 ERROR Failed to tokenize input for semantic tokens for C:\Users\Vinicius\UnB\FLanguage\src\main\scala\br\unb\cic\flang\Monad.scala
scala.meta.tokenizers.TokenizeException: <input>:20: error: unclosed string literal
    println("dabhw
            ^
	at scala.meta.internal.tokenizers.Reporter.syntaxError(Reporter.scala:23)
	at scala.meta.internal.tokenizers.Reporter.syntaxError$(Reporter.scala:23)
	at scala.meta.internal.tokenizers.Reporter$$anon$1.syntaxError(Reporter.scala:32)
	at scala.meta.internal.tokenizers.Reporter.syntaxError(Reporter.scala:25)
	at scala.meta.internal.tokenizers.Reporter.syntaxError$(Reporter.scala:25)
	at scala.meta.internal.tokenizers.Reporter$$anon$1.syntaxError(Reporter.scala:32)
	at scala.meta.internal.tokenizers.LegacyScanner.getStringLit(LegacyScanner.scala:509)
	at scala.meta.internal.tokenizers.LegacyScanner.fetchDoubleQuote$1(LegacyScanner.scala:361)
	at scala.meta.internal.tokenizers.LegacyScanner.fetchToken(LegacyScanner.scala:363)
	at scala.meta.internal.tokenizers.LegacyScanner.nextToken(LegacyScanner.scala:201)
	at scala.meta.internal.tokenizers.LegacyScanner.foreach(LegacyScanner.scala:912)
	at scala.meta.internal.tokenizers.ScalametaTokenizer.uncachedTokenize(ScalametaTokenizer.scala:23)
	at scala.meta.internal.tokenizers.ScalametaTokenizer.$anonfun$tokenize$1(ScalametaTokenizer.scala:17)
	at scala.collection.concurrent.TrieMap.getOrElseUpdate(TrieMap.scala:960)
	at scala.meta.internal.tokenizers.ScalametaTokenizer.tokenize(ScalametaTokenizer.scala:17)
	at scala.meta.internal.tokenizers.ScalametaTokenizer$$anon$2.apply(ScalametaTokenizer.scala:322)
	at scala.meta.tokenizers.Api$XtensionTokenizeDialectInput.tokenize(Api.scala:22)
	at scala.meta.tokenizers.Api$XtensionTokenizeInputLike.tokenize(Api.scala:13)
	at scala.meta.internal.metals.SemanticTokensProvider$.getTokens(SemanticTokensProvider.scala:30)
	at scala.meta.internal.metals.SemanticTokensProvider$.provide(SemanticTokensProvider.scala:89)
	at scala.meta.internal.metals.Compilers.$anonfun$semanticTokens$3(Compilers.scala:545)
	at scala.concurrent.impl.Promise$Transformation.run(Promise.scala:467)
	at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.lang.Thread.run(Thread.java:833)

2024.07.19 00:42:36 INFO  Can not organize imports if file has error
2024.07.19 00:42:55 INFO  compiling root (1 scala source)
2024.07.19 00:42:55 INFO  time: compiled root in 0.92s
jul. 19, 2024 12:43:07 AM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
ADVERTÊNCIA: Unmatched cancel notification for request id 5122
2024.07.19 00:43:31 INFO  compiling root-test (1 scala source)
2024.07.19 00:43:32 INFO  time: compiled root-test in 1s
something's wrong: no file:///C:/Users/Vinicius/UnB/FLanguage/src/main/scala/br/unb/cic/flang/MonadState.scala in cats.data.State[br.unb.cic.flang.MonadState.package.S,<error>]RangePosition(file:///C:/Users/Vinicius/UnB/FLanguage/src/main/scala/br/unb/cic/flang/MonadState.scala, 136, 136, 153)
something's wrong: no file:///C:/Users/Vinicius/UnB/FLanguage/src/main/scala/br/unb/cic/flang/MonadState.scala in cats.data.State[br.unb.cic.flang.MonadState.package.S,<error>]RangePosition(file:///C:/Users/Vinicius/UnB/FLanguage/src/main/scala/br/unb/cic/flang/MonadState.scala, 136, 136, 154)
something's wrong: no file:///C:/Users/Vinicius/UnB/FLanguage/src/main/scala/br/unb/cic/flang/MonadState.scala in cats.data.State[br.unb.cic.flang.MonadState.package.S,br.unb.cic.flang.MonadState.package.S]RangePosition(file:///C:/Users/Vinicius/UnB/FLanguage/src/main/scala/br/unb/cic/flang/MonadState.scala, 136, 136, 147)
something's wrong: no file:///C:/Users/Vinicius/UnB/FLanguage/src/main/scala/br/unb/cic/flang/MonadState.scala in cats.data.State[br.unb.cic.flang.MonadState.package.S,<error>]RangePosition(file:///C:/Users/Vinicius/UnB/FLanguage/src/main/scala/br/unb/cic/flang/MonadState.scala, 136, 136, 148)
something's wrong: no file:///C:/Users/Vinicius/UnB/FLanguage/src/main/scala/br/unb/cic/flang/MonadState.scala in cats.data.State[br.unb.cic.flang.MonadState.package.S,<error>]RangePosition(file:///C:/Users/Vinicius/UnB/FLanguage/src/main/scala/br/unb/cic/flang/MonadState.scala, 136, 136, 150)
2024.07.19 00:49:31 INFO  compiling root (1 scala source)
2024.07.19 00:49:31 INFO  time: compiled root in 0.78s
jul. 19, 2024 12:49:50 AM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleNotification
ADVERTÊNCIA: Notification threw an exception: {
  "jsonrpc": "2.0",
  "method": "textDocument/didOpen",
  "params": {
    "textDocument": {
      "uri": "jar:file%3A///C%3A/Users/Vinicius/AppData/Local/Coursier/cache/arc/https/github.com/adoptium/temurin17-binaries/releases/download/jdk-17%25252B35/OpenJDK17-jdk_x64_windows_hotspot_17_35.zip/jdk-17%2B35/lib/src.zip%21/java.base/java/lang/Integer.java",
      "languageId": "java",
      "version": 1,
      "text": "/*\n * Copyright (c) 1994, 2021, Oracle and/or its affiliates. All rights reserved.\n * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n *\n * This code is free software; you can redistribute it and/or modify it\n * under the terms of the GNU General Public License version 2 only, as\n * published by the Free Software Foundation.  Oracle designates this\n * particular file as subject to the \"Classpath\" exception as provided\n * by Oracle in the LICENSE file that accompanied this code.\n *\n * This code is distributed in the hope that it will be useful, but WITHOUT\n * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n * version 2 for more details (a copy is included in the LICENSE file that\n * accompanied this code).\n *\n * You should have received a copy of the GNU General Public License version\n * 2 along with this work; if not, write to the Free Software Foundation,\n * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n *\n * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n * or visit www.oracle.com if you need additional information or have any\n * questions.\n */\n\npackage java.lang;\n\nimport java.lang.annotation.Native;\nimport java.lang.invoke.MethodHandles;\nimport java.lang.constant.Constable;\nimport java.lang.constant.ConstantDesc;\nimport java.util.Objects;\nimport java.util.Optional;\n\nimport jdk.internal.misc.CDS;\nimport jdk.internal.misc.VM;\nimport jdk.internal.vm.annotation.IntrinsicCandidate;\n\nimport static java.lang.String.COMPACT_STRINGS;\nimport static java.lang.String.LATIN1;\nimport static java.lang.String.UTF16;\n\n/**\n * The {@code Integer} class wraps a value of the primitive type\n * {@code int} in an object. An object of type {@code Integer}\n * contains a single field whose type is {@code int}.\n *\n * \u003cp\u003eIn addition, this class provides several methods for converting\n * an {@code int} to a {@code String} and a {@code String} to an\n * {@code int}, as well as other constants and methods useful when\n * dealing with an {@code int}.\n *\n * \u003cp\u003eThis is a \u003ca href\u003d\"{@docRoot}/java.base/java/lang/doc-files/ValueBased.html\"\u003evalue-based\u003c/a\u003e\n * class; programmers should treat instances that are\n * {@linkplain #equals(Object) equal} as interchangeable and should not\n * use instances for synchronization, or unpredictable behavior may\n * occur. For example, in a future release, synchronization may fail.\n *\n * \u003cp\u003eImplementation note: The implementations of the \"bit twiddling\"\n * methods (such as {@link #highestOneBit(int) highestOneBit} and\n * {@link #numberOfTrailingZeros(int) numberOfTrailingZeros}) are\n * based on material from Henry S. Warren, Jr.\u0027s \u003ci\u003eHacker\u0027s\n * Delight\u003c/i\u003e, (Addison Wesley, 2002).\n *\n * @author  Lee Boynton\n * @author  Arthur van Hoff\n * @author  Josh Bloch\n * @author  Joseph D. Darcy\n * @since 1.0\n */\n@jdk.internal.ValueBased\npublic final class Integer extends Number\n        implements Comparable\u003cInteger\u003e, Constable, ConstantDesc {\n    /**\n     * A constant holding the minimum value an {@code int} can\n     * have, -2\u003csup\u003e31\u003c/sup\u003e.\n     */\n    @Native public static final int   MIN_VALUE \u003d 0x80000000;\n\n    /**\n     * A constant holding the maximum value an {@code int} can\n     * have, 2\u003csup\u003e31\u003c/sup\u003e-1.\n     */\n    @Native public static final int   MAX_VALUE \u003d 0x7fffffff;\n\n    /**\n     * The {@code Class} instance representing the primitive type\n     * {@code int}.\n     *\n     * @since   1.1\n     */\n    @SuppressWarnings(\"unchecked\")\n    public static final Class\u003cInteger\u003e  TYPE \u003d (Class\u003cInteger\u003e) Class.getPrimitiveClass(\"int\");\n\n    /**\n     * All possible chars for representing a number as a String\n     */\n    static final char[] digits \u003d {\n        \u00270\u0027 , \u00271\u0027 , \u00272\u0027 , \u00273\u0027 , \u00274\u0027 , \u00275\u0027 ,\n        \u00276\u0027 , \u00277\u0027 , \u00278\u0027 , \u00279\u0027 , \u0027a\u0027 , \u0027b\u0027 ,\n        \u0027c\u0027 , \u0027d\u0027 , \u0027e\u0027 , \u0027f\u0027 , \u0027g\u0027 , \u0027h\u0027 ,\n        \u0027i\u0027 , \u0027j\u0027 , \u0027k\u0027 , \u0027l\u0027 , \u0027m\u0027 , \u0027n\u0027 ,\n        \u0027o\u0027 , \u0027p\u0027 , \u0027q\u0027 , \u0027r\u0027 , \u0027s\u0027 , \u0027t\u0027 ,\n        \u0027u\u0027 , \u0027v\u0027 , \u0027w\u0027 , \u0027x\u0027 , \u0027y\u0027 , \u0027z\u0027\n    };\n\n    /**\n     * Returns a string representation of the first argument in the\n     * radix specified by the second argument.\n     *\n     * \u003cp\u003eIf the radix is smaller than {@code Character.MIN_RADIX}\n     * or larger than {@code Character.MAX_RADIX}, then the radix\n     * {@code 10} is used instead.\n     *\n     * \u003cp\u003eIf the first argument is negative, the first element of the\n     * result is the ASCII minus character {@code \u0027-\u0027}\n     * ({@code \u0027\\u005Cu002D\u0027}). If the first argument is not\n     * negative, no sign character appears in the result.\n     *\n     * \u003cp\u003eThe remaining characters of the result represent the magnitude\n     * of the first argument. If the magnitude is zero, it is\n     * represented by a single zero character {@code \u00270\u0027}\n     * ({@code \u0027\\u005Cu0030\u0027}); otherwise, the first character of\n     * the representation of the magnitude will not be the zero\n     * character.  The following ASCII characters are used as digits:\n     *\n     * \u003cblockquote\u003e\n     *   {@code 0123456789abcdefghijklmnopqrstuvwxyz}\n     * \u003c/blockquote\u003e\n     *\n     * These are {@code \u0027\\u005Cu0030\u0027} through\n     * {@code \u0027\\u005Cu0039\u0027} and {@code \u0027\\u005Cu0061\u0027} through\n     * {@code \u0027\\u005Cu007A\u0027}. If {@code radix} is\n     * \u003cvar\u003eN\u003c/var\u003e, then the first \u003cvar\u003eN\u003c/var\u003e of these characters\n     * are used as radix-\u003cvar\u003eN\u003c/var\u003e digits in the order shown. Thus,\n     * the digits for hexadecimal (radix 16) are\n     * {@code 0123456789abcdef}. If uppercase letters are\n     * desired, the {@link java.lang.String#toUpperCase()} method may\n     * be called on the result:\n     *\n     * \u003cblockquote\u003e\n     *  {@code Integer.toString(n, 16).toUpperCase()}\n     * \u003c/blockquote\u003e\n     *\n     * @param   i       an integer to be converted to a string.\n     * @param   radix   the radix to use in the string representation.\n     * @return  a string representation of the argument in the specified radix.\n     * @see     java.lang.Character#MAX_RADIX\n     * @see     java.lang.Character#MIN_RADIX\n     */\n    public static String toString(int i, int radix) {\n        if (radix \u003c Character.MIN_RADIX || radix \u003e Character.MAX_RADIX)\n            radix \u003d 10;\n\n        /* Use the faster version */\n        if (radix \u003d\u003d 10) {\n            return toString(i);\n        }\n\n        if (COMPACT_STRINGS) {\n            byte[] buf \u003d new byte[33];\n            boolean negative \u003d (i \u003c 0);\n            int charPos \u003d 32;\n\n            if (!negative) {\n                i \u003d -i;\n            }\n\n            while (i \u003c\u003d -radix) {\n                buf[charPos--] \u003d (byte)digits[-(i % radix)];\n                i \u003d i / radix;\n            }\n            buf[charPos] \u003d (byte)digits[-i];\n\n            if (negative) {\n                buf[--charPos] \u003d \u0027-\u0027;\n            }\n\n            return StringLatin1.newString(buf, charPos, (33 - charPos));\n        }\n        return toStringUTF16(i, radix);\n    }\n\n    private static String toStringUTF16(int i, int radix) {\n        byte[] buf \u003d new byte[33 * 2];\n        boolean negative \u003d (i \u003c 0);\n        int charPos \u003d 32;\n        if (!negative) {\n            i \u003d -i;\n        }\n        while (i \u003c\u003d -radix) {\n            StringUTF16.putChar(buf, charPos--, digits[-(i % radix)]);\n            i \u003d i / radix;\n        }\n        StringUTF16.putChar(buf, charPos, digits[-i]);\n\n        if (negative) {\n            StringUTF16.putChar(buf, --charPos, \u0027-\u0027);\n        }\n        return StringUTF16.newString(buf, charPos, (33 - charPos));\n    }\n\n    /**\n     * Returns a string representation of the first argument as an\n     * unsigned integer value in the radix specified by the second\n     * argument.\n     *\n     * \u003cp\u003eIf the radix is smaller than {@code Character.MIN_RADIX}\n     * or larger than {@code Character.MAX_RADIX}, then the radix\n     * {@code 10} is used instead.\n     *\n     * \u003cp\u003eNote that since the first argument is treated as an unsigned\n     * value, no leading sign character is printed.\n     *\n     * \u003cp\u003eIf the magnitude is zero, it is represented by a single zero\n     * character {@code \u00270\u0027} ({@code \u0027\\u005Cu0030\u0027}); otherwise,\n     * the first character of the representation of the magnitude will\n     * not be the zero character.\n     *\n     * \u003cp\u003eThe behavior of radixes and the characters used as digits\n     * are the same as {@link #toString(int, int) toString}.\n     *\n     * @param   i       an integer to be converted to an unsigned string.\n     * @param   radix   the radix to use in the string representation.\n     * @return  an unsigned string representation of the argument in the specified radix.\n     * @see     #toString(int, int)\n     * @since 1.8\n     */\n    public static String toUnsignedString(int i, int radix) {\n        return Long.toUnsignedString(toUnsignedLong(i), radix);\n    }\n\n    /**\n     * Returns a string representation of the integer argument as an\n     * unsigned integer in base\u0026nbsp;16.\n     *\n     * \u003cp\u003eThe unsigned integer value is the argument plus 2\u003csup\u003e32\u003c/sup\u003e\n     * if the argument is negative; otherwise, it is equal to the\n     * argument.  This value is converted to a string of ASCII digits\n     * in hexadecimal (base\u0026nbsp;16) with no extra leading\n     * {@code 0}s.\n     *\n     * \u003cp\u003eThe value of the argument can be recovered from the returned\n     * string {@code s} by calling {@link\n     * Integer#parseUnsignedInt(String, int)\n     * Integer.parseUnsignedInt(s, 16)}.\n     *\n     * \u003cp\u003eIf the unsigned magnitude is zero, it is represented by a\n     * single zero character {@code \u00270\u0027} ({@code \u0027\\u005Cu0030\u0027});\n     * otherwise, the first character of the representation of the\n     * unsigned magnitude will not be the zero character. The\n     * following characters are used as hexadecimal digits:\n     *\n     * \u003cblockquote\u003e\n     *  {@code 0123456789abcdef}\n     * \u003c/blockquote\u003e\n     *\n     * These are the characters {@code \u0027\\u005Cu0030\u0027} through\n     * {@code \u0027\\u005Cu0039\u0027} and {@code \u0027\\u005Cu0061\u0027} through\n     * {@code \u0027\\u005Cu0066\u0027}. If uppercase letters are\n     * desired, the {@link java.lang.String#toUpperCase()} method may\n     * be called on the result:\n     *\n     * \u003cblockquote\u003e\n     *  {@code Integer.toHexString(n).toUpperCase()}\n     * \u003c/blockquote\u003e\n     *\n     * @apiNote\n     * The {@link java.util.HexFormat} class provides formatting and parsing\n     * of byte arrays and primitives to return a string or adding to an {@link Appendable}.\n     * {@code HexFormat} formats and parses uppercase or lowercase hexadecimal characters,\n     * with leading zeros and for byte arrays includes for each byte\n     * a delimiter, prefix, and suffix.\n     *\n     * @param   i   an integer to be converted to a string.\n     * @return  the string representation of the unsigned integer value\n     *          represented by the argument in hexadecimal (base\u0026nbsp;16).\n     * @see java.util.HexFormat\n     * @see #parseUnsignedInt(String, int)\n     * @see #toUnsignedString(int, int)\n     * @since   1.0.2\n     */\n    public static String toHexString(int i) {\n        return toUnsignedString0(i, 4);\n    }\n\n    /**\n     * Returns a string representation of the integer argument as an\n     * unsigned integer in base\u0026nbsp;8.\n     *\n     * \u003cp\u003eThe unsigned integer value is the argument plus 2\u003csup\u003e32\u003c/sup\u003e\n     * if the argument is negative; otherwise, it is equal to the\n     * argument.  This value is converted to a string of ASCII digits\n     * in octal (base\u0026nbsp;8) with no extra leading {@code 0}s.\n     *\n     * \u003cp\u003eThe value of the argument can be recovered from the returned\n     * string {@code s} by calling {@link\n     * Integer#parseUnsignedInt(String, int)\n     * Integer.parseUnsignedInt(s, 8)}.\n     *\n     * \u003cp\u003eIf the unsigned magnitude is zero, it is represented by a\n     * single zero character {@code \u00270\u0027} ({@code \u0027\\u005Cu0030\u0027});\n     * otherwise, the first character of the representation of the\n     * unsigned magnitude will not be the zero character. The\n     * following characters are used as octal digits:\n     *\n     * \u003cblockquote\u003e\n     * {@code 01234567}\n     * \u003c/blockquote\u003e\n     *\n     * These are the characters {@code \u0027\\u005Cu0030\u0027} through\n     * {@code \u0027\\u005Cu0037\u0027}.\n     *\n     * @param   i   an integer to be converted to a string.\n     * @return  the string representation of the unsigned integer value\n     *          represented by the argument in octal (base\u0026nbsp;8).\n     * @see #parseUnsignedInt(String, int)\n     * @see #toUnsignedString(int, int)\n     * @since   1.0.2\n     */\n    public static String toOctalString(int i) {\n        return toUnsignedString0(i, 3);\n    }\n\n    /**\n     * Returns a string representation of the integer argument as an\n     * unsigned integer in base\u0026nbsp;2.\n     *\n     * \u003cp\u003eThe unsigned integer value is the argument plus 2\u003csup\u003e32\u003c/sup\u003e\n     * if the argument is negative; otherwise it is equal to the\n     * argument.  This value is converted to a string of ASCII digits\n     * in binary (base\u0026nbsp;2) with no extra leading {@code 0}s.\n     *\n     * \u003cp\u003eThe value of the argument can be recovered from the returned\n     * string {@code s} by calling {@link\n     * Integer#parseUnsignedInt(String, int)\n     * Integer.parseUnsignedInt(s, 2)}.\n     *\n     * \u003cp\u003eIf the unsigned magnitude is zero, it is represented by a\n     * single zero character {@code \u00270\u0027} ({@code \u0027\\u005Cu0030\u0027});\n     * otherwise, the first character of the representation of the\n     * unsigned magnitude will not be the zero character. The\n     * characters {@code \u00270\u0027} ({@code \u0027\\u005Cu0030\u0027}) and {@code\n     * \u00271\u0027} ({@code \u0027\\u005Cu0031\u0027}) are used as binary digits.\n     *\n     * @param   i   an integer to be converted to a string.\n     * @return  the string representation of the unsigned integer value\n     *          represented by the argument in binary (base\u0026nbsp;2).\n     * @see #parseUnsignedInt(String, int)\n     * @see #toUnsignedString(int, int)\n     * @since   1.0.2\n     */\n    public static String toBinaryString(int i) {\n        return toUnsignedString0(i, 1);\n    }\n\n    /**\n     * Convert the integer to an unsigned number.\n     */\n    private static String toUnsignedString0(int val, int shift) {\n        // assert shift \u003e 0 \u0026\u0026 shift \u003c\u003d5 : \"Illegal shift value\";\n        int mag \u003d Integer.SIZE - Integer.numberOfLeadingZeros(val);\n        int chars \u003d Math.max(((mag + (shift - 1)) / shift), 1);\n        if (COMPACT_STRINGS) {\n            byte[] buf \u003d new byte[chars];\n            formatUnsignedInt(val, shift, buf, chars);\n            return new String(buf, LATIN1);\n        } else {\n            byte[] buf \u003d new byte[chars * 2];\n            formatUnsignedIntUTF16(val, shift, buf, chars);\n            return new String(buf, UTF16);\n        }\n    }\n\n    /**\n     * Format an {@code int} (treated as unsigned) into a byte buffer (LATIN1 version). If\n     * {@code len} exceeds the formatted ASCII representation of {@code val},\n     * {@code buf} will be padded with leading zeroes.\n     *\n     * @param val the unsigned int to format\n     * @param shift the log2 of the base to format in (4 for hex, 3 for octal, 1 for binary)\n     * @param buf the byte buffer to write to\n     * @param len the number of characters to write\n     */\n    private static void formatUnsignedInt(int val, int shift, byte[] buf, int len) {\n        int charPos \u003d len;\n        int radix \u003d 1 \u003c\u003c shift;\n        int mask \u003d radix - 1;\n        do {\n            buf[--charPos] \u003d (byte)Integer.digits[val \u0026 mask];\n            val \u003e\u003e\u003e\u003d shift;\n        } while (charPos \u003e 0);\n    }\n\n    /**\n     * Format an {@code int} (treated as unsigned) into a byte buffer (UTF16 version). If\n     * {@code len} exceeds the formatted ASCII representation of {@code val},\n     * {@code buf} will be padded with leading zeroes.\n     *\n     * @param val the unsigned int to format\n     * @param shift the log2 of the base to format in (4 for hex, 3 for octal, 1 for binary)\n     * @param buf the byte buffer to write to\n     * @param len the number of characters to write\n     */\n    private static void formatUnsignedIntUTF16(int val, int shift, byte[] buf, int len) {\n        int charPos \u003d len;\n        int radix \u003d 1 \u003c\u003c shift;\n        int mask \u003d radix - 1;\n        do {\n            StringUTF16.putChar(buf, --charPos, Integer.digits[val \u0026 mask]);\n            val \u003e\u003e\u003e\u003d shift;\n        } while (charPos \u003e 0);\n    }\n\n    static final byte[] DigitTens \u003d {\n        \u00270\u0027, \u00270\u0027, \u00270\u0027, \u00270\u0027, \u00270\u0027, \u00270\u0027, \u00270\u0027, \u00270\u0027, \u00270\u0027, \u00270\u0027,\n        \u00271\u0027, \u00271\u0027, \u00271\u0027, \u00271\u0027, \u00271\u0027, \u00271\u0027, \u00271\u0027, \u00271\u0027, \u00271\u0027, \u00271\u0027,\n        \u00272\u0027, \u00272\u0027, \u00272\u0027, \u00272\u0027, \u00272\u0027, \u00272\u0027, \u00272\u0027, \u00272\u0027, \u00272\u0027, \u00272\u0027,\n        \u00273\u0027, \u00273\u0027, \u00273\u0027, \u00273\u0027, \u00273\u0027, \u00273\u0027, \u00273\u0027, \u00273\u0027, \u00273\u0027, \u00273\u0027,\n        \u00274\u0027, \u00274\u0027, \u00274\u0027, \u00274\u0027, \u00274\u0027, \u00274\u0027, \u00274\u0027, \u00274\u0027, \u00274\u0027, \u00274\u0027,\n        \u00275\u0027, \u00275\u0027, \u00275\u0027, \u00275\u0027, \u00275\u0027, \u00275\u0027, \u00275\u0027, \u00275\u0027, \u00275\u0027, \u00275\u0027,\n        \u00276\u0027, \u00276\u0027, \u00276\u0027, \u00276\u0027, \u00276\u0027, \u00276\u0027, \u00276\u0027, \u00276\u0027, \u00276\u0027, \u00276\u0027,\n        \u00277\u0027, \u00277\u0027, \u00277\u0027, \u00277\u0027, \u00277\u0027, \u00277\u0027, \u00277\u0027, \u00277\u0027, \u00277\u0027, \u00277\u0027,\n        \u00278\u0027, \u00278\u0027, \u00278\u0027, \u00278\u0027, \u00278\u0027, \u00278\u0027, \u00278\u0027, \u00278\u0027, \u00278\u0027, \u00278\u0027,\n        \u00279\u0027, \u00279\u0027, \u00279\u0027, \u00279\u0027, \u00279\u0027, \u00279\u0027, \u00279\u0027, \u00279\u0027, \u00279\u0027, \u00279\u0027,\n        } ;\n\n    static final byte[] DigitOnes \u003d {\n        \u00270\u0027, \u00271\u0027, \u00272\u0027, \u00273\u0027, \u00274\u0027, \u00275\u0027, \u00276\u0027, \u00277\u0027, \u00278\u0027, \u00279\u0027,\n        \u00270\u0027, \u00271\u0027, \u00272\u0027, \u00273\u0027, \u00274\u0027, \u00275\u0027, \u00276\u0027, \u00277\u0027, \u00278\u0027, \u00279\u0027,\n        \u00270\u0027, \u00271\u0027, \u00272\u0027, \u00273\u0027, \u00274\u0027, \u00275\u0027, \u00276\u0027, \u00277\u0027, \u00278\u0027, \u00279\u0027,\n        \u00270\u0027, \u00271\u0027, \u00272\u0027, \u00273\u0027, \u00274\u0027, \u00275\u0027, \u00276\u0027, \u00277\u0027, \u00278\u0027, \u00279\u0027,\n        \u00270\u0027, \u00271\u0027, \u00272\u0027, \u00273\u0027, \u00274\u0027, \u00275\u0027, \u00276\u0027, \u00277\u0027, \u00278\u0027, \u00279\u0027,\n        \u00270\u0027, \u00271\u0027, \u00272\u0027, \u00273\u0027, \u00274\u0027, \u00275\u0027, \u00276\u0027, \u00277\u0027, \u00278\u0027, \u00279\u0027,\n        \u00270\u0027, \u00271\u0027, \u00272\u0027, \u00273\u0027, \u00274\u0027, \u00275\u0027, \u00276\u0027, \u00277\u0027, \u00278\u0027, \u00279\u0027,\n        \u00270\u0027, \u00271\u0027, \u00272\u0027, \u00273\u0027, \u00274\u0027, \u00275\u0027, \u00276\u0027, \u00277\u0027, \u00278\u0027, \u00279\u0027,\n        \u00270\u0027, \u00271\u0027, \u00272\u0027, \u00273\u0027, \u00274\u0027, \u00275\u0027, \u00276\u0027, \u00277\u0027, \u00278\u0027, \u00279\u0027,\n        \u00270\u0027, \u00271\u0027, \u00272\u0027, \u00273\u0027, \u00274\u0027, \u00275\u0027, \u00276\u0027, \u00277\u0027, \u00278\u0027, \u00279\u0027,\n        } ;\n\n\n    /**\n     * Returns a {@code String} object representing the\n     * specified integer. The argument is converted to signed decimal\n     * representation and returned as a string, exactly as if the\n     * argument and radix 10 were given as arguments to the {@link\n     * #toString(int, int)} method.\n     *\n     * @param   i   an integer to be converted.\n     * @return  a string representation of the argument in base\u0026nbsp;10.\n     */\n    @IntrinsicCandidate\n    public static String toString(int i) {\n        int size \u003d stringSize(i);\n        if (COMPACT_STRINGS) {\n            byte[] buf \u003d new byte[size];\n            getChars(i, size, buf);\n            return new String(buf, LATIN1);\n        } else {\n            byte[] buf \u003d new byte[size * 2];\n            StringUTF16.getChars(i, size, buf);\n            return new String(buf, UTF16);\n        }\n    }\n\n    /**\n     * Returns a string representation of the argument as an unsigned\n     * decimal value.\n     *\n     * The argument is converted to unsigned decimal representation\n     * and returned as a string exactly as if the argument and radix\n     * 10 were given as arguments to the {@link #toUnsignedString(int,\n     * int)} method.\n     *\n     * @param   i  an integer to be converted to an unsigned string.\n     * @return  an unsigned string representation of the argument.\n     * @see     #toUnsignedString(int, int)\n     * @since 1.8\n     */\n    public static String toUnsignedString(int i) {\n        return Long.toString(toUnsignedLong(i));\n    }\n\n    /**\n     * Places characters representing the integer i into the\n     * character array buf. The characters are placed into\n     * the buffer backwards starting with the least significant\n     * digit at the specified index (exclusive), and working\n     * backwards from there.\n     *\n     * @implNote This method converts positive inputs into negative\n     * values, to cover the Integer.MIN_VALUE case. Converting otherwise\n     * (negative to positive) will expose -Integer.MIN_VALUE that overflows\n     * integer.\n     *\n     * @param i     value to convert\n     * @param index next index, after the least significant digit\n     * @param buf   target buffer, Latin1-encoded\n     * @return index of the most significant digit or minus sign, if present\n     */\n    static int getChars(int i, int index, byte[] buf) {\n        int q, r;\n        int charPos \u003d index;\n\n        boolean negative \u003d i \u003c 0;\n        if (!negative) {\n            i \u003d -i;\n        }\n\n        // Generate two digits per iteration\n        while (i \u003c\u003d -100) {\n            q \u003d i / 100;\n            r \u003d (q * 100) - i;\n            i \u003d q;\n            buf[--charPos] \u003d DigitOnes[r];\n            buf[--charPos] \u003d DigitTens[r];\n        }\n\n        // We know there are at most two digits left at this point.\n        q \u003d i / 10;\n        r \u003d (q * 10) - i;\n        buf[--charPos] \u003d (byte)(\u00270\u0027 + r);\n\n        // Whatever left is the remaining digit.\n        if (q \u003c 0) {\n            buf[--charPos] \u003d (byte)(\u00270\u0027 - q);\n        }\n\n        if (negative) {\n            buf[--charPos] \u003d (byte)\u0027-\u0027;\n        }\n        return charPos;\n    }\n\n    // Left here for compatibility reasons, see JDK-8143900.\n    static final int [] sizeTable \u003d { 9, 99, 999, 9999, 99999, 999999, 9999999,\n                                      99999999, 999999999, Integer.MAX_VALUE };\n\n    /**\n     * Returns the string representation size for a given int value.\n     *\n     * @param x int value\n     * @return string size\n     *\n     * @implNote There are other ways to compute this: e.g. binary search,\n     * but values are biased heavily towards zero, and therefore linear search\n     * wins. The iteration results are also routinely inlined in the generated\n     * code after loop unrolling.\n     */\n    static int stringSize(int x) {\n        int d \u003d 1;\n        if (x \u003e\u003d 0) {\n            d \u003d 0;\n            x \u003d -x;\n        }\n        int p \u003d -10;\n        for (int i \u003d 1; i \u003c 10; i++) {\n            if (x \u003e p)\n                return i + d;\n            p \u003d 10 * p;\n        }\n        return 10 + d;\n    }\n\n    /**\n     * Parses the string argument as a signed integer in the radix\n     * specified by the second argument. The characters in the string\n     * must all be digits of the specified radix (as determined by\n     * whether {@link java.lang.Character#digit(char, int)} returns a\n     * nonnegative value), except that the first character may be an\n     * ASCII minus sign {@code \u0027-\u0027} ({@code \u0027\\u005Cu002D\u0027}) to\n     * indicate a negative value or an ASCII plus sign {@code \u0027+\u0027}\n     * ({@code \u0027\\u005Cu002B\u0027}) to indicate a positive value. The\n     * resulting integer value is returned.\n     *\n     * \u003cp\u003eAn exception of type {@code NumberFormatException} is\n     * thrown if any of the following situations occurs:\n     * \u003cul\u003e\n     * \u003cli\u003eThe first argument is {@code null} or is a string of\n     * length zero.\n     *\n     * \u003cli\u003eThe radix is either smaller than\n     * {@link java.lang.Character#MIN_RADIX} or\n     * larger than {@link java.lang.Character#MAX_RADIX}.\n     *\n     * \u003cli\u003eAny character of the string is not a digit of the specified\n     * radix, except that the first character may be a minus sign\n     * {@code \u0027-\u0027} ({@code \u0027\\u005Cu002D\u0027}) or plus sign\n     * {@code \u0027+\u0027} ({@code \u0027\\u005Cu002B\u0027}) provided that the\n     * string is longer than length 1.\n     *\n     * \u003cli\u003eThe value represented by the string is not a value of type\n     * {@code int}.\n     * \u003c/ul\u003e\n     *\n     * \u003cp\u003eExamples:\n     * \u003cblockquote\u003e\u003cpre\u003e\n     * parseInt(\"0\", 10) returns 0\n     * parseInt(\"473\", 10) returns 473\n     * parseInt(\"+42\", 10) returns 42\n     * parseInt(\"-0\", 10) returns 0\n     * parseInt(\"-FF\", 16) returns -255\n     * parseInt(\"1100110\", 2) returns 102\n     * parseInt(\"2147483647\", 10) returns 2147483647\n     * parseInt(\"-2147483648\", 10) returns -2147483648\n     * parseInt(\"2147483648\", 10) throws a NumberFormatException\n     * parseInt(\"99\", 8) throws a NumberFormatException\n     * parseInt(\"Kona\", 10) throws a NumberFormatException\n     * parseInt(\"Kona\", 27) returns 411787\n     * \u003c/pre\u003e\u003c/blockquote\u003e\n     *\n     * @param      s   the {@code String} containing the integer\n     *                  representation to be parsed\n     * @param      radix   the radix to be used while parsing {@code s}.\n     * @return     the integer represented by the string argument in the\n     *             specified radix.\n     * @throws     NumberFormatException if the {@code String}\n     *             does not contain a parsable {@code int}.\n     */\n    public static int parseInt(String s, int radix)\n                throws NumberFormatException\n    {\n        /*\n         * WARNING: This method may be invoked early during VM initialization\n         * before IntegerCache is initialized. Care must be taken to not use\n         * the valueOf method.\n         */\n\n        if (s \u003d\u003d null) {\n            throw new NumberFormatException(\"Cannot parse null string\");\n        }\n\n        if (radix \u003c Character.MIN_RADIX) {\n            throw new NumberFormatException(\"radix \" + radix +\n                                            \" less than Character.MIN_RADIX\");\n        }\n\n        if (radix \u003e Character.MAX_RADIX) {\n            throw new NumberFormatException(\"radix \" + radix +\n                                            \" greater than Character.MAX_RADIX\");\n        }\n\n        boolean negative \u003d false;\n        int i \u003d 0, len \u003d s.length();\n        int limit \u003d -Integer.MAX_VALUE;\n\n        if (len \u003e 0) {\n            char firstChar \u003d s.charAt(0);\n            if (firstChar \u003c \u00270\u0027) { // Possible leading \"+\" or \"-\"\n                if (firstChar \u003d\u003d \u0027-\u0027) {\n                    negative \u003d true;\n                    limit \u003d Integer.MIN_VALUE;\n                } else if (firstChar !\u003d \u0027+\u0027) {\n                    throw NumberFormatException.forInputString(s, radix);\n                }\n\n                if (len \u003d\u003d 1) { // Cannot have lone \"+\" or \"-\"\n                    throw NumberFormatException.forInputString(s, radix);\n                }\n                i++;\n            }\n            int multmin \u003d limit / radix;\n            int result \u003d 0;\n            while (i \u003c len) {\n                // Accumulating negatively avoids surprises near MAX_VALUE\n                int digit \u003d Character.digit(s.charAt(i++), radix);\n                if (digit \u003c 0 || result \u003c multmin) {\n                    throw NumberFormatException.forInputString(s, radix);\n                }\n                result *\u003d radix;\n                if (result \u003c limit + digit) {\n                    throw NumberFormatException.forInputString(s, radix);\n                }\n                result -\u003d digit;\n            }\n            return negative ? result : -result;\n        } else {\n            throw NumberFormatException.forInputString(s, radix);\n        }\n    }\n\n    /**\n     * Parses the {@link CharSequence} argument as a signed {@code int} in the\n     * specified {@code radix}, beginning at the specified {@code beginIndex}\n     * and extending to {@code endIndex - 1}.\n     *\n     * \u003cp\u003eThe method does not take steps to guard against the\n     * {@code CharSequence} being mutated while parsing.\n     *\n     * @param      s   the {@code CharSequence} containing the {@code int}\n     *                  representation to be parsed\n     * @param      beginIndex   the beginning index, inclusive.\n     * @param      endIndex     the ending index, exclusive.\n     * @param      radix   the radix to be used while parsing {@code s}.\n     * @return     the signed {@code int} represented by the subsequence in\n     *             the specified radix.\n     * @throws     NullPointerException  if {@code s} is null.\n     * @throws     IndexOutOfBoundsException  if {@code beginIndex} is\n     *             negative, or if {@code beginIndex} is greater than\n     *             {@code endIndex} or if {@code endIndex} is greater than\n     *             {@code s.length()}.\n     * @throws     NumberFormatException  if the {@code CharSequence} does not\n     *             contain a parsable {@code int} in the specified\n     *             {@code radix}, or if {@code radix} is either smaller than\n     *             {@link java.lang.Character#MIN_RADIX} or larger than\n     *             {@link java.lang.Character#MAX_RADIX}.\n     * @since  9\n     */\n    public static int parseInt(CharSequence s, int beginIndex, int endIndex, int radix)\n                throws NumberFormatException {\n        Objects.requireNonNull(s);\n\n        if (beginIndex \u003c 0 || beginIndex \u003e endIndex || endIndex \u003e s.length()) {\n            throw new IndexOutOfBoundsException();\n        }\n        if (radix \u003c Character.MIN_RADIX) {\n            throw new NumberFormatException(\"radix \" + radix +\n                                            \" less than Character.MIN_RADIX\");\n        }\n        if (radix \u003e Character.MAX_RADIX) {\n            throw new NumberFormatException(\"radix \" + radix +\n                                            \" greater than Character.MAX_RADIX\");\n        }\n\n        boolean negative \u003d false;\n        int i \u003d beginIndex;\n        int limit \u003d -Integer.MAX_VALUE;\n\n        if (i \u003c endIndex) {\n            char firstChar \u003d s.charAt(i);\n            if (firstChar \u003c \u00270\u0027) { // Possible leading \"+\" or \"-\"\n                if (firstChar \u003d\u003d \u0027-\u0027) {\n                    negative \u003d true;\n                    limit \u003d Integer.MIN_VALUE;\n                } else if (firstChar !\u003d \u0027+\u0027) {\n                    throw NumberFormatException.forCharSequence(s, beginIndex,\n                            endIndex, i);\n                }\n                i++;\n                if (i \u003d\u003d endIndex) { // Cannot have lone \"+\" or \"-\"\n                    throw NumberFormatException.forCharSequence(s, beginIndex,\n                            endIndex, i);\n                }\n            }\n            int multmin \u003d limit / radix;\n            int result \u003d 0;\n            while (i \u003c endIndex) {\n                // Accumulating negatively avoids surprises near MAX_VALUE\n                int digit \u003d Character.digit(s.charAt(i), radix);\n                if (digit \u003c 0 || result \u003c multmin) {\n                    throw NumberFormatException.forCharSequence(s, beginIndex,\n                            endIndex, i);\n                }\n                result *\u003d radix;\n                if (result \u003c limit + digit) {\n                    throw NumberFormatException.forCharSequence(s, beginIndex,\n                            endIndex, i);\n                }\n                i++;\n                result -\u003d digit;\n            }\n            return negative ? result : -result;\n        } else {\n            throw NumberFormatException.forInputString(\"\", radix);\n        }\n    }\n\n    /**\n     * Parses the string argument as a signed decimal integer. The\n     * characters in the string must all be decimal digits, except\n     * that the first character may be an ASCII minus sign {@code \u0027-\u0027}\n     * ({@code \u0027\\u005Cu002D\u0027}) to indicate a negative value or an\n     * ASCII plus sign {@code \u0027+\u0027} ({@code \u0027\\u005Cu002B\u0027}) to\n     * indicate a positive value. The resulting integer value is\n     * returned, exactly as if the argument and the radix 10 were\n     * given as arguments to the {@link #parseInt(java.lang.String,\n     * int)} method.\n     *\n     * @param s    a {@code String} containing the {@code int}\n     *             representation to be parsed\n     * @return     the integer value represented by the argument in decimal.\n     * @throws     NumberFormatException  if the string does not contain a\n     *               parsable integer.\n     */\n    public static int parseInt(String s) throws NumberFormatException {\n        return parseInt(s,10);\n    }\n\n    /**\n     * Parses the string argument as an unsigned integer in the radix\n     * specified by the second argument.  An unsigned integer maps the\n     * values usually associated with negative numbers to positive\n     * numbers larger than {@code MAX_VALUE}.\n     *\n     * The characters in the string must all be digits of the\n     * specified radix (as determined by whether {@link\n     * java.lang.Character#digit(char, int)} returns a nonnegative\n     * value), except that the first character may be an ASCII plus\n     * sign {@code \u0027+\u0027} ({@code \u0027\\u005Cu002B\u0027}). The resulting\n     * integer value is returned.\n     *\n     * \u003cp\u003eAn exception of type {@code NumberFormatException} is\n     * thrown if any of the following situations occurs:\n     * \u003cul\u003e\n     * \u003cli\u003eThe first argument is {@code null} or is a string of\n     * length zero.\n     *\n     * \u003cli\u003eThe radix is either smaller than\n     * {@link java.lang.Character#MIN_RADIX} or\n     * larger than {@link java.lang.Character#MAX_RADIX}.\n     *\n     * \u003cli\u003eAny character of the string is not a digit of the specified\n     * radix, except that the first character may be a plus sign\n     * {@code \u0027+\u0027} ({@code \u0027\\u005Cu002B\u0027}) provided that the\n     * string is longer than length 1.\n     *\n     * \u003cli\u003eThe value represented by the string is larger than the\n     * largest unsigned {@code int}, 2\u003csup\u003e32\u003c/sup\u003e-1.\n     *\n     * \u003c/ul\u003e\n     *\n     *\n     * @param      s   the {@code String} containing the unsigned integer\n     *                  representation to be parsed\n     * @param      radix   the radix to be used while parsing {@code s}.\n     * @return     the integer represented by the string argument in the\n     *             specified radix.\n     * @throws     NumberFormatException if the {@code String}\n     *             does not contain a parsable {@code int}.\n     * @since 1.8\n     */\n    public static int parseUnsignedInt(String s, int radix)\n                throws NumberFormatException {\n        if (s \u003d\u003d null)  {\n            throw new NumberFormatException(\"Cannot parse null string\");\n        }\n\n        int len \u003d s.length();\n        if (len \u003e 0) {\n            char firstChar \u003d s.charAt(0);\n            if (firstChar \u003d\u003d \u0027-\u0027) {\n                throw new\n                    NumberFormatException(String.format(\"Illegal leading minus sign \" +\n                                                       \"on unsigned string %s.\", s));\n            } else {\n                if (len \u003c\u003d 5 || // Integer.MAX_VALUE in Character.MAX_RADIX is 6 digits\n                    (radix \u003d\u003d 10 \u0026\u0026 len \u003c\u003d 9) ) { // Integer.MAX_VALUE in base 10 is 10 digits\n                    return parseInt(s, radix);\n                } else {\n                    long ell \u003d Long.parseLong(s, radix);\n                    if ((ell \u0026 0xffff_ffff_0000_0000L) \u003d\u003d 0) {\n                        return (int) ell;\n                    } else {\n                        throw new\n                            NumberFormatException(String.format(\"String value %s exceeds \" +\n                                                                \"range of unsigned int.\", s));\n                    }\n                }\n            }\n        } else {\n            throw NumberFormatException.forInputString(s, radix);\n        }\n    }\n\n    /**\n     * Parses the {@link CharSequence} argument as an unsigned {@code int} in\n     * the specified {@code radix}, beginning at the specified\n     * {@code beginIndex} and extending to {@code endIndex - 1}.\n     *\n     * \u003cp\u003eThe method does not take steps to guard against the\n     * {@code CharSequence} being mutated while parsing.\n     *\n     * @param      s   the {@code CharSequence} containing the unsigned\n     *                 {@code int} representation to be parsed\n     * @param      beginIndex   the beginning index, inclusive.\n     * @param      endIndex     the ending index, exclusive.\n     * @param      radix   the radix to be used while parsing {@code s}.\n     * @return     the unsigned {@code int} represented by the subsequence in\n     *             the specified radix.\n     * @throws     NullPointerException  if {@code s} is null.\n     * @throws     IndexOutOfBoundsException  if {@code beginIndex} is\n     *             negative, or if {@code beginIndex} is greater than\n     *             {@code endIndex} or if {@code endIndex} is greater than\n     *             {@code s.length()}.\n     * @throws     NumberFormatException  if the {@code CharSequence} does not\n     *             contain a parsable unsigned {@code int} in the specified\n     *             {@code radix}, or if {@code radix} is either smaller than\n     *             {@link java.lang.Character#MIN_RADIX} or larger than\n     *             {@link java.lang.Character#MAX_RADIX}.\n     * @since  9\n     */\n    public static int parseUnsignedInt(CharSequence s, int beginIndex, int endIndex, int radix)\n                throws NumberFormatException {\n        Objects.requireNonNull(s);\n\n        if (beginIndex \u003c 0 || beginIndex \u003e endIndex || endIndex \u003e s.length()) {\n            throw new IndexOutOfBoundsException();\n        }\n        int start \u003d beginIndex, len \u003d endIndex - beginIndex;\n\n        if (len \u003e 0) {\n            char firstChar \u003d s.charAt(start);\n            if (firstChar \u003d\u003d \u0027-\u0027) {\n                throw new\n                    NumberFormatException(String.format(\"Illegal leading minus sign \" +\n                                                       \"on unsigned string %s.\", s));\n            } else {\n                if (len \u003c\u003d 5 || // Integer.MAX_VALUE in Character.MAX_RADIX is 6 digits\n                        (radix \u003d\u003d 10 \u0026\u0026 len \u003c\u003d 9)) { // Integer.MAX_VALUE in base 10 is 10 digits\n                    return parseInt(s, start, start + len, radix);\n                } else {\n                    long ell \u003d Long.parseLong(s, start, start + len, radix);\n                    if ((ell \u0026 0xffff_ffff_0000_0000L) \u003d\u003d 0) {\n                        return (int) ell;\n                    } else {\n                        throw new\n                            NumberFormatException(String.format(\"String value %s exceeds \" +\n                                                                \"range of unsigned int.\", s));\n                    }\n                }\n            }\n        } else {\n            throw new NumberFormatException(\"\");\n        }\n    }\n\n    /**\n     * Parses the string argument as an unsigned decimal integer. The\n     * characters in the string must all be decimal digits, except\n     * that the first character may be an ASCII plus sign {@code\n     * \u0027+\u0027} ({@code \u0027\\u005Cu002B\u0027}). The resulting integer value\n     * is returned, exactly as if the argument and the radix 10 were\n     * given as arguments to the {@link\n     * #parseUnsignedInt(java.lang.String, int)} method.\n     *\n     * @param s   a {@code String} containing the unsigned {@code int}\n     *            representation to be parsed\n     * @return    the unsigned integer value represented by the argument in decimal.\n     * @throws    NumberFormatException  if the string does not contain a\n     *            parsable unsigned integer.\n     * @since 1.8\n     */\n    public static int parseUnsignedInt(String s) throws NumberFormatException {\n        return parseUnsignedInt(s, 10);\n    }\n\n    /**\n     * Returns an {@code Integer} object holding the value\n     * extracted from the specified {@code String} when parsed\n     * with the radix given by the second argument. The first argument\n     * is interpreted as representing a signed integer in the radix\n     * specified by the second argument, exactly as if the arguments\n     * were given to the {@link #parseInt(java.lang.String, int)}\n     * method. The result is an {@code Integer} object that\n     * represents the integer value specified by the string.\n     *\n     * \u003cp\u003eIn other words, this method returns an {@code Integer}\n     * object equal to the value of:\n     *\n     * \u003cblockquote\u003e\n     *  {@code new Integer(Integer.parseInt(s, radix))}\n     * \u003c/blockquote\u003e\n     *\n     * @param      s   the string to be parsed.\n     * @param      radix the radix to be used in interpreting {@code s}\n     * @return     an {@code Integer} object holding the value\n     *             represented by the string argument in the specified\n     *             radix.\n     * @throws    NumberFormatException if the {@code String}\n     *            does not contain a parsable {@code int}.\n     */\n    public static Integer valueOf(String s, int radix) throws NumberFormatException {\n        return Integer.valueOf(parseInt(s,radix));\n    }\n\n    /**\n     * Returns an {@code Integer} object holding the\n     * value of the specified {@code String}. The argument is\n     * interpreted as representing a signed decimal integer, exactly\n     * as if the argument were given to the {@link\n     * #parseInt(java.lang.String)} method. The result is an\n     * {@code Integer} object that represents the integer value\n     * specified by the string.\n     *\n     * \u003cp\u003eIn other words, this method returns an {@code Integer}\n     * object equal to the value of:\n     *\n     * \u003cblockquote\u003e\n     *  {@code new Integer(Integer.parseInt(s))}\n     * \u003c/blockquote\u003e\n     *\n     * @param      s   the string to be parsed.\n     * @return     an {@code Integer} object holding the value\n     *             represented by the string argument.\n     * @throws     NumberFormatException  if the string cannot be parsed\n     *             as an integer.\n     */\n    public static Integer valueOf(String s) throws NumberFormatException {\n        return Integer.valueOf(parseInt(s, 10));\n    }\n\n    /**\n     * Cache to support the object identity semantics of autoboxing for values between\n     * -128 and 127 (inclusive) as required by JLS.\n     *\n     * The cache is initialized on first usage.  The size of the cache\n     * may be controlled by the {@code -XX:AutoBoxCacheMax\u003d\u003csize\u003e} option.\n     * During VM initialization, java.lang.Integer.IntegerCache.high property\n     * may be set and saved in the private system properties in the\n     * jdk.internal.misc.VM class.\n     *\n     * WARNING: The cache is archived with CDS and reloaded from the shared\n     * archive at runtime. The archived cache (Integer[]) and Integer objects\n     * reside in the closed archive heap regions. Care should be taken when\n     * changing the implementation and the cache array should not be assigned\n     * with new Integer object(s) after initialization.\n     */\n\n    private static class IntegerCache {\n        static final int low \u003d -128;\n        static final int high;\n        static final Integer[] cache;\n        static Integer[] archivedCache;\n\n        static {\n            // high value may be configured by property\n            int h \u003d 127;\n            String integerCacheHighPropValue \u003d\n                VM.getSavedProperty(\"java.lang.Integer.IntegerCache.high\");\n            if (integerCacheHighPropValue !\u003d null) {\n                try {\n                    h \u003d Math.max(parseInt(integerCacheHighPropValue), 127);\n                    // Maximum array size is Integer.MAX_VALUE\n                    h \u003d Math.min(h, Integer.MAX_VALUE - (-low) -1);\n                } catch( NumberFormatException nfe) {\n                    // If the property cannot be parsed into an int, ignore it.\n                }\n            }\n            high \u003d h;\n\n            // Load IntegerCache.archivedCache from archive, if possible\n            CDS.initializeFromArchive(IntegerCache.class);\n            int size \u003d (high - low) + 1;\n\n            // Use the archived cache if it exists and is large enough\n            if (archivedCache \u003d\u003d null || size \u003e archivedCache.length) {\n                Integer[] c \u003d new Integer[size];\n                int j \u003d low;\n                for(int i \u003d 0; i \u003c c.length; i++) {\n                    c[i] \u003d new Integer(j++);\n                }\n                archivedCache \u003d c;\n            }\n            cache \u003d archivedCache;\n            // range [-128, 127] must be interned (JLS7 5.1.7)\n            assert IntegerCache.high \u003e\u003d 127;\n        }\n\n        private IntegerCache() {}\n    }\n\n    /**\n     * Returns an {@code Integer} instance representing the specified\n     * {@code int} value.  If a new {@code Integer} instance is not\n     * required, this method should generally be used in preference to\n     * the constructor {@link #Integer(int)}, as this method is likely\n     * to yield significantly better space and time performance by\n     * caching frequently requested values.\n     *\n     * This method will always cache values in the range -128 to 127,\n     * inclusive, and may cache other values outside of this range.\n     *\n     * @param  i an {@code int} value.\n     * @return an {@code Integer} instance representing {@code i}.\n     * @since  1.5\n     */\n    @IntrinsicCandidate\n    public static Integer valueOf(int i) {\n        if (i \u003e\u003d IntegerCache.low \u0026\u0026 i \u003c\u003d IntegerCache.high)\n            return IntegerCache.cache[i + (-IntegerCache.low)];\n        return new Integer(i);\n    }\n\n    /**\n     * The value of the {@code Integer}.\n     *\n     * @serial\n     */\n    private final int value;\n\n    /**\n     * Constructs a newly allocated {@code Integer} object that\n     * represents the specified {@code int} value.\n     *\n     * @param   value   the value to be represented by the\n     *                  {@code Integer} object.\n     *\n     * @deprecated\n     * It is rarely appropriate to use this constructor. The static factory\n     * {@link #valueOf(int)} is generally a better choice, as it is\n     * likely to yield significantly better space and time performance.\n     */\n    @Deprecated(since\u003d\"9\", forRemoval \u003d true)\n    public Integer(int value) {\n        this.value \u003d value;\n    }\n\n    /**\n     * Constructs a newly allocated {@code Integer} object that\n     * represents the {@code int} value indicated by the\n     * {@code String} parameter. The string is converted to an\n     * {@code int} value in exactly the manner used by the\n     * {@code parseInt} method for radix 10.\n     *\n     * @param   s   the {@code String} to be converted to an {@code Integer}.\n     * @throws      NumberFormatException if the {@code String} does not\n     *              contain a parsable integer.\n     *\n     * @deprecated\n     * It is rarely appropriate to use this constructor.\n     * Use {@link #parseInt(String)} to convert a string to a\n     * {@code int} primitive, or use {@link #valueOf(String)}\n     * to convert a string to an {@code Integer} object.\n     */\n    @Deprecated(since\u003d\"9\", forRemoval \u003d true)\n    public Integer(String s) throws NumberFormatException {\n        this.value \u003d parseInt(s, 10);\n    }\n\n    /**\n     * Returns the value of this {@code Integer} as a {@code byte}\n     * after a narrowing primitive conversion.\n     * @jls 5.1.3 Narrowing Primitive Conversion\n     */\n    public byte byteValue() {\n        return (byte)value;\n    }\n\n    /**\n     * Returns the value of this {@code Integer} as a {@code short}\n     * after a narrowing primitive conversion.\n     * @jls 5.1.3 Narrowing Primitive Conversion\n     */\n    public short shortValue() {\n        return (short)value;\n    }\n\n    /**\n     * Returns the value of this {@code Integer} as an\n     * {@code int}.\n     */\n    @IntrinsicCandidate\n    public int intValue() {\n        return value;\n    }\n\n    /**\n     * Returns the value of this {@code Integer} as a {@code long}\n     * after a widening primitive conversion.\n     * @jls 5.1.2 Widening Primitive Conversion\n     * @see Integer#toUnsignedLong(int)\n     */\n    public long longValue() {\n        return (long)value;\n    }\n\n    /**\n     * Returns the value of this {@code Integer} as a {@code float}\n     * after a widening primitive conversion.\n     * @jls 5.1.2 Widening Primitive Conversion\n     */\n    public float floatValue() {\n        return (float)value;\n    }\n\n    /**\n     * Returns the value of this {@code Integer} as a {@code double}\n     * after a widening primitive conversion.\n     * @jls 5.1.2 Widening Primitive Conversion\n     */\n    public double doubleValue() {\n        return (double)value;\n    }\n\n    /**\n     * Returns a {@code String} object representing this\n     * {@code Integer}\u0027s value. The value is converted to signed\n     * decimal representation and returned as a string, exactly as if\n     * the integer value were given as an argument to the {@link\n     * java.lang.Integer#toString(int)} method.\n     *\n     * @return  a string representation of the value of this object in\n     *          base\u0026nbsp;10.\n     */\n    public String toString() {\n        return toString(value);\n    }\n\n    /**\n     * Returns a hash code for this {@code Integer}.\n     *\n     * @return  a hash code value for this object, equal to the\n     *          primitive {@code int} value represented by this\n     *          {@code Integer} object.\n     */\n    @Override\n    public int hashCode() {\n        return Integer.hashCode(value);\n    }\n\n    /**\n     * Returns a hash code for an {@code int} value; compatible with\n     * {@code Integer.hashCode()}.\n     *\n     * @param value the value to hash\n     * @since 1.8\n     *\n     * @return a hash code value for an {@code int} value.\n     */\n    public static int hashCode(int value) {\n        return value;\n    }\n\n    /**\n     * Compares this object to the specified object.  The result is\n     * {@code true} if and only if the argument is not\n     * {@code null} and is an {@code Integer} object that\n     * contains the same {@code int} value as this object.\n     *\n     * @param   obj   the object to compare with.\n     * @return  {@code true} if the objects are the same;\n     *          {@code false} otherwise.\n     */\n    public boolean equals(Object obj) {\n        if (obj instanceof Integer) {\n            return value \u003d\u003d ((Integer)obj).intValue();\n        }\n        return false;\n    }\n\n    /**\n     * Determines the integer value of the system property with the\n     * specified name.\n     *\n     * \u003cp\u003eThe first argument is treated as the name of a system\n     * property.  System properties are accessible through the {@link\n     * java.lang.System#getProperty(java.lang.String)} method. The\n     * string value of this property is then interpreted as an integer\n     * value using the grammar supported by {@link Integer#decode decode} and\n     * an {@code Integer} object representing this value is returned.\n     *\n     * \u003cp\u003eIf there is no property with the specified name, if the\n     * specified name is empty or {@code null}, or if the property\n     * does not have the correct numeric format, then {@code null} is\n     * returned.\n     *\n     * \u003cp\u003eIn other words, this method returns an {@code Integer}\n     * object equal to the value of:\n     *\n     * \u003cblockquote\u003e\n     *  {@code getInteger(nm, null)}\n     * \u003c/blockquote\u003e\n     *\n     * @param   nm   property name.\n     * @return  the {@code Integer} value of the property.\n     * @throws  SecurityException for the same reasons as\n     *          {@link System#getProperty(String) System.getProperty}\n     * @see     java.lang.System#getProperty(java.lang.String)\n     * @see     java.lang.System#getProperty(java.lang.String, java.lang.String)\n     */\n    public static Integer getInteger(String nm) {\n        return getInteger(nm, null);\n    }\n\n    /**\n     * Determines the integer value of the system property with the\n     * specified name.\n     *\n     * \u003cp\u003eThe first argument is treated as the name of a system\n     * property.  System properties are accessible through the {@link\n     * java.lang.System#getProperty(java.lang.String)} method. The\n     * string value of this property is then interpreted as an integer\n     * value using the grammar supported by {@link Integer#decode decode} and\n     * an {@code Integer} object representing this value is returned.\n     *\n     * \u003cp\u003eThe second argument is the default value. An {@code Integer} object\n     * that represents the value of the second argument is returned if there\n     * is no property of the specified name, if the property does not have\n     * the correct numeric format, or if the specified name is empty or\n     * {@code null}.\n     *\n     * \u003cp\u003eIn other words, this method returns an {@code Integer} object\n     * equal to the value of:\n     *\n     * \u003cblockquote\u003e\n     *  {@code getInteger(nm, new Integer(val))}\n     * \u003c/blockquote\u003e\n     *\n     * but in practice it may be implemented in a manner such as:\n     *\n     * \u003cblockquote\u003e\u003cpre\u003e\n     * Integer result \u003d getInteger(nm, null);\n     * return (result \u003d\u003d null) ? new Integer(val) : result;\n     * \u003c/pre\u003e\u003c/blockquote\u003e\n     *\n     * to avoid the unnecessary allocation of an {@code Integer}\n     * object when the default value is not needed.\n     *\n     * @param   nm   property name.\n     * @param   val   default value.\n     * @return  the {@code Integer} value of the property.\n     * @throws  SecurityException for the same reasons as\n     *          {@link System#getProperty(String) System.getProperty}\n     * @see     java.lang.System#getProperty(java.lang.String)\n     * @see     java.lang.System#getProperty(java.lang.String, java.lang.String)\n     */\n    public static Integer getInteger(String nm, int val) {\n        Integer result \u003d getInteger(nm, null);\n        return (result \u003d\u003d null) ? Integer.valueOf(val) : result;\n    }\n\n    /**\n     * Returns the integer value of the system property with the\n     * specified name.  The first argument is treated as the name of a\n     * system property.  System properties are accessible through the\n     * {@link java.lang.System#getProperty(java.lang.String)} method.\n     * The string value of this property is then interpreted as an\n     * integer value, as per the {@link Integer#decode decode} method,\n     * and an {@code Integer} object representing this value is\n     * returned; in summary:\n     *\n     * \u003cul\u003e\u003cli\u003eIf the property value begins with the two ASCII characters\n     *         {@code 0x} or the ASCII character {@code #}, not\n     *      followed by a minus sign, then the rest of it is parsed as a\n     *      hexadecimal integer exactly as by the method\n     *      {@link #valueOf(java.lang.String, int)} with radix 16.\n     * \u003cli\u003eIf the property value begins with the ASCII character\n     *     {@code 0} followed by another character, it is parsed as an\n     *     octal integer exactly as by the method\n     *     {@link #valueOf(java.lang.String, int)} with radix 8.\n     * \u003cli\u003eOtherwise, the property value is parsed as a decimal integer\n     * exactly as by the method {@link #valueOf(java.lang.String, int)}\n     * with radix 10.\n     * \u003c/ul\u003e\n     *\n     * \u003cp\u003eThe second argument is the default value. The default value is\n     * returned if there is no property of the specified name, if the\n     * property does not have the correct numeric format, or if the\n     * specified name is empty or {@code null}.\n     *\n     * @param   nm   property name.\n     * @param   val   default value.\n     * @return  the {@code Integer} value of the property.\n     * @throws  SecurityException for the same reasons as\n     *          {@link System#getProperty(String) System.getProperty}\n     * @see     System#getProperty(java.lang.String)\n     * @see     System#getProperty(java.lang.String, java.lang.String)\n     */\n    public static Integer getInteger(String nm, Integer val) {\n        String v \u003d null;\n        try {\n            v \u003d System.getProperty(nm);\n        } catch (IllegalArgumentException | NullPointerException e) {\n        }\n        if (v !\u003d null) {\n            try {\n                return Integer.decode(v);\n            } catch (NumberFormatException e) {\n            }\n        }\n        return val;\n    }\n\n    /**\n     * Decodes a {@code String} into an {@code Integer}.\n     * Accepts decimal, hexadecimal, and octal numbers given\n     * by the following grammar:\n     *\n     * \u003cblockquote\u003e\n     * \u003cdl\u003e\n     * \u003cdt\u003e\u003ci\u003eDecodableString:\u003c/i\u003e\n     * \u003cdd\u003e\u003ci\u003eSign\u003csub\u003eopt\u003c/sub\u003e DecimalNumeral\u003c/i\u003e\n     * \u003cdd\u003e\u003ci\u003eSign\u003csub\u003eopt\u003c/sub\u003e\u003c/i\u003e {@code 0x} \u003ci\u003eHexDigits\u003c/i\u003e\n     * \u003cdd\u003e\u003ci\u003eSign\u003csub\u003eopt\u003c/sub\u003e\u003c/i\u003e {@code 0X} \u003ci\u003eHexDigits\u003c/i\u003e\n     * \u003cdd\u003e\u003ci\u003eSign\u003csub\u003eopt\u003c/sub\u003e\u003c/i\u003e {@code #} \u003ci\u003eHexDigits\u003c/i\u003e\n     * \u003cdd\u003e\u003ci\u003eSign\u003csub\u003eopt\u003c/sub\u003e\u003c/i\u003e {@code 0} \u003ci\u003eOctalDigits\u003c/i\u003e\n     *\n     * \u003cdt\u003e\u003ci\u003eSign:\u003c/i\u003e\n     * \u003cdd\u003e{@code -}\n     * \u003cdd\u003e{@code +}\n     * \u003c/dl\u003e\n     * \u003c/blockquote\u003e\n     *\n     * \u003ci\u003eDecimalNumeral\u003c/i\u003e, \u003ci\u003eHexDigits\u003c/i\u003e, and \u003ci\u003eOctalDigits\u003c/i\u003e\n     * are as defined in section {@jls 3.10.1} of\n     * \u003ccite\u003eThe Java Language Specification\u003c/cite\u003e,\n     * except that underscores are not accepted between digits.\n     *\n     * \u003cp\u003eThe sequence of characters following an optional\n     * sign and/or radix specifier (\"{@code 0x}\", \"{@code 0X}\",\n     * \"{@code #}\", or leading zero) is parsed as by the {@code\n     * Integer.parseInt} method with the indicated radix (10, 16, or\n     * 8).  This sequence of characters must represent a positive\n     * value or a {@link NumberFormatException} will be thrown.  The\n     * result is negated if first character of the specified {@code\n     * String} is the minus sign.  No whitespace characters are\n     * permitted in the {@code String}.\n     *\n     * @param     nm the {@code String} to decode.\n     * @return    an {@code Integer} object holding the {@code int}\n     *             value represented by {@code nm}\n     * @throws    NumberFormatException  if the {@code String} does not\n     *            contain a parsable integer.\n     * @see java.lang.Integer#parseInt(java.lang.String, int)\n     */\n    public static Integer decode(String nm) throws NumberFormatException {\n        int radix \u003d 10;\n        int index \u003d 0;\n        boolean negative \u003d false;\n        Integer result;\n\n        if (nm.isEmpty())\n            throw new NumberFormatException(\"Zero length string\");\n        char firstChar \u003d nm.charAt(0);\n        // Handle sign, if present\n        if (firstChar \u003d\u003d \u0027-\u0027) {\n            negative \u003d true;\n            index++;\n        } else if (firstChar \u003d\u003d \u0027+\u0027)\n            index++;\n\n        // Handle radix specifier, if present\n        if (nm.startsWith(\"0x\", index) || nm.startsWith(\"0X\", index)) {\n            index +\u003d 2;\n            radix \u003d 16;\n        }\n        else if (nm.startsWith(\"#\", index)) {\n            index ++;\n            radix \u003d 16;\n        }\n        else if (nm.startsWith(\"0\", index) \u0026\u0026 nm.length() \u003e 1 + index) {\n            index ++;\n            radix \u003d 8;\n        }\n\n        if (nm.startsWith(\"-\", index) || nm.startsWith(\"+\", index))\n            throw new NumberFormatException(\"Sign character in wrong position\");\n\n        try {\n            result \u003d Integer.valueOf(nm.substring(index), radix);\n            result \u003d negative ? Integer.valueOf(-result.intValue()) : result;\n        } catch (NumberFormatException e) {\n            // If number is Integer.MIN_VALUE, we\u0027ll end up here. The next line\n            // handles this case, and causes any genuine format error to be\n            // rethrown.\n            String constant \u003d negative ? (\"-\" + nm.substring(index))\n                                       : nm.substring(index);\n            result \u003d Integer.valueOf(constant, radix);\n        }\n        return result;\n    }\n\n    /**\n     * Compares two {@code Integer} objects numerically.\n     *\n     * @param   anotherInteger   the {@code Integer} to be compared.\n     * @return  the value {@code 0} if this {@code Integer} is\n     *          equal to the argument {@code Integer}; a value less than\n     *          {@code 0} if this {@code Integer} is numerically less\n     *          than the argument {@code Integer}; and a value greater\n     *          than {@code 0} if this {@code Integer} is numerically\n     *           greater than the argument {@code Integer} (signed\n     *           comparison).\n     * @since   1.2\n     */\n    public int compareTo(Integer anotherInteger) {\n        return compare(this.value, anotherInteger.value);\n    }\n\n    /**\n     * Compares two {@code int} values numerically.\n     * The value returned is identical to what would be returned by:\n     * \u003cpre\u003e\n     *    Integer.valueOf(x).compareTo(Integer.valueOf(y))\n     * \u003c/pre\u003e\n     *\n     * @param  x the first {@code int} to compare\n     * @param  y the second {@code int} to compare\n     * @return the value {@code 0} if {@code x \u003d\u003d y};\n     *         a value less than {@code 0} if {@code x \u003c y}; and\n     *         a value greater than {@code 0} if {@code x \u003e y}\n     * @since 1.7\n     */\n    public static int compare(int x, int y) {\n        return (x \u003c y) ? -1 : ((x \u003d\u003d y) ? 0 : 1);\n    }\n\n    /**\n     * Compares two {@code int} values numerically treating the values\n     * as unsigned.\n     *\n     * @param  x the first {@code int} to compare\n     * @param  y the second {@code int} to compare\n     * @return the value {@code 0} if {@code x \u003d\u003d y}; a value less\n     *         than {@code 0} if {@code x \u003c y} as unsigned values; and\n     *         a value greater than {@code 0} if {@code x \u003e y} as\n     *         unsigned values\n     * @since 1.8\n     */\n    public static int compareUnsigned(int x, int y) {\n        return compare(x + MIN_VALUE, y + MIN_VALUE);\n    }\n\n    /**\n     * Converts the argument to a {@code long} by an unsigned\n     * conversion.  In an unsigned conversion to a {@code long}, the\n     * high-order 32 bits of the {@code long} are zero and the\n     * low-order 32 bits are equal to the bits of the integer\n     * argument.\n     *\n     * Consequently, zero and positive {@code int} values are mapped\n     * to a numerically equal {@code long} value and negative {@code\n     * int} values are mapped to a {@code long} value equal to the\n     * input plus 2\u003csup\u003e32\u003c/sup\u003e.\n     *\n     * @param  x the value to convert to an unsigned {@code long}\n     * @return the argument converted to {@code long} by an unsigned\n     *         conversion\n     * @since 1.8\n     */\n    public static long toUnsignedLong(int x) {\n        return ((long) x) \u0026 0xffffffffL;\n    }\n\n    /**\n     * Returns the unsigned quotient of dividing the first argument by\n     * the second where each argument and the result is interpreted as\n     * an unsigned value.\n     *\n     * \u003cp\u003eNote that in two\u0027s complement arithmetic, the three other\n     * basic arithmetic operations of add, subtract, and multiply are\n     * bit-wise identical if the two operands are regarded as both\n     * being signed or both being unsigned.  Therefore separate {@code\n     * addUnsigned}, etc. methods are not provided.\n     *\n     * @param dividend the value to be divided\n     * @param divisor the value doing the dividing\n     * @return the unsigned quotient of the first argument divided by\n     * the second argument\n     * @see #remainderUnsigned\n     * @since 1.8\n     */\n    public static int divideUnsigned(int dividend, int divisor) {\n        // In lieu of tricky code, for now just use long arithmetic.\n        return (int)(toUnsignedLong(dividend) / toUnsignedLong(divisor));\n    }\n\n    /**\n     * Returns the unsigned remainder from dividing the first argument\n     * by the second where each argument and the result is interpreted\n     * as an unsigned value.\n     *\n     * @param dividend the value to be divided\n     * @param divisor the value doing the dividing\n     * @return the unsigned remainder of the first argument divided by\n     * the second argument\n     * @see #divideUnsigned\n     * @since 1.8\n     */\n    public static int remainderUnsigned(int dividend, int divisor) {\n        // In lieu of tricky code, for now just use long arithmetic.\n        return (int)(toUnsignedLong(dividend) % toUnsignedLong(divisor));\n    }\n\n\n    // Bit twiddling\n\n    /**\n     * The number of bits used to represent an {@code int} value in two\u0027s\n     * complement binary form.\n     *\n     * @since 1.5\n     */\n    @Native public static final int SIZE \u003d 32;\n\n    /**\n     * The number of bytes used to represent an {@code int} value in two\u0027s\n     * complement binary form.\n     *\n     * @since 1.8\n     */\n    public static final int BYTES \u003d SIZE / Byte.SIZE;\n\n    /**\n     * Returns an {@code int} value with at most a single one-bit, in the\n     * position of the highest-order (\"leftmost\") one-bit in the specified\n     * {@code int} value.  Returns zero if the specified value has no\n     * one-bits in its two\u0027s complement binary representation, that is, if it\n     * is equal to zero.\n     *\n     * @param i the value whose highest one bit is to be computed\n     * @return an {@code int} value with a single one-bit, in the position\n     *     of the highest-order one-bit in the specified value, or zero if\n     *     the specified value is itself equal to zero.\n     * @since 1.5\n     */\n    public static int highestOneBit(int i) {\n        return i \u0026 (MIN_VALUE \u003e\u003e\u003e numberOfLeadingZeros(i));\n    }\n\n    /**\n     * Returns an {@code int} value with at most a single one-bit, in the\n     * position of the lowest-order (\"rightmost\") one-bit in the specified\n     * {@code int} value.  Returns zero if the specified value has no\n     * one-bits in its two\u0027s complement binary representation, that is, if it\n     * is equal to zero.\n     *\n     * @param i the value whose lowest one bit is to be computed\n     * @return an {@code int} value with a single one-bit, in the position\n     *     of the lowest-order one-bit in the specified value, or zero if\n     *     the specified value is itself equal to zero.\n     * @since 1.5\n     */\n    public static int lowestOneBit(int i) {\n        // HD, Section 2-1\n        return i \u0026 -i;\n    }\n\n    /**\n     * Returns the number of zero bits preceding the highest-order\n     * (\"leftmost\") one-bit in the two\u0027s complement binary representation\n     * of the specified {@code int} value.  Returns 32 if the\n     * specified value has no one-bits in its two\u0027s complement representation,\n     * in other words if it is equal to zero.\n     *\n     * \u003cp\u003eNote that this method is closely related to the logarithm base 2.\n     * For all positive {@code int} values x:\n     * \u003cul\u003e\n     * \u003cli\u003efloor(log\u003csub\u003e2\u003c/sub\u003e(x)) \u003d {@code 31 - numberOfLeadingZeros(x)}\n     * \u003cli\u003eceil(log\u003csub\u003e2\u003c/sub\u003e(x)) \u003d {@code 32 - numberOfLeadingZeros(x - 1)}\n     * \u003c/ul\u003e\n     *\n     * @param i the value whose number of leading zeros is to be computed\n     * @return the number of zero bits preceding the highest-order\n     *     (\"leftmost\") one-bit in the two\u0027s complement binary representation\n     *     of the specified {@code int} value, or 32 if the value\n     *     is equal to zero.\n     * @since 1.5\n     */\n    @IntrinsicCandidate\n    public static int numberOfLeadingZeros(int i) {\n        // HD, Count leading 0\u0027s\n        if (i \u003c\u003d 0)\n            return i \u003d\u003d 0 ? 32 : 0;\n        int n \u003d 31;\n        if (i \u003e\u003d 1 \u003c\u003c 16) { n -\u003d 16; i \u003e\u003e\u003e\u003d 16; }\n        if (i \u003e\u003d 1 \u003c\u003c  8) { n -\u003d  8; i \u003e\u003e\u003e\u003d  8; }\n        if (i \u003e\u003d 1 \u003c\u003c  4) { n -\u003d  4; i \u003e\u003e\u003e\u003d  4; }\n        if (i \u003e\u003d 1 \u003c\u003c  2) { n -\u003d  2; i \u003e\u003e\u003e\u003d  2; }\n        return n - (i \u003e\u003e\u003e 1);\n    }\n\n    /**\n     * Returns the number of zero bits following the lowest-order (\"rightmost\")\n     * one-bit in the two\u0027s complement binary representation of the specified\n     * {@code int} value.  Returns 32 if the specified value has no\n     * one-bits in its two\u0027s complement representation, in other words if it is\n     * equal to zero.\n     *\n     * @param i the value whose number of trailing zeros is to be computed\n     * @return the number of zero bits following the lowest-order (\"rightmost\")\n     *     one-bit in the two\u0027s complement binary representation of the\n     *     specified {@code int} value, or 32 if the value is equal\n     *     to zero.\n     * @since 1.5\n     */\n    @IntrinsicCandidate\n    public static int numberOfTrailingZeros(int i) {\n        // HD, Count trailing 0\u0027s\n        i \u003d ~i \u0026 (i - 1);\n        if (i \u003c\u003d 0) return i \u0026 32;\n        int n \u003d 1;\n        if (i \u003e 1 \u003c\u003c 16) { n +\u003d 16; i \u003e\u003e\u003e\u003d 16; }\n        if (i \u003e 1 \u003c\u003c  8) { n +\u003d  8; i \u003e\u003e\u003e\u003d  8; }\n        if (i \u003e 1 \u003c\u003c  4) { n +\u003d  4; i \u003e\u003e\u003e\u003d  4; }\n        if (i \u003e 1 \u003c\u003c  2) { n +\u003d  2; i \u003e\u003e\u003e\u003d  2; }\n        return n + (i \u003e\u003e\u003e 1);\n    }\n\n    /**\n     * Returns the number of one-bits in the two\u0027s complement binary\n     * representation of the specified {@code int} value.  This function is\n     * sometimes referred to as the \u003ci\u003epopulation count\u003c/i\u003e.\n     *\n     * @param i the value whose bits are to be counted\n     * @return the number of one-bits in the two\u0027s complement binary\n     *     representation of the specified {@code int} value.\n     * @since 1.5\n     */\n    @IntrinsicCandidate\n    public static int bitCount(int i) {\n        // HD, Figure 5-2\n        i \u003d i - ((i \u003e\u003e\u003e 1) \u0026 0x55555555);\n        i \u003d (i \u0026 0x33333333) + ((i \u003e\u003e\u003e 2) \u0026 0x33333333);\n        i \u003d (i + (i \u003e\u003e\u003e 4)) \u0026 0x0f0f0f0f;\n        i \u003d i + (i \u003e\u003e\u003e 8);\n        i \u003d i + (i \u003e\u003e\u003e 16);\n        return i \u0026 0x3f;\n    }\n\n    /**\n     * Returns the value obtained by rotating the two\u0027s complement binary\n     * representation of the specified {@code int} value left by the\n     * specified number of bits.  (Bits shifted out of the left hand, or\n     * high-order, side reenter on the right, or low-order.)\n     *\n     * \u003cp\u003eNote that left rotation with a negative distance is equivalent to\n     * right rotation: {@code rotateLeft(val, -distance) \u003d\u003d rotateRight(val,\n     * distance)}.  Note also that rotation by any multiple of 32 is a\n     * no-op, so all but the last five bits of the rotation distance can be\n     * ignored, even if the distance is negative: {@code rotateLeft(val,\n     * distance) \u003d\u003d rotateLeft(val, distance \u0026 0x1F)}.\n     *\n     * @param i the value whose bits are to be rotated left\n     * @param distance the number of bit positions to rotate left\n     * @return the value obtained by rotating the two\u0027s complement binary\n     *     representation of the specified {@code int} value left by the\n     *     specified number of bits.\n     * @since 1.5\n     */\n    public static int rotateLeft(int i, int distance) {\n        return (i \u003c\u003c distance) | (i \u003e\u003e\u003e -distance);\n    }\n\n    /**\n     * Returns the value obtained by rotating the two\u0027s complement binary\n     * representation of the specified {@code int} value right by the\n     * specified number of bits.  (Bits shifted out of the right hand, or\n     * low-order, side reenter on the left, or high-order.)\n     *\n     * \u003cp\u003eNote that right rotation with a negative distance is equivalent to\n     * left rotation: {@code rotateRight(val, -distance) \u003d\u003d rotateLeft(val,\n     * distance)}.  Note also that rotation by any multiple of 32 is a\n     * no-op, so all but the last five bits of the rotation distance can be\n     * ignored, even if the distance is negative: {@code rotateRight(val,\n     * distance) \u003d\u003d rotateRight(val, distance \u0026 0x1F)}.\n     *\n     * @param i the value whose bits are to be rotated right\n     * @param distance the number of bit positions to rotate right\n     * @return the value obtained by rotating the two\u0027s complement binary\n     *     representation of the specified {@code int} value right by the\n     *     specified number of bits.\n     * @since 1.5\n     */\n    public static int rotateRight(int i, int distance) {\n        return (i \u003e\u003e\u003e distance) | (i \u003c\u003c -distance);\n    }\n\n    /**\n     * Returns the value obtained by reversing the order of the bits in the\n     * two\u0027s complement binary representation of the specified {@code int}\n     * value.\n     *\n     * @param i the value to be reversed\n     * @return the value obtained by reversing order of the bits in the\n     *     specified {@code int} value.\n     * @since 1.5\n     */\n    public static int reverse(int i) {\n        // HD, Figure 7-1\n        i \u003d (i \u0026 0x55555555) \u003c\u003c 1 | (i \u003e\u003e\u003e 1) \u0026 0x55555555;\n        i \u003d (i \u0026 0x33333333) \u003c\u003c 2 | (i \u003e\u003e\u003e 2) \u0026 0x33333333;\n        i \u003d (i \u0026 0x0f0f0f0f) \u003c\u003c 4 | (i \u003e\u003e\u003e 4) \u0026 0x0f0f0f0f;\n\n        return reverseBytes(i);\n    }\n\n    /**\n     * Returns the signum function of the specified {@code int} value.  (The\n     * return value is -1 if the specified value is negative; 0 if the\n     * specified value is zero; and 1 if the specified value is positive.)\n     *\n     * @param i the value whose signum is to be computed\n     * @return the signum function of the specified {@code int} value.\n     * @since 1.5\n     */\n    public static int signum(int i) {\n        // HD, Section 2-7\n        return (i \u003e\u003e 31) | (-i \u003e\u003e\u003e 31);\n    }\n\n    /**\n     * Returns the value obtained by reversing the order of the bytes in the\n     * two\u0027s complement representation of the specified {@code int} value.\n     *\n     * @param i the value whose bytes are to be reversed\n     * @return the value obtained by reversing the bytes in the specified\n     *     {@code int} value.\n     * @since 1.5\n     */\n    @IntrinsicCandidate\n    public static int reverseBytes(int i) {\n        return (i \u003c\u003c 24)            |\n               ((i \u0026 0xff00) \u003c\u003c 8)  |\n               ((i \u003e\u003e\u003e 8) \u0026 0xff00) |\n               (i \u003e\u003e\u003e 24);\n    }\n\n    /**\n     * Adds two integers together as per the + operator.\n     *\n     * @param a the first operand\n     * @param b the second operand\n     * @return the sum of {@code a} and {@code b}\n     * @see java.util.function.BinaryOperator\n     * @since 1.8\n     */\n    public static int sum(int a, int b) {\n        return a + b;\n    }\n\n    /**\n     * Returns the greater of two {@code int} values\n     * as if by calling {@link Math#max(int, int) Math.max}.\n     *\n     * @param a the first operand\n     * @param b the second operand\n     * @return the greater of {@code a} and {@code b}\n     * @see java.util.function.BinaryOperator\n     * @since 1.8\n     */\n    public static int max(int a, int b) {\n        return Math.max(a, b);\n    }\n\n    /**\n     * Returns the smaller of two {@code int} values\n     * as if by calling {@link Math#min(int, int) Math.min}.\n     *\n     * @param a the first operand\n     * @param b the second operand\n     * @return the smaller of {@code a} and {@code b}\n     * @see java.util.function.BinaryOperator\n     * @since 1.8\n     */\n    public static int min(int a, int b) {\n        return Math.min(a, b);\n    }\n\n    /**\n     * Returns an {@link Optional} containing the nominal descriptor for this\n     * instance, which is the instance itself.\n     *\n     * @return an {@link Optional} describing the {@linkplain Integer} instance\n     * @since 12\n     */\n    @Override\n    public Optional\u003cInteger\u003e describeConstable() {\n        return Optional.of(this);\n    }\n\n    /**\n     * Resolves this instance as a {@link ConstantDesc}, the result of which is\n     * the instance itself.\n     *\n     * @param lookup ignored\n     * @return the {@linkplain Integer} instance\n     * @since 12\n     */\n    @Override\n    public Integer resolveConstantDesc(MethodHandles.Lookup lookup) {\n        return this;\n    }\n\n    /** use serialVersionUID from JDK 1.0.2 for interoperability */\n    @java.io.Serial\n    @Native private static final long serialVersionUID \u003d 1360826667806852920L;\n}\n"
    }
  }
}
java.lang.IllegalArgumentException: Illegal character in opaque part at index 188: jar:file:///C:/Users/Vinicius/AppData/Local/Coursier/cache/arc/https/github.com/adoptium/temurin17-binaries/releases/download/jdk-17%2B35/OpenJDK17-jdk_x64_windows_hotspot_17_35.zip/jdk-17 35/lib/src.zip!/java.base/java/lang/Integer.java
	at java.base/java.net.URI.create(URI.java:906)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:178)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.$anonfun$toAbsolutePath$3(MtagsEnrichments.scala:175)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.withTryDecode$1(MtagsEnrichments.scala:153)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:175)
	at scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:756)
	at scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:753)
	at scala.meta.internal.metals.WorkspaceLspService.didOpen(WorkspaceLspService.scala:388)
	at scala.meta.metals.lsp.DelegatingScalaService.didOpen(DelegatingScalaService.scala:39)
	at jdk.internal.reflect.GeneratedMethodAccessor31.invoke(Unknown Source)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:568)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$recursiveFindRpcMethods$0(GenericEndpoint.java:65)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.notify(GenericEndpoint.java:160)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleNotification(RemoteEndpoint.java:231)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:198)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:185)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:97)
	at org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:114)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:539)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.base/java.lang.Thread.run(Thread.java:833)
Caused by: java.net.URISyntaxException: Illegal character in opaque part at index 188: jar:file:///C:/Users/Vinicius/AppData/Local/Coursier/cache/arc/https/github.com/adoptium/temurin17-binaries/releases/download/jdk-17%2B35/OpenJDK17-jdk_x64_windows_hotspot_17_35.zip/jdk-17 35/lib/src.zip!/java.base/java/lang/Integer.java
	at java.base/java.net.URI$Parser.fail(URI.java:2974)
	at java.base/java.net.URI$Parser.checkChars(URI.java:3145)
	at java.base/java.net.URI$Parser.parse(URI.java:3181)
	at java.base/java.net.URI.<init>(URI.java:623)
	at java.base/java.net.URI.create(URI.java:904)
	... 23 more

jul. 19, 2024 12:49:50 AM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleNotification
ADVERTÊNCIA: Notification threw an exception: {
  "jsonrpc": "2.0",
  "method": "textDocument/didClose",
  "params": {
    "textDocument": {
      "uri": "jar:file%3A///C%3A/Users/Vinicius/AppData/Local/Coursier/cache/arc/https/github.com/adoptium/temurin17-binaries/releases/download/jdk-17%25252B35/OpenJDK17-jdk_x64_windows_hotspot_17_35.zip/jdk-17%2B35/lib/src.zip%21/java.base/java/lang/Integer.java"
    }
  }
}
java.lang.IllegalArgumentException: Illegal character in opaque part at index 188: jar:file:///C:/Users/Vinicius/AppData/Local/Coursier/cache/arc/https/github.com/adoptium/temurin17-binaries/releases/download/jdk-17%2B35/OpenJDK17-jdk_x64_windows_hotspot_17_35.zip/jdk-17 35/lib/src.zip!/java.base/java/lang/Integer.java
	at java.base/java.net.URI.create(URI.java:906)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:178)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.$anonfun$toAbsolutePath$3(MtagsEnrichments.scala:175)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.withTryDecode$1(MtagsEnrichments.scala:153)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:175)
	at scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:756)
	at scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:753)
	at scala.meta.internal.metals.WorkspaceLspService.didClose(WorkspaceLspService.scala:407)
	at scala.meta.metals.lsp.DelegatingScalaService.didClose(DelegatingScalaService.scala:53)
	at jdk.internal.reflect.GeneratedMethodAccessor32.invoke(Unknown Source)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:568)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$recursiveFindRpcMethods$0(GenericEndpoint.java:65)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.notify(GenericEndpoint.java:160)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleNotification(RemoteEndpoint.java:231)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:198)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:185)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:97)
	at org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:114)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:539)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.base/java.lang.Thread.run(Thread.java:833)
Caused by: java.net.URISyntaxException: Illegal character in opaque part at index 188: jar:file:///C:/Users/Vinicius/AppData/Local/Coursier/cache/arc/https/github.com/adoptium/temurin17-binaries/releases/download/jdk-17%2B35/OpenJDK17-jdk_x64_windows_hotspot_17_35.zip/jdk-17 35/lib/src.zip!/java.base/java/lang/Integer.java
	at java.base/java.net.URI$Parser.fail(URI.java:2974)
	at java.base/java.net.URI$Parser.checkChars(URI.java:3145)
	at java.base/java.net.URI$Parser.parse(URI.java:3181)
	at java.base/java.net.URI.<init>(URI.java:623)
	at java.base/java.net.URI.create(URI.java:904)
	... 23 more

jul. 19, 2024 12:49:51 AM scala.meta.internal.pc.CompilerAccess retryWithCleanCompiler
INFORMAÇÕES: compiler crashed due to an error in the Scala compiler, retrying with new compiler instance.
jul. 19, 2024 12:49:51 AM scala.meta.internal.pc.CompilerAccess handleError
GRAVE: A severe compiler error occurred, full details of the error can be found in the error report C:\Users\Vinicius\UnB\FLanguage\.metals\.reports\metals-full\2024-07-19\r_compiler-error_(root)_00-49-51-235.md
jul. 19, 2024 12:49:51 AM scala.meta.internal.pc.CompilerAccess handleError
GRAVE: A severe compiler error occurred, full details of the error can be found in the error report C:\Users\Vinicius\UnB\FLanguage\.metals\.reports\metals-full\2024-07-19\r_compiler-error_(root)_00-49-51-303.md
jul. 19, 2024 12:49:51 AM scala.meta.internal.pc.CompilerAccess retryWithCleanCompiler
INFORMAÇÕES: compiler crashed due to an error in the Scala compiler, retrying with new compiler instance.
2024.07.19 00:49:51 ERROR TextDocument.uri not found: src/main/scala/br/unb/cic/flang/MonadState.scala
scala.meta.internal.metals.ScalafixProvider$ScalafixRunException: TextDocument.uri not found: src/main/scala/br/unb/cic/flang/MonadState.scala
	at scala.meta.internal.metals.ScalafixProvider.$anonfun$runScalafixRules$2(ScalafixProvider.scala:130)
	at scala.concurrent.impl.Promise$Transformation.run(Promise.scala:470)
	at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.lang.Thread.run(Thread.java:833)

jul. 19, 2024 12:49:51 AM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint fallbackResponseError
GRAVE: Internal error: scala.meta.internal.metals.ScalafixProvider$ScalafixRunException: TextDocument.uri not found: src/main/scala/br/unb/cic/flang/MonadState.scala
java.util.concurrent.CompletionException: scala.meta.internal.metals.ScalafixProvider$ScalafixRunException: TextDocument.uri not found: src/main/scala/br/unb/cic/flang/MonadState.scala
	at java.base/java.util.concurrent.CompletableFuture.encodeThrowable(CompletableFuture.java:332)
	at java.base/java.util.concurrent.CompletableFuture.completeThrowable(CompletableFuture.java:347)
	at java.base/java.util.concurrent.CompletableFuture$UniAccept.tryFire(CompletableFuture.java:708)
	at java.base/java.util.concurrent.CompletableFuture.postComplete(CompletableFuture.java:510)
	at java.base/java.util.concurrent.CompletableFuture.completeExceptionally(CompletableFuture.java:2162)
	at scala.meta.internal.metals.CancelTokens$.$anonfun$future$1(CancelTokens.scala:40)
	at scala.meta.internal.metals.CancelTokens$.$anonfun$future$1$adapted(CancelTokens.scala:38)
	at scala.concurrent.impl.Promise$Transformation.run(Promise.scala:484)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.base/java.lang.Thread.run(Thread.java:833)
Caused by: scala.meta.internal.metals.ScalafixProvider$ScalafixRunException: TextDocument.uri not found: src/main/scala/br/unb/cic/flang/MonadState.scala
	at scala.meta.internal.metals.ScalafixProvider.$anonfun$runScalafixRules$2(ScalafixProvider.scala:130)
	at scala.concurrent.impl.Promise$Transformation.run(Promise.scala:470)
	... 3 more

2024.07.19 00:49:51 INFO  compiling root (1 scala source)
jul. 19, 2024 12:49:51 AM scala.meta.internal.pc.CompilerAccess handleError
GRAVE: A severe compiler error occurred, full details of the error can be found in the error report C:\Users\Vinicius\UnB\FLanguage\.metals\.reports\metals-full\2024-07-19\r_compiler-error_(root)_00-49-51-453.md
2024.07.19 00:49:51 INFO  time: compiled root in 0.14s
jul. 19, 2024 12:49:56 AM scala.meta.internal.pc.CompilerAccess retryWithCleanCompiler
INFORMAÇÕES: compiler crashed due to an error in the Scala compiler, retrying with new compiler instance.
jul. 19, 2024 12:49:56 AM scala.meta.internal.pc.CompilerAccess handleError
GRAVE: A severe compiler error occurred, full details of the error can be found in the error report C:\Users\Vinicius\UnB\FLanguage\.metals\.reports\metals-full\2024-07-19\r_compiler-error_(root)_00-49-56-204.md
2024.07.19 00:49:56 INFO  Can not organize imports if file has error
jul. 19, 2024 12:50:10 AM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
ADVERTÊNCIA: Unmatched cancel notification for request id 5584
jul. 19, 2024 12:50:11 AM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
ADVERTÊNCIA: Unmatched cancel notification for request id 5592
jul. 19, 2024 12:50:14 AM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
ADVERTÊNCIA: Unmatched cancel notification for request id 5600
jul. 19, 2024 12:50:15 AM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
ADVERTÊNCIA: Unmatched cancel notification for request id 5611
2024.07.19 00:50:21 INFO  compiling root-test (1 scala source)
2024.07.19 00:50:21 INFO  time: compiled root-test in 0.25s
2024.07.19 00:50:28 INFO  Can not organize imports if file has error
2024.07.19 00:50:28 INFO  compiling root-test (1 scala source)
2024.07.19 00:50:29 INFO  time: compiled root-test in 1.34s
2024.07.19 00:50:32 INFO  compiling root-test (1 scala source)
2024.07.19 00:50:32 WARN  Could not load snapshot text for C:\Users\Vinicius\UnB\FLanguage\src\test\scala\br\unb\cic\flang\MonadTest.scala
2024.07.19 00:50:32 INFO  time: compiled root-test in 0.26s
2024.07.19 00:50:33 WARN  Could not load snapshot text for C:\Users\Vinicius\UnB\FLanguage\src\test\scala\br\unb\cic\flang\MonadTest.scala
2024.07.19 00:50:38 WARN  Could not load snapshot text for C:\Users\Vinicius\UnB\FLanguage\src\test\scala\br\unb\cic\flang\MonadTest.scala
2024.07.19 00:50:40 WARN  Could not load snapshot text for C:\Users\Vinicius\UnB\FLanguage\src\test\scala\br\unb\cic\flang\MonadTest.scala
2024.07.19 00:50:43 WARN  Could not load snapshot text for C:\Users\Vinicius\UnB\FLanguage\src\test\scala\br\unb\cic\flang\MonadTest.scala
2024.07.19 00:50:43 WARN  Could not load snapshot text for C:\Users\Vinicius\UnB\FLanguage\src\test\scala\br\unb\cic\flang\MonadTest.scala
jul. 19, 2024 12:50:43 AM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
ADVERTÊNCIA: Unmatched cancel notification for request id 5732
2024.07.19 00:50:43 WARN  Could not load snapshot text for C:\Users\Vinicius\UnB\FLanguage\src\test\scala\br\unb\cic\flang\MonadTest.scala
2024.07.19 00:50:43 WARN  Could not load snapshot text for C:\Users\Vinicius\UnB\FLanguage\src\test\scala\br\unb\cic\flang\MonadTest.scala
2024.07.19 00:50:44 WARN  Could not load snapshot text for C:\Users\Vinicius\UnB\FLanguage\src\test\scala\br\unb\cic\flang\MonadTest.scala
2024.07.19 00:50:44 WARN  Could not load snapshot text for C:\Users\Vinicius\UnB\FLanguage\src\test\scala\br\unb\cic\flang\MonadTest.scala
2024.07.19 00:50:44 WARN  Could not load snapshot text for C:\Users\Vinicius\UnB\FLanguage\src\test\scala\br\unb\cic\flang\MonadTest.scala
2024.07.19 00:50:44 INFO  Can not organize imports if file has error
2024.07.19 00:50:44 WARN  Could not load snapshot text for C:\Users\Vinicius\UnB\FLanguage\src\test\scala\br\unb\cic\flang\MonadTest.scala
2024.07.19 00:50:44 WARN  Could not load snapshot text for C:\Users\Vinicius\UnB\FLanguage\src\test\scala\br\unb\cic\flang\MonadTest.scala
2024.07.19 00:50:44 INFO  compiling root-test (1 scala source)
2024.07.19 00:50:44 INFO  time: compiled root-test in 0.29s
2024.07.19 00:50:45 WARN  Could not load snapshot text for C:\Users\Vinicius\UnB\FLanguage\src\test\scala\br\unb\cic\flang\MonadTest.scala
2024.07.19 00:50:46 WARN  Could not load snapshot text for C:\Users\Vinicius\UnB\FLanguage\src\test\scala\br\unb\cic\flang\MonadTest.scala
2024.07.19 00:50:46 INFO  Can not organize imports if file has error
2024.07.19 00:50:46 INFO  compiling root-test (1 scala source)
2024.07.19 00:50:46 INFO  time: compiled root-test in 0.93s
2024.07.19 00:50:54 INFO  compiling root-test (1 scala source)
2024.07.19 00:50:54 INFO  time: compiled root-test in 0.26s
2024.07.19 00:51:11 INFO  compiling root-test (1 scala source)
2024.07.19 00:51:11 INFO  time: compiled root-test in 0.29s
2024.07.19 00:51:17 INFO  Can not organize imports if file has error
2024.07.19 00:51:17 INFO  compiling root-test (1 scala source)
2024.07.19 00:51:17 INFO  time: compiled root-test in 0.15s
2024.07.19 00:51:19 INFO  Can not organize imports if file has error
2024.07.19 00:51:19 INFO  compiling root-test (1 scala source)
2024.07.19 00:51:19 INFO  time: compiled root-test in 0.25s
jul. 19, 2024 12:51:21 AM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
ADVERTÊNCIA: Unmatched cancel notification for request id 5910
2024.07.19 00:51:27 INFO  compiling root-test (1 scala source)
2024.07.19 00:51:27 INFO  time: compiled root-test in 0.33s
2024.07.19 00:53:25 INFO  compiling root-test (1 scala source)
2024.07.19 00:53:25 INFO  time: compiled root-test in 0.37s
2024.07.19 00:54:19 INFO  compiling root-test (1 scala source)
2024.07.19 00:54:19 INFO  time: compiled root-test in 0.31s
2024.07.19 00:54:33 INFO  Can not organize imports if file has error
2024.07.19 00:54:33 INFO  compiling root-test (1 scala source)
2024.07.19 00:54:33 INFO  time: compiled root-test in 0.98s
2024.07.19 00:55:07 INFO  compiling root-test (1 scala source)
2024.07.19 00:55:07 INFO  time: compiled root-test in 0.25s
2024.07.19 00:55:10 INFO  Can not organize imports if file has error
2024.07.19 00:55:10 INFO  compiling root-test (1 scala source)
2024.07.19 00:55:11 INFO  time: compiled root-test in 1.31s
2024.07.19 00:55:27 INFO  compiling root-test (1 scala source)
2024.07.19 00:55:27 INFO  time: compiled root-test in 0.25s
2024.07.19 00:55:31 INFO  Can not organize imports if file has error
2024.07.19 00:55:31 INFO  compiling root-test (1 scala source)
2024.07.19 00:55:32 INFO  time: compiled root-test in 1.02s
jul. 19, 2024 12:55:34 AM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleNotification
ADVERTÊNCIA: Notification threw an exception: {
  "jsonrpc": "2.0",
  "method": "textDocument/didOpen",
  "params": {
    "textDocument": {
      "uri": "jar:file%3A///C%3A/Users/Vinicius/AppData/Local/Coursier/cache/arc/https/github.com/adoptium/temurin17-binaries/releases/download/jdk-17%25252B35/OpenJDK17-jdk_x64_windows_hotspot_17_35.zip/jdk-17%2B35/lib/src.zip%21/java.base/java/lang/String.java",
      "languageId": "java",
      "version": 1,
      "text": "/*\n * Copyright (c) 1994, 2021, Oracle and/or its affiliates. All rights reserved.\n * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n *\n * This code is free software; you can redistribute it and/or modify it\n * under the terms of the GNU General Public License version 2 only, as\n * published by the Free Software Foundation.  Oracle designates this\n * particular file as subject to the \"Classpath\" exception as provided\n * by Oracle in the LICENSE file that accompanied this code.\n *\n * This code is distributed in the hope that it will be useful, but WITHOUT\n * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n * version 2 for more details (a copy is included in the LICENSE file that\n * accompanied this code).\n *\n * You should have received a copy of the GNU General Public License version\n * 2 along with this work; if not, write to the Free Software Foundation,\n * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n *\n * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n * or visit www.oracle.com if you need additional information or have any\n * questions.\n */\n\npackage java.lang;\n\nimport java.io.ObjectStreamField;\nimport java.io.UnsupportedEncodingException;\nimport java.lang.annotation.Native;\nimport java.lang.invoke.MethodHandles;\nimport java.lang.constant.Constable;\nimport java.lang.constant.ConstantDesc;\nimport java.nio.ByteBuffer;\nimport java.nio.CharBuffer;\nimport java.nio.charset.*;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Comparator;\nimport java.util.Formatter;\nimport java.util.List;\nimport java.util.Locale;\nimport java.util.Objects;\nimport java.util.Optional;\nimport java.util.Spliterator;\nimport java.util.function.Function;\nimport java.util.regex.Pattern;\nimport java.util.regex.PatternSyntaxException;\nimport java.util.stream.Collectors;\nimport java.util.stream.IntStream;\nimport java.util.stream.Stream;\nimport java.util.stream.StreamSupport;\n\nimport jdk.internal.vm.annotation.ForceInline;\nimport jdk.internal.vm.annotation.IntrinsicCandidate;\nimport jdk.internal.vm.annotation.Stable;\nimport sun.nio.cs.ArrayDecoder;\nimport sun.nio.cs.ArrayEncoder;\n\nimport sun.nio.cs.ISO_8859_1;\nimport sun.nio.cs.US_ASCII;\nimport sun.nio.cs.UTF_8;\n\n/**\n * The {@code String} class represents character strings. All\n * string literals in Java programs, such as {@code \"abc\"}, are\n * implemented as instances of this class.\n * \u003cp\u003e\n * Strings are constant; their values cannot be changed after they\n * are created. String buffers support mutable strings.\n * Because String objects are immutable they can be shared. For example:\n * \u003cblockquote\u003e\u003cpre\u003e\n *     String str \u003d \"abc\";\n * \u003c/pre\u003e\u003c/blockquote\u003e\u003cp\u003e\n * is equivalent to:\n * \u003cblockquote\u003e\u003cpre\u003e\n *     char data[] \u003d {\u0027a\u0027, \u0027b\u0027, \u0027c\u0027};\n *     String str \u003d new String(data);\n * \u003c/pre\u003e\u003c/blockquote\u003e\u003cp\u003e\n * Here are some more examples of how strings can be used:\n * \u003cblockquote\u003e\u003cpre\u003e\n *     System.out.println(\"abc\");\n *     String cde \u003d \"cde\";\n *     System.out.println(\"abc\" + cde);\n *     String c \u003d \"abc\".substring(2, 3);\n *     String d \u003d cde.substring(1, 2);\n * \u003c/pre\u003e\u003c/blockquote\u003e\n * \u003cp\u003e\n * The class {@code String} includes methods for examining\n * individual characters of the sequence, for comparing strings, for\n * searching strings, for extracting substrings, and for creating a\n * copy of a string with all characters translated to uppercase or to\n * lowercase. Case mapping is based on the Unicode Standard version\n * specified by the {@link java.lang.Character Character} class.\n * \u003cp\u003e\n * The Java language provides special support for the string\n * concatenation operator (\u0026nbsp;+\u0026nbsp;), and for conversion of\n * other objects to strings. For additional information on string\n * concatenation and conversion, see \u003ci\u003eThe Java Language Specification\u003c/i\u003e.\n *\n * \u003cp\u003e Unless otherwise noted, passing a {@code null} argument to a constructor\n * or method in this class will cause a {@link NullPointerException} to be\n * thrown.\n *\n * \u003cp\u003eA {@code String} represents a string in the UTF-16 format\n * in which \u003cem\u003esupplementary characters\u003c/em\u003e are represented by \u003cem\u003esurrogate\n * pairs\u003c/em\u003e (see the section \u003ca href\u003d\"Character.html#unicode\"\u003eUnicode\n * Character Representations\u003c/a\u003e in the {@code Character} class for\n * more information).\n * Index values refer to {@code char} code units, so a supplementary\n * character uses two positions in a {@code String}.\n * \u003cp\u003eThe {@code String} class provides methods for dealing with\n * Unicode code points (i.e., characters), in addition to those for\n * dealing with Unicode code units (i.e., {@code char} values).\n *\n * \u003cp\u003eUnless otherwise noted, methods for comparing Strings do not take locale\n * into account.  The {@link java.text.Collator} class provides methods for\n * finer-grain, locale-sensitive String comparison.\n *\n * @implNote The implementation of the string concatenation operator is left to\n * the discretion of a Java compiler, as long as the compiler ultimately conforms\n * to \u003ci\u003eThe Java Language Specification\u003c/i\u003e. For example, the {@code javac} compiler\n * may implement the operator with {@code StringBuffer}, {@code StringBuilder},\n * or {@code java.lang.invoke.StringConcatFactory} depending on the JDK version. The\n * implementation of string conversion is typically through the method {@code toString},\n * defined by {@code Object} and inherited by all classes in Java.\n *\n * @author  Lee Boynton\n * @author  Arthur van Hoff\n * @author  Martin Buchholz\n * @author  Ulf Zibis\n * @see     java.lang.Object#toString()\n * @see     java.lang.StringBuffer\n * @see     java.lang.StringBuilder\n * @see     java.nio.charset.Charset\n * @since   1.0\n * @jls     15.18.1 String Concatenation Operator +\n */\n\npublic final class String\n    implements java.io.Serializable, Comparable\u003cString\u003e, CharSequence,\n               Constable, ConstantDesc {\n\n    /**\n     * The value is used for character storage.\n     *\n     * @implNote This field is trusted by the VM, and is a subject to\n     * constant folding if String instance is constant. Overwriting this\n     * field after construction will cause problems.\n     *\n     * Additionally, it is marked with {@link Stable} to trust the contents\n     * of the array. No other facility in JDK provides this functionality (yet).\n     * {@link Stable} is safe here, because value is never null.\n     */\n    @Stable\n    private final byte[] value;\n\n    /**\n     * The identifier of the encoding used to encode the bytes in\n     * {@code value}. The supported values in this implementation are\n     *\n     * LATIN1\n     * UTF16\n     *\n     * @implNote This field is trusted by the VM, and is a subject to\n     * constant folding if String instance is constant. Overwriting this\n     * field after construction will cause problems.\n     */\n    private final byte coder;\n\n    /** Cache the hash code for the string */\n    private int hash; // Default to 0\n\n    /**\n     * Cache if the hash has been calculated as actually being zero, enabling\n     * us to avoid recalculating this.\n     */\n    private boolean hashIsZero; // Default to false;\n\n    /** use serialVersionUID from JDK 1.0.2 for interoperability */\n    @java.io.Serial\n    private static final long serialVersionUID \u003d -6849794470754667710L;\n\n    /**\n     * If String compaction is disabled, the bytes in {@code value} are\n     * always encoded in UTF16.\n     *\n     * For methods with several possible implementation paths, when String\n     * compaction is disabled, only one code path is taken.\n     *\n     * The instance field value is generally opaque to optimizing JIT\n     * compilers. Therefore, in performance-sensitive place, an explicit\n     * check of the static boolean {@code COMPACT_STRINGS} is done first\n     * before checking the {@code coder} field since the static boolean\n     * {@code COMPACT_STRINGS} would be constant folded away by an\n     * optimizing JIT compiler. The idioms for these cases are as follows.\n     *\n     * For code such as:\n     *\n     *    if (coder \u003d\u003d LATIN1) { ... }\n     *\n     * can be written more optimally as\n     *\n     *    if (coder() \u003d\u003d LATIN1) { ... }\n     *\n     * or:\n     *\n     *    if (COMPACT_STRINGS \u0026\u0026 coder \u003d\u003d LATIN1) { ... }\n     *\n     * An optimizing JIT compiler can fold the above conditional as:\n     *\n     *    COMPACT_STRINGS \u003d\u003d true  \u003d\u003e if (coder \u003d\u003d LATIN1) { ... }\n     *    COMPACT_STRINGS \u003d\u003d false \u003d\u003e if (false)           { ... }\n     *\n     * @implNote\n     * The actual value for this field is injected by JVM. The static\n     * initialization block is used to set the value here to communicate\n     * that this static final field is not statically foldable, and to\n     * avoid any possible circular dependency during vm initialization.\n     */\n    static final boolean COMPACT_STRINGS;\n\n    static {\n        COMPACT_STRINGS \u003d true;\n    }\n\n    /**\n     * Class String is special cased within the Serialization Stream Protocol.\n     *\n     * A String instance is written into an ObjectOutputStream according to\n     * \u003ca href\u003d\"{@docRoot}/../specs/serialization/protocol.html#stream-elements\"\u003e\n     * Object Serialization Specification, Section 6.2, \"Stream Elements\"\u003c/a\u003e\n     */\n    @java.io.Serial\n    private static final ObjectStreamField[] serialPersistentFields \u003d\n        new ObjectStreamField[0];\n\n    /**\n     * Initializes a newly created {@code String} object so that it represents\n     * an empty character sequence.  Note that use of this constructor is\n     * unnecessary since Strings are immutable.\n     */\n    public String() {\n        this.value \u003d \"\".value;\n        this.coder \u003d \"\".coder;\n    }\n\n    /**\n     * Initializes a newly created {@code String} object so that it represents\n     * the same sequence of characters as the argument; in other words, the\n     * newly created string is a copy of the argument string. Unless an\n     * explicit copy of {@code original} is needed, use of this constructor is\n     * unnecessary since Strings are immutable.\n     *\n     * @param  original\n     *         A {@code String}\n     */\n    @IntrinsicCandidate\n    public String(String original) {\n        this.value \u003d original.value;\n        this.coder \u003d original.coder;\n        this.hash \u003d original.hash;\n    }\n\n    /**\n     * Allocates a new {@code String} so that it represents the sequence of\n     * characters currently contained in the character array argument. The\n     * contents of the character array are copied; subsequent modification of\n     * the character array does not affect the newly created string.\n     *\n     * @param  value\n     *         The initial value of the string\n     */\n    public String(char value[]) {\n        this(value, 0, value.length, null);\n    }\n\n    /**\n     * Allocates a new {@code String} that contains characters from a subarray\n     * of the character array argument. The {@code offset} argument is the\n     * index of the first character of the subarray and the {@code count}\n     * argument specifies the length of the subarray. The contents of the\n     * subarray are copied; subsequent modification of the character array does\n     * not affect the newly created string.\n     *\n     * @param  value\n     *         Array that is the source of characters\n     *\n     * @param  offset\n     *         The initial offset\n     *\n     * @param  count\n     *         The length\n     *\n     * @throws  IndexOutOfBoundsException\n     *          If {@code offset} is negative, {@code count} is negative, or\n     *          {@code offset} is greater than {@code value.length - count}\n     */\n    public String(char value[], int offset, int count) {\n        this(value, offset, count, rangeCheck(value, offset, count));\n    }\n\n    private static Void rangeCheck(char[] value, int offset, int count) {\n        checkBoundsOffCount(offset, count, value.length);\n        return null;\n    }\n\n    /**\n     * Allocates a new {@code String} that contains characters from a subarray\n     * of the \u003ca href\u003d\"Character.html#unicode\"\u003eUnicode code point\u003c/a\u003e array\n     * argument.  The {@code offset} argument is the index of the first code\n     * point of the subarray and the {@code count} argument specifies the\n     * length of the subarray.  The contents of the subarray are converted to\n     * {@code char}s; subsequent modification of the {@code int} array does not\n     * affect the newly created string.\n     *\n     * @param  codePoints\n     *         Array that is the source of Unicode code points\n     *\n     * @param  offset\n     *         The initial offset\n     *\n     * @param  count\n     *         The length\n     *\n     * @throws  IllegalArgumentException\n     *          If any invalid Unicode code point is found in {@code\n     *          codePoints}\n     *\n     * @throws  IndexOutOfBoundsException\n     *          If {@code offset} is negative, {@code count} is negative, or\n     *          {@code offset} is greater than {@code codePoints.length - count}\n     *\n     * @since  1.5\n     */\n    public String(int[] codePoints, int offset, int count) {\n        checkBoundsOffCount(offset, count, codePoints.length);\n        if (count \u003d\u003d 0) {\n            this.value \u003d \"\".value;\n            this.coder \u003d \"\".coder;\n            return;\n        }\n        if (COMPACT_STRINGS) {\n            byte[] val \u003d StringLatin1.toBytes(codePoints, offset, count);\n            if (val !\u003d null) {\n                this.coder \u003d LATIN1;\n                this.value \u003d val;\n                return;\n            }\n        }\n        this.coder \u003d UTF16;\n        this.value \u003d StringUTF16.toBytes(codePoints, offset, count);\n    }\n\n    /**\n     * Allocates a new {@code String} constructed from a subarray of an array\n     * of 8-bit integer values.\n     *\n     * \u003cp\u003e The {@code offset} argument is the index of the first byte of the\n     * subarray, and the {@code count} argument specifies the length of the\n     * subarray.\n     *\n     * \u003cp\u003e Each {@code byte} in the subarray is converted to a {@code char} as\n     * specified in the {@link #String(byte[],int) String(byte[],int)} constructor.\n     *\n     * @deprecated This method does not properly convert bytes into characters.\n     * As of JDK\u0026nbsp;1.1, the preferred way to do this is via the\n     * {@code String} constructors that take a {@link\n     * java.nio.charset.Charset}, charset name, or that use the platform\u0027s\n     * default charset.\n     *\n     * @param  ascii\n     *         The bytes to be converted to characters\n     *\n     * @param  hibyte\n     *         The top 8 bits of each 16-bit Unicode code unit\n     *\n     * @param  offset\n     *         The initial offset\n     * @param  count\n     *         The length\n     *\n     * @throws  IndexOutOfBoundsException\n     *          If {@code offset} is negative, {@code count} is negative, or\n     *          {@code offset} is greater than {@code ascii.length - count}\n     *\n     * @see  #String(byte[], int)\n     * @see  #String(byte[], int, int, java.lang.String)\n     * @see  #String(byte[], int, int, java.nio.charset.Charset)\n     * @see  #String(byte[], int, int)\n     * @see  #String(byte[], java.lang.String)\n     * @see  #String(byte[], java.nio.charset.Charset)\n     * @see  #String(byte[])\n     */\n    @Deprecated(since\u003d\"1.1\")\n    public String(byte ascii[], int hibyte, int offset, int count) {\n        checkBoundsOffCount(offset, count, ascii.length);\n        if (count \u003d\u003d 0) {\n            this.value \u003d \"\".value;\n            this.coder \u003d \"\".coder;\n            return;\n        }\n        if (COMPACT_STRINGS \u0026\u0026 (byte)hibyte \u003d\u003d 0) {\n            this.value \u003d Arrays.copyOfRange(ascii, offset, offset + count);\n            this.coder \u003d LATIN1;\n        } else {\n            hibyte \u003c\u003c\u003d 8;\n            byte[] val \u003d StringUTF16.newBytesFor(count);\n            for (int i \u003d 0; i \u003c count; i++) {\n                StringUTF16.putChar(val, i, hibyte | (ascii[offset++] \u0026 0xff));\n            }\n            this.value \u003d val;\n            this.coder \u003d UTF16;\n        }\n    }\n\n    /**\n     * Allocates a new {@code String} containing characters constructed from\n     * an array of 8-bit integer values. Each character \u003ci\u003ec\u003c/i\u003e in the\n     * resulting string is constructed from the corresponding component\n     * \u003ci\u003eb\u003c/i\u003e in the byte array such that:\n     *\n     * \u003cblockquote\u003e\u003cpre\u003e\n     *     \u003cb\u003e\u003ci\u003ec\u003c/i\u003e\u003c/b\u003e \u003d\u003d (char)(((hibyte \u0026amp; 0xff) \u0026lt;\u0026lt; 8)\n     *                         | (\u003cb\u003e\u003ci\u003eb\u003c/i\u003e\u003c/b\u003e \u0026amp; 0xff))\n     * \u003c/pre\u003e\u003c/blockquote\u003e\n     *\n     * @deprecated  This method does not properly convert bytes into\n     * characters.  As of JDK\u0026nbsp;1.1, the preferred way to do this is via the\n     * {@code String} constructors that take a {@link\n     * java.nio.charset.Charset}, charset name, or that use the platform\u0027s\n     * default charset.\n     *\n     * @param  ascii\n     *         The bytes to be converted to characters\n     *\n     * @param  hibyte\n     *         The top 8 bits of each 16-bit Unicode code unit\n     *\n     * @see  #String(byte[], int, int, java.lang.String)\n     * @see  #String(byte[], int, int, java.nio.charset.Charset)\n     * @see  #String(byte[], int, int)\n     * @see  #String(byte[], java.lang.String)\n     * @see  #String(byte[], java.nio.charset.Charset)\n     * @see  #String(byte[])\n     */\n    @Deprecated(since\u003d\"1.1\")\n    public String(byte ascii[], int hibyte) {\n        this(ascii, hibyte, 0, ascii.length);\n    }\n\n    /**\n     * Constructs a new {@code String} by decoding the specified subarray of\n     * bytes using the specified charset.  The length of the new {@code String}\n     * is a function of the charset, and hence may not be equal to the length\n     * of the subarray.\n     *\n     * \u003cp\u003e The behavior of this constructor when the given bytes are not valid\n     * in the given charset is unspecified.  The {@link\n     * java.nio.charset.CharsetDecoder} class should be used when more control\n     * over the decoding process is required.\n     *\n     * @param  bytes\n     *         The bytes to be decoded into characters\n     *\n     * @param  offset\n     *         The index of the first byte to decode\n     *\n     * @param  length\n     *         The number of bytes to decode\n     *\n     * @param  charsetName\n     *         The name of a supported {@linkplain java.nio.charset.Charset\n     *         charset}\n     *\n     * @throws  UnsupportedEncodingException\n     *          If the named charset is not supported\n     *\n     * @throws  IndexOutOfBoundsException\n     *          If {@code offset} is negative, {@code length} is negative, or\n     *          {@code offset} is greater than {@code bytes.length - length}\n     *\n     * @since  1.1\n     */\n    public String(byte[] bytes, int offset, int length, String charsetName)\n            throws UnsupportedEncodingException {\n        this(bytes, offset, length, lookupCharset(charsetName));\n    }\n\n    /**\n     * Constructs a new {@code String} by decoding the specified subarray of\n     * bytes using the specified {@linkplain java.nio.charset.Charset charset}.\n     * The length of the new {@code String} is a function of the charset, and\n     * hence may not be equal to the length of the subarray.\n     *\n     * \u003cp\u003e This method always replaces malformed-input and unmappable-character\n     * sequences with this charset\u0027s default replacement string.  The {@link\n     * java.nio.charset.CharsetDecoder} class should be used when more control\n     * over the decoding process is required.\n     *\n     * @param  bytes\n     *         The bytes to be decoded into characters\n     *\n     * @param  offset\n     *         The index of the first byte to decode\n     *\n     * @param  length\n     *         The number of bytes to decode\n     *\n     * @param  charset\n     *         The {@linkplain java.nio.charset.Charset charset} to be used to\n     *         decode the {@code bytes}\n     *\n     * @throws  IndexOutOfBoundsException\n     *          If {@code offset} is negative, {@code length} is negative, or\n     *          {@code offset} is greater than {@code bytes.length - length}\n     *\n     * @since  1.6\n     */\n    @SuppressWarnings(\"removal\")\n    public String(byte[] bytes, int offset, int length, Charset charset) {\n        Objects.requireNonNull(charset);\n        checkBoundsOffCount(offset, length, bytes.length);\n        if (length \u003d\u003d 0) {\n            this.value \u003d \"\".value;\n            this.coder \u003d \"\".coder;\n        } else if (charset \u003d\u003d UTF_8.INSTANCE) {\n            if (COMPACT_STRINGS \u0026\u0026 !StringCoding.hasNegatives(bytes, offset, length)) {\n                this.value \u003d Arrays.copyOfRange(bytes, offset, offset + length);\n                this.coder \u003d LATIN1;\n            } else {\n                int sl \u003d offset + length;\n                int dp \u003d 0;\n                byte[] dst \u003d null;\n                if (COMPACT_STRINGS) {\n                    dst \u003d new byte[length];\n                    while (offset \u003c sl) {\n                        int b1 \u003d bytes[offset];\n                        if (b1 \u003e\u003d 0) {\n                            dst[dp++] \u003d (byte)b1;\n                            offset++;\n                            continue;\n                        }\n                        if ((b1 \u003d\u003d (byte)0xc2 || b1 \u003d\u003d (byte)0xc3) \u0026\u0026\n                                offset + 1 \u003c sl) {\n                            int b2 \u003d bytes[offset + 1];\n                            if (!isNotContinuation(b2)) {\n                                dst[dp++] \u003d (byte)decode2(b1, b2);\n                                offset +\u003d 2;\n                                continue;\n                            }\n                        }\n                        // anything not a latin1, including the repl\n                        // we have to go with the utf16\n                        break;\n                    }\n                    if (offset \u003d\u003d sl) {\n                        if (dp !\u003d dst.length) {\n                            dst \u003d Arrays.copyOf(dst, dp);\n                        }\n                        this.value \u003d dst;\n                        this.coder \u003d LATIN1;\n                        return;\n                    }\n                }\n                if (dp \u003d\u003d 0 || dst \u003d\u003d null) {\n                    dst \u003d new byte[length \u003c\u003c 1];\n                } else {\n                    byte[] buf \u003d new byte[length \u003c\u003c 1];\n                    StringLatin1.inflate(dst, 0, buf, 0, dp);\n                    dst \u003d buf;\n                }\n                dp \u003d decodeUTF8_UTF16(bytes, offset, sl, dst, dp, true);\n                if (dp !\u003d length) {\n                    dst \u003d Arrays.copyOf(dst, dp \u003c\u003c 1);\n                }\n                this.value \u003d dst;\n                this.coder \u003d UTF16;\n            }\n        } else if (charset \u003d\u003d ISO_8859_1.INSTANCE) {\n            if (COMPACT_STRINGS) {\n                this.value \u003d Arrays.copyOfRange(bytes, offset, offset + length);\n                this.coder \u003d LATIN1;\n            } else {\n                this.value \u003d StringLatin1.inflate(bytes, offset, length);\n                this.coder \u003d UTF16;\n            }\n        } else if (charset \u003d\u003d US_ASCII.INSTANCE) {\n            if (COMPACT_STRINGS \u0026\u0026 !StringCoding.hasNegatives(bytes, offset, length)) {\n                this.value \u003d Arrays.copyOfRange(bytes, offset, offset + length);\n                this.coder \u003d LATIN1;\n            } else {\n                byte[] dst \u003d new byte[length \u003c\u003c 1];\n                int dp \u003d 0;\n                while (dp \u003c length) {\n                    int b \u003d bytes[offset++];\n                    StringUTF16.putChar(dst, dp++, (b \u003e\u003d 0) ? (char) b : REPL);\n                }\n                this.value \u003d dst;\n                this.coder \u003d UTF16;\n            }\n        } else {\n            // (1)We never cache the \"external\" cs, the only benefit of creating\n            // an additional StringDe/Encoder object to wrap it is to share the\n            // de/encode() method. These SD/E objects are short-lived, the young-gen\n            // gc should be able to take care of them well. But the best approach\n            // is still not to generate them if not really necessary.\n            // (2)The defensive copy of the input byte/char[] has a big performance\n            // impact, as well as the outgoing result byte/char[]. Need to do the\n            // optimization check of (sm\u003d\u003dnull \u0026\u0026 classLoader0\u003d\u003dnull) for both.\n            CharsetDecoder cd \u003d charset.newDecoder();\n            // ArrayDecoder fastpaths\n            if (cd instanceof ArrayDecoder ad) {\n                // ascii\n                if (ad.isASCIICompatible() \u0026\u0026 !StringCoding.hasNegatives(bytes, offset, length)) {\n                    if (COMPACT_STRINGS) {\n                        this.value \u003d Arrays.copyOfRange(bytes, offset, offset + length);\n                        this.coder \u003d LATIN1;\n                        return;\n                    }\n                    this.value \u003d StringLatin1.inflate(bytes, offset, length);\n                    this.coder \u003d UTF16;\n                    return;\n                }\n\n                // fastpath for always Latin1 decodable single byte\n                if (COMPACT_STRINGS \u0026\u0026 ad.isLatin1Decodable()) {\n                    byte[] dst \u003d new byte[length];\n                    ad.decodeToLatin1(bytes, offset, length, dst);\n                    this.value \u003d dst;\n                    this.coder \u003d LATIN1;\n                    return;\n                }\n\n                int en \u003d scale(length, cd.maxCharsPerByte());\n                cd.onMalformedInput(CodingErrorAction.REPLACE)\n                        .onUnmappableCharacter(CodingErrorAction.REPLACE);\n                char[] ca \u003d new char[en];\n                int clen \u003d ad.decode(bytes, offset, length, ca);\n                if (COMPACT_STRINGS) {\n                    byte[] bs \u003d StringUTF16.compress(ca, 0, clen);\n                    if (bs !\u003d null) {\n                        value \u003d bs;\n                        coder \u003d LATIN1;\n                        return;\n                    }\n                }\n                coder \u003d UTF16;\n                value \u003d StringUTF16.toBytes(ca, 0, clen);\n                return;\n            }\n\n            // decode using CharsetDecoder\n            int en \u003d scale(length, cd.maxCharsPerByte());\n            cd.onMalformedInput(CodingErrorAction.REPLACE)\n                    .onUnmappableCharacter(CodingErrorAction.REPLACE);\n            char[] ca \u003d new char[en];\n            if (charset.getClass().getClassLoader0() !\u003d null \u0026\u0026\n                    System.getSecurityManager() !\u003d null) {\n                bytes \u003d Arrays.copyOfRange(bytes, offset, offset + length);\n                offset \u003d 0;\n            }\n\n            int caLen \u003d decodeWithDecoder(cd, ca, bytes, offset, length);\n            if (COMPACT_STRINGS) {\n                byte[] bs \u003d StringUTF16.compress(ca, 0, caLen);\n                if (bs !\u003d null) {\n                    value \u003d bs;\n                    coder \u003d LATIN1;\n                    return;\n                }\n            }\n            coder \u003d UTF16;\n            value \u003d StringUTF16.toBytes(ca, 0, caLen);\n        }\n    }\n\n    /*\n     * Throws iae, instead of replacing, if malformed or unmappable.\n     */\n    static String newStringUTF8NoRepl(byte[] bytes, int offset, int length) {\n        checkBoundsOffCount(offset, length, bytes.length);\n        if (length \u003d\u003d 0) {\n            return \"\";\n        }\n        if (COMPACT_STRINGS \u0026\u0026 !StringCoding.hasNegatives(bytes, offset, length)) {\n            return new String(Arrays.copyOfRange(bytes, offset, offset + length), LATIN1);\n        } else {\n            int sl \u003d offset + length;\n            int dp \u003d 0;\n            byte[] dst \u003d null;\n            if (COMPACT_STRINGS) {\n                dst \u003d new byte[length];\n                while (offset \u003c sl) {\n                    int b1 \u003d bytes[offset];\n                    if (b1 \u003e\u003d 0) {\n                        dst[dp++] \u003d (byte) b1;\n                        offset++;\n                        continue;\n                    }\n                    if ((b1 \u003d\u003d (byte) 0xc2 || b1 \u003d\u003d (byte) 0xc3) \u0026\u0026\n                            offset + 1 \u003c sl) {\n                        int b2 \u003d bytes[offset + 1];\n                        if (!isNotContinuation(b2)) {\n                            dst[dp++] \u003d (byte) decode2(b1, b2);\n                            offset +\u003d 2;\n                            continue;\n                        }\n                    }\n                    // anything not a latin1, including the REPL\n                    // we have to go with the utf16\n                    break;\n                }\n                if (offset \u003d\u003d sl) {\n                    if (dp !\u003d dst.length) {\n                        dst \u003d Arrays.copyOf(dst, dp);\n                    }\n                    return new String(dst, LATIN1);\n                }\n            }\n            if (dp \u003d\u003d 0 || dst \u003d\u003d null) {\n                dst \u003d new byte[length \u003c\u003c 1];\n            } else {\n                byte[] buf \u003d new byte[length \u003c\u003c 1];\n                StringLatin1.inflate(dst, 0, buf, 0, dp);\n                dst \u003d buf;\n            }\n            dp \u003d decodeUTF8_UTF16(bytes, offset, sl, dst, dp, false);\n            if (dp !\u003d length) {\n                dst \u003d Arrays.copyOf(dst, dp \u003c\u003c 1);\n            }\n            return new String(dst, UTF16);\n        }\n    }\n\n    static String newStringNoRepl(byte[] src, Charset cs) throws CharacterCodingException {\n        try {\n            return newStringNoRepl1(src, cs);\n        } catch (IllegalArgumentException e) {\n            //newStringNoRepl1 throws IAE with MalformedInputException or CCE as the cause\n            Throwable cause \u003d e.getCause();\n            if (cause instanceof MalformedInputException mie) {\n                throw mie;\n            }\n            throw (CharacterCodingException)cause;\n        }\n    }\n\n    @SuppressWarnings(\"removal\")\n    private static String newStringNoRepl1(byte[] src, Charset cs) {\n        int len \u003d src.length;\n        if (len \u003d\u003d 0) {\n            return \"\";\n        }\n        if (cs \u003d\u003d UTF_8.INSTANCE) {\n            return newStringUTF8NoRepl(src, 0, src.length);\n        }\n        if (cs \u003d\u003d ISO_8859_1.INSTANCE) {\n            if (COMPACT_STRINGS)\n                return new String(src, LATIN1);\n            return new String(StringLatin1.inflate(src, 0, src.length), UTF16);\n        }\n        if (cs \u003d\u003d US_ASCII.INSTANCE) {\n            if (!StringCoding.hasNegatives(src, 0, src.length)) {\n                if (COMPACT_STRINGS)\n                    return new String(src, LATIN1);\n                return new String(StringLatin1.inflate(src, 0, src.length), UTF16);\n            } else {\n                throwMalformed(src);\n            }\n        }\n\n        CharsetDecoder cd \u003d cs.newDecoder();\n        // ascii fastpath\n        if (cd instanceof ArrayDecoder ad \u0026\u0026\n                ad.isASCIICompatible() \u0026\u0026\n                !StringCoding.hasNegatives(src, 0, src.length)) {\n            return new String(src, 0, src.length, ISO_8859_1.INSTANCE);\n        }\n        int en \u003d scale(len, cd.maxCharsPerByte());\n        char[] ca \u003d new char[en];\n        if (cs.getClass().getClassLoader0() !\u003d null \u0026\u0026\n                System.getSecurityManager() !\u003d null) {\n            src \u003d Arrays.copyOf(src, len);\n        }\n        int caLen \u003d decodeWithDecoder(cd, ca, src, 0, src.length);\n        if (COMPACT_STRINGS) {\n            byte[] bs \u003d StringUTF16.compress(ca, 0, caLen);\n            if (bs !\u003d null) {\n                return new String(bs, LATIN1);\n            }\n        }\n        return new String(StringUTF16.toBytes(ca, 0, caLen), UTF16);\n    }\n\n    private static final char REPL \u003d \u0027\\ufffd\u0027;\n\n    // Trim the given byte array to the given length\n    @SuppressWarnings(\"removal\")\n    private static byte[] safeTrim(byte[] ba, int len, boolean isTrusted) {\n        if (len \u003d\u003d ba.length \u0026\u0026 (isTrusted || System.getSecurityManager() \u003d\u003d null)) {\n            return ba;\n        } else {\n            return Arrays.copyOf(ba, len);\n        }\n    }\n\n    private static int scale(int len, float expansionFactor) {\n        // We need to perform double, not float, arithmetic; otherwise\n        // we lose low order bits when len is larger than 2**24.\n        return (int)(len * (double)expansionFactor);\n    }\n\n    private static Charset lookupCharset(String csn) throws UnsupportedEncodingException {\n        Objects.requireNonNull(csn);\n        try {\n            return Charset.forName(csn);\n        } catch (UnsupportedCharsetException | IllegalCharsetNameException x) {\n            throw new UnsupportedEncodingException(csn);\n        }\n    }\n\n    private static byte[] encode(Charset cs, byte coder, byte[] val) {\n        if (cs \u003d\u003d UTF_8.INSTANCE) {\n            return encodeUTF8(coder, val, true);\n        }\n        if (cs \u003d\u003d ISO_8859_1.INSTANCE) {\n            return encode8859_1(coder, val);\n        }\n        if (cs \u003d\u003d US_ASCII.INSTANCE) {\n            return encodeASCII(coder, val);\n        }\n        return encodeWithEncoder(cs, coder, val, true);\n    }\n\n    private static byte[] encodeWithEncoder(Charset cs, byte coder, byte[] val, boolean doReplace) {\n        CharsetEncoder ce \u003d cs.newEncoder();\n        int len \u003d val.length \u003e\u003e coder;  // assume LATIN1\u003d0/UTF16\u003d1;\n        int en \u003d scale(len, ce.maxBytesPerChar());\n        if (ce instanceof ArrayEncoder ae) {\n            // fastpath for ascii compatible\n            if (coder \u003d\u003d LATIN1 \u0026\u0026\n                    ae.isASCIICompatible() \u0026\u0026\n                    !StringCoding.hasNegatives(val, 0, val.length)) {\n                return Arrays.copyOf(val, val.length);\n            }\n            byte[] ba \u003d new byte[en];\n            if (len \u003d\u003d 0) {\n                return ba;\n            }\n            if (doReplace) {\n                ce.onMalformedInput(CodingErrorAction.REPLACE)\n                        .onUnmappableCharacter(CodingErrorAction.REPLACE);\n            }\n\n            int blen \u003d (coder \u003d\u003d LATIN1) ? ae.encodeFromLatin1(val, 0, len, ba)\n                    : ae.encodeFromUTF16(val, 0, len, ba);\n            if (blen !\u003d -1) {\n                return safeTrim(ba, blen, true);\n            }\n        }\n\n        byte[] ba \u003d new byte[en];\n        if (len \u003d\u003d 0) {\n            return ba;\n        }\n        if (doReplace) {\n            ce.onMalformedInput(CodingErrorAction.REPLACE)\n                    .onUnmappableCharacter(CodingErrorAction.REPLACE);\n        }\n        char[] ca \u003d (coder \u003d\u003d LATIN1 ) ? StringLatin1.toChars(val)\n                : StringUTF16.toChars(val);\n        ByteBuffer bb \u003d ByteBuffer.wrap(ba);\n        CharBuffer cb \u003d CharBuffer.wrap(ca, 0, len);\n        try {\n            CoderResult cr \u003d ce.encode(cb, bb, true);\n            if (!cr.isUnderflow())\n                cr.throwException();\n            cr \u003d ce.flush(bb);\n            if (!cr.isUnderflow())\n                cr.throwException();\n        } catch (CharacterCodingException x) {\n            if (!doReplace) {\n                throw new IllegalArgumentException(x);\n            } else {\n                throw new Error(x);\n            }\n        }\n        return safeTrim(ba, bb.position(), cs.getClass().getClassLoader0() \u003d\u003d null);\n    }\n\n    /*\n     * Throws iae, instead of replacing, if unmappable.\n     */\n    static byte[] getBytesUTF8NoRepl(String s) {\n        return encodeUTF8(s.coder(), s.value(), false);\n    }\n\n    private static boolean isASCII(byte[] src) {\n        return !StringCoding.hasNegatives(src, 0, src.length);\n    }\n\n    /*\n     * Throws CCE, instead of replacing, if unmappable.\n     */\n    static byte[] getBytesNoRepl(String s, Charset cs) throws CharacterCodingException {\n        try {\n            return getBytesNoRepl1(s, cs);\n        } catch (IllegalArgumentException e) {\n            //getBytesNoRepl1 throws IAE with UnmappableCharacterException or CCE as the cause\n            Throwable cause \u003d e.getCause();\n            if (cause instanceof UnmappableCharacterException) {\n                throw (UnmappableCharacterException)cause;\n            }\n            throw (CharacterCodingException)cause;\n        }\n    }\n\n    private static byte[] getBytesNoRepl1(String s, Charset cs) {\n        byte[] val \u003d s.value();\n        byte coder \u003d s.coder();\n        if (cs \u003d\u003d UTF_8.INSTANCE) {\n            if (coder \u003d\u003d LATIN1 \u0026\u0026 isASCII(val)) {\n                return val;\n            }\n            return encodeUTF8(coder, val, false);\n        }\n        if (cs \u003d\u003d ISO_8859_1.INSTANCE) {\n            if (coder \u003d\u003d LATIN1) {\n                return val;\n            }\n            return encode8859_1(coder, val, false);\n        }\n        if (cs \u003d\u003d US_ASCII.INSTANCE) {\n            if (coder \u003d\u003d LATIN1) {\n                if (isASCII(val)) {\n                    return val;\n                } else {\n                    throwUnmappable(val);\n                }\n            }\n        }\n        return encodeWithEncoder(cs, coder, val, false);\n    }\n\n    private static byte[] encodeASCII(byte coder, byte[] val) {\n        if (coder \u003d\u003d LATIN1) {\n            byte[] dst \u003d Arrays.copyOf(val, val.length);\n            for (int i \u003d 0; i \u003c dst.length; i++) {\n                if (dst[i] \u003c 0) {\n                    dst[i] \u003d \u0027?\u0027;\n                }\n            }\n            return dst;\n        }\n        int len \u003d val.length \u003e\u003e 1;\n        byte[] dst \u003d new byte[len];\n        int dp \u003d 0;\n        for (int i \u003d 0; i \u003c len; i++) {\n            char c \u003d StringUTF16.getChar(val, i);\n            if (c \u003c 0x80) {\n                dst[dp++] \u003d (byte)c;\n                continue;\n            }\n            if (Character.isHighSurrogate(c) \u0026\u0026 i + 1 \u003c len \u0026\u0026\n                    Character.isLowSurrogate(StringUTF16.getChar(val, i + 1))) {\n                i++;\n            }\n            dst[dp++] \u003d \u0027?\u0027;\n        }\n        if (len \u003d\u003d dp) {\n            return dst;\n        }\n        return Arrays.copyOf(dst, dp);\n    }\n\n    private static byte[] encode8859_1(byte coder, byte[] val) {\n        return encode8859_1(coder, val, true);\n    }\n\n    private static byte[] encode8859_1(byte coder, byte[] val, boolean doReplace) {\n        if (coder \u003d\u003d LATIN1) {\n            return Arrays.copyOf(val, val.length);\n        }\n        int len \u003d val.length \u003e\u003e 1;\n        byte[] dst \u003d new byte[len];\n        int dp \u003d 0;\n        int sp \u003d 0;\n        int sl \u003d len;\n        while (sp \u003c sl) {\n            int ret \u003d StringCoding.implEncodeISOArray(val, sp, dst, dp, len);\n            sp \u003d sp + ret;\n            dp \u003d dp + ret;\n            if (ret !\u003d len) {\n                if (!doReplace) {\n                    throwUnmappable(sp);\n                }\n                char c \u003d StringUTF16.getChar(val, sp++);\n                if (Character.isHighSurrogate(c) \u0026\u0026 sp \u003c sl \u0026\u0026\n                        Character.isLowSurrogate(StringUTF16.getChar(val, sp))) {\n                    sp++;\n                }\n                dst[dp++] \u003d \u0027?\u0027;\n                len \u003d sl - sp;\n            }\n        }\n        if (dp \u003d\u003d dst.length) {\n            return dst;\n        }\n        return Arrays.copyOf(dst, dp);\n    }\n\n    //////////////////////////////// utf8 ////////////////////////////////////\n\n    /**\n     * Decodes ASCII from the source byte array into the destination\n     * char array. Used via JavaLangAccess from UTF_8 and other charset\n     * decoders.\n     *\n     * @return the number of bytes successfully decoded, at most len\n     */\n    /* package-private */\n    static int decodeASCII(byte[] sa, int sp, char[] da, int dp, int len) {\n        if (!StringCoding.hasNegatives(sa, sp, len)) {\n            StringLatin1.inflate(sa, sp, da, dp, len);\n            return len;\n        } else {\n            int start \u003d sp;\n            int end \u003d sp + len;\n            while (sp \u003c end \u0026\u0026 sa[sp] \u003e\u003d 0) {\n                da[dp++] \u003d (char) sa[sp++];\n            }\n            return sp - start;\n        }\n    }\n\n    private static boolean isNotContinuation(int b) {\n        return (b \u0026 0xc0) !\u003d 0x80;\n    }\n\n    private static boolean isMalformed3(int b1, int b2, int b3) {\n        return (b1 \u003d\u003d (byte)0xe0 \u0026\u0026 (b2 \u0026 0xe0) \u003d\u003d 0x80) ||\n                (b2 \u0026 0xc0) !\u003d 0x80 || (b3 \u0026 0xc0) !\u003d 0x80;\n    }\n\n    private static boolean isMalformed3_2(int b1, int b2) {\n        return (b1 \u003d\u003d (byte)0xe0 \u0026\u0026 (b2 \u0026 0xe0) \u003d\u003d 0x80) ||\n                (b2 \u0026 0xc0) !\u003d 0x80;\n    }\n\n    private static boolean isMalformed4(int b2, int b3, int b4) {\n        return (b2 \u0026 0xc0) !\u003d 0x80 || (b3 \u0026 0xc0) !\u003d 0x80 ||\n                (b4 \u0026 0xc0) !\u003d 0x80;\n    }\n\n    private static boolean isMalformed4_2(int b1, int b2) {\n        return (b1 \u003d\u003d 0xf0 \u0026\u0026 (b2 \u003c 0x90 || b2 \u003e 0xbf)) ||\n                (b1 \u003d\u003d 0xf4 \u0026\u0026 (b2 \u0026 0xf0) !\u003d 0x80) ||\n                (b2 \u0026 0xc0) !\u003d 0x80;\n    }\n\n    private static boolean isMalformed4_3(int b3) {\n        return (b3 \u0026 0xc0) !\u003d 0x80;\n    }\n\n    private static char decode2(int b1, int b2) {\n        return (char)(((b1 \u003c\u003c 6) ^ b2) ^\n                (((byte) 0xC0 \u003c\u003c 6) ^\n                        ((byte) 0x80 \u003c\u003c 0)));\n    }\n\n    private static char decode3(int b1, int b2, int b3) {\n        return (char)((b1 \u003c\u003c 12) ^\n                (b2 \u003c\u003c  6) ^\n                (b3 ^\n                        (((byte) 0xE0 \u003c\u003c 12) ^\n                                ((byte) 0x80 \u003c\u003c  6) ^\n                                ((byte) 0x80 \u003c\u003c  0))));\n    }\n\n    private static int decode4(int b1, int b2, int b3, int b4) {\n        return ((b1 \u003c\u003c 18) ^\n                (b2 \u003c\u003c 12) ^\n                (b3 \u003c\u003c  6) ^\n                (b4 ^\n                        (((byte) 0xF0 \u003c\u003c 18) ^\n                                ((byte) 0x80 \u003c\u003c 12) ^\n                                ((byte) 0x80 \u003c\u003c  6) ^\n                                ((byte) 0x80 \u003c\u003c  0))));\n    }\n\n    private static int decodeUTF8_UTF16(byte[] src, int sp, int sl, byte[] dst, int dp, boolean doReplace) {\n        while (sp \u003c sl) {\n            int b1 \u003d src[sp++];\n            if (b1 \u003e\u003d 0) {\n                StringUTF16.putChar(dst, dp++, (char) b1);\n            } else if ((b1 \u003e\u003e 5) \u003d\u003d -2 \u0026\u0026 (b1 \u0026 0x1e) !\u003d 0) {\n                if (sp \u003c sl) {\n                    int b2 \u003d src[sp++];\n                    if (isNotContinuation(b2)) {\n                        if (!doReplace) {\n                            throwMalformed(sp - 1, 1);\n                        }\n                        StringUTF16.putChar(dst, dp++, REPL);\n                        sp--;\n                    } else {\n                        StringUTF16.putChar(dst, dp++, decode2(b1, b2));\n                    }\n                    continue;\n                }\n                if (!doReplace) {\n                    throwMalformed(sp, 1);  // underflow()\n                }\n                StringUTF16.putChar(dst, dp++, REPL);\n                break;\n            } else if ((b1 \u003e\u003e 4) \u003d\u003d -2) {\n                if (sp + 1 \u003c sl) {\n                    int b2 \u003d src[sp++];\n                    int b3 \u003d src[sp++];\n                    if (isMalformed3(b1, b2, b3)) {\n                        if (!doReplace) {\n                            throwMalformed(sp - 3, 3);\n                        }\n                        StringUTF16.putChar(dst, dp++, REPL);\n                        sp -\u003d 3;\n                        sp +\u003d malformed3(src, sp);\n                    } else {\n                        char c \u003d decode3(b1, b2, b3);\n                        if (Character.isSurrogate(c)) {\n                            if (!doReplace) {\n                                throwMalformed(sp - 3, 3);\n                            }\n                            StringUTF16.putChar(dst, dp++, REPL);\n                        } else {\n                            StringUTF16.putChar(dst, dp++, c);\n                        }\n                    }\n                    continue;\n                }\n                if (sp \u003c sl \u0026\u0026 isMalformed3_2(b1, src[sp])) {\n                    if (!doReplace) {\n                        throwMalformed(sp - 1, 2);\n                    }\n                    StringUTF16.putChar(dst, dp++, REPL);\n                    continue;\n                }\n                if (!doReplace) {\n                    throwMalformed(sp, 1);\n                }\n                StringUTF16.putChar(dst, dp++, REPL);\n                break;\n            } else if ((b1 \u003e\u003e 3) \u003d\u003d -2) {\n                if (sp + 2 \u003c sl) {\n                    int b2 \u003d src[sp++];\n                    int b3 \u003d src[sp++];\n                    int b4 \u003d src[sp++];\n                    int uc \u003d decode4(b1, b2, b3, b4);\n                    if (isMalformed4(b2, b3, b4) ||\n                            !Character.isSupplementaryCodePoint(uc)) { // shortest form check\n                        if (!doReplace) {\n                            throwMalformed(sp - 4, 4);\n                        }\n                        StringUTF16.putChar(dst, dp++, REPL);\n                        sp -\u003d 4;\n                        sp +\u003d malformed4(src, sp);\n                    } else {\n                        StringUTF16.putChar(dst, dp++, Character.highSurrogate(uc));\n                        StringUTF16.putChar(dst, dp++, Character.lowSurrogate(uc));\n                    }\n                    continue;\n                }\n                b1 \u0026\u003d 0xff;\n                if (b1 \u003e 0xf4 || sp \u003c sl \u0026\u0026 isMalformed4_2(b1, src[sp] \u0026 0xff)) {\n                    if (!doReplace) {\n                        throwMalformed(sp - 1, 1);  // or 2\n                    }\n                    StringUTF16.putChar(dst, dp++, REPL);\n                    continue;\n                }\n                if (!doReplace) {\n                    throwMalformed(sp - 1, 1);\n                }\n                sp++;\n                StringUTF16.putChar(dst, dp++, REPL);\n                if (sp \u003c sl \u0026\u0026 isMalformed4_3(src[sp])) {\n                    continue;\n                }\n                break;\n            } else {\n                if (!doReplace) {\n                    throwMalformed(sp - 1, 1);\n                }\n                StringUTF16.putChar(dst, dp++, REPL);\n            }\n        }\n        return dp;\n    }\n\n    private static int decodeWithDecoder(CharsetDecoder cd, char[] dst, byte[] src, int offset, int length) {\n        ByteBuffer bb \u003d ByteBuffer.wrap(src, offset, length);\n        CharBuffer cb \u003d CharBuffer.wrap(dst, 0, dst.length);\n        try {\n            CoderResult cr \u003d cd.decode(bb, cb, true);\n            if (!cr.isUnderflow())\n                cr.throwException();\n            cr \u003d cd.flush(cb);\n            if (!cr.isUnderflow())\n                cr.throwException();\n        } catch (CharacterCodingException x) {\n            // Substitution is always enabled,\n            // so this shouldn\u0027t happen\n            throw new Error(x);\n        }\n        return cb.position();\n    }\n\n    private static int malformed3(byte[] src, int sp) {\n        int b1 \u003d src[sp++];\n        int b2 \u003d src[sp];    // no need to lookup b3\n        return ((b1 \u003d\u003d (byte)0xe0 \u0026\u0026 (b2 \u0026 0xe0) \u003d\u003d 0x80) ||\n                isNotContinuation(b2)) ? 1 : 2;\n    }\n\n    private static int malformed4(byte[] src, int sp) {\n        // we don\u0027t care the speed here\n        int b1 \u003d src[sp++] \u0026 0xff;\n        int b2 \u003d src[sp++] \u0026 0xff;\n        if (b1 \u003e 0xf4 ||\n                (b1 \u003d\u003d 0xf0 \u0026\u0026 (b2 \u003c 0x90 || b2 \u003e 0xbf)) ||\n                (b1 \u003d\u003d 0xf4 \u0026\u0026 (b2 \u0026 0xf0) !\u003d 0x80) ||\n                isNotContinuation(b2))\n            return 1;\n        if (isNotContinuation(src[sp]))\n            return 2;\n        return 3;\n    }\n\n    private static void throwMalformed(int off, int nb) {\n        String msg \u003d \"malformed input off : \" + off + \", length : \" + nb;\n        throw new IllegalArgumentException(msg, new MalformedInputException(nb));\n    }\n\n    private static void throwMalformed(byte[] val) {\n        int dp \u003d 0;\n        while (dp \u003c val.length \u0026\u0026 val[dp] \u003e\u003d0) { dp++; }\n        throwMalformed(dp, 1);\n    }\n\n    private static void throwUnmappable(int off) {\n        String msg \u003d \"malformed input off : \" + off + \", length : 1\";\n        throw new IllegalArgumentException(msg, new UnmappableCharacterException(1));\n    }\n\n    private static void throwUnmappable(byte[] val) {\n        int dp \u003d 0;\n        while (dp \u003c val.length \u0026\u0026 val[dp] \u003e\u003d0) { dp++; }\n        throwUnmappable(dp);\n    }\n\n    private static byte[] encodeUTF8(byte coder, byte[] val, boolean doReplace) {\n        if (coder \u003d\u003d UTF16)\n            return encodeUTF8_UTF16(val, doReplace);\n\n        if (!StringCoding.hasNegatives(val, 0, val.length))\n            return Arrays.copyOf(val, val.length);\n\n        int dp \u003d 0;\n        byte[] dst \u003d new byte[val.length \u003c\u003c 1];\n        for (byte c : val) {\n            if (c \u003c 0) {\n                dst[dp++] \u003d (byte) (0xc0 | ((c \u0026 0xff) \u003e\u003e 6));\n                dst[dp++] \u003d (byte) (0x80 | (c \u0026 0x3f));\n            } else {\n                dst[dp++] \u003d c;\n            }\n        }\n        if (dp \u003d\u003d dst.length)\n            return dst;\n        return Arrays.copyOf(dst, dp);\n    }\n\n    private static byte[] encodeUTF8_UTF16(byte[] val, boolean doReplace) {\n        int dp \u003d 0;\n        int sp \u003d 0;\n        int sl \u003d val.length \u003e\u003e 1;\n        byte[] dst \u003d new byte[sl * 3];\n        char c;\n        while (sp \u003c sl \u0026\u0026 (c \u003d StringUTF16.getChar(val, sp)) \u003c \u0027\\u0080\u0027) {\n            // ascii fast loop;\n            dst[dp++] \u003d (byte)c;\n            sp++;\n        }\n        while (sp \u003c sl) {\n            c \u003d StringUTF16.getChar(val, sp++);\n            if (c \u003c 0x80) {\n                dst[dp++] \u003d (byte)c;\n            } else if (c \u003c 0x800) {\n                dst[dp++] \u003d (byte)(0xc0 | (c \u003e\u003e 6));\n                dst[dp++] \u003d (byte)(0x80 | (c \u0026 0x3f));\n            } else if (Character.isSurrogate(c)) {\n                int uc \u003d -1;\n                char c2;\n                if (Character.isHighSurrogate(c) \u0026\u0026 sp \u003c sl \u0026\u0026\n                        Character.isLowSurrogate(c2 \u003d StringUTF16.getChar(val, sp))) {\n                    uc \u003d Character.toCodePoint(c, c2);\n                }\n                if (uc \u003c 0) {\n                    if (doReplace) {\n                        dst[dp++] \u003d \u0027?\u0027;\n                    } else {\n                        throwUnmappable(sp - 1);\n                    }\n                } else {\n                    dst[dp++] \u003d (byte)(0xf0 | ((uc \u003e\u003e 18)));\n                    dst[dp++] \u003d (byte)(0x80 | ((uc \u003e\u003e 12) \u0026 0x3f));\n                    dst[dp++] \u003d (byte)(0x80 | ((uc \u003e\u003e  6) \u0026 0x3f));\n                    dst[dp++] \u003d (byte)(0x80 | (uc \u0026 0x3f));\n                    sp++;  // 2 chars\n                }\n            } else {\n                // 3 bytes, 16 bits\n                dst[dp++] \u003d (byte)(0xe0 | ((c \u003e\u003e 12)));\n                dst[dp++] \u003d (byte)(0x80 | ((c \u003e\u003e  6) \u0026 0x3f));\n                dst[dp++] \u003d (byte)(0x80 | (c \u0026 0x3f));\n            }\n        }\n        if (dp \u003d\u003d dst.length) {\n            return dst;\n        }\n        return Arrays.copyOf(dst, dp);\n    }\n\n    /**\n     * Constructs a new {@code String} by decoding the specified array of bytes\n     * using the specified {@linkplain java.nio.charset.Charset charset}.  The\n     * length of the new {@code String} is a function of the charset, and hence\n     * may not be equal to the length of the byte array.\n     *\n     * \u003cp\u003e The behavior of this constructor when the given bytes are not valid\n     * in the given charset is unspecified.  The {@link\n     * java.nio.charset.CharsetDecoder} class should be used when more control\n     * over the decoding process is required.\n     *\n     * @param  bytes\n     *         The bytes to be decoded into characters\n     *\n     * @param  charsetName\n     *         The name of a supported {@linkplain java.nio.charset.Charset\n     *         charset}\n     *\n     * @throws  UnsupportedEncodingException\n     *          If the named charset is not supported\n     *\n     * @since  1.1\n     */\n    public String(byte bytes[], String charsetName)\n            throws UnsupportedEncodingException {\n        this(bytes, 0, bytes.length, charsetName);\n    }\n\n    /**\n     * Constructs a new {@code String} by decoding the specified array of\n     * bytes using the specified {@linkplain java.nio.charset.Charset charset}.\n     * The length of the new {@code String} is a function of the charset, and\n     * hence may not be equal to the length of the byte array.\n     *\n     * \u003cp\u003e This method always replaces malformed-input and unmappable-character\n     * sequences with this charset\u0027s default replacement string.  The {@link\n     * java.nio.charset.CharsetDecoder} class should be used when more control\n     * over the decoding process is required.\n     *\n     * @param  bytes\n     *         The bytes to be decoded into characters\n     *\n     * @param  charset\n     *         The {@linkplain java.nio.charset.Charset charset} to be used to\n     *         decode the {@code bytes}\n     *\n     * @since  1.6\n     */\n    public String(byte bytes[], Charset charset) {\n        this(bytes, 0, bytes.length, charset);\n    }\n\n    /**\n     * Constructs a new {@code String} by decoding the specified subarray of\n     * bytes using the platform\u0027s default charset.  The length of the new\n     * {@code String} is a function of the charset, and hence may not be equal\n     * to the length of the subarray.\n     *\n     * \u003cp\u003e The behavior of this constructor when the given bytes are not valid\n     * in the default charset is unspecified.  The {@link\n     * java.nio.charset.CharsetDecoder} class should be used when more control\n     * over the decoding process is required.\n     *\n     * @param  bytes\n     *         The bytes to be decoded into characters\n     *\n     * @param  offset\n     *         The index of the first byte to decode\n     *\n     * @param  length\n     *         The number of bytes to decode\n     *\n     * @throws  IndexOutOfBoundsException\n     *          If {@code offset} is negative, {@code length} is negative, or\n     *          {@code offset} is greater than {@code bytes.length - length}\n     *\n     * @since  1.1\n     */\n    public String(byte[] bytes, int offset, int length) {\n        this(bytes, offset, length, Charset.defaultCharset());\n    }\n\n    /**\n     * Constructs a new {@code String} by decoding the specified array of bytes\n     * using the platform\u0027s default charset.  The length of the new {@code\n     * String} is a function of the charset, and hence may not be equal to the\n     * length of the byte array.\n     *\n     * \u003cp\u003e The behavior of this constructor when the given bytes are not valid\n     * in the default charset is unspecified.  The {@link\n     * java.nio.charset.CharsetDecoder} class should be used when more control\n     * over the decoding process is required.\n     *\n     * @param  bytes\n     *         The bytes to be decoded into characters\n     *\n     * @since  1.1\n     */\n    public String(byte[] bytes) {\n        this(bytes, 0, bytes.length);\n    }\n\n    /**\n     * Allocates a new string that contains the sequence of characters\n     * currently contained in the string buffer argument. The contents of the\n     * string buffer are copied; subsequent modification of the string buffer\n     * does not affect the newly created string.\n     *\n     * @param  buffer\n     *         A {@code StringBuffer}\n     */\n    public String(StringBuffer buffer) {\n        this(buffer.toString());\n    }\n\n    /**\n     * Allocates a new string that contains the sequence of characters\n     * currently contained in the string builder argument. The contents of the\n     * string builder are copied; subsequent modification of the string builder\n     * does not affect the newly created string.\n     *\n     * \u003cp\u003e This constructor is provided to ease migration to {@code\n     * StringBuilder}. Obtaining a string from a string builder via the {@code\n     * toString} method is likely to run faster and is generally preferred.\n     *\n     * @param   builder\n     *          A {@code StringBuilder}\n     *\n     * @since  1.5\n     */\n    public String(StringBuilder builder) {\n        this(builder, null);\n    }\n\n    /**\n     * Returns the length of this string.\n     * The length is equal to the number of \u003ca href\u003d\"Character.html#unicode\"\u003eUnicode\n     * code units\u003c/a\u003e in the string.\n     *\n     * @return  the length of the sequence of characters represented by this\n     *          object.\n     */\n    public int length() {\n        return value.length \u003e\u003e coder();\n    }\n\n    /**\n     * Returns {@code true} if, and only if, {@link #length()} is {@code 0}.\n     *\n     * @return {@code true} if {@link #length()} is {@code 0}, otherwise\n     * {@code false}\n     *\n     * @since 1.6\n     */\n    @Override\n    public boolean isEmpty() {\n        return value.length \u003d\u003d 0;\n    }\n\n    /**\n     * Returns the {@code char} value at the\n     * specified index. An index ranges from {@code 0} to\n     * {@code length() - 1}. The first {@code char} value of the sequence\n     * is at index {@code 0}, the next at index {@code 1},\n     * and so on, as for array indexing.\n     *\n     * \u003cp\u003eIf the {@code char} value specified by the index is a\n     * \u003ca href\u003d\"Character.html#unicode\"\u003esurrogate\u003c/a\u003e, the surrogate\n     * value is returned.\n     *\n     * @param      index   the index of the {@code char} value.\n     * @return     the {@code char} value at the specified index of this string.\n     *             The first {@code char} value is at index {@code 0}.\n     * @throws     IndexOutOfBoundsException  if the {@code index}\n     *             argument is negative or not less than the length of this\n     *             string.\n     */\n    public char charAt(int index) {\n        if (isLatin1()) {\n            return StringLatin1.charAt(value, index);\n        } else {\n            return StringUTF16.charAt(value, index);\n        }\n    }\n\n    /**\n     * Returns the character (Unicode code point) at the specified\n     * index. The index refers to {@code char} values\n     * (Unicode code units) and ranges from {@code 0} to\n     * {@link #length()}{@code  - 1}.\n     *\n     * \u003cp\u003e If the {@code char} value specified at the given index\n     * is in the high-surrogate range, the following index is less\n     * than the length of this {@code String}, and the\n     * {@code char} value at the following index is in the\n     * low-surrogate range, then the supplementary code point\n     * corresponding to this surrogate pair is returned. Otherwise,\n     * the {@code char} value at the given index is returned.\n     *\n     * @param      index the index to the {@code char} values\n     * @return     the code point value of the character at the\n     *             {@code index}\n     * @throws     IndexOutOfBoundsException  if the {@code index}\n     *             argument is negative or not less than the length of this\n     *             string.\n     * @since      1.5\n     */\n    public int codePointAt(int index) {\n        if (isLatin1()) {\n            checkIndex(index, value.length);\n            return value[index] \u0026 0xff;\n        }\n        int length \u003d value.length \u003e\u003e 1;\n        checkIndex(index, length);\n        return StringUTF16.codePointAt(value, index, length);\n    }\n\n    /**\n     * Returns the character (Unicode code point) before the specified\n     * index. The index refers to {@code char} values\n     * (Unicode code units) and ranges from {@code 1} to {@link\n     * CharSequence#length() length}.\n     *\n     * \u003cp\u003e If the {@code char} value at {@code (index - 1)}\n     * is in the low-surrogate range, {@code (index - 2)} is not\n     * negative, and the {@code char} value at {@code (index -\n     * 2)} is in the high-surrogate range, then the\n     * supplementary code point value of the surrogate pair is\n     * returned. If the {@code char} value at {@code index -\n     * 1} is an unpaired low-surrogate or a high-surrogate, the\n     * surrogate value is returned.\n     *\n     * @param     index the index following the code point that should be returned\n     * @return    the Unicode code point value before the given index.\n     * @throws    IndexOutOfBoundsException if the {@code index}\n     *            argument is less than 1 or greater than the length\n     *            of this string.\n     * @since     1.5\n     */\n    public int codePointBefore(int index) {\n        int i \u003d index - 1;\n        if (i \u003c 0 || i \u003e\u003d length()) {\n            throw new StringIndexOutOfBoundsException(index);\n        }\n        if (isLatin1()) {\n            return (value[i] \u0026 0xff);\n        }\n        return StringUTF16.codePointBefore(value, index);\n    }\n\n    /**\n     * Returns the number of Unicode code points in the specified text\n     * range of this {@code String}. The text range begins at the\n     * specified {@code beginIndex} and extends to the\n     * {@code char} at index {@code endIndex - 1}. Thus the\n     * length (in {@code char}s) of the text range is\n     * {@code endIndex-beginIndex}. Unpaired surrogates within\n     * the text range count as one code point each.\n     *\n     * @param beginIndex the index to the first {@code char} of\n     * the text range.\n     * @param endIndex the index after the last {@code char} of\n     * the text range.\n     * @return the number of Unicode code points in the specified text\n     * range\n     * @throws    IndexOutOfBoundsException if the\n     * {@code beginIndex} is negative, or {@code endIndex}\n     * is larger than the length of this {@code String}, or\n     * {@code beginIndex} is larger than {@code endIndex}.\n     * @since  1.5\n     */\n    public int codePointCount(int beginIndex, int endIndex) {\n        if (beginIndex \u003c 0 || beginIndex \u003e endIndex ||\n            endIndex \u003e length()) {\n            throw new IndexOutOfBoundsException();\n        }\n        if (isLatin1()) {\n            return endIndex - beginIndex;\n        }\n        return StringUTF16.codePointCount(value, beginIndex, endIndex);\n    }\n\n    /**\n     * Returns the index within this {@code String} that is\n     * offset from the given {@code index} by\n     * {@code codePointOffset} code points. Unpaired surrogates\n     * within the text range given by {@code index} and\n     * {@code codePointOffset} count as one code point each.\n     *\n     * @param index the index to be offset\n     * @param codePointOffset the offset in code points\n     * @return the index within this {@code String}\n     * @throws    IndexOutOfBoundsException if {@code index}\n     *   is negative or larger then the length of this\n     *   {@code String}, or if {@code codePointOffset} is positive\n     *   and the substring starting with {@code index} has fewer\n     *   than {@code codePointOffset} code points,\n     *   or if {@code codePointOffset} is negative and the substring\n     *   before {@code index} has fewer than the absolute value\n     *   of {@code codePointOffset} code points.\n     * @since 1.5\n     */\n    public int offsetByCodePoints(int index, int codePointOffset) {\n        if (index \u003c 0 || index \u003e length()) {\n            throw new IndexOutOfBoundsException();\n        }\n        return Character.offsetByCodePoints(this, index, codePointOffset);\n    }\n\n    /**\n     * Copies characters from this string into the destination character\n     * array.\n     * \u003cp\u003e\n     * The first character to be copied is at index {@code srcBegin};\n     * the last character to be copied is at index {@code srcEnd-1}\n     * (thus the total number of characters to be copied is\n     * {@code srcEnd-srcBegin}). The characters are copied into the\n     * subarray of {@code dst} starting at index {@code dstBegin}\n     * and ending at index:\n     * \u003cblockquote\u003e\u003cpre\u003e\n     *     dstBegin + (srcEnd-srcBegin) - 1\n     * \u003c/pre\u003e\u003c/blockquote\u003e\n     *\n     * @param      srcBegin   index of the first character in the string\n     *                        to copy.\n     * @param      srcEnd     index after the last character in the string\n     *                        to copy.\n     * @param      dst        the destination array.\n     * @param      dstBegin   the start offset in the destination array.\n     * @throws    IndexOutOfBoundsException If any of the following\n     *            is true:\n     *            \u003cul\u003e\u003cli\u003e{@code srcBegin} is negative.\n     *            \u003cli\u003e{@code srcBegin} is greater than {@code srcEnd}\n     *            \u003cli\u003e{@code srcEnd} is greater than the length of this\n     *                string\n     *            \u003cli\u003e{@code dstBegin} is negative\n     *            \u003cli\u003e{@code dstBegin+(srcEnd-srcBegin)} is larger than\n     *                {@code dst.length}\u003c/ul\u003e\n     */\n    public void getChars(int srcBegin, int srcEnd, char dst[], int dstBegin) {\n        checkBoundsBeginEnd(srcBegin, srcEnd, length());\n        checkBoundsOffCount(dstBegin, srcEnd - srcBegin, dst.length);\n        if (isLatin1()) {\n            StringLatin1.getChars(value, srcBegin, srcEnd, dst, dstBegin);\n        } else {\n            StringUTF16.getChars(value, srcBegin, srcEnd, dst, dstBegin);\n        }\n    }\n\n    /**\n     * Copies characters from this string into the destination byte array. Each\n     * byte receives the 8 low-order bits of the corresponding character. The\n     * eight high-order bits of each character are not copied and do not\n     * participate in the transfer in any way.\n     *\n     * \u003cp\u003e The first character to be copied is at index {@code srcBegin}; the\n     * last character to be copied is at index {@code srcEnd-1}.  The total\n     * number of characters to be copied is {@code srcEnd-srcBegin}. The\n     * characters, converted to bytes, are copied into the subarray of {@code\n     * dst} starting at index {@code dstBegin} and ending at index:\n     *\n     * \u003cblockquote\u003e\u003cpre\u003e\n     *     dstBegin + (srcEnd-srcBegin) - 1\n     * \u003c/pre\u003e\u003c/blockquote\u003e\n     *\n     * @deprecated  This method does not properly convert characters into\n     * bytes.  As of JDK\u0026nbsp;1.1, the preferred way to do this is via the\n     * {@link #getBytes()} method, which uses the platform\u0027s default charset.\n     *\n     * @param  srcBegin\n     *         Index of the first character in the string to copy\n     *\n     * @param  srcEnd\n     *         Index after the last character in the string to copy\n     *\n     * @param  dst\n     *         The destination array\n     *\n     * @param  dstBegin\n     *         The start offset in the destination array\n     *\n     * @throws  IndexOutOfBoundsException\n     *          If any of the following is true:\n     *          \u003cul\u003e\n     *            \u003cli\u003e {@code srcBegin} is negative\n     *            \u003cli\u003e {@code srcBegin} is greater than {@code srcEnd}\n     *            \u003cli\u003e {@code srcEnd} is greater than the length of this String\n     *            \u003cli\u003e {@code dstBegin} is negative\n     *            \u003cli\u003e {@code dstBegin+(srcEnd-srcBegin)} is larger than {@code\n     *                 dst.length}\n     *          \u003c/ul\u003e\n     */\n    @Deprecated(since\u003d\"1.1\")\n    public void getBytes(int srcBegin, int srcEnd, byte dst[], int dstBegin) {\n        checkBoundsBeginEnd(srcBegin, srcEnd, length());\n        Objects.requireNonNull(dst);\n        checkBoundsOffCount(dstBegin, srcEnd - srcBegin, dst.length);\n        if (isLatin1()) {\n            StringLatin1.getBytes(value, srcBegin, srcEnd, dst, dstBegin);\n        } else {\n            StringUTF16.getBytes(value, srcBegin, srcEnd, dst, dstBegin);\n        }\n    }\n\n    /**\n     * Encodes this {@code String} into a sequence of bytes using the named\n     * charset, storing the result into a new byte array.\n     *\n     * \u003cp\u003e The behavior of this method when this string cannot be encoded in\n     * the given charset is unspecified.  The {@link\n     * java.nio.charset.CharsetEncoder} class should be used when more control\n     * over the encoding process is required.\n     *\n     * @param  charsetName\n     *         The name of a supported {@linkplain java.nio.charset.Charset\n     *         charset}\n     *\n     * @return  The resultant byte array\n     *\n     * @throws  UnsupportedEncodingException\n     *          If the named charset is not supported\n     *\n     * @since  1.1\n     */\n    public byte[] getBytes(String charsetName)\n            throws UnsupportedEncodingException {\n        if (charsetName \u003d\u003d null) throw new NullPointerException();\n        return encode(lookupCharset(charsetName), coder(), value);\n    }\n\n    /**\n     * Encodes this {@code String} into a sequence of bytes using the given\n     * {@linkplain java.nio.charset.Charset charset}, storing the result into a\n     * new byte array.\n     *\n     * \u003cp\u003e This method always replaces malformed-input and unmappable-character\n     * sequences with this charset\u0027s default replacement byte array.  The\n     * {@link java.nio.charset.CharsetEncoder} class should be used when more\n     * control over the encoding process is required.\n     *\n     * @param  charset\n     *         The {@linkplain java.nio.charset.Charset} to be used to encode\n     *         the {@code String}\n     *\n     * @return  The resultant byte array\n     *\n     * @since  1.6\n     */\n    public byte[] getBytes(Charset charset) {\n        if (charset \u003d\u003d null) throw new NullPointerException();\n        return encode(charset, coder(), value);\n     }\n\n    /**\n     * Encodes this {@code String} into a sequence of bytes using the\n     * platform\u0027s default charset, storing the result into a new byte array.\n     *\n     * \u003cp\u003e The behavior of this method when this string cannot be encoded in\n     * the default charset is unspecified.  The {@link\n     * java.nio.charset.CharsetEncoder} class should be used when more control\n     * over the encoding process is required.\n     *\n     * @return  The resultant byte array\n     *\n     * @since      1.1\n     */\n    public byte[] getBytes() {\n        return encode(Charset.defaultCharset(), coder(), value);\n    }\n\n    /**\n     * Compares this string to the specified object.  The result is {@code\n     * true} if and only if the argument is not {@code null} and is a {@code\n     * String} object that represents the same sequence of characters as this\n     * object.\n     *\n     * \u003cp\u003eFor finer-grained String comparison, refer to\n     * {@link java.text.Collator}.\n     *\n     * @param  anObject\n     *         The object to compare this {@code String} against\n     *\n     * @return  {@code true} if the given object represents a {@code String}\n     *          equivalent to this string, {@code false} otherwise\n     *\n     * @see  #compareTo(String)\n     * @see  #equalsIgnoreCase(String)\n     */\n    public boolean equals(Object anObject) {\n        if (this \u003d\u003d anObject) {\n            return true;\n        }\n        return (anObject instanceof String aString)\n                \u0026\u0026 (!COMPACT_STRINGS || this.coder \u003d\u003d aString.coder)\n                \u0026\u0026 StringLatin1.equals(value, aString.value);\n    }\n\n    /**\n     * Compares this string to the specified {@code StringBuffer}.  The result\n     * is {@code true} if and only if this {@code String} represents the same\n     * sequence of characters as the specified {@code StringBuffer}. This method\n     * synchronizes on the {@code StringBuffer}.\n     *\n     * \u003cp\u003eFor finer-grained String comparison, refer to\n     * {@link java.text.Collator}.\n     *\n     * @param  sb\n     *         The {@code StringBuffer} to compare this {@code String} against\n     *\n     * @return  {@code true} if this {@code String} represents the same\n     *          sequence of characters as the specified {@code StringBuffer},\n     *          {@code false} otherwise\n     *\n     * @since  1.4\n     */\n    public boolean contentEquals(StringBuffer sb) {\n        return contentEquals((CharSequence)sb);\n    }\n\n    private boolean nonSyncContentEquals(AbstractStringBuilder sb) {\n        int len \u003d length();\n        if (len !\u003d sb.length()) {\n            return false;\n        }\n        byte v1[] \u003d value;\n        byte v2[] \u003d sb.getValue();\n        byte coder \u003d coder();\n        if (coder \u003d\u003d sb.getCoder()) {\n            int n \u003d v1.length;\n            for (int i \u003d 0; i \u003c n; i++) {\n                if (v1[i] !\u003d v2[i]) {\n                    return false;\n                }\n            }\n        } else {\n            if (coder !\u003d LATIN1) {  // utf16 str and latin1 abs can never be \"equal\"\n                return false;\n            }\n            return StringUTF16.contentEquals(v1, v2, len);\n        }\n        return true;\n    }\n\n    /**\n     * Compares this string to the specified {@code CharSequence}.  The\n     * result is {@code true} if and only if this {@code String} represents the\n     * same sequence of char values as the specified sequence. Note that if the\n     * {@code CharSequence} is a {@code StringBuffer} then the method\n     * synchronizes on it.\n     *\n     * \u003cp\u003eFor finer-grained String comparison, refer to\n     * {@link java.text.Collator}.\n     *\n     * @param  cs\n     *         The sequence to compare this {@code String} against\n     *\n     * @return  {@code true} if this {@code String} represents the same\n     *          sequence of char values as the specified sequence, {@code\n     *          false} otherwise\n     *\n     * @since  1.5\n     */\n    public boolean contentEquals(CharSequence cs) {\n        // Argument is a StringBuffer, StringBuilder\n        if (cs instanceof AbstractStringBuilder) {\n            if (cs instanceof StringBuffer) {\n                synchronized(cs) {\n                   return nonSyncContentEquals((AbstractStringBuilder)cs);\n                }\n            } else {\n                return nonSyncContentEquals((AbstractStringBuilder)cs);\n            }\n        }\n        // Argument is a String\n        if (cs instanceof String) {\n            return equals(cs);\n        }\n        // Argument is a generic CharSequence\n        int n \u003d cs.length();\n        if (n !\u003d length()) {\n            return false;\n        }\n        byte[] val \u003d this.value;\n        if (isLatin1()) {\n            for (int i \u003d 0; i \u003c n; i++) {\n                if ((val[i] \u0026 0xff) !\u003d cs.charAt(i)) {\n                    return false;\n                }\n            }\n        } else {\n            if (!StringUTF16.contentEquals(val, cs, n)) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    /**\n     * Compares this {@code String} to another {@code String}, ignoring case\n     * considerations.  Two strings are considered equal ignoring case if they\n     * are of the same length and corresponding Unicode code points in the two\n     * strings are equal ignoring case.\n     *\n     * \u003cp\u003e Two Unicode code points are considered the same\n     * ignoring case if at least one of the following is true:\n     * \u003cul\u003e\n     *   \u003cli\u003e The two Unicode code points are the same (as compared by the\n     *        {@code \u003d\u003d} operator)\n     *   \u003cli\u003e Calling {@code Character.toLowerCase(Character.toUpperCase(int))}\n     *        on each Unicode code point produces the same result\n     * \u003c/ul\u003e\n     *\n     * \u003cp\u003eNote that this method does \u003cem\u003enot\u003c/em\u003e take locale into account, and\n     * will result in unsatisfactory results for certain locales.  The\n     * {@link java.text.Collator} class provides locale-sensitive comparison.\n     *\n     * @param  anotherString\n     *         The {@code String} to compare this {@code String} against\n     *\n     * @return  {@code true} if the argument is not {@code null} and it\n     *          represents an equivalent {@code String} ignoring case; {@code\n     *          false} otherwise\n     *\n     * @see  #equals(Object)\n     * @see  #codePoints()\n     */\n    public boolean equalsIgnoreCase(String anotherString) {\n        return (this \u003d\u003d anotherString) ? true\n                : (anotherString !\u003d null)\n                \u0026\u0026 (anotherString.length() \u003d\u003d length())\n                \u0026\u0026 regionMatches(true, 0, anotherString, 0, length());\n    }\n\n    /**\n     * Compares two strings lexicographically.\n     * The comparison is based on the Unicode value of each character in\n     * the strings. The character sequence represented by this\n     * {@code String} object is compared lexicographically to the\n     * character sequence represented by the argument string. The result is\n     * a negative integer if this {@code String} object\n     * lexicographically precedes the argument string. The result is a\n     * positive integer if this {@code String} object lexicographically\n     * follows the argument string. The result is zero if the strings\n     * are equal; {@code compareTo} returns {@code 0} exactly when\n     * the {@link #equals(Object)} method would return {@code true}.\n     * \u003cp\u003e\n     * This is the definition of lexicographic ordering. If two strings are\n     * different, then either they have different characters at some index\n     * that is a valid index for both strings, or their lengths are different,\n     * or both. If they have different characters at one or more index\n     * positions, let \u003ci\u003ek\u003c/i\u003e be the smallest such index; then the string\n     * whose character at position \u003ci\u003ek\u003c/i\u003e has the smaller value, as\n     * determined by using the {@code \u003c} operator, lexicographically precedes the\n     * other string. In this case, {@code compareTo} returns the\n     * difference of the two character values at position {@code k} in\n     * the two string -- that is, the value:\n     * \u003cblockquote\u003e\u003cpre\u003e\n     * this.charAt(k)-anotherString.charAt(k)\n     * \u003c/pre\u003e\u003c/blockquote\u003e\n     * If there is no index position at which they differ, then the shorter\n     * string lexicographically precedes the longer string. In this case,\n     * {@code compareTo} returns the difference of the lengths of the\n     * strings -- that is, the value:\n     * \u003cblockquote\u003e\u003cpre\u003e\n     * this.length()-anotherString.length()\n     * \u003c/pre\u003e\u003c/blockquote\u003e\n     *\n     * \u003cp\u003eFor finer-grained String comparison, refer to\n     * {@link java.text.Collator}.\n     *\n     * @param   anotherString   the {@code String} to be compared.\n     * @return  the value {@code 0} if the argument string is equal to\n     *          this string; a value less than {@code 0} if this string\n     *          is lexicographically less than the string argument; and a\n     *          value greater than {@code 0} if this string is\n     *          lexicographically greater than the string argument.\n     */\n    public int compareTo(String anotherString) {\n        byte v1[] \u003d value;\n        byte v2[] \u003d anotherString.value;\n        byte coder \u003d coder();\n        if (coder \u003d\u003d anotherString.coder()) {\n            return coder \u003d\u003d LATIN1 ? StringLatin1.compareTo(v1, v2)\n                                   : StringUTF16.compareTo(v1, v2);\n        }\n        return coder \u003d\u003d LATIN1 ? StringLatin1.compareToUTF16(v1, v2)\n                               : StringUTF16.compareToLatin1(v1, v2);\n     }\n\n    /**\n     * A Comparator that orders {@code String} objects as by\n     * {@link #compareToIgnoreCase(String) compareToIgnoreCase}.\n     * This comparator is serializable.\n     * \u003cp\u003e\n     * Note that this Comparator does \u003cem\u003enot\u003c/em\u003e take locale into account,\n     * and will result in an unsatisfactory ordering for certain locales.\n     * The {@link java.text.Collator} class provides locale-sensitive comparison.\n     *\n     * @see     java.text.Collator\n     * @since   1.2\n     */\n    public static final Comparator\u003cString\u003e CASE_INSENSITIVE_ORDER\n                                         \u003d new CaseInsensitiveComparator();\n\n    /**\n     * CaseInsensitiveComparator for Strings.\n     */\n    private static class CaseInsensitiveComparator\n            implements Comparator\u003cString\u003e, java.io.Serializable {\n        // use serialVersionUID from JDK 1.2.2 for interoperability\n        @java.io.Serial\n        private static final long serialVersionUID \u003d 8575799808933029326L;\n\n        public int compare(String s1, String s2) {\n            byte v1[] \u003d s1.value;\n            byte v2[] \u003d s2.value;\n            byte coder \u003d s1.coder();\n            if (coder \u003d\u003d s2.coder()) {\n                return coder \u003d\u003d LATIN1 ? StringLatin1.compareToCI(v1, v2)\n                                       : StringUTF16.compareToCI(v1, v2);\n            }\n            return coder \u003d\u003d LATIN1 ? StringLatin1.compareToCI_UTF16(v1, v2)\n                                   : StringUTF16.compareToCI_Latin1(v1, v2);\n        }\n\n        /** Replaces the de-serialized object. */\n        @java.io.Serial\n        private Object readResolve() { return CASE_INSENSITIVE_ORDER; }\n    }\n\n    /**\n     * Compares two strings lexicographically, ignoring case\n     * differences. This method returns an integer whose sign is that of\n     * calling {@code compareTo} with case folded versions of the strings\n     * where case differences have been eliminated by calling\n     * {@code Character.toLowerCase(Character.toUpperCase(int))} on\n     * each Unicode code point.\n     * \u003cp\u003e\n     * Note that this method does \u003cem\u003enot\u003c/em\u003e take locale into account,\n     * and will result in an unsatisfactory ordering for certain locales.\n     * The {@link java.text.Collator} class provides locale-sensitive comparison.\n     *\n     * @param   str   the {@code String} to be compared.\n     * @return  a negative integer, zero, or a positive integer as the\n     *          specified String is greater than, equal to, or less\n     *          than this String, ignoring case considerations.\n     * @see     java.text.Collator\n     * @see     #codePoints()\n     * @since   1.2\n     */\n    public int compareToIgnoreCase(String str) {\n        return CASE_INSENSITIVE_ORDER.compare(this, str);\n    }\n\n    /**\n     * Tests if two string regions are equal.\n     * \u003cp\u003e\n     * A substring of this {@code String} object is compared to a substring\n     * of the argument other. The result is true if these substrings\n     * represent identical character sequences. The substring of this\n     * {@code String} object to be compared begins at index {@code toffset}\n     * and has length {@code len}. The substring of other to be compared\n     * begins at index {@code ooffset} and has length {@code len}. The\n     * result is {@code false} if and only if at least one of the following\n     * is true:\n     * \u003cul\u003e\u003cli\u003e{@code toffset} is negative.\n     * \u003cli\u003e{@code ooffset} is negative.\n     * \u003cli\u003e{@code toffset+len} is greater than the length of this\n     * {@code String} object.\n     * \u003cli\u003e{@code ooffset+len} is greater than the length of the other\n     * argument.\n     * \u003cli\u003eThere is some nonnegative integer \u003ci\u003ek\u003c/i\u003e less than {@code len}\n     * such that:\n     * {@code this.charAt(toffset + }\u003ci\u003ek\u003c/i\u003e{@code ) !\u003d other.charAt(ooffset + }\n     * \u003ci\u003ek\u003c/i\u003e{@code )}\n     * \u003c/ul\u003e\n     *\n     * \u003cp\u003eNote that this method does \u003cem\u003enot\u003c/em\u003e take locale into account.  The\n     * {@link java.text.Collator} class provides locale-sensitive comparison.\n     *\n     * @param   toffset   the starting offset of the subregion in this string.\n     * @param   other     the string argument.\n     * @param   ooffset   the starting offset of the subregion in the string\n     *                    argument.\n     * @param   len       the number of characters to compare.\n     * @return  {@code true} if the specified subregion of this string\n     *          exactly matches the specified subregion of the string argument;\n     *          {@code false} otherwise.\n     */\n    public boolean regionMatches(int toffset, String other, int ooffset, int len) {\n        byte tv[] \u003d value;\n        byte ov[] \u003d other.value;\n        // Note: toffset, ooffset, or len might be near -1\u003e\u003e\u003e1.\n        if ((ooffset \u003c 0) || (toffset \u003c 0) ||\n             (toffset \u003e (long)length() - len) ||\n             (ooffset \u003e (long)other.length() - len)) {\n            return false;\n        }\n        byte coder \u003d coder();\n        if (coder \u003d\u003d other.coder()) {\n            if (!isLatin1() \u0026\u0026 (len \u003e 0)) {\n                toffset \u003d toffset \u003c\u003c 1;\n                ooffset \u003d ooffset \u003c\u003c 1;\n                len \u003d len \u003c\u003c 1;\n            }\n            while (len-- \u003e 0) {\n                if (tv[toffset++] !\u003d ov[ooffset++]) {\n                    return false;\n                }\n            }\n        } else {\n            if (coder \u003d\u003d LATIN1) {\n                while (len-- \u003e 0) {\n                    if (StringLatin1.getChar(tv, toffset++) !\u003d\n                        StringUTF16.getChar(ov, ooffset++)) {\n                        return false;\n                    }\n                }\n            } else {\n                while (len-- \u003e 0) {\n                    if (StringUTF16.getChar(tv, toffset++) !\u003d\n                        StringLatin1.getChar(ov, ooffset++)) {\n                        return false;\n                    }\n                }\n            }\n        }\n        return true;\n    }\n\n    /**\n     * Tests if two string regions are equal.\n     * \u003cp\u003e\n     * A substring of this {@code String} object is compared to a substring\n     * of the argument {@code other}. The result is {@code true} if these\n     * substrings represent Unicode code point sequences that are the same,\n     * ignoring case if and only if {@code ignoreCase} is true.\n     * The sequences {@code tsequence} and {@code osequence} are compared,\n     * where {@code tsequence} is the sequence produced as if by calling\n     * {@code this.substring(toffset, toffset + len).codePoints()} and\n     * {@code osequence} is the sequence produced as if by calling\n     * {@code other.substring(ooffset, ooffset + len).codePoints()}.\n     * The result is {@code true} if and only if all of the following\n     * are true:\n     * \u003cul\u003e\u003cli\u003e{@code toffset} is non-negative.\n     * \u003cli\u003e{@code ooffset} is non-negative.\n     * \u003cli\u003e{@code toffset+len} is less than or equal to the length of this\n     * {@code String} object.\n     * \u003cli\u003e{@code ooffset+len} is less than or equal to the length of the other\n     * argument.\n     * \u003cli\u003eif {@code ignoreCase} is {@code false}, all pairs of corresponding Unicode\n     * code points are equal integer values; or if {@code ignoreCase} is {@code true},\n     * {@link Character#toLowerCase(int) Character.toLowerCase(}\n     * {@link Character#toUpperCase(int)}{@code )} on all pairs of Unicode code points\n     * results in equal integer values.\n     * \u003c/ul\u003e\n     *\n     * \u003cp\u003eNote that this method does \u003cem\u003enot\u003c/em\u003e take locale into account,\n     * and will result in unsatisfactory results for certain locales when\n     * {@code ignoreCase} is {@code true}.  The {@link java.text.Collator} class\n     * provides locale-sensitive comparison.\n     *\n     * @param   ignoreCase   if {@code true}, ignore case when comparing\n     *                       characters.\n     * @param   toffset      the starting offset of the subregion in this\n     *                       string.\n     * @param   other        the string argument.\n     * @param   ooffset      the starting offset of the subregion in the string\n     *                       argument.\n     * @param   len          the number of characters (Unicode code units -\n     *                       16bit {@code char} value) to compare.\n     * @return  {@code true} if the specified subregion of this string\n     *          matches the specified subregion of the string argument;\n     *          {@code false} otherwise. Whether the matching is exact\n     *          or case insensitive depends on the {@code ignoreCase}\n     *          argument.\n     * @see     #codePoints()\n     */\n    public boolean regionMatches(boolean ignoreCase, int toffset,\n            String other, int ooffset, int len) {\n        if (!ignoreCase) {\n            return regionMatches(toffset, other, ooffset, len);\n        }\n        // Note: toffset, ooffset, or len might be near -1\u003e\u003e\u003e1.\n        if ((ooffset \u003c 0) || (toffset \u003c 0)\n                || (toffset \u003e (long)length() - len)\n                || (ooffset \u003e (long)other.length() - len)) {\n            return false;\n        }\n        byte tv[] \u003d value;\n        byte ov[] \u003d other.value;\n        byte coder \u003d coder();\n        if (coder \u003d\u003d other.coder()) {\n            return coder \u003d\u003d LATIN1\n              ? StringLatin1.regionMatchesCI(tv, toffset, ov, ooffset, len)\n              : StringUTF16.regionMatchesCI(tv, toffset, ov, ooffset, len);\n        }\n        return coder \u003d\u003d LATIN1\n              ? StringLatin1.regionMatchesCI_UTF16(tv, toffset, ov, ooffset, len)\n              : StringUTF16.regionMatchesCI_Latin1(tv, toffset, ov, ooffset, len);\n    }\n\n    /**\n     * Tests if the substring of this string beginning at the\n     * specified index starts with the specified prefix.\n     *\n     * @param   prefix    the prefix.\n     * @param   toffset   where to begin looking in this string.\n     * @return  {@code true} if the character sequence represented by the\n     *          argument is a prefix of the substring of this object starting\n     *          at index {@code toffset}; {@code false} otherwise.\n     *          The result is {@code false} if {@code toffset} is\n     *          negative or greater than the length of this\n     *          {@code String} object; otherwise the result is the same\n     *          as the result of the expression\n     *          \u003cpre\u003e\n     *          this.substring(toffset).startsWith(prefix)\n     *          \u003c/pre\u003e\n     */\n    public boolean startsWith(String prefix, int toffset) {\n        // Note: toffset might be near -1\u003e\u003e\u003e1.\n        if (toffset \u003c 0 || toffset \u003e length() - prefix.length()) {\n            return false;\n        }\n        byte ta[] \u003d value;\n        byte pa[] \u003d prefix.value;\n        int po \u003d 0;\n        int pc \u003d pa.length;\n        byte coder \u003d coder();\n        if (coder \u003d\u003d prefix.coder()) {\n            int to \u003d (coder \u003d\u003d LATIN1) ? toffset : toffset \u003c\u003c 1;\n            while (po \u003c pc) {\n                if (ta[to++] !\u003d pa[po++]) {\n                    return false;\n                }\n            }\n        } else {\n            if (coder \u003d\u003d LATIN1) {  // \u0026\u0026 pcoder \u003d\u003d UTF16\n                return false;\n            }\n            // coder \u003d\u003d UTF16 \u0026\u0026 pcoder \u003d\u003d LATIN1)\n            while (po \u003c pc) {\n                if (StringUTF16.getChar(ta, toffset++) !\u003d (pa[po++] \u0026 0xff)) {\n                    return false;\n               }\n            }\n        }\n        return true;\n    }\n\n    /**\n     * Tests if this string starts with the specified prefix.\n     *\n     * @param   prefix   the prefix.\n     * @return  {@code true} if the character sequence represented by the\n     *          argument is a prefix of the character sequence represented by\n     *          this string; {@code false} otherwise.\n     *          Note also that {@code true} will be returned if the\n     *          argument is an empty string or is equal to this\n     *          {@code String} object as determined by the\n     *          {@link #equals(Object)} method.\n     * @since   1.0\n     */\n    public boolean startsWith(String prefix) {\n        return startsWith(prefix, 0);\n    }\n\n    /**\n     * Tests if this string ends with the specified suffix.\n     *\n     * @param   suffix   the suffix.\n     * @return  {@code true} if the character sequence represented by the\n     *          argument is a suffix of the character sequence represented by\n     *          this object; {@code false} otherwise. Note that the\n     *          result will be {@code true} if the argument is the\n     *          empty string or is equal to this {@code String} object\n     *          as determined by the {@link #equals(Object)} method.\n     */\n    public boolean endsWith(String suffix) {\n        return startsWith(suffix, length() - suffix.length());\n    }\n\n    /**\n     * Returns a hash code for this string. The hash code for a\n     * {@code String} object is computed as\n     * \u003cblockquote\u003e\u003cpre\u003e\n     * s[0]*31^(n-1) + s[1]*31^(n-2) + ... + s[n-1]\n     * \u003c/pre\u003e\u003c/blockquote\u003e\n     * using {@code int} arithmetic, where {@code s[i]} is the\n     * \u003ci\u003ei\u003c/i\u003eth character of the string, {@code n} is the length of\n     * the string, and {@code ^} indicates exponentiation.\n     * (The hash value of the empty string is zero.)\n     *\n     * @return  a hash code value for this object.\n     */\n    public int hashCode() {\n        // The hash or hashIsZero fields are subject to a benign data race,\n        // making it crucial to ensure that any observable result of the\n        // calculation in this method stays correct under any possible read of\n        // these fields. Necessary restrictions to allow this to be correct\n        // without explicit memory fences or similar concurrency primitives is\n        // that we can ever only write to one of these two fields for a given\n        // String instance, and that the computation is idempotent and derived\n        // from immutable state\n        int h \u003d hash;\n        if (h \u003d\u003d 0 \u0026\u0026 !hashIsZero) {\n            h \u003d isLatin1() ? StringLatin1.hashCode(value)\n                           : StringUTF16.hashCode(value);\n            if (h \u003d\u003d 0) {\n                hashIsZero \u003d true;\n            } else {\n                hash \u003d h;\n            }\n        }\n        return h;\n    }\n\n    /**\n     * Returns the index within this string of the first occurrence of\n     * the specified character. If a character with value\n     * {@code ch} occurs in the character sequence represented by\n     * this {@code String} object, then the index (in Unicode\n     * code units) of the first such occurrence is returned. For\n     * values of {@code ch} in the range from 0 to 0xFFFF\n     * (inclusive), this is the smallest value \u003ci\u003ek\u003c/i\u003e such that:\n     * \u003cblockquote\u003e\u003cpre\u003e\n     * this.charAt(\u003ci\u003ek\u003c/i\u003e) \u003d\u003d ch\n     * \u003c/pre\u003e\u003c/blockquote\u003e\n     * is true. For other values of {@code ch}, it is the\n     * smallest value \u003ci\u003ek\u003c/i\u003e such that:\n     * \u003cblockquote\u003e\u003cpre\u003e\n     * this.codePointAt(\u003ci\u003ek\u003c/i\u003e) \u003d\u003d ch\n     * \u003c/pre\u003e\u003c/blockquote\u003e\n     * is true. In either case, if no such character occurs in this\n     * string, then {@code -1} is returned.\n     *\n     * @param   ch   a character (Unicode code point).\n     * @return  the index of the first occurrence of the character in the\n     *          character sequence represented by this object, or\n     *          {@code -1} if the character does not occur.\n     */\n    public int indexOf(int ch) {\n        return indexOf(ch, 0);\n    }\n\n    /**\n     * Returns the index within this string of the first occurrence of the\n     * specified character, starting the search at the specified index.\n     * \u003cp\u003e\n     * If a character with value {@code ch} occurs in the\n     * character sequence represented by this {@code String}\n     * object at an index no smaller than {@code fromIndex}, then\n     * the index of the first such occurrence is returned. For values\n     * of {@code ch} in the range from 0 to 0xFFFF (inclusive),\n     * this is the smallest value \u003ci\u003ek\u003c/i\u003e such that:\n     * \u003cblockquote\u003e\u003cpre\u003e\n     * (this.charAt(\u003ci\u003ek\u003c/i\u003e) \u003d\u003d ch) {@code \u0026\u0026} (\u003ci\u003ek\u003c/i\u003e \u0026gt;\u003d fromIndex)\n     * \u003c/pre\u003e\u003c/blockquote\u003e\n     * is true. For other values of {@code ch}, it is the\n     * smallest value \u003ci\u003ek\u003c/i\u003e such that:\n     * \u003cblockquote\u003e\u003cpre\u003e\n     * (this.codePointAt(\u003ci\u003ek\u003c/i\u003e) \u003d\u003d ch) {@code \u0026\u0026} (\u003ci\u003ek\u003c/i\u003e \u0026gt;\u003d fromIndex)\n     * \u003c/pre\u003e\u003c/blockquote\u003e\n     * is true. In either case, if no such character occurs in this\n     * string at or after position {@code fromIndex}, then\n     * {@code -1} is returned.\n     *\n     * \u003cp\u003e\n     * There is no restriction on the value of {@code fromIndex}. If it\n     * is negative, it has the same effect as if it were zero: this entire\n     * string may be searched. If it is greater than the length of this\n     * string, it has the same effect as if it were equal to the length of\n     * this string: {@code -1} is returned.\n     *\n     * \u003cp\u003eAll indices are specified in {@code char} values\n     * (Unicode code units).\n     *\n     * @param   ch          a character (Unicode code point).\n     * @param   fromIndex   the index to start the search from.\n     * @return  the index of the first occurrence of the character in the\n     *          character sequence represented by this object that is greater\n     *          than or equal to {@code fromIndex}, or {@code -1}\n     *          if the character does not occur.\n     */\n    public int indexOf(int ch, int fromIndex) {\n        return isLatin1() ? StringLatin1.indexOf(value, ch, fromIndex)\n                          : StringUTF16.indexOf(value, ch, fromIndex);\n    }\n\n    /**\n     * Returns the index within this string of the last occurrence of\n     * the specified character. For values of {@code ch} in the\n     * range from 0 to 0xFFFF (inclusive), the index (in Unicode code\n     * units) returned is the largest value \u003ci\u003ek\u003c/i\u003e such that:\n     * \u003cblockquote\u003e\u003cpre\u003e\n     * this.charAt(\u003ci\u003ek\u003c/i\u003e) \u003d\u003d ch\n     * \u003c/pre\u003e\u003c/blockquote\u003e\n     * is true. For other values of {@code ch}, it is the\n     * largest value \u003ci\u003ek\u003c/i\u003e such that:\n     * \u003cblockquote\u003e\u003cpre\u003e\n     * this.codePointAt(\u003ci\u003ek\u003c/i\u003e) \u003d\u003d ch\n     * \u003c/pre\u003e\u003c/blockquote\u003e\n     * is true.  In either case, if no such character occurs in this\n     * string, then {@code -1} is returned.  The\n     * {@code String} is searched backwards starting at the last\n     * character.\n     *\n     * @param   ch   a character (Unicode code point).\n     * @return  the index of the last occurrence of the character in the\n     *          character sequence represented by this object, or\n     *          {@code -1} if the character does not occur.\n     */\n    public int lastIndexOf(int ch) {\n        return lastIndexOf(ch, length() - 1);\n    }\n\n    /**\n     * Returns the index within this string of the last occurrence of\n     * the specified character, searching backward starting at the\n     * specified index. For values of {@code ch} in the range\n     * from 0 to 0xFFFF (inclusive), the index returned is the largest\n     * value \u003ci\u003ek\u003c/i\u003e such that:\n     * \u003cblockquote\u003e\u003cpre\u003e\n     * (this.charAt(\u003ci\u003ek\u003c/i\u003e) \u003d\u003d ch) {@code \u0026\u0026} (\u003ci\u003ek\u003c/i\u003e \u0026lt;\u003d fromIndex)\n     * \u003c/pre\u003e\u003c/blockquote\u003e\n     * is true. For other values of {@code ch}, it is the\n     * largest value \u003ci\u003ek\u003c/i\u003e such that:\n     * \u003cblockquote\u003e\u003cpre\u003e\n     * (this.codePointAt(\u003ci\u003ek\u003c/i\u003e) \u003d\u003d ch) {@code \u0026\u0026} (\u003ci\u003ek\u003c/i\u003e \u0026lt;\u003d fromIndex)\n     * \u003c/pre\u003e\u003c/blockquote\u003e\n     * is true. In either case, if no such character occurs in this\n     * string at or before position {@code fromIndex}, then\n     * {@code -1} is returned.\n     *\n     * \u003cp\u003eAll indices are specified in {@code char} values\n     * (Unicode code units).\n     *\n     * @param   ch          a character (Unicode code point).\n     * @param   fromIndex   the index to start the search from. There is no\n     *          restriction on the value of {@code fromIndex}. If it is\n     *          greater than or equal to the length of this string, it has\n     *          the same effect as if it were equal to one less than the\n     *          length of this string: this entire string may be searched.\n     *          If it is negative, it has the same effect as if it were -1:\n     *          -1 is returned.\n     * @return  the index of the last occurrence of the character in the\n     *          character sequence represented by this object that is less\n     *          than or equal to {@code fromIndex}, or {@code -1}\n     *          if the character does not occur before that point.\n     */\n    public int lastIndexOf(int ch, int fromIndex) {\n        return isLatin1() ? StringLatin1.lastIndexOf(value, ch, fromIndex)\n                          : StringUTF16.lastIndexOf(value, ch, fromIndex);\n    }\n\n    /**\n     * Returns the index within this string of the first occurrence of the\n     * specified substring.\n     *\n     * \u003cp\u003eThe returned index is the smallest value {@code k} for which:\n     * \u003cpre\u003e{@code\n     * this.startsWith(str, k)\n     * }\u003c/pre\u003e\n     * If no such value of {@code k} exists, then {@code -1} is returned.\n     *\n     * @param   str   the substring to search for.\n     * @return  the index of the first occurrence of the specified substring,\n     *          or {@code -1} if there is no such occurrence.\n     */\n    public int indexOf(String str) {\n        byte coder \u003d coder();\n        if (coder \u003d\u003d str.coder()) {\n            return isLatin1() ? StringLatin1.indexOf(value, str.value)\n                              : StringUTF16.indexOf(value, str.value);\n        }\n        if (coder \u003d\u003d LATIN1) {  // str.coder \u003d\u003d UTF16\n            return -1;\n        }\n        return StringUTF16.indexOfLatin1(value, str.value);\n    }\n\n    /**\n     * Returns the index within this string of the first occurrence of the\n     * specified substring, starting at the specified index.\n     *\n     * \u003cp\u003eThe returned index is the smallest value {@code k} for which:\n     * \u003cpre\u003e{@code\n     *     k \u003e\u003d Math.min(fromIndex, this.length()) \u0026\u0026\n     *                   this.startsWith(str, k)\n     * }\u003c/pre\u003e\n     * If no such value of {@code k} exists, then {@code -1} is returned.\n     *\n     * @param   str         the substring to search for.\n     * @param   fromIndex   the index from which to start the search.\n     * @return  the index of the first occurrence of the specified substring,\n     *          starting at the specified index,\n     *          or {@code -1} if there is no such occurrence.\n     */\n    public int indexOf(String str, int fromIndex) {\n        return indexOf(value, coder(), length(), str, fromIndex);\n    }\n\n    /**\n     * Code shared by String and AbstractStringBuilder to do searches. The\n     * source is the character array being searched, and the target\n     * is the string being searched for.\n     *\n     * @param   src       the characters being searched.\n     * @param   srcCoder  the coder of the source string.\n     * @param   srcCount  length of the source string.\n     * @param   tgtStr    the characters being searched for.\n     * @param   fromIndex the index to begin searching from.\n     */\n    static int indexOf(byte[] src, byte srcCoder, int srcCount,\n                       String tgtStr, int fromIndex) {\n        byte[] tgt    \u003d tgtStr.value;\n        byte tgtCoder \u003d tgtStr.coder();\n        int tgtCount  \u003d tgtStr.length();\n\n        if (fromIndex \u003e\u003d srcCount) {\n            return (tgtCount \u003d\u003d 0 ? srcCount : -1);\n        }\n        if (fromIndex \u003c 0) {\n            fromIndex \u003d 0;\n        }\n        if (tgtCount \u003d\u003d 0) {\n            return fromIndex;\n        }\n        if (tgtCount \u003e srcCount) {\n            return -1;\n        }\n        if (srcCoder \u003d\u003d tgtCoder) {\n            return srcCoder \u003d\u003d LATIN1\n                ? StringLatin1.indexOf(src, srcCount, tgt, tgtCount, fromIndex)\n                : StringUTF16.indexOf(src, srcCount, tgt, tgtCount, fromIndex);\n        }\n        if (srcCoder \u003d\u003d LATIN1) {    //  \u0026\u0026 tgtCoder \u003d\u003d UTF16\n            return -1;\n        }\n        // srcCoder \u003d\u003d UTF16 \u0026\u0026 tgtCoder \u003d\u003d LATIN1) {\n        return StringUTF16.indexOfLatin1(src, srcCount, tgt, tgtCount, fromIndex);\n    }\n\n    /**\n     * Returns the index within this string of the last occurrence of the\n     * specified substring.  The last occurrence of the empty string \"\"\n     * is considered to occur at the index value {@code this.length()}.\n     *\n     * \u003cp\u003eThe returned index is the largest value {@code k} for which:\n     * \u003cpre\u003e{@code\n     * this.startsWith(str, k)\n     * }\u003c/pre\u003e\n     * If no such value of {@code k} exists, then {@code -1} is returned.\n     *\n     * @param   str   the substring to search for.\n     * @return  the index of the last occurrence of the specified substring,\n     *          or {@code -1} if there is no such occurrence.\n     */\n    public int lastIndexOf(String str) {\n        return lastIndexOf(str, length());\n    }\n\n    /**\n     * Returns the index within this string of the last occurrence of the\n     * specified substring, searching backward starting at the specified index.\n     *\n     * \u003cp\u003eThe returned index is the largest value {@code k} for which:\n     * \u003cpre\u003e{@code\n     *     k \u003c\u003d Math.min(fromIndex, this.length()) \u0026\u0026\n     *                   this.startsWith(str, k)\n     * }\u003c/pre\u003e\n     * If no such value of {@code k} exists, then {@code -1} is returned.\n     *\n     * @param   str         the substring to search for.\n     * @param   fromIndex   the index to start the search from.\n     * @return  the index of the last occurrence of the specified substring,\n     *          searching backward from the specified index,\n     *          or {@code -1} if there is no such occurrence.\n     */\n    public int lastIndexOf(String str, int fromIndex) {\n        return lastIndexOf(value, coder(), length(), str, fromIndex);\n    }\n\n    /**\n     * Code shared by String and AbstractStringBuilder to do searches. The\n     * source is the character array being searched, and the target\n     * is the string being searched for.\n     *\n     * @param   src         the characters being searched.\n     * @param   srcCoder    coder handles the mapping between bytes/chars\n     * @param   srcCount    count of the source string.\n     * @param   tgtStr      the characters being searched for.\n     * @param   fromIndex   the index to begin searching from.\n     */\n    static int lastIndexOf(byte[] src, byte srcCoder, int srcCount,\n                           String tgtStr, int fromIndex) {\n        byte[] tgt \u003d tgtStr.value;\n        byte tgtCoder \u003d tgtStr.coder();\n        int tgtCount \u003d tgtStr.length();\n        /*\n         * Check arguments; return immediately where possible. For\n         * consistency, don\u0027t check for null str.\n         */\n        int rightIndex \u003d srcCount - tgtCount;\n        if (fromIndex \u003e rightIndex) {\n            fromIndex \u003d rightIndex;\n        }\n        if (fromIndex \u003c 0) {\n            return -1;\n        }\n        /* Empty string always matches. */\n        if (tgtCount \u003d\u003d 0) {\n            return fromIndex;\n        }\n        if (srcCoder \u003d\u003d tgtCoder) {\n            return srcCoder \u003d\u003d LATIN1\n                ? StringLatin1.lastIndexOf(src, srcCount, tgt, tgtCount, fromIndex)\n                : StringUTF16.lastIndexOf(src, srcCount, tgt, tgtCount, fromIndex);\n        }\n        if (srcCoder \u003d\u003d LATIN1) {    // \u0026\u0026 tgtCoder \u003d\u003d UTF16\n            return -1;\n        }\n        // srcCoder \u003d\u003d UTF16 \u0026\u0026 tgtCoder \u003d\u003d LATIN1\n        return StringUTF16.lastIndexOfLatin1(src, srcCount, tgt, tgtCount, fromIndex);\n    }\n\n    /**\n     * Returns a string that is a substring of this string. The\n     * substring begins with the character at the specified index and\n     * extends to the end of this string. \u003cp\u003e\n     * Examples:\n     * \u003cblockquote\u003e\u003cpre\u003e\n     * \"unhappy\".substring(2) returns \"happy\"\n     * \"Harbison\".substring(3) returns \"bison\"\n     * \"emptiness\".substring(9) returns \"\" (an empty string)\n     * \u003c/pre\u003e\u003c/blockquote\u003e\n     *\n     * @param      beginIndex   the beginning index, inclusive.\n     * @return     the specified substring.\n     * @throws     IndexOutOfBoundsException  if\n     *             {@code beginIndex} is negative or larger than the\n     *             length of this {@code String} object.\n     */\n    public String substring(int beginIndex) {\n        return substring(beginIndex, length());\n    }\n\n    /**\n     * Returns a string that is a substring of this string. The\n     * substring begins at the specified {@code beginIndex} and\n     * extends to the character at index {@code endIndex - 1}.\n     * Thus the length of the substring is {@code endIndex-beginIndex}.\n     * \u003cp\u003e\n     * Examples:\n     * \u003cblockquote\u003e\u003cpre\u003e\n     * \"hamburger\".substring(4, 8) returns \"urge\"\n     * \"smiles\".substring(1, 5) returns \"mile\"\n     * \u003c/pre\u003e\u003c/blockquote\u003e\n     *\n     * @param      beginIndex   the beginning index, inclusive.\n     * @param      endIndex     the ending index, exclusive.\n     * @return     the specified substring.\n     * @throws     IndexOutOfBoundsException  if the\n     *             {@code beginIndex} is negative, or\n     *             {@code endIndex} is larger than the length of\n     *             this {@code String} object, or\n     *             {@code beginIndex} is larger than\n     *             {@code endIndex}.\n     */\n    public String substring(int beginIndex, int endIndex) {\n        int length \u003d length();\n        checkBoundsBeginEnd(beginIndex, endIndex, length);\n        if (beginIndex \u003d\u003d 0 \u0026\u0026 endIndex \u003d\u003d length) {\n            return this;\n        }\n        int subLen \u003d endIndex - beginIndex;\n        return isLatin1() ? StringLatin1.newString(value, beginIndex, subLen)\n                          : StringUTF16.newString(value, beginIndex, subLen);\n    }\n\n    /**\n     * Returns a character sequence that is a subsequence of this sequence.\n     *\n     * \u003cp\u003e An invocation of this method of the form\n     *\n     * \u003cblockquote\u003e\u003cpre\u003e\n     * str.subSequence(begin,\u0026nbsp;end)\u003c/pre\u003e\u003c/blockquote\u003e\n     *\n     * behaves in exactly the same way as the invocation\n     *\n     * \u003cblockquote\u003e\u003cpre\u003e\n     * str.substring(begin,\u0026nbsp;end)\u003c/pre\u003e\u003c/blockquote\u003e\n     *\n     * @apiNote\n     * This method is defined so that the {@code String} class can implement\n     * the {@link CharSequence} interface.\n     *\n     * @param   beginIndex   the begin index, inclusive.\n     * @param   endIndex     the end index, exclusive.\n     * @return  the specified subsequence.\n     *\n     * @throws  IndexOutOfBoundsException\n     *          if {@code beginIndex} or {@code endIndex} is negative,\n     *          if {@code endIndex} is greater than {@code length()},\n     *          or if {@code beginIndex} is greater than {@code endIndex}\n     *\n     * @since 1.4\n     */\n    public CharSequence subSequence(int beginIndex, int endIndex) {\n        return this.substring(beginIndex, endIndex);\n    }\n\n    /**\n     * Concatenates the specified string to the end of this string.\n     * \u003cp\u003e\n     * If the length of the argument string is {@code 0}, then this\n     * {@code String} object is returned. Otherwise, a\n     * {@code String} object is returned that represents a character\n     * sequence that is the concatenation of the character sequence\n     * represented by this {@code String} object and the character\n     * sequence represented by the argument string.\u003cp\u003e\n     * Examples:\n     * \u003cblockquote\u003e\u003cpre\u003e\n     * \"cares\".concat(\"s\") returns \"caress\"\n     * \"to\".concat(\"get\").concat(\"her\") returns \"together\"\n     * \u003c/pre\u003e\u003c/blockquote\u003e\n     *\n     * @param   str   the {@code String} that is concatenated to the end\n     *                of this {@code String}.\n     * @return  a string that represents the concatenation of this object\u0027s\n     *          characters followed by the string argument\u0027s characters.\n     */\n    public String concat(String str) {\n        if (str.isEmpty()) {\n            return this;\n        }\n        return StringConcatHelper.simpleConcat(this, str);\n    }\n\n    /**\n     * Returns a string resulting from replacing all occurrences of\n     * {@code oldChar} in this string with {@code newChar}.\n     * \u003cp\u003e\n     * If the character {@code oldChar} does not occur in the\n     * character sequence represented by this {@code String} object,\n     * then a reference to this {@code String} object is returned.\n     * Otherwise, a {@code String} object is returned that\n     * represents a character sequence identical to the character sequence\n     * represented by this {@code String} object, except that every\n     * occurrence of {@code oldChar} is replaced by an occurrence\n     * of {@code newChar}.\n     * \u003cp\u003e\n     * Examples:\n     * \u003cblockquote\u003e\u003cpre\u003e\n     * \"mesquite in your cellar\".replace(\u0027e\u0027, \u0027o\u0027)\n     *         returns \"mosquito in your collar\"\n     * \"the war of baronets\".replace(\u0027r\u0027, \u0027y\u0027)\n     *         returns \"the way of bayonets\"\n     * \"sparring with a purple porpoise\".replace(\u0027p\u0027, \u0027t\u0027)\n     *         returns \"starring with a turtle tortoise\"\n     * \"JonL\".replace(\u0027q\u0027, \u0027x\u0027) returns \"JonL\" (no change)\n     * \u003c/pre\u003e\u003c/blockquote\u003e\n     *\n     * @param   oldChar   the old character.\n     * @param   newChar   the new character.\n     * @return  a string derived from this string by replacing every\n     *          occurrence of {@code oldChar} with {@code newChar}.\n     */\n    public String replace(char oldChar, char newChar) {\n        if (oldChar !\u003d newChar) {\n            String ret \u003d isLatin1() ? StringLatin1.replace(value, oldChar, newChar)\n                                    : StringUTF16.replace(value, oldChar, newChar);\n            if (ret !\u003d null) {\n                return ret;\n            }\n        }\n        return this;\n    }\n\n    /**\n     * Tells whether or not this string matches the given \u003ca\n     * href\u003d\"../util/regex/Pattern.html#sum\"\u003eregular expression\u003c/a\u003e.\n     *\n     * \u003cp\u003e An invocation of this method of the form\n     * \u003ci\u003estr\u003c/i\u003e{@code .matches(}\u003ci\u003eregex\u003c/i\u003e{@code )} yields exactly the\n     * same result as the expression\n     *\n     * \u003cblockquote\u003e\n     * {@link java.util.regex.Pattern}.{@link java.util.regex.Pattern#matches(String,CharSequence)\n     * matches(\u003ci\u003eregex\u003c/i\u003e, \u003ci\u003estr\u003c/i\u003e)}\n     * \u003c/blockquote\u003e\n     *\n     * @param   regex\n     *          the regular expression to which this string is to be matched\n     *\n     * @return  {@code true} if, and only if, this string matches the\n     *          given regular expression\n     *\n     * @throws  PatternSyntaxException\n     *          if the regular expression\u0027s syntax is invalid\n     *\n     * @see java.util.regex.Pattern\n     *\n     * @since 1.4\n     */\n    public boolean matches(String regex) {\n        return Pattern.matches(regex, this);\n    }\n\n    /**\n     * Returns true if and only if this string contains the specified\n     * sequence of char values.\n     *\n     * @param s the sequence to search for\n     * @return true if this string contains {@code s}, false otherwise\n     * @since 1.5\n     */\n    public boolean contains(CharSequence s) {\n        return indexOf(s.toString()) \u003e\u003d 0;\n    }\n\n    /**\n     * Replaces the first substring of this string that matches the given \u003ca\n     * href\u003d\"../util/regex/Pattern.html#sum\"\u003eregular expression\u003c/a\u003e with the\n     * given replacement.\n     *\n     * \u003cp\u003e An invocation of this method of the form\n     * \u003ci\u003estr\u003c/i\u003e{@code .replaceFirst(}\u003ci\u003eregex\u003c/i\u003e{@code ,} \u003ci\u003erepl\u003c/i\u003e{@code )}\n     * yields exactly the same result as the expression\n     *\n     * \u003cblockquote\u003e\n     * \u003ccode\u003e\n     * {@link java.util.regex.Pattern}.{@link\n     * java.util.regex.Pattern#compile(String) compile}(\u003ci\u003eregex\u003c/i\u003e).{@link\n     * java.util.regex.Pattern#matcher(java.lang.CharSequence) matcher}(\u003ci\u003estr\u003c/i\u003e).{@link\n     * java.util.regex.Matcher#replaceFirst(String) replaceFirst}(\u003ci\u003erepl\u003c/i\u003e)\n     * \u003c/code\u003e\n     * \u003c/blockquote\u003e\n     *\n     *\u003cp\u003e\n     * Note that backslashes ({@code \\}) and dollar signs ({@code $}) in the\n     * replacement string may cause the results to be different than if it were\n     * being treated as a literal replacement string; see\n     * {@link java.util.regex.Matcher#replaceFirst}.\n     * Use {@link java.util.regex.Matcher#quoteReplacement} to suppress the special\n     * meaning of these characters, if desired.\n     *\n     * @param   regex\n     *          the regular expression to which this string is to be matched\n     * @param   replacement\n     *          the string to be substituted for the first match\n     *\n     * @return  The resulting {@code String}\n     *\n     * @throws  PatternSyntaxException\n     *          if the regular expression\u0027s syntax is invalid\n     *\n     * @see java.util.regex.Pattern\n     *\n     * @since 1.4\n     */\n    public String replaceFirst(String regex, String replacement) {\n        return Pattern.compile(regex).matcher(this).replaceFirst(replacement);\n    }\n\n    /**\n     * Replaces each substring of this string that matches the given \u003ca\n     * href\u003d\"../util/regex/Pattern.html#sum\"\u003eregular expression\u003c/a\u003e with the\n     * given replacement.\n     *\n     * \u003cp\u003e An invocation of this method of the form\n     * \u003ci\u003estr\u003c/i\u003e{@code .replaceAll(}\u003ci\u003eregex\u003c/i\u003e{@code ,} \u003ci\u003erepl\u003c/i\u003e{@code )}\n     * yields exactly the same result as the expression\n     *\n     * \u003cblockquote\u003e\n     * \u003ccode\u003e\n     * {@link java.util.regex.Pattern}.{@link\n     * java.util.regex.Pattern#compile(String) compile}(\u003ci\u003eregex\u003c/i\u003e).{@link\n     * java.util.regex.Pattern#matcher(java.lang.CharSequence) matcher}(\u003ci\u003estr\u003c/i\u003e).{@link\n     * java.util.regex.Matcher#replaceAll(String) replaceAll}(\u003ci\u003erepl\u003c/i\u003e)\n     * \u003c/code\u003e\n     * \u003c/blockquote\u003e\n     *\n     *\u003cp\u003e\n     * Note that backslashes ({@code \\}) and dollar signs ({@code $}) in the\n     * replacement string may cause the results to be different than if it were\n     * being treated as a literal replacement string; see\n     * {@link java.util.regex.Matcher#replaceAll Matcher.replaceAll}.\n     * Use {@link java.util.regex.Matcher#quoteReplacement} to suppress the special\n     * meaning of these characters, if desired.\n     *\n     * @param   regex\n     *          the regular expression to which this string is to be matched\n     * @param   replacement\n     *          the string to be substituted for each match\n     *\n     * @return  The resulting {@code String}\n     *\n     * @throws  PatternSyntaxException\n     *          if the regular expression\u0027s syntax is invalid\n     *\n     * @see java.util.regex.Pattern\n     *\n     * @since 1.4\n     */\n    public String replaceAll(String regex, String replacement) {\n        return Pattern.compile(regex).matcher(this).replaceAll(replacement);\n    }\n\n    /**\n     * Replaces each substring of this string that matches the literal target\n     * sequence with the specified literal replacement sequence. The\n     * replacement proceeds from the beginning of the string to the end, for\n     * example, replacing \"aa\" with \"b\" in the string \"aaa\" will result in\n     * \"ba\" rather than \"ab\".\n     *\n     * @param  target The sequence of char values to be replaced\n     * @param  replacement The replacement sequence of char values\n     * @return  The resulting string\n     * @since 1.5\n     */\n    public String replace(CharSequence target, CharSequence replacement) {\n        String trgtStr \u003d target.toString();\n        String replStr \u003d replacement.toString();\n        int thisLen \u003d length();\n        int trgtLen \u003d trgtStr.length();\n        int replLen \u003d replStr.length();\n\n        if (trgtLen \u003e 0) {\n            if (trgtLen \u003d\u003d 1 \u0026\u0026 replLen \u003d\u003d 1) {\n                return replace(trgtStr.charAt(0), replStr.charAt(0));\n            }\n\n            boolean thisIsLatin1 \u003d this.isLatin1();\n            boolean trgtIsLatin1 \u003d trgtStr.isLatin1();\n            boolean replIsLatin1 \u003d replStr.isLatin1();\n            String ret \u003d (thisIsLatin1 \u0026\u0026 trgtIsLatin1 \u0026\u0026 replIsLatin1)\n                    ? StringLatin1.replace(value, thisLen,\n                                           trgtStr.value, trgtLen,\n                                           replStr.value, replLen)\n                    : StringUTF16.replace(value, thisLen, thisIsLatin1,\n                                          trgtStr.value, trgtLen, trgtIsLatin1,\n                                          replStr.value, replLen, replIsLatin1);\n            if (ret !\u003d null) {\n                return ret;\n            }\n            return this;\n\n        } else { // trgtLen \u003d\u003d 0\n            int resultLen;\n            try {\n                resultLen \u003d Math.addExact(thisLen, Math.multiplyExact(\n                        Math.addExact(thisLen, 1), replLen));\n            } catch (ArithmeticException ignored) {\n                throw new OutOfMemoryError(\"Required length exceeds implementation limit\");\n            }\n\n            StringBuilder sb \u003d new StringBuilder(resultLen);\n            sb.append(replStr);\n            for (int i \u003d 0; i \u003c thisLen; ++i) {\n                sb.append(charAt(i)).append(replStr);\n            }\n            return sb.toString();\n        }\n    }\n\n    /**\n     * Splits this string around matches of the given\n     * \u003ca href\u003d\"../util/regex/Pattern.html#sum\"\u003eregular expression\u003c/a\u003e.\n     *\n     * \u003cp\u003e The array returned by this method contains each substring of this\n     * string that is terminated by another substring that matches the given\n     * expression or is terminated by the end of the string.  The substrings in\n     * the array are in the order in which they occur in this string.  If the\n     * expression does not match any part of the input then the resulting array\n     * has just one element, namely this string.\n     *\n     * \u003cp\u003e When there is a positive-width match at the beginning of this\n     * string then an empty leading substring is included at the beginning\n     * of the resulting array. A zero-width match at the beginning however\n     * never produces such empty leading substring.\n     *\n     * \u003cp\u003e The {@code limit} parameter controls the number of times the\n     * pattern is applied and therefore affects the length of the resulting\n     * array.\n     * \u003cul\u003e\n     *    \u003cli\u003e\u003cp\u003e\n     *    If the \u003ci\u003elimit\u003c/i\u003e is positive then the pattern will be applied\n     *    at most \u003ci\u003elimit\u003c/i\u003e\u0026nbsp;-\u0026nbsp;1 times, the array\u0027s length will be\n     *    no greater than \u003ci\u003elimit\u003c/i\u003e, and the array\u0027s last entry will contain\n     *    all input beyond the last matched delimiter.\u003c/p\u003e\u003c/li\u003e\n     *\n     *    \u003cli\u003e\u003cp\u003e\n     *    If the \u003ci\u003elimit\u003c/i\u003e is zero then the pattern will be applied as\n     *    many times as possible, the array can have any length, and trailing\n     *    empty strings will be discarded.\u003c/p\u003e\u003c/li\u003e\n     *\n     *    \u003cli\u003e\u003cp\u003e\n     *    If the \u003ci\u003elimit\u003c/i\u003e is negative then the pattern will be applied\n     *    as many times as possible and the array can have any length.\u003c/p\u003e\u003c/li\u003e\n     * \u003c/ul\u003e\n     *\n     * \u003cp\u003e The string {@code \"boo:and:foo\"}, for example, yields the\n     * following results with these parameters:\n     *\n     * \u003cblockquote\u003e\u003ctable class\u003d\"plain\"\u003e\n     * \u003ccaption style\u003d\"display:none\"\u003eSplit example showing regex, limit, and result\u003c/caption\u003e\n     * \u003cthead\u003e\n     * \u003ctr\u003e\n     *     \u003cth scope\u003d\"col\"\u003eRegex\u003c/th\u003e\n     *     \u003cth scope\u003d\"col\"\u003eLimit\u003c/th\u003e\n     *     \u003cth scope\u003d\"col\"\u003eResult\u003c/th\u003e\n     * \u003c/tr\u003e\n     * \u003c/thead\u003e\n     * \u003ctbody\u003e\n     * \u003ctr\u003e\u003cth scope\u003d\"row\" rowspan\u003d\"3\" style\u003d\"font-weight:normal\"\u003e:\u003c/th\u003e\n     *     \u003cth scope\u003d\"row\" style\u003d\"font-weight:normal; text-align:right; padding-right:1em\"\u003e2\u003c/th\u003e\n     *     \u003ctd\u003e{@code { \"boo\", \"and:foo\" }}\u003c/td\u003e\u003c/tr\u003e\n     * \u003ctr\u003e\u003c!-- : --\u003e\n     *     \u003cth scope\u003d\"row\" style\u003d\"font-weight:normal; text-align:right; padding-right:1em\"\u003e5\u003c/th\u003e\n     *     \u003ctd\u003e{@code { \"boo\", \"and\", \"foo\" }}\u003c/td\u003e\u003c/tr\u003e\n     * \u003ctr\u003e\u003c!-- : --\u003e\n     *     \u003cth scope\u003d\"row\" style\u003d\"font-weight:normal; text-align:right; padding-right:1em\"\u003e-2\u003c/th\u003e\n     *     \u003ctd\u003e{@code { \"boo\", \"and\", \"foo\" }}\u003c/td\u003e\u003c/tr\u003e\n     * \u003ctr\u003e\u003cth scope\u003d\"row\" rowspan\u003d\"3\" style\u003d\"font-weight:normal\"\u003eo\u003c/th\u003e\n     *     \u003cth scope\u003d\"row\" style\u003d\"font-weight:normal; text-align:right; padding-right:1em\"\u003e5\u003c/th\u003e\n     *     \u003ctd\u003e{@code { \"b\", \"\", \":and:f\", \"\", \"\" }}\u003c/td\u003e\u003c/tr\u003e\n     * \u003ctr\u003e\u003c!-- o --\u003e\n     *     \u003cth scope\u003d\"row\" style\u003d\"font-weight:normal; text-align:right; padding-right:1em\"\u003e-2\u003c/th\u003e\n     *     \u003ctd\u003e{@code { \"b\", \"\", \":and:f\", \"\", \"\" }}\u003c/td\u003e\u003c/tr\u003e\n     * \u003ctr\u003e\u003c!-- o --\u003e\n     *     \u003cth scope\u003d\"row\" style\u003d\"font-weight:normal; text-align:right; padding-right:1em\"\u003e0\u003c/th\u003e\n     *     \u003ctd\u003e{@code { \"b\", \"\", \":and:f\" }}\u003c/td\u003e\u003c/tr\u003e\n     * \u003c/tbody\u003e\n     * \u003c/table\u003e\u003c/blockquote\u003e\n     *\n     * \u003cp\u003e An invocation of this method of the form\n     * \u003ci\u003estr.\u003c/i\u003e{@code split(}\u003ci\u003eregex\u003c/i\u003e{@code ,}\u0026nbsp;\u003ci\u003en\u003c/i\u003e{@code )}\n     * yields the same result as the expression\n     *\n     * \u003cblockquote\u003e\n     * \u003ccode\u003e\n     * {@link java.util.regex.Pattern}.{@link\n     * java.util.regex.Pattern#compile(String) compile}(\u003ci\u003eregex\u003c/i\u003e).{@link\n     * java.util.regex.Pattern#split(java.lang.CharSequence,int) split}(\u003ci\u003estr\u003c/i\u003e,\u0026nbsp;\u003ci\u003en\u003c/i\u003e)\n     * \u003c/code\u003e\n     * \u003c/blockquote\u003e\n     *\n     *\n     * @param  regex\n     *         the delimiting regular expression\n     *\n     * @param  limit\n     *         the result threshold, as described above\n     *\n     * @return  the array of strings computed by splitting this string\n     *          around matches of the given regular expression\n     *\n     * @throws  PatternSyntaxException\n     *          if the regular expression\u0027s syntax is invalid\n     *\n     * @see java.util.regex.Pattern\n     *\n     * @since 1.4\n     */\n    public String[] split(String regex, int limit) {\n        /* fastpath if the regex is a\n         * (1) one-char String and this character is not one of the\n         *     RegEx\u0027s meta characters \".$|()[{^?*+\\\\\", or\n         * (2) two-char String and the first char is the backslash and\n         *     the second is not the ascii digit or ascii letter.\n         */\n        char ch \u003d 0;\n        if (((regex.length() \u003d\u003d 1 \u0026\u0026\n             \".$|()[{^?*+\\\\\".indexOf(ch \u003d regex.charAt(0)) \u003d\u003d -1) ||\n             (regex.length() \u003d\u003d 2 \u0026\u0026\n              regex.charAt(0) \u003d\u003d \u0027\\\\\u0027 \u0026\u0026\n              (((ch \u003d regex.charAt(1))-\u00270\u0027)|(\u00279\u0027-ch)) \u003c 0 \u0026\u0026\n              ((ch-\u0027a\u0027)|(\u0027z\u0027-ch)) \u003c 0 \u0026\u0026\n              ((ch-\u0027A\u0027)|(\u0027Z\u0027-ch)) \u003c 0)) \u0026\u0026\n            (ch \u003c Character.MIN_HIGH_SURROGATE ||\n             ch \u003e Character.MAX_LOW_SURROGATE))\n        {\n            int off \u003d 0;\n            int next \u003d 0;\n            boolean limited \u003d limit \u003e 0;\n            ArrayList\u003cString\u003e list \u003d new ArrayList\u003c\u003e();\n            while ((next \u003d indexOf(ch, off)) !\u003d -1) {\n                if (!limited || list.size() \u003c limit - 1) {\n                    list.add(substring(off, next));\n                    off \u003d next + 1;\n                } else {    // last one\n                    //assert (list.size() \u003d\u003d limit - 1);\n                    int last \u003d length();\n                    list.add(substring(off, last));\n                    off \u003d last;\n                    break;\n                }\n            }\n            // If no match was found, return this\n            if (off \u003d\u003d 0)\n                return new String[]{this};\n\n            // Add remaining segment\n            if (!limited || list.size() \u003c limit)\n                list.add(substring(off, length()));\n\n            // Construct result\n            int resultSize \u003d list.size();\n            if (limit \u003d\u003d 0) {\n                while (resultSize \u003e 0 \u0026\u0026 list.get(resultSize - 1).isEmpty()) {\n                    resultSize--;\n                }\n            }\n            String[] result \u003d new String[resultSize];\n            return list.subList(0, resultSize).toArray(result);\n        }\n        return Pattern.compile(regex).split(this, limit);\n    }\n\n    /**\n     * Splits this string around matches of the given \u003ca\n     * href\u003d\"../util/regex/Pattern.html#sum\"\u003eregular expression\u003c/a\u003e.\n     *\n     * \u003cp\u003e This method works as if by invoking the two-argument {@link\n     * #split(String, int) split} method with the given expression and a limit\n     * argument of zero.  Trailing empty strings are therefore not included in\n     * the resulting array.\n     *\n     * \u003cp\u003e The string {@code \"boo:and:foo\"}, for example, yields the following\n     * results with these expressions:\n     *\n     * \u003cblockquote\u003e\u003ctable class\u003d\"plain\"\u003e\n     * \u003ccaption style\u003d\"display:none\"\u003eSplit examples showing regex and result\u003c/caption\u003e\n     * \u003cthead\u003e\n     * \u003ctr\u003e\n     *  \u003cth scope\u003d\"col\"\u003eRegex\u003c/th\u003e\n     *  \u003cth scope\u003d\"col\"\u003eResult\u003c/th\u003e\n     * \u003c/tr\u003e\n     * \u003c/thead\u003e\n     * \u003ctbody\u003e\n     * \u003ctr\u003e\u003cth scope\u003d\"row\" style\u003d\"text-weight:normal\"\u003e:\u003c/th\u003e\n     *     \u003ctd\u003e{@code { \"boo\", \"and\", \"foo\" }}\u003c/td\u003e\u003c/tr\u003e\n     * \u003ctr\u003e\u003cth scope\u003d\"row\" style\u003d\"text-weight:normal\"\u003eo\u003c/th\u003e\n     *     \u003ctd\u003e{@code { \"b\", \"\", \":and:f\" }}\u003c/td\u003e\u003c/tr\u003e\n     * \u003c/tbody\u003e\n     * \u003c/table\u003e\u003c/blockquote\u003e\n     *\n     *\n     * @param  regex\n     *         the delimiting regular expression\n     *\n     * @return  the array of strings computed by splitting this string\n     *          around matches of the given regular expression\n     *\n     * @throws  PatternSyntaxException\n     *          if the regular expression\u0027s syntax is invalid\n     *\n     * @see java.util.regex.Pattern\n     *\n     * @since 1.4\n     */\n    public String[] split(String regex) {\n        return split(regex, 0);\n    }\n\n    /**\n     * Returns a new String composed of copies of the\n     * {@code CharSequence elements} joined together with a copy of\n     * the specified {@code delimiter}.\n     *\n     * \u003cblockquote\u003eFor example,\n     * \u003cpre\u003e{@code\n     *     String message \u003d String.join(\"-\", \"Java\", \"is\", \"cool\");\n     *     // message returned is: \"Java-is-cool\"\n     * }\u003c/pre\u003e\u003c/blockquote\u003e\n     *\n     * Note that if an element is null, then {@code \"null\"} is added.\n     *\n     * @param  delimiter the delimiter that separates each element\n     * @param  elements the elements to join together.\n     *\n     * @return a new {@code String} that is composed of the {@code elements}\n     *         separated by the {@code delimiter}\n     *\n     * @throws NullPointerException If {@code delimiter} or {@code elements}\n     *         is {@code null}\n     *\n     * @see java.util.StringJoiner\n     * @since 1.8\n     */\n    public static String join(CharSequence delimiter, CharSequence... elements) {\n        var delim \u003d delimiter.toString();\n        var elems \u003d new String[elements.length];\n        for (int i \u003d 0; i \u003c elements.length; i++) {\n            elems[i] \u003d String.valueOf(elements[i]);\n        }\n        return join(\"\", \"\", delim, elems, elems.length);\n    }\n\n    /**\n     * Designated join routine.\n     *\n     * @param prefix the non-null prefix\n     * @param suffix the non-null suffix\n     * @param delimiter the non-null delimiter\n     * @param elements the non-null array of non-null elements\n     * @param size the number of elements in the array (\u003c\u003d elements.length)\n     * @return the joined string\n     */\n    @ForceInline\n    static String join(String prefix, String suffix, String delimiter, String[] elements, int size) {\n        int icoder \u003d prefix.coder() | suffix.coder();\n        long len \u003d (long) prefix.length() + suffix.length();\n        if (size \u003e 1) { // when there are more than one element, size - 1 delimiters will be emitted\n            len +\u003d (long) (size - 1) * delimiter.length();\n            icoder |\u003d delimiter.coder();\n        }\n        // assert len \u003e 0L; // max: (long) Integer.MAX_VALUE \u003c\u003c 32\n        // following loop wil add max: (long) Integer.MAX_VALUE * Integer.MAX_VALUE to len\n        // so len can overflow at most once\n        for (int i \u003d 0; i \u003c size; i++) {\n            var el \u003d elements[i];\n            len +\u003d el.length();\n            icoder |\u003d el.coder();\n        }\n        byte coder \u003d (byte) icoder;\n        // long len overflow check, char -\u003e byte length, int len overflow check\n        if (len \u003c 0L || (len \u003c\u003c\u003d coder) !\u003d (int) len) {\n            throw new OutOfMemoryError(\"Requested string length exceeds VM limit\");\n        }\n        byte[] value \u003d StringConcatHelper.newArray(len);\n\n        int off \u003d 0;\n        prefix.getBytes(value, off, coder); off +\u003d prefix.length();\n        if (size \u003e 0) {\n            var el \u003d elements[0];\n            el.getBytes(value, off, coder); off +\u003d el.length();\n            for (int i \u003d 1; i \u003c size; i++) {\n                delimiter.getBytes(value, off, coder); off +\u003d delimiter.length();\n                el \u003d elements[i];\n                el.getBytes(value, off, coder); off +\u003d el.length();\n            }\n        }\n        suffix.getBytes(value, off, coder);\n        // assert off + suffix.length() \u003d\u003d value.length \u003e\u003e coder;\n\n        return new String(value, coder);\n    }\n\n    /**\n     * Returns a new {@code String} composed of copies of the\n     * {@code CharSequence elements} joined together with a copy of the\n     * specified {@code delimiter}.\n     *\n     * \u003cblockquote\u003eFor example,\n     * \u003cpre\u003e{@code\n     *     List\u003cString\u003e strings \u003d List.of(\"Java\", \"is\", \"cool\");\n     *     String message \u003d String.join(\" \", strings);\n     *     // message returned is: \"Java is cool\"\n     *\n     *     Set\u003cString\u003e strings \u003d\n     *         new LinkedHashSet\u003c\u003e(List.of(\"Java\", \"is\", \"very\", \"cool\"));\n     *     String message \u003d String.join(\"-\", strings);\n     *     // message returned is: \"Java-is-very-cool\"\n     * }\u003c/pre\u003e\u003c/blockquote\u003e\n     *\n     * Note that if an individual element is {@code null}, then {@code \"null\"} is added.\n     *\n     * @param  delimiter a sequence of characters that is used to separate each\n     *         of the {@code elements} in the resulting {@code String}\n     * @param  elements an {@code Iterable} that will have its {@code elements}\n     *         joined together.\n     *\n     * @return a new {@code String} that is composed from the {@code elements}\n     *         argument\n     *\n     * @throws NullPointerException If {@code delimiter} or {@code elements}\n     *         is {@code null}\n     *\n     * @see    #join(CharSequence,CharSequence...)\n     * @see    java.util.StringJoiner\n     * @since 1.8\n     */\n    public static String join(CharSequence delimiter,\n            Iterable\u003c? extends CharSequence\u003e elements) {\n        Objects.requireNonNull(delimiter);\n        Objects.requireNonNull(elements);\n        var delim \u003d delimiter.toString();\n        var elems \u003d new String[8];\n        int size \u003d 0;\n        for (CharSequence cs: elements) {\n            if (size \u003e\u003d elems.length) {\n                elems \u003d Arrays.copyOf(elems, elems.length \u003c\u003c 1);\n            }\n            elems[size++] \u003d String.valueOf(cs);\n        }\n        return join(\"\", \"\", delim, elems, size);\n    }\n\n    /**\n     * Converts all of the characters in this {@code String} to lower\n     * case using the rules of the given {@code Locale}.  Case mapping is based\n     * on the Unicode Standard version specified by the {@link java.lang.Character Character}\n     * class. Since case mappings are not always 1:1 char mappings, the resulting\n     * {@code String} may be a different length than the original {@code String}.\n     * \u003cp\u003e\n     * Examples of lowercase  mappings are in the following table:\n     * \u003ctable class\u003d\"plain\"\u003e\n     * \u003ccaption style\u003d\"display:none\"\u003eLowercase mapping examples showing language code of locale, upper case, lower case, and description\u003c/caption\u003e\n     * \u003cthead\u003e\n     * \u003ctr\u003e\n     *   \u003cth scope\u003d\"col\"\u003eLanguage Code of Locale\u003c/th\u003e\n     *   \u003cth scope\u003d\"col\"\u003eUpper Case\u003c/th\u003e\n     *   \u003cth scope\u003d\"col\"\u003eLower Case\u003c/th\u003e\n     *   \u003cth scope\u003d\"col\"\u003eDescription\u003c/th\u003e\n     * \u003c/tr\u003e\n     * \u003c/thead\u003e\n     * \u003ctbody\u003e\n     * \u003ctr\u003e\n     *   \u003ctd\u003etr (Turkish)\u003c/td\u003e\n     *   \u003cth scope\u003d\"row\" style\u003d\"font-weight:normal; text-align:left\"\u003e\u0026#92;u0130\u003c/th\u003e\n     *   \u003ctd\u003e\u0026#92;u0069\u003c/td\u003e\n     *   \u003ctd\u003ecapital letter I with dot above -\u0026gt; small letter i\u003c/td\u003e\n     * \u003c/tr\u003e\n     * \u003ctr\u003e\n     *   \u003ctd\u003etr (Turkish)\u003c/td\u003e\n     *   \u003cth scope\u003d\"row\" style\u003d\"font-weight:normal; text-align:left\"\u003e\u0026#92;u0049\u003c/th\u003e\n     *   \u003ctd\u003e\u0026#92;u0131\u003c/td\u003e\n     *   \u003ctd\u003ecapital letter I -\u0026gt; small letter dotless i \u003c/td\u003e\n     * \u003c/tr\u003e\n     * \u003ctr\u003e\n     *   \u003ctd\u003e(all)\u003c/td\u003e\n     *   \u003cth scope\u003d\"row\" style\u003d\"font-weight:normal; text-align:left\"\u003eFrench Fries\u003c/th\u003e\n     *   \u003ctd\u003efrench fries\u003c/td\u003e\n     *   \u003ctd\u003elowercased all chars in String\u003c/td\u003e\n     * \u003c/tr\u003e\n     * \u003ctr\u003e\n     *   \u003ctd\u003e(all)\u003c/td\u003e\n     *   \u003cth scope\u003d\"row\" style\u003d\"font-weight:normal; text-align:left\"\u003e\n     *       \u0026Iota;\u0026Chi;\u0026Theta;\u0026Upsilon;\u0026Sigma;\u003c/th\u003e\n     *   \u003ctd\u003e\u0026iota;\u0026chi;\u0026theta;\u0026upsilon;\u0026sigma;\u003c/td\u003e\n     *   \u003ctd\u003elowercased all chars in String\u003c/td\u003e\n     * \u003c/tr\u003e\n     * \u003c/tbody\u003e\n     * \u003c/table\u003e\n     *\n     * @param locale use the case transformation rules for this locale\n     * @return the {@code String}, converted to lowercase.\n     * @see     java.lang.String#toLowerCase()\n     * @see     java.lang.String#toUpperCase()\n     * @see     java.lang.String#toUpperCase(Locale)\n     * @since   1.1\n     */\n    public String toLowerCase(Locale locale) {\n        return isLatin1() ? StringLatin1.toLowerCase(this, value, locale)\n                          : StringUTF16.toLowerCase(this, value, locale);\n    }\n\n    /**\n     * Converts all of the characters in this {@code String} to lower\n     * case using the rules of the default locale. This is equivalent to calling\n     * {@code toLowerCase(Locale.getDefault())}.\n     * \u003cp\u003e\n     * \u003cb\u003eNote:\u003c/b\u003e This method is locale sensitive, and may produce unexpected\n     * results if used for strings that are intended to be interpreted locale\n     * independently.\n     * Examples are programming language identifiers, protocol keys, and HTML\n     * tags.\n     * For instance, {@code \"TITLE\".toLowerCase()} in a Turkish locale\n     * returns {@code \"t\\u005Cu0131tle\"}, where \u0027\\u005Cu0131\u0027 is the\n     * LATIN SMALL LETTER DOTLESS I character.\n     * To obtain correct results for locale insensitive strings, use\n     * {@code toLowerCase(Locale.ROOT)}.\n     *\n     * @return  the {@code String}, converted to lowercase.\n     * @see     java.lang.String#toLowerCase(Locale)\n     */\n    public String toLowerCase() {\n        return toLowerCase(Locale.getDefault());\n    }\n\n    /**\n     * Converts all of the characters in this {@code String} to upper\n     * case using the rules of the given {@code Locale}. Case mapping is based\n     * on the Unicode Standard version specified by the {@link java.lang.Character Character}\n     * class. Since case mappings are not always 1:1 char mappings, the resulting\n     * {@code String} may be a different length than the original {@code String}.\n     * \u003cp\u003e\n     * Examples of locale-sensitive and 1:M case mappings are in the following table.\n     *\n     * \u003ctable class\u003d\"plain\"\u003e\n     * \u003ccaption style\u003d\"display:none\"\u003eExamples of locale-sensitive and 1:M case mappings. Shows Language code of locale, lower case, upper case, and description.\u003c/caption\u003e\n     * \u003cthead\u003e\n     * \u003ctr\u003e\n     *   \u003cth scope\u003d\"col\"\u003eLanguage Code of Locale\u003c/th\u003e\n     *   \u003cth scope\u003d\"col\"\u003eLower Case\u003c/th\u003e\n     *   \u003cth scope\u003d\"col\"\u003eUpper Case\u003c/th\u003e\n     *   \u003cth scope\u003d\"col\"\u003eDescription\u003c/th\u003e\n     * \u003c/tr\u003e\n     * \u003c/thead\u003e\n     * \u003ctbody\u003e\n     * \u003ctr\u003e\n     *   \u003ctd\u003etr (Turkish)\u003c/td\u003e\n     *   \u003cth scope\u003d\"row\" style\u003d\"font-weight:normal; text-align:left\"\u003e\u0026#92;u0069\u003c/th\u003e\n     *   \u003ctd\u003e\u0026#92;u0130\u003c/td\u003e\n     *   \u003ctd\u003esmall letter i -\u0026gt; capital letter I with dot above\u003c/td\u003e\n     * \u003c/tr\u003e\n     * \u003ctr\u003e\n     *   \u003ctd\u003etr (Turkish)\u003c/td\u003e\n     *   \u003cth scope\u003d\"row\" style\u003d\"font-weight:normal; text-align:left\"\u003e\u0026#92;u0131\u003c/th\u003e\n     *   \u003ctd\u003e\u0026#92;u0049\u003c/td\u003e\n     *   \u003ctd\u003esmall letter dotless i -\u0026gt; capital letter I\u003c/td\u003e\n     * \u003c/tr\u003e\n     * \u003ctr\u003e\n     *   \u003ctd\u003e(all)\u003c/td\u003e\n     *   \u003cth scope\u003d\"row\" style\u003d\"font-weight:normal; text-align:left\"\u003e\u0026#92;u00df\u003c/th\u003e\n     *   \u003ctd\u003e\u0026#92;u0053 \u0026#92;u0053\u003c/td\u003e\n     *   \u003ctd\u003esmall letter sharp s -\u0026gt; two letters: SS\u003c/td\u003e\n     * \u003c/tr\u003e\n     * \u003ctr\u003e\n     *   \u003ctd\u003e(all)\u003c/td\u003e\n     *   \u003cth scope\u003d\"row\" style\u003d\"font-weight:normal; text-align:left\"\u003eFahrvergn\u0026uuml;gen\u003c/th\u003e\n     *   \u003ctd\u003eFAHRVERGN\u0026Uuml;GEN\u003c/td\u003e\n     *   \u003ctd\u003e\u003c/td\u003e\n     * \u003c/tr\u003e\n     * \u003c/tbody\u003e\n     * \u003c/table\u003e\n     * @param locale use the case transformation rules for this locale\n     * @return the {@code String}, converted to uppercase.\n     * @see     java.lang.String#toUpperCase()\n     * @see     java.lang.String#toLowerCase()\n     * @see     java.lang.String#toLowerCase(Locale)\n     * @since   1.1\n     */\n    public String toUpperCase(Locale locale) {\n        return isLatin1() ? StringLatin1.toUpperCase(this, value, locale)\n                          : StringUTF16.toUpperCase(this, value, locale);\n    }\n\n    /**\n     * Converts all of the characters in this {@code String} to upper\n     * case using the rules of the default locale. This method is equivalent to\n     * {@code toUpperCase(Locale.getDefault())}.\n     * \u003cp\u003e\n     * \u003cb\u003eNote:\u003c/b\u003e This method is locale sensitive, and may produce unexpected\n     * results if used for strings that are intended to be interpreted locale\n     * independently.\n     * Examples are programming language identifiers, protocol keys, and HTML\n     * tags.\n     * For instance, {@code \"title\".toUpperCase()} in a Turkish locale\n     * returns {@code \"T\\u005Cu0130TLE\"}, where \u0027\\u005Cu0130\u0027 is the\n     * LATIN CAPITAL LETTER I WITH DOT ABOVE character.\n     * To obtain correct results for locale insensitive strings, use\n     * {@code toUpperCase(Locale.ROOT)}.\n     *\n     * @return  the {@code String}, converted to uppercase.\n     * @see     java.lang.String#toUpperCase(Locale)\n     */\n    public String toUpperCase() {\n        return toUpperCase(Locale.getDefault());\n    }\n\n    /**\n     * Returns a string whose value is this string, with all leading\n     * and trailing space removed, where space is defined\n     * as any character whose codepoint is less than or equal to\n     * {@code \u0027U+0020\u0027} (the space character).\n     * \u003cp\u003e\n     * If this {@code String} object represents an empty character\n     * sequence, or the first and last characters of character sequence\n     * represented by this {@code String} object both have codes\n     * that are not space (as defined above), then a\n     * reference to this {@code String} object is returned.\n     * \u003cp\u003e\n     * Otherwise, if all characters in this string are space (as\n     * defined above), then a  {@code String} object representing an\n     * empty string is returned.\n     * \u003cp\u003e\n     * Otherwise, let \u003ci\u003ek\u003c/i\u003e be the index of the first character in the\n     * string whose code is not a space (as defined above) and let\n     * \u003ci\u003em\u003c/i\u003e be the index of the last character in the string whose code\n     * is not a space (as defined above). A {@code String}\n     * object is returned, representing the substring of this string that\n     * begins with the character at index \u003ci\u003ek\u003c/i\u003e and ends with the\n     * character at index \u003ci\u003em\u003c/i\u003e-that is, the result of\n     * {@code this.substring(k, m + 1)}.\n     * \u003cp\u003e\n     * This method may be used to trim space (as defined above) from\n     * the beginning and end of a string.\n     *\n     * @return  a string whose value is this string, with all leading\n     *          and trailing space removed, or this string if it\n     *          has no leading or trailing space.\n     */\n    public String trim() {\n        String ret \u003d isLatin1() ? StringLatin1.trim(value)\n                                : StringUTF16.trim(value);\n        return ret \u003d\u003d null ? this : ret;\n    }\n\n    /**\n     * Returns a string whose value is this string, with all leading\n     * and trailing {@linkplain Character#isWhitespace(int) white space}\n     * removed.\n     * \u003cp\u003e\n     * If this {@code String} object represents an empty string,\n     * or if all code points in this string are\n     * {@linkplain Character#isWhitespace(int) white space}, then an empty string\n     * is returned.\n     * \u003cp\u003e\n     * Otherwise, returns a substring of this string beginning with the first\n     * code point that is not a {@linkplain Character#isWhitespace(int) white space}\n     * up to and including the last code point that is not a\n     * {@linkplain Character#isWhitespace(int) white space}.\n     * \u003cp\u003e\n     * This method may be used to strip\n     * {@linkplain Character#isWhitespace(int) white space} from\n     * the beginning and end of a string.\n     *\n     * @return  a string whose value is this string, with all leading\n     *          and trailing white space removed\n     *\n     * @see Character#isWhitespace(int)\n     *\n     * @since 11\n     */\n    public String strip() {\n        String ret \u003d isLatin1() ? StringLatin1.strip(value)\n                                : StringUTF16.strip(value);\n        return ret \u003d\u003d null ? this : ret;\n    }\n\n    /**\n     * Returns a string whose value is this string, with all leading\n     * {@linkplain Character#isWhitespace(int) white space} removed.\n     * \u003cp\u003e\n     * If this {@code String} object represents an empty string,\n     * or if all code points in this string are\n     * {@linkplain Character#isWhitespace(int) white space}, then an empty string\n     * is returned.\n     * \u003cp\u003e\n     * Otherwise, returns a substring of this string beginning with the first\n     * code point that is not a {@linkplain Character#isWhitespace(int) white space}\n     * up to and including the last code point of this string.\n     * \u003cp\u003e\n     * This method may be used to trim\n     * {@linkplain Character#isWhitespace(int) white space} from\n     * the beginning of a string.\n     *\n     * @return  a string whose value is this string, with all leading white\n     *          space removed\n     *\n     * @see Character#isWhitespace(int)\n     *\n     * @since 11\n     */\n    public String stripLeading() {\n        String ret \u003d isLatin1() ? StringLatin1.stripLeading(value)\n                                : StringUTF16.stripLeading(value);\n        return ret \u003d\u003d null ? this : ret;\n    }\n\n    /**\n     * Returns a string whose value is this string, with all trailing\n     * {@linkplain Character#isWhitespace(int) white space} removed.\n     * \u003cp\u003e\n     * If this {@code String} object represents an empty string,\n     * or if all characters in this string are\n     * {@linkplain Character#isWhitespace(int) white space}, then an empty string\n     * is returned.\n     * \u003cp\u003e\n     * Otherwise, returns a substring of this string beginning with the first\n     * code point of this string up to and including the last code point\n     * that is not a {@linkplain Character#isWhitespace(int) white space}.\n     * \u003cp\u003e\n     * This method may be used to trim\n     * {@linkplain Character#isWhitespace(int) white space} from\n     * the end of a string.\n     *\n     * @return  a string whose value is this string, with all trailing white\n     *          space removed\n     *\n     * @see Character#isWhitespace(int)\n     *\n     * @since 11\n     */\n    public String stripTrailing() {\n        String ret \u003d isLatin1() ? StringLatin1.stripTrailing(value)\n                                : StringUTF16.stripTrailing(value);\n        return ret \u003d\u003d null ? this : ret;\n    }\n\n    /**\n     * Returns {@code true} if the string is empty or contains only\n     * {@linkplain Character#isWhitespace(int) white space} codepoints,\n     * otherwise {@code false}.\n     *\n     * @return {@code true} if the string is empty or contains only\n     *         {@linkplain Character#isWhitespace(int) white space} codepoints,\n     *         otherwise {@code false}\n     *\n     * @see Character#isWhitespace(int)\n     *\n     * @since 11\n     */\n    public boolean isBlank() {\n        return indexOfNonWhitespace() \u003d\u003d length();\n    }\n\n    /**\n     * Returns a stream of lines extracted from this string,\n     * separated by line terminators.\n     * \u003cp\u003e\n     * A \u003ci\u003eline terminator\u003c/i\u003e is one of the following:\n     * a line feed character {@code \"\\n\"} (U+000A),\n     * a carriage return character {@code \"\\r\"} (U+000D),\n     * or a carriage return followed immediately by a line feed\n     * {@code \"\\r\\n\"} (U+000D U+000A).\n     * \u003cp\u003e\n     * A \u003ci\u003eline\u003c/i\u003e is either a sequence of zero or more characters\n     * followed by a line terminator, or it is a sequence of one or\n     * more characters followed by the end of the string. A\n     * line does not include the line terminator.\n     * \u003cp\u003e\n     * The stream returned by this method contains the lines from\n     * this string in the order in which they occur.\n     *\n     * @apiNote This definition of \u003ci\u003eline\u003c/i\u003e implies that an empty\n     *          string has zero lines and that there is no empty line\n     *          following a line terminator at the end of a string.\n     *\n     * @implNote This method provides better performance than\n     *           split(\"\\R\") by supplying elements lazily and\n     *           by faster search of new line terminators.\n     *\n     * @return  the stream of lines extracted from this string\n     *\n     * @since 11\n     */\n    public Stream\u003cString\u003e lines() {\n        return isLatin1() ? StringLatin1.lines(value) : StringUTF16.lines(value);\n    }\n\n    /**\n     * Adjusts the indentation of each line of this string based on the value of\n     * {@code n}, and normalizes line termination characters.\n     * \u003cp\u003e\n     * This string is conceptually separated into lines using\n     * {@link String#lines()}. Each line is then adjusted as described below\n     * and then suffixed with a line feed {@code \"\\n\"} (U+000A). The resulting\n     * lines are then concatenated and returned.\n     * \u003cp\u003e\n     * If {@code n \u003e 0} then {@code n} spaces (U+0020) are inserted at the\n     * beginning of each line.\n     * \u003cp\u003e\n     * If {@code n \u003c 0} then up to {@code n}\n     * {@linkplain Character#isWhitespace(int) white space characters} are removed\n     * from the beginning of each line. If a given line does not contain\n     * sufficient white space then all leading\n     * {@linkplain Character#isWhitespace(int) white space characters} are removed.\n     * Each white space character is treated as a single character. In\n     * particular, the tab character {@code \"\\t\"} (U+0009) is considered a\n     * single character; it is not expanded.\n     * \u003cp\u003e\n     * If {@code n \u003d\u003d 0} then the line remains unchanged. However, line\n     * terminators are still normalized.\n     *\n     * @param n  number of leading\n     *           {@linkplain Character#isWhitespace(int) white space characters}\n     *           to add or remove\n     *\n     * @return string with indentation adjusted and line endings normalized\n     *\n     * @see String#lines()\n     * @see String#isBlank()\n     * @see Character#isWhitespace(int)\n     *\n     * @since 12\n     */\n    public String indent(int n) {\n        if (isEmpty()) {\n            return \"\";\n        }\n        Stream\u003cString\u003e stream \u003d lines();\n        if (n \u003e 0) {\n            final String spaces \u003d \" \".repeat(n);\n            stream \u003d stream.map(s -\u003e spaces + s);\n        } else if (n \u003d\u003d Integer.MIN_VALUE) {\n            stream \u003d stream.map(s -\u003e s.stripLeading());\n        } else if (n \u003c 0) {\n            stream \u003d stream.map(s -\u003e s.substring(Math.min(-n, s.indexOfNonWhitespace())));\n        }\n        return stream.collect(Collectors.joining(\"\\n\", \"\", \"\\n\"));\n    }\n\n    private int indexOfNonWhitespace() {\n        return isLatin1() ? StringLatin1.indexOfNonWhitespace(value)\n                          : StringUTF16.indexOfNonWhitespace(value);\n    }\n\n    private int lastIndexOfNonWhitespace() {\n        return isLatin1() ? StringLatin1.lastIndexOfNonWhitespace(value)\n                          : StringUTF16.lastIndexOfNonWhitespace(value);\n    }\n\n    /**\n     * Returns a string whose value is this string, with incidental\n     * {@linkplain Character#isWhitespace(int) white space} removed from\n     * the beginning and end of every line.\n     * \u003cp\u003e\n     * Incidental {@linkplain Character#isWhitespace(int) white space}\n     * is often present in a text block to align the content with the opening\n     * delimiter. For example, in the following code, dots represent incidental\n     * {@linkplain Character#isWhitespace(int) white space}:\n     * \u003cblockquote\u003e\u003cpre\u003e\n     * String html \u003d \"\"\"\n     * ..............\u0026lt;html\u0026gt;\n     * ..............    \u0026lt;body\u0026gt;\n     * ..............        \u0026lt;p\u0026gt;Hello, world\u0026lt;/p\u0026gt;\n     * ..............    \u0026lt;/body\u0026gt;\n     * ..............\u0026lt;/html\u0026gt;\n     * ..............\"\"\";\n     * \u003c/pre\u003e\u003c/blockquote\u003e\n     * This method treats the incidental\n     * {@linkplain Character#isWhitespace(int) white space} as indentation to be\n     * stripped, producing a string that preserves the relative indentation of\n     * the content. Using | to visualize the start of each line of the string:\n     * \u003cblockquote\u003e\u003cpre\u003e\n     * |\u0026lt;html\u0026gt;\n     * |    \u0026lt;body\u0026gt;\n     * |        \u0026lt;p\u0026gt;Hello, world\u0026lt;/p\u0026gt;\n     * |    \u0026lt;/body\u0026gt;\n     * |\u0026lt;/html\u0026gt;\n     * \u003c/pre\u003e\u003c/blockquote\u003e\n     * First, the individual lines of this string are extracted. A \u003ci\u003eline\u003c/i\u003e\n     * is a sequence of zero or more characters followed by either a line\n     * terminator or the end of the string.\n     * If the string has at least one line terminator, the last line consists\n     * of the characters between the last terminator and the end of the string.\n     * Otherwise, if the string has no terminators, the last line is the start\n     * of the string to the end of the string, in other words, the entire\n     * string.\n     * A line does not include the line terminator.\n     * \u003cp\u003e\n     * Then, the \u003ci\u003eminimum indentation\u003c/i\u003e (min) is determined as follows:\n     * \u003cul\u003e\n     *   \u003cli\u003e\u003cp\u003eFor each non-blank line (as defined by {@link String#isBlank()}),\n     *   the leading {@linkplain Character#isWhitespace(int) white space}\n     *   characters are counted.\u003c/p\u003e\n     *   \u003c/li\u003e\n     *   \u003cli\u003e\u003cp\u003eThe leading {@linkplain Character#isWhitespace(int) white space}\n     *   characters on the last line are also counted even if\n     *   {@linkplain String#isBlank() blank}.\u003c/p\u003e\n     *   \u003c/li\u003e\n     * \u003c/ul\u003e\n     * \u003cp\u003eThe \u003ci\u003emin\u003c/i\u003e value is the smallest of these counts.\n     * \u003cp\u003e\n     * For each {@linkplain String#isBlank() non-blank} line, \u003ci\u003emin\u003c/i\u003e leading\n     * {@linkplain Character#isWhitespace(int) white space} characters are\n     * removed, and any trailing {@linkplain Character#isWhitespace(int) white\n     * space} characters are removed. {@linkplain String#isBlank() Blank} lines\n     * are replaced with the empty string.\n     *\n     * \u003cp\u003e\n     * Finally, the lines are joined into a new string, using the LF character\n     * {@code \"\\n\"} (U+000A) to separate lines.\n     *\n     * @apiNote\n     * This method\u0027s primary purpose is to shift a block of lines as far as\n     * possible to the left, while preserving relative indentation. Lines\n     * that were indented the least will thus have no leading\n     * {@linkplain Character#isWhitespace(int) white space}.\n     * The result will have the same number of line terminators as this string.\n     * If this string ends with a line terminator then the result will end\n     * with a line terminator.\n     *\n     * @implSpec\n     * This method treats all {@linkplain Character#isWhitespace(int) white space}\n     * characters as having equal width. As long as the indentation on every\n     * line is consistently composed of the same character sequences, then the\n     * result will be as described above.\n     *\n     * @return string with incidental indentation removed and line\n     *         terminators normalized\n     *\n     * @see String#lines()\n     * @see String#isBlank()\n     * @see String#indent(int)\n     * @see Character#isWhitespace(int)\n     *\n     * @since 15\n     *\n     */\n    public String stripIndent() {\n        int length \u003d length();\n        if (length \u003d\u003d 0) {\n            return \"\";\n        }\n        char lastChar \u003d charAt(length - 1);\n        boolean optOut \u003d lastChar \u003d\u003d \u0027\\n\u0027 || lastChar \u003d\u003d \u0027\\r\u0027;\n        List\u003cString\u003e lines \u003d lines().toList();\n        final int outdent \u003d optOut ? 0 : outdent(lines);\n        return lines.stream()\n            .map(line -\u003e {\n                int firstNonWhitespace \u003d line.indexOfNonWhitespace();\n                int lastNonWhitespace \u003d line.lastIndexOfNonWhitespace();\n                int incidentalWhitespace \u003d Math.min(outdent, firstNonWhitespace);\n                return firstNonWhitespace \u003e lastNonWhitespace\n                    ? \"\" : line.substring(incidentalWhitespace, lastNonWhitespace);\n            })\n            .collect(Collectors.joining(\"\\n\", \"\", optOut ? \"\\n\" : \"\"));\n    }\n\n    private static int outdent(List\u003cString\u003e lines) {\n        // Note: outdent is guaranteed to be zero or positive number.\n        // If there isn\u0027t a non-blank line then the last must be blank\n        int outdent \u003d Integer.MAX_VALUE;\n        for (String line : lines) {\n            int leadingWhitespace \u003d line.indexOfNonWhitespace();\n            if (leadingWhitespace !\u003d line.length()) {\n                outdent \u003d Integer.min(outdent, leadingWhitespace);\n            }\n        }\n        String lastLine \u003d lines.get(lines.size() - 1);\n        if (lastLine.isBlank()) {\n            outdent \u003d Integer.min(outdent, lastLine.length());\n        }\n        return outdent;\n    }\n\n    /**\n     * Returns a string whose value is this string, with escape sequences\n     * translated as if in a string literal.\n     * \u003cp\u003e\n     * Escape sequences are translated as follows;\n     * \u003ctable class\u003d\"striped\"\u003e\n     *   \u003ccaption style\u003d\"display:none\"\u003eTranslation\u003c/caption\u003e\n     *   \u003cthead\u003e\n     *   \u003ctr\u003e\n     *     \u003cth scope\u003d\"col\"\u003eEscape\u003c/th\u003e\n     *     \u003cth scope\u003d\"col\"\u003eName\u003c/th\u003e\n     *     \u003cth scope\u003d\"col\"\u003eTranslation\u003c/th\u003e\n     *   \u003c/tr\u003e\n     *   \u003c/thead\u003e\n     *   \u003ctbody\u003e\n     *   \u003ctr\u003e\n     *     \u003cth scope\u003d\"row\"\u003e{@code \\u005Cb}\u003c/th\u003e\n     *     \u003ctd\u003ebackspace\u003c/td\u003e\n     *     \u003ctd\u003e{@code U+0008}\u003c/td\u003e\n     *   \u003c/tr\u003e\n     *   \u003ctr\u003e\n     *     \u003cth scope\u003d\"row\"\u003e{@code \\u005Ct}\u003c/th\u003e\n     *     \u003ctd\u003ehorizontal tab\u003c/td\u003e\n     *     \u003ctd\u003e{@code U+0009}\u003c/td\u003e\n     *   \u003c/tr\u003e\n     *   \u003ctr\u003e\n     *     \u003cth scope\u003d\"row\"\u003e{@code \\u005Cn}\u003c/th\u003e\n     *     \u003ctd\u003eline feed\u003c/td\u003e\n     *     \u003ctd\u003e{@code U+000A}\u003c/td\u003e\n     *   \u003c/tr\u003e\n     *   \u003ctr\u003e\n     *     \u003cth scope\u003d\"row\"\u003e{@code \\u005Cf}\u003c/th\u003e\n     *     \u003ctd\u003eform feed\u003c/td\u003e\n     *     \u003ctd\u003e{@code U+000C}\u003c/td\u003e\n     *   \u003c/tr\u003e\n     *   \u003ctr\u003e\n     *     \u003cth scope\u003d\"row\"\u003e{@code \\u005Cr}\u003c/th\u003e\n     *     \u003ctd\u003ecarriage return\u003c/td\u003e\n     *     \u003ctd\u003e{@code U+000D}\u003c/td\u003e\n     *   \u003c/tr\u003e\n     *   \u003ctr\u003e\n     *     \u003cth scope\u003d\"row\"\u003e{@code \\u005Cs}\u003c/th\u003e\n     *     \u003ctd\u003espace\u003c/td\u003e\n     *     \u003ctd\u003e{@code U+0020}\u003c/td\u003e\n     *   \u003c/tr\u003e\n     *   \u003ctr\u003e\n     *     \u003cth scope\u003d\"row\"\u003e{@code \\u005C\"}\u003c/th\u003e\n     *     \u003ctd\u003edouble quote\u003c/td\u003e\n     *     \u003ctd\u003e{@code U+0022}\u003c/td\u003e\n     *   \u003c/tr\u003e\n     *   \u003ctr\u003e\n     *     \u003cth scope\u003d\"row\"\u003e{@code \\u005C\u0027}\u003c/th\u003e\n     *     \u003ctd\u003esingle quote\u003c/td\u003e\n     *     \u003ctd\u003e{@code U+0027}\u003c/td\u003e\n     *   \u003c/tr\u003e\n     *   \u003ctr\u003e\n     *     \u003cth scope\u003d\"row\"\u003e{@code \\u005C\\u005C}\u003c/th\u003e\n     *     \u003ctd\u003ebackslash\u003c/td\u003e\n     *     \u003ctd\u003e{@code U+005C}\u003c/td\u003e\n     *   \u003c/tr\u003e\n     *   \u003ctr\u003e\n     *     \u003cth scope\u003d\"row\"\u003e{@code \\u005C0 - \\u005C377}\u003c/th\u003e\n     *     \u003ctd\u003eoctal escape\u003c/td\u003e\n     *     \u003ctd\u003ecode point equivalents\u003c/td\u003e\n     *   \u003c/tr\u003e\n     *   \u003ctr\u003e\n     *     \u003cth scope\u003d\"row\"\u003e{@code \\u005C\u003cline-terminator\u003e}\u003c/th\u003e\n     *     \u003ctd\u003econtinuation\u003c/td\u003e\n     *     \u003ctd\u003ediscard\u003c/td\u003e\n     *   \u003c/tr\u003e\n     *   \u003c/tbody\u003e\n     * \u003c/table\u003e\n     *\n     * @implNote\n     * This method does \u003cem\u003enot\u003c/em\u003e translate Unicode escapes such as \"{@code \\u005cu2022}\".\n     * Unicode escapes are translated by the Java compiler when reading input characters and\n     * are not part of the string literal specification.\n     *\n     * @throws IllegalArgumentException when an escape sequence is malformed.\n     *\n     * @return String with escape sequences translated.\n     *\n     * @jls 3.10.7 Escape Sequences\n     *\n     * @since 15\n     */\n    public String translateEscapes() {\n        if (isEmpty()) {\n            return \"\";\n        }\n        char[] chars \u003d toCharArray();\n        int length \u003d chars.length;\n        int from \u003d 0;\n        int to \u003d 0;\n        while (from \u003c length) {\n            char ch \u003d chars[from++];\n            if (ch \u003d\u003d \u0027\\\\\u0027) {\n                ch \u003d from \u003c length ? chars[from++] : \u0027\\0\u0027;\n                switch (ch) {\n                case \u0027b\u0027:\n                    ch \u003d \u0027\\b\u0027;\n                    break;\n                case \u0027f\u0027:\n                    ch \u003d \u0027\\f\u0027;\n                    break;\n                case \u0027n\u0027:\n                    ch \u003d \u0027\\n\u0027;\n                    break;\n                case \u0027r\u0027:\n                    ch \u003d \u0027\\r\u0027;\n                    break;\n                case \u0027s\u0027:\n                    ch \u003d \u0027 \u0027;\n                    break;\n                case \u0027t\u0027:\n                    ch \u003d \u0027\\t\u0027;\n                    break;\n                case \u0027\\\u0027\u0027:\n                case \u0027\\\"\u0027:\n                case \u0027\\\\\u0027:\n                    // as is\n                    break;\n                case \u00270\u0027: case \u00271\u0027: case \u00272\u0027: case \u00273\u0027:\n                case \u00274\u0027: case \u00275\u0027: case \u00276\u0027: case \u00277\u0027:\n                    int limit \u003d Integer.min(from + (ch \u003c\u003d \u00273\u0027 ? 2 : 1), length);\n                    int code \u003d ch - \u00270\u0027;\n                    while (from \u003c limit) {\n                        ch \u003d chars[from];\n                        if (ch \u003c \u00270\u0027 || \u00277\u0027 \u003c ch) {\n                            break;\n                        }\n                        from++;\n                        code \u003d (code \u003c\u003c 3) | (ch - \u00270\u0027);\n                    }\n                    ch \u003d (char)code;\n                    break;\n                case \u0027\\n\u0027:\n                    continue;\n                case \u0027\\r\u0027:\n                    if (from \u003c length \u0026\u0026 chars[from] \u003d\u003d \u0027\\n\u0027) {\n                        from++;\n                    }\n                    continue;\n                default: {\n                    String msg \u003d String.format(\n                        \"Invalid escape sequence: \\\\%c \\\\\\\\u%04X\",\n                        ch, (int)ch);\n                    throw new IllegalArgumentException(msg);\n                }\n                }\n            }\n\n            chars[to++] \u003d ch;\n        }\n\n        return new String(chars, 0, to);\n    }\n\n    /**\n     * This method allows the application of a function to {@code this}\n     * string. The function should expect a single String argument\n     * and produce an {@code R} result.\n     * \u003cp\u003e\n     * Any exception thrown by {@code f.apply()} will be propagated to the\n     * caller.\n     *\n     * @param f    a function to apply\n     *\n     * @param \u003cR\u003e  the type of the result\n     *\n     * @return     the result of applying the function to this string\n     *\n     * @see java.util.function.Function\n     *\n     * @since 12\n     */\n    public \u003cR\u003e R transform(Function\u003c? super String, ? extends R\u003e f) {\n        return f.apply(this);\n    }\n\n    /**\n     * This object (which is already a string!) is itself returned.\n     *\n     * @return  the string itself.\n     */\n    public String toString() {\n        return this;\n    }\n\n    /**\n     * Returns a stream of {@code int} zero-extending the {@code char} values\n     * from this sequence.  Any char which maps to a \u003ca\n     * href\u003d\"{@docRoot}/java.base/java/lang/Character.html#unicode\"\u003esurrogate code\n     * point\u003c/a\u003e is passed through uninterpreted.\n     *\n     * @return an IntStream of char values from this sequence\n     * @since 9\n     */\n    @Override\n    public IntStream chars() {\n        return StreamSupport.intStream(\n            isLatin1() ? new StringLatin1.CharsSpliterator(value, Spliterator.IMMUTABLE)\n                       : new StringUTF16.CharsSpliterator(value, Spliterator.IMMUTABLE),\n            false);\n    }\n\n\n    /**\n     * Returns a stream of code point values from this sequence.  Any surrogate\n     * pairs encountered in the sequence are combined as if by {@linkplain\n     * Character#toCodePoint Character.toCodePoint} and the result is passed\n     * to the stream. Any other code units, including ordinary BMP characters,\n     * unpaired surrogates, and undefined code units, are zero-extended to\n     * {@code int} values which are then passed to the stream.\n     *\n     * @return an IntStream of Unicode code points from this sequence\n     * @since 9\n     */\n    @Override\n    public IntStream codePoints() {\n        return StreamSupport.intStream(\n            isLatin1() ? new StringLatin1.CharsSpliterator(value, Spliterator.IMMUTABLE)\n                       : new StringUTF16.CodePointsSpliterator(value, Spliterator.IMMUTABLE),\n            false);\n    }\n\n    /**\n     * Converts this string to a new character array.\n     *\n     * @return  a newly allocated character array whose length is the length\n     *          of this string and whose contents are initialized to contain\n     *          the character sequence represented by this string.\n     */\n    public char[] toCharArray() {\n        return isLatin1() ? StringLatin1.toChars(value)\n                          : StringUTF16.toChars(value);\n    }\n\n    /**\n     * Returns a formatted string using the specified format string and\n     * arguments.\n     *\n     * \u003cp\u003e The locale always used is the one returned by {@link\n     * java.util.Locale#getDefault(java.util.Locale.Category)\n     * Locale.getDefault(Locale.Category)} with\n     * {@link java.util.Locale.Category#FORMAT FORMAT} category specified.\n     *\n     * @param  format\n     *         A \u003ca href\u003d\"../util/Formatter.html#syntax\"\u003eformat string\u003c/a\u003e\n     *\n     * @param  args\n     *         Arguments referenced by the format specifiers in the format\n     *         string.  If there are more arguments than format specifiers, the\n     *         extra arguments are ignored.  The number of arguments is\n     *         variable and may be zero.  The maximum number of arguments is\n     *         limited by the maximum dimension of a Java array as defined by\n     *         \u003ccite\u003eThe Java Virtual Machine Specification\u003c/cite\u003e.\n     *         The behaviour on a\n     *         {@code null} argument depends on the \u003ca\n     *         href\u003d\"../util/Formatter.html#syntax\"\u003econversion\u003c/a\u003e.\n     *\n     * @throws  java.util.IllegalFormatException\n     *          If a format string contains an illegal syntax, a format\n     *          specifier that is incompatible with the given arguments,\n     *          insufficient arguments given the format string, or other\n     *          illegal conditions.  For specification of all possible\n     *          formatting errors, see the \u003ca\n     *          href\u003d\"../util/Formatter.html#detail\"\u003eDetails\u003c/a\u003e section of the\n     *          formatter class specification.\n     *\n     * @return  A formatted string\n     *\n     * @see  java.util.Formatter\n     * @since  1.5\n     */\n    public static String format(String format, Object... args) {\n        return new Formatter().format(format, args).toString();\n    }\n\n    /**\n     * Returns a formatted string using the specified locale, format string,\n     * and arguments.\n     *\n     * @param  l\n     *         The {@linkplain java.util.Locale locale} to apply during\n     *         formatting.  If {@code l} is {@code null} then no localization\n     *         is applied.\n     *\n     * @param  format\n     *         A \u003ca href\u003d\"../util/Formatter.html#syntax\"\u003eformat string\u003c/a\u003e\n     *\n     * @param  args\n     *         Arguments referenced by the format specifiers in the format\n     *         string.  If there are more arguments than format specifiers, the\n     *         extra arguments are ignored.  The number of arguments is\n     *         variable and may be zero.  The maximum number of arguments is\n     *         limited by the maximum dimension of a Java array as defined by\n     *         \u003ccite\u003eThe Java Virtual Machine Specification\u003c/cite\u003e.\n     *         The behaviour on a\n     *         {@code null} argument depends on the\n     *         \u003ca href\u003d\"../util/Formatter.html#syntax\"\u003econversion\u003c/a\u003e.\n     *\n     * @throws  java.util.IllegalFormatException\n     *          If a format string contains an illegal syntax, a format\n     *          specifier that is incompatible with the given arguments,\n     *          insufficient arguments given the format string, or other\n     *          illegal conditions.  For specification of all possible\n     *          formatting errors, see the \u003ca\n     *          href\u003d\"../util/Formatter.html#detail\"\u003eDetails\u003c/a\u003e section of the\n     *          formatter class specification\n     *\n     * @return  A formatted string\n     *\n     * @see  java.util.Formatter\n     * @since  1.5\n     */\n    public static String format(Locale l, String format, Object... args) {\n        return new Formatter(l).format(format, args).toString();\n    }\n\n    /**\n     * Formats using this string as the format string, and the supplied\n     * arguments.\n     *\n     * @implSpec This method is equivalent to {@code String.format(this, args)}.\n     *\n     * @param  args\n     *         Arguments referenced by the format specifiers in this string.\n     *\n     * @return  A formatted string\n     *\n     * @see  java.lang.String#format(String,Object...)\n     * @see  java.util.Formatter\n     *\n     * @since 15\n     *\n     */\n    public String formatted(Object... args) {\n        return new Formatter().format(this, args).toString();\n    }\n\n    /**\n     * Returns the string representation of the {@code Object} argument.\n     *\n     * @param   obj   an {@code Object}.\n     * @return  if the argument is {@code null}, then a string equal to\n     *          {@code \"null\"}; otherwise, the value of\n     *          {@code obj.toString()} is returned.\n     * @see     java.lang.Object#toString()\n     */\n    public static String valueOf(Object obj) {\n        return (obj \u003d\u003d null) ? \"null\" : obj.toString();\n    }\n\n    /**\n     * Returns the string representation of the {@code char} array\n     * argument. The contents of the character array are copied; subsequent\n     * modification of the character array does not affect the returned\n     * string.\n     *\n     * @param   data     the character array.\n     * @return  a {@code String} that contains the characters of the\n     *          character array.\n     */\n    public static String valueOf(char data[]) {\n        return new String(data);\n    }\n\n    /**\n     * Returns the string representation of a specific subarray of the\n     * {@code char} array argument.\n     * \u003cp\u003e\n     * The {@code offset} argument is the index of the first\n     * character of the subarray. The {@code count} argument\n     * specifies the length of the subarray. The contents of the subarray\n     * are copied; subsequent modification of the character array does not\n     * affect the returned string.\n     *\n     * @param   data     the character array.\n     * @param   offset   initial offset of the subarray.\n     * @param   count    length of the subarray.\n     * @return  a {@code String} that contains the characters of the\n     *          specified subarray of the character array.\n     * @throws    IndexOutOfBoundsException if {@code offset} is\n     *          negative, or {@code count} is negative, or\n     *          {@code offset+count} is larger than\n     *          {@code data.length}.\n     */\n    public static String valueOf(char data[], int offset, int count) {\n        return new String(data, offset, count);\n    }\n\n    /**\n     * Equivalent to {@link #valueOf(char[], int, int)}.\n     *\n     * @param   data     the character array.\n     * @param   offset   initial offset of the subarray.\n     * @param   count    length of the subarray.\n     * @return  a {@code String} that contains the characters of the\n     *          specified subarray of the character array.\n     * @throws    IndexOutOfBoundsException if {@code offset} is\n     *          negative, or {@code count} is negative, or\n     *          {@code offset+count} is larger than\n     *          {@code data.length}.\n     */\n    public static String copyValueOf(char data[], int offset, int count) {\n        return new String(data, offset, count);\n    }\n\n    /**\n     * Equivalent to {@link #valueOf(char[])}.\n     *\n     * @param   data   the character array.\n     * @return  a {@code String} that contains the characters of the\n     *          character array.\n     */\n    public static String copyValueOf(char data[]) {\n        return new String(data);\n    }\n\n    /**\n     * Returns the string representation of the {@code boolean} argument.\n     *\n     * @param   b   a {@code boolean}.\n     * @return  if the argument is {@code true}, a string equal to\n     *          {@code \"true\"} is returned; otherwise, a string equal to\n     *          {@code \"false\"} is returned.\n     */\n    public static String valueOf(boolean b) {\n        return b ? \"true\" : \"false\";\n    }\n\n    /**\n     * Returns the string representation of the {@code char}\n     * argument.\n     *\n     * @param   c   a {@code char}.\n     * @return  a string of length {@code 1} containing\n     *          as its single character the argument {@code c}.\n     */\n    public static String valueOf(char c) {\n        if (COMPACT_STRINGS \u0026\u0026 StringLatin1.canEncode(c)) {\n            return new String(StringLatin1.toBytes(c), LATIN1);\n        }\n        return new String(StringUTF16.toBytes(c), UTF16);\n    }\n\n    /**\n     * Returns the string representation of the {@code int} argument.\n     * \u003cp\u003e\n     * The representation is exactly the one returned by the\n     * {@code Integer.toString} method of one argument.\n     *\n     * @param   i   an {@code int}.\n     * @return  a string representation of the {@code int} argument.\n     * @see     java.lang.Integer#toString(int, int)\n     */\n    public static String valueOf(int i) {\n        return Integer.toString(i);\n    }\n\n    /**\n     * Returns the string representation of the {@code long} argument.\n     * \u003cp\u003e\n     * The representation is exactly the one returned by the\n     * {@code Long.toString} method of one argument.\n     *\n     * @param   l   a {@code long}.\n     * @return  a string representation of the {@code long} argument.\n     * @see     java.lang.Long#toString(long)\n     */\n    public static String valueOf(long l) {\n        return Long.toString(l);\n    }\n\n    /**\n     * Returns the string representation of the {@code float} argument.\n     * \u003cp\u003e\n     * The representation is exactly the one returned by the\n     * {@code Float.toString} method of one argument.\n     *\n     * @param   f   a {@code float}.\n     * @return  a string representation of the {@code float} argument.\n     * @see     java.lang.Float#toString(float)\n     */\n    public static String valueOf(float f) {\n        return Float.toString(f);\n    }\n\n    /**\n     * Returns the string representation of the {@code double} argument.\n     * \u003cp\u003e\n     * The representation is exactly the one returned by the\n     * {@code Double.toString} method of one argument.\n     *\n     * @param   d   a {@code double}.\n     * @return  a  string representation of the {@code double} argument.\n     * @see     java.lang.Double#toString(double)\n     */\n    public static String valueOf(double d) {\n        return Double.toString(d);\n    }\n\n    /**\n     * Returns a canonical representation for the string object.\n     * \u003cp\u003e\n     * A pool of strings, initially empty, is maintained privately by the\n     * class {@code String}.\n     * \u003cp\u003e\n     * When the intern method is invoked, if the pool already contains a\n     * string equal to this {@code String} object as determined by\n     * the {@link #equals(Object)} method, then the string from the pool is\n     * returned. Otherwise, this {@code String} object is added to the\n     * pool and a reference to this {@code String} object is returned.\n     * \u003cp\u003e\n     * It follows that for any two strings {@code s} and {@code t},\n     * {@code s.intern() \u003d\u003d t.intern()} is {@code true}\n     * if and only if {@code s.equals(t)} is {@code true}.\n     * \u003cp\u003e\n     * All literal strings and string-valued constant expressions are\n     * interned. String literals are defined in section {@jls 3.10.5} of the\n     * \u003ccite\u003eThe Java Language Specification\u003c/cite\u003e.\n     *\n     * @return  a string that has the same contents as this string, but is\n     *          guaranteed to be from a pool of unique strings.\n     */\n    public native String intern();\n\n    /**\n     * Returns a string whose value is the concatenation of this\n     * string repeated {@code count} times.\n     * \u003cp\u003e\n     * If this string is empty or count is zero then the empty\n     * string is returned.\n     *\n     * @param   count number of times to repeat\n     *\n     * @return  A string composed of this string repeated\n     *          {@code count} times or the empty string if this\n     *          string is empty or count is zero\n     *\n     * @throws  IllegalArgumentException if the {@code count} is\n     *          negative.\n     *\n     * @since 11\n     */\n    public String repeat(int count) {\n        if (count \u003c 0) {\n            throw new IllegalArgumentException(\"count is negative: \" + count);\n        }\n        if (count \u003d\u003d 1) {\n            return this;\n        }\n        final int len \u003d value.length;\n        if (len \u003d\u003d 0 || count \u003d\u003d 0) {\n            return \"\";\n        }\n        if (Integer.MAX_VALUE / count \u003c len) {\n            throw new OutOfMemoryError(\"Required length exceeds implementation limit\");\n        }\n        if (len \u003d\u003d 1) {\n            final byte[] single \u003d new byte[count];\n            Arrays.fill(single, value[0]);\n            return new String(single, coder);\n        }\n        final int limit \u003d len * count;\n        final byte[] multiple \u003d new byte[limit];\n        System.arraycopy(value, 0, multiple, 0, len);\n        int copied \u003d len;\n        for (; copied \u003c limit - copied; copied \u003c\u003c\u003d 1) {\n            System.arraycopy(multiple, 0, multiple, copied, copied);\n        }\n        System.arraycopy(multiple, 0, multiple, copied, limit - copied);\n        return new String(multiple, coder);\n    }\n\n    ////////////////////////////////////////////////////////////////\n\n    /**\n     * Copy character bytes from this string into dst starting at dstBegin.\n     * This method doesn\u0027t perform any range checking.\n     *\n     * Invoker guarantees: dst is in UTF16 (inflate itself for asb), if two\n     * coders are different, and dst is big enough (range check)\n     *\n     * @param dstBegin  the char index, not offset of byte[]\n     * @param coder     the coder of dst[]\n     */\n    void getBytes(byte[] dst, int dstBegin, byte coder) {\n        if (coder() \u003d\u003d coder) {\n            System.arraycopy(value, 0, dst, dstBegin \u003c\u003c coder, value.length);\n        } else {    // this.coder \u003d\u003d LATIN \u0026\u0026 coder \u003d\u003d UTF16\n            StringLatin1.inflate(value, 0, dst, dstBegin, value.length);\n        }\n    }\n\n    /**\n     * Copy character bytes from this string into dst starting at dstBegin.\n     * This method doesn\u0027t perform any range checking.\n     *\n     * Invoker guarantees: dst is in UTF16 (inflate itself for asb), if two\n     * coders are different, and dst is big enough (range check)\n     *\n     * @param srcPos    the char index, not offset of byte[]\n     * @param dstBegin  the char index to start from\n     * @param coder     the coder of dst[]\n     * @param length    the amount of copied chars\n     */\n    void getBytes(byte[] dst, int srcPos, int dstBegin, byte coder, int length) {\n        if (coder() \u003d\u003d coder) {\n            System.arraycopy(value, srcPos \u003c\u003c coder, dst, dstBegin \u003c\u003c coder, length \u003c\u003c coder);\n        } else {    // this.coder \u003d\u003d LATIN \u0026\u0026 coder \u003d\u003d UTF16\n            StringLatin1.inflate(value, srcPos, dst, dstBegin, length);\n        }\n    }\n\n    /*\n     * Package private constructor. Trailing Void argument is there for\n     * disambiguating it against other (public) constructors.\n     *\n     * Stores the char[] value into a byte[] that each byte represents\n     * the8 low-order bits of the corresponding character, if the char[]\n     * contains only latin1 character. Or a byte[] that stores all\n     * characters in their byte sequences defined by the {@code StringUTF16}.\n     */\n    String(char[] value, int off, int len, Void sig) {\n        if (len \u003d\u003d 0) {\n            this.value \u003d \"\".value;\n            this.coder \u003d \"\".coder;\n            return;\n        }\n        if (COMPACT_STRINGS) {\n            byte[] val \u003d StringUTF16.compress(value, off, len);\n            if (val !\u003d null) {\n                this.value \u003d val;\n                this.coder \u003d LATIN1;\n                return;\n            }\n        }\n        this.coder \u003d UTF16;\n        this.value \u003d StringUTF16.toBytes(value, off, len);\n    }\n\n    /*\n     * Package private constructor. Trailing Void argument is there for\n     * disambiguating it against other (public) constructors.\n     */\n    String(AbstractStringBuilder asb, Void sig) {\n        byte[] val \u003d asb.getValue();\n        int length \u003d asb.length();\n        if (asb.isLatin1()) {\n            this.coder \u003d LATIN1;\n            this.value \u003d Arrays.copyOfRange(val, 0, length);\n        } else {\n            if (COMPACT_STRINGS) {\n                byte[] buf \u003d StringUTF16.compress(val, 0, length);\n                if (buf !\u003d null) {\n                    this.coder \u003d LATIN1;\n                    this.value \u003d buf;\n                    return;\n                }\n            }\n            this.coder \u003d UTF16;\n            this.value \u003d Arrays.copyOfRange(val, 0, length \u003c\u003c 1);\n        }\n    }\n\n   /*\n    * Package private constructor which shares value array for speed.\n    */\n    String(byte[] value, byte coder) {\n        this.value \u003d value;\n        this.coder \u003d coder;\n    }\n\n    byte coder() {\n        return COMPACT_STRINGS ? coder : UTF16;\n    }\n\n    byte[] value() {\n        return value;\n    }\n\n    boolean isLatin1() {\n        return COMPACT_STRINGS \u0026\u0026 coder \u003d\u003d LATIN1;\n    }\n\n    @Native static final byte LATIN1 \u003d 0;\n    @Native static final byte UTF16  \u003d 1;\n\n    /*\n     * StringIndexOutOfBoundsException  if {@code index} is\n     * negative or greater than or equal to {@code length}.\n     */\n    static void checkIndex(int index, int length) {\n        if (index \u003c 0 || index \u003e\u003d length) {\n            throw new StringIndexOutOfBoundsException(\"index \" + index +\n                                                      \", length \" + length);\n        }\n    }\n\n    /*\n     * StringIndexOutOfBoundsException  if {@code offset}\n     * is negative or greater than {@code length}.\n     */\n    static void checkOffset(int offset, int length) {\n        if (offset \u003c 0 || offset \u003e length) {\n            throw new StringIndexOutOfBoundsException(\"offset \" + offset +\n                                                      \", length \" + length);\n        }\n    }\n\n    /*\n     * Check {@code offset}, {@code count} against {@code 0} and {@code length}\n     * bounds.\n     *\n     * @throws  StringIndexOutOfBoundsException\n     *          If {@code offset} is negative, {@code count} is negative,\n     *          or {@code offset} is greater than {@code length - count}\n     */\n    static void checkBoundsOffCount(int offset, int count, int length) {\n        if (offset \u003c 0 || count \u003c 0 || offset \u003e length - count) {\n            throw new StringIndexOutOfBoundsException(\n                \"offset \" + offset + \", count \" + count + \", length \" + length);\n        }\n    }\n\n    /*\n     * Check {@code begin}, {@code end} against {@code 0} and {@code length}\n     * bounds.\n     *\n     * @throws  StringIndexOutOfBoundsException\n     *          If {@code begin} is negative, {@code begin} is greater than\n     *          {@code end}, or {@code end} is greater than {@code length}.\n     */\n    static void checkBoundsBeginEnd(int begin, int end, int length) {\n        if (begin \u003c 0 || begin \u003e end || end \u003e length) {\n            throw new StringIndexOutOfBoundsException(\n                \"begin \" + begin + \", end \" + end + \", length \" + length);\n        }\n    }\n\n    /**\n     * Returns the string representation of the {@code codePoint}\n     * argument.\n     *\n     * @param   codePoint a {@code codePoint}.\n     * @return  a string of length {@code 1} or {@code 2} containing\n     *          as its single character the argument {@code codePoint}.\n     * @throws IllegalArgumentException if the specified\n     *          {@code codePoint} is not a {@linkplain Character#isValidCodePoint\n     *          valid Unicode code point}.\n     */\n    static String valueOfCodePoint(int codePoint) {\n        if (COMPACT_STRINGS \u0026\u0026 StringLatin1.canEncode(codePoint)) {\n            return new String(StringLatin1.toBytes((char)codePoint), LATIN1);\n        } else if (Character.isBmpCodePoint(codePoint)) {\n            return new String(StringUTF16.toBytes((char)codePoint), UTF16);\n        } else if (Character.isSupplementaryCodePoint(codePoint)) {\n            return new String(StringUTF16.toBytesSupplementary(codePoint), UTF16);\n        }\n\n        throw new IllegalArgumentException(\n            format(\"Not a valid Unicode code point: 0x%X\", codePoint));\n    }\n\n    /**\n     * Returns an {@link Optional} containing the nominal descriptor for this\n     * instance, which is the instance itself.\n     *\n     * @return an {@link Optional} describing the {@linkplain String} instance\n     * @since 12\n     */\n    @Override\n    public Optional\u003cString\u003e describeConstable() {\n        return Optional.of(this);\n    }\n\n    /**\n     * Resolves this instance as a {@link ConstantDesc}, the result of which is\n     * the instance itself.\n     *\n     * @param lookup ignored\n     * @return the {@linkplain String} instance\n     * @since 12\n     */\n    @Override\n    public String resolveConstantDesc(MethodHandles.Lookup lookup) {\n        return this;\n    }\n\n}\n"
    }
  }
}
java.lang.IllegalArgumentException: Illegal character in opaque part at index 188: jar:file:///C:/Users/Vinicius/AppData/Local/Coursier/cache/arc/https/github.com/adoptium/temurin17-binaries/releases/download/jdk-17%2B35/OpenJDK17-jdk_x64_windows_hotspot_17_35.zip/jdk-17 35/lib/src.zip!/java.base/java/lang/String.java
	at java.base/java.net.URI.create(URI.java:906)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:178)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.$anonfun$toAbsolutePath$3(MtagsEnrichments.scala:175)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.withTryDecode$1(MtagsEnrichments.scala:153)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:175)
	at scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:756)
	at scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:753)
	at scala.meta.internal.metals.WorkspaceLspService.didOpen(WorkspaceLspService.scala:388)
	at scala.meta.metals.lsp.DelegatingScalaService.didOpen(DelegatingScalaService.scala:39)
	at jdk.internal.reflect.GeneratedMethodAccessor31.invoke(Unknown Source)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:568)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$recursiveFindRpcMethods$0(GenericEndpoint.java:65)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.notify(GenericEndpoint.java:160)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleNotification(RemoteEndpoint.java:231)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:198)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:185)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:97)
	at org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:114)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:539)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.base/java.lang.Thread.run(Thread.java:833)
Caused by: java.net.URISyntaxException: Illegal character in opaque part at index 188: jar:file:///C:/Users/Vinicius/AppData/Local/Coursier/cache/arc/https/github.com/adoptium/temurin17-binaries/releases/download/jdk-17%2B35/OpenJDK17-jdk_x64_windows_hotspot_17_35.zip/jdk-17 35/lib/src.zip!/java.base/java/lang/String.java
	at java.base/java.net.URI$Parser.fail(URI.java:2974)
	at java.base/java.net.URI$Parser.checkChars(URI.java:3145)
	at java.base/java.net.URI$Parser.parse(URI.java:3181)
	at java.base/java.net.URI.<init>(URI.java:623)
	at java.base/java.net.URI.create(URI.java:904)
	... 23 more

jul. 19, 2024 12:55:34 AM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleNotification
ADVERTÊNCIA: Notification threw an exception: {
  "jsonrpc": "2.0",
  "method": "textDocument/didClose",
  "params": {
    "textDocument": {
      "uri": "jar:file%3A///C%3A/Users/Vinicius/AppData/Local/Coursier/cache/arc/https/github.com/adoptium/temurin17-binaries/releases/download/jdk-17%25252B35/OpenJDK17-jdk_x64_windows_hotspot_17_35.zip/jdk-17%2B35/lib/src.zip%21/java.base/java/lang/String.java"
    }
  }
}
java.lang.IllegalArgumentException: Illegal character in opaque part at index 188: jar:file:///C:/Users/Vinicius/AppData/Local/Coursier/cache/arc/https/github.com/adoptium/temurin17-binaries/releases/download/jdk-17%2B35/OpenJDK17-jdk_x64_windows_hotspot_17_35.zip/jdk-17 35/lib/src.zip!/java.base/java/lang/String.java
	at java.base/java.net.URI.create(URI.java:906)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:178)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.$anonfun$toAbsolutePath$3(MtagsEnrichments.scala:175)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.withTryDecode$1(MtagsEnrichments.scala:153)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:175)
	at scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:756)
	at scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:753)
	at scala.meta.internal.metals.WorkspaceLspService.didClose(WorkspaceLspService.scala:407)
	at scala.meta.metals.lsp.DelegatingScalaService.didClose(DelegatingScalaService.scala:53)
	at jdk.internal.reflect.GeneratedMethodAccessor32.invoke(Unknown Source)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:568)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$recursiveFindRpcMethods$0(GenericEndpoint.java:65)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.notify(GenericEndpoint.java:160)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleNotification(RemoteEndpoint.java:231)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:198)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:185)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:97)
	at org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:114)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:539)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.base/java.lang.Thread.run(Thread.java:833)
Caused by: java.net.URISyntaxException: Illegal character in opaque part at index 188: jar:file:///C:/Users/Vinicius/AppData/Local/Coursier/cache/arc/https/github.com/adoptium/temurin17-binaries/releases/download/jdk-17%2B35/OpenJDK17-jdk_x64_windows_hotspot_17_35.zip/jdk-17 35/lib/src.zip!/java.base/java/lang/String.java
	at java.base/java.net.URI$Parser.fail(URI.java:2974)
	at java.base/java.net.URI$Parser.checkChars(URI.java:3145)
	at java.base/java.net.URI$Parser.parse(URI.java:3181)
	at java.base/java.net.URI.<init>(URI.java:623)
	at java.base/java.net.URI.create(URI.java:904)
	... 23 more

2024.07.19 00:55:38 INFO  compiling root-test (1 scala source)
2024.07.19 00:55:39 INFO  time: compiled root-test in 1.14s
jul. 19, 2024 12:55:40 AM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
ADVERTÊNCIA: Unmatched cancel notification for request id 6286
2024.07.19 00:56:00 WARN  Using indexes to guess the definition of run
2024.07.19 00:56:01 INFO  compiling root-test (1 scala source)
2024.07.19 00:56:02 INFO  time: compiled root-test in 1.28s
2024.07.19 00:56:10 INFO  compiling root-test (1 scala source)
2024.07.19 00:56:11 INFO  time: compiled root-test in 1.06s
2024.07.19 00:56:43 INFO  compiling root-test (1 scala source)
2024.07.19 00:56:43 INFO  Deduplicating compilation of root-test from bsp client 'Metals 1.3.3' (since 51m 7.404s)
2024.07.19 00:56:43 INFO  compiling root-test (1 scala source)
2024.07.19 00:56:44 INFO  time: compiled root-test in 0.6s
2024.07.19 00:56:47 INFO  compiling root-test (1 scala source)
2024.07.19 00:56:48 INFO  time: compiled root-test in 1.11s
jul. 19, 2024 12:58:25 AM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
ADVERTÊNCIA: Unmatched cancel notification for request id 6584
jul. 19, 2024 12:58:28 AM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
ADVERTÊNCIA: Unmatched cancel notification for request id 6592
jul. 19, 2024 12:58:35 AM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
ADVERTÊNCIA: Unmatched cancel notification for request id 6607
jul. 19, 2024 12:58:38 AM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
ADVERTÊNCIA: Unmatched cancel notification for request id 6615
jul. 19, 2024 12:58:39 AM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
ADVERTÊNCIA: Unmatched cancel notification for request id 6623
jul. 19, 2024 12:58:58 AM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
ADVERTÊNCIA: Unmatched cancel notification for request id 6655
2024.07.19 01:01:35 INFO  compiling root (1 scala source)
2024.07.19 01:01:35 INFO  time: compiled root in 0.91s
jul. 19, 2024 1:03:38 AM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
ADVERTÊNCIA: Unmatched cancel notification for request id 6800
jul. 19, 2024 1:03:57 AM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
ADVERTÊNCIA: Unmatched cancel notification for request id 6817
jul. 19, 2024 1:04:00 AM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
ADVERTÊNCIA: Unmatched cancel notification for request id 6830
jul. 19, 2024 1:04:01 AM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
ADVERTÊNCIA: Unmatched cancel notification for request id 6838
jul. 19, 2024 1:04:08 AM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
ADVERTÊNCIA: Unmatched cancel notification for request id 6847
jul. 19, 2024 1:04:29 AM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
ADVERTÊNCIA: Unmatched cancel notification for request id 6858
jul. 19, 2024 1:04:30 AM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
ADVERTÊNCIA: Unmatched cancel notification for request id 6866
jul. 19, 2024 1:04:32 AM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
ADVERTÊNCIA: Unmatched cancel notification for request id 6874
jul. 19, 2024 1:04:56 AM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
ADVERTÊNCIA: Unmatched cancel notification for request id 6916
jul. 19, 2024 1:05:04 AM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
ADVERTÊNCIA: Unmatched cancel notification for request id 6933
2024.07.19 01:05:06 INFO  compiling root (1 scala source)
2024.07.19 01:05:06 INFO  time: compiled root in 0.91s
2024.07.19 01:05:42 INFO  compiling root-test (1 scala source)
2024.07.19 01:05:42 INFO  time: compiled root-test in 0.27s
2024.07.19 01:05:44 INFO  Can not organize imports if file has error
2024.07.19 01:05:45 INFO  compiling root-test (1 scala source)
2024.07.19 01:05:45 INFO  time: compiled root-test in 0.26s
2024.07.19 01:05:48 INFO  Can not organize imports if file has error
2024.07.19 01:05:48 INFO  compiling root-test (1 scala source)
2024.07.19 01:05:50 INFO  time: compiled root-test in 1.5s
2024.07.19 01:06:06 INFO  compiling root-test (1 scala source)
2024.07.19 01:06:06 INFO  time: compiled root-test in 0.26s
jul. 19, 2024 1:06:11 AM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
ADVERTÊNCIA: Unmatched cancel notification for request id 7122
jul. 19, 2024 1:06:34 AM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
ADVERTÊNCIA: Unmatched cancel notification for request id 7136
jul. 19, 2024 1:06:42 AM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
ADVERTÊNCIA: Unmatched cancel notification for request id 7146
2024.07.19 01:06:42 INFO  compiling root-test (1 scala source)
2024.07.19 01:06:42 INFO  time: compiled root-test in 0.31s
jul. 19, 2024 1:06:50 AM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
ADVERTÊNCIA: Unmatched cancel notification for request id 7158
jul. 19, 2024 1:06:51 AM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
ADVERTÊNCIA: Unmatched cancel notification for request id 7166
jul. 19, 2024 1:06:51 AM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
ADVERTÊNCIA: Unmatched cancel notification for request id 7174
2024.07.19 01:06:59 INFO  compiling root-test (1 scala source)
2024.07.19 01:06:59 INFO  time: compiled root-test in 0.29s
2024.07.19 01:07:07 INFO  Can not organize imports if file has error
2024.07.19 01:07:07 INFO  compiling root-test (1 scala source)
2024.07.19 01:07:07 INFO  time: compiled root-test in 0.26s
2024.07.19 01:07:14 INFO  Can not organize imports if file has error
2024.07.19 01:07:14 INFO  compiling root-test (1 scala source)
2024.07.19 01:07:14 INFO  time: compiled root-test in 0.3s
2024.07.19 01:07:17 INFO  Can not organize imports if file has error
2024.07.19 01:07:17 INFO  compiling root-test (1 scala source)
2024.07.19 01:07:17 INFO  time: compiled root-test in 0.28s
2024.07.19 01:07:22 INFO  Can not organize imports if file has error
2024.07.19 01:07:22 INFO  compiling root-test (1 scala source)
2024.07.19 01:07:23 INFO  time: compiled root-test in 1.38s
2024.07.19 01:07:26 INFO  compiling root-test (1 scala source)
2024.07.19 01:07:27 INFO  time: compiled root-test in 1.22s
jul. 19, 2024 1:07:35 AM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
ADVERTÊNCIA: Unmatched cancel notification for request id 7380
jul. 19, 2024 1:07:40 AM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
ADVERTÊNCIA: Unmatched cancel notification for request id 7388
2024.07.19 01:07:48 INFO  compiling root-test (1 scala source)
2024.07.19 01:07:48 INFO  time: compiled root-test in 0.29s
2024.07.19 01:07:57 INFO  Can not organize imports if file has error
2024.07.19 01:08:06 INFO  compiling root-test (1 scala source)
2024.07.19 01:08:06 INFO  time: compiled root-test in 0.34s
2024.07.19 01:08:10 WARN  Using indexes to guess the definition of eval
2024.07.19 01:08:10 INFO  Can not organize imports if file has error
2024.07.19 01:08:10 INFO  compiling root-test (1 scala source)
2024.07.19 01:08:10 INFO  time: compiled root-test in 0.3s
2024.07.19 01:08:30 INFO  Can not organize imports if file has error
2024.07.19 01:08:30 INFO  compiling root-test (1 scala source)
2024.07.19 01:08:31 INFO  time: compiled root-test in 1.4s
2024.07.19 01:08:49 INFO  compiling root-test (1 scala source)
2024.07.19 01:08:49 INFO  time: compiled root-test in 0.26s
jul. 19, 2024 1:09:31 AM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
ADVERTÊNCIA: Unmatched cancel notification for request id 7586
jul. 19, 2024 1:09:39 AM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
ADVERTÊNCIA: Unmatched cancel notification for request id 7598
2024.07.19 01:09:39 INFO  compiling root-test (1 scala source)
2024.07.19 01:09:39 INFO  time: compiled root-test in 0.33s
jul. 19, 2024 1:10:09 AM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
ADVERTÊNCIA: Unmatched cancel notification for request id 7634
jul. 19, 2024 1:10:12 AM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
ADVERTÊNCIA: Unmatched cancel notification for request id 7642
2024.07.19 01:10:12 INFO  compiling root-test (1 scala source)
2024.07.19 01:10:12 INFO  time: compiled root-test in 0.35s
2024.07.19 01:10:18 INFO  Can not organize imports if file has error
2024.07.19 01:10:18 INFO  compiling root-test (1 scala source)
2024.07.19 01:10:18 INFO  time: compiled root-test in 0.3s
jul. 19, 2024 1:10:28 AM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
ADVERTÊNCIA: Unmatched cancel notification for request id 7677
2024.07.19 01:10:37 INFO  compiling root-test (1 scala source)
2024.07.19 01:10:37 INFO  time: compiled root-test in 0.38s
2024.07.19 01:10:43 INFO  Can not organize imports if file has error
2024.07.19 01:10:43 WARN  Using indexes to guess the definition of get
2024.07.19 01:10:43 INFO  compiling root-test (1 scala source)
2024.07.19 01:10:43 INFO  time: compiled root-test in 0.29s
2024.07.19 01:11:08 INFO  Can not organize imports if file has error
2024.07.19 01:11:08 INFO  compiling root-test (1 scala source)
2024.07.19 01:11:08 INFO  time: compiled root-test in 0.28s
2024.07.19 01:11:19 INFO  Can not organize imports if file has error
2024.07.19 01:11:19 INFO  compiling root-test (1 scala source)
2024.07.19 01:11:19 INFO  time: compiled root-test in 0.25s
2024.07.19 01:11:24 INFO  Can not organize imports if file has error
2024.07.19 01:11:24 INFO  compiling root-test (1 scala source)
2024.07.19 01:11:24 INFO  time: compiled root-test in 0.29s
2024.07.19 01:11:47 INFO  Can not organize imports if file has error
2024.07.19 01:11:47 INFO  compiling root-test (1 scala source)
2024.07.19 01:11:47 INFO  time: compiled root-test in 0.28s
2024.07.19 01:12:07 INFO  Can not organize imports if file has error
2024.07.19 01:12:07 INFO  compiling root-test (1 scala source)
2024.07.19 01:12:07 INFO  time: compiled root-test in 0.27s
jul. 19, 2024 1:12:11 AM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
ADVERTÊNCIA: Unmatched cancel notification for request id 7945
2024.07.19 01:12:12 INFO  Can not organize imports if file has error
2024.07.19 01:12:12 INFO  compiling root-test (1 scala source)
2024.07.19 01:12:12 INFO  time: compiled root-test in 0.3s
2024.07.19 01:12:26 INFO  compiling root (1 scala source)
2024.07.19 01:12:26 INFO  time: compiled root in 0.98s
jul. 19, 2024 1:12:29 AM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
ADVERTÊNCIA: Unmatched cancel notification for request id 8036
2024.07.19 01:12:36 INFO  compiling root (1 scala source)
2024.07.19 01:12:36 INFO  time: compiled root in 0.18s
jul. 19, 2024 1:12:48 AM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
ADVERTÊNCIA: Unmatched cancel notification for request id 8089
jul. 19, 2024 1:12:50 AM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
ADVERTÊNCIA: Unmatched cancel notification for request id 8097
2024.07.19 01:13:01 INFO  compiling root (1 scala source)
2024.07.19 01:13:01 INFO  time: compiled root in 0.27s
2024.07.19 01:13:04 INFO  compiling root (1 scala source)
2024.07.19 01:13:04 INFO  time: compiled root in 0.23s
jul. 19, 2024 1:13:30 AM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
ADVERTÊNCIA: Unmatched cancel notification for request id 8344
jul. 19, 2024 1:13:31 AM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
ADVERTÊNCIA: Unmatched cancel notification for request id 8352
2024.07.19 01:13:32 INFO  compiling root (2 scala sources)
2024.07.19 01:13:32 INFO  time: compiled root in 0.19s
jul. 19, 2024 1:13:37 AM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
ADVERTÊNCIA: Unmatched cancel notification for request id 8392
2024.07.19 01:13:49 INFO  compiling root (2 scala sources)
2024.07.19 01:13:49 INFO  time: compiled root in 0.28s
2024.07.19 01:14:01 INFO  compiling root (2 scala sources)
2024.07.19 01:14:01 INFO  time: compiled root in 0.24s
2024.07.19 01:14:11 INFO  Can not organize imports if file has error
2024.07.19 01:14:11 INFO  compiling root (2 scala sources)
2024.07.19 01:14:11 INFO  time: compiled root in 0.21s
jul. 19, 2024 1:14:46 AM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
ADVERTÊNCIA: Unmatched cancel notification for request id 8615
2024.07.19 01:15:17 WARN  Using indexes to guess the definition of A
jul. 19, 2024 1:15:25 AM scala.meta.internal.pc.CompilerAccess handleError
GRAVE: A severe compiler error occurred, full details of the error can be found in the error report C:\Users\Vinicius\UnB\FLanguage\.metals\.reports\metals-full\2024-07-19\r_compiler-error_(root)_01-15-25-499.md
2024.07.19 01:15:25 ERROR TextDocument.uri not found: src/main/scala/br/unb/cic/flang/MonadState.scala
scala.meta.internal.metals.ScalafixProvider$ScalafixRunException: TextDocument.uri not found: src/main/scala/br/unb/cic/flang/MonadState.scala
	at scala.meta.internal.metals.ScalafixProvider.$anonfun$runScalafixRules$2(ScalafixProvider.scala:130)
	at scala.concurrent.impl.Promise$Transformation.run(Promise.scala:470)
	at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.lang.Thread.run(Thread.java:833)

jul. 19, 2024 1:15:25 AM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint fallbackResponseError
GRAVE: Internal error: scala.meta.internal.metals.ScalafixProvider$ScalafixRunException: TextDocument.uri not found: src/main/scala/br/unb/cic/flang/MonadState.scala
java.util.concurrent.CompletionException: scala.meta.internal.metals.ScalafixProvider$ScalafixRunException: TextDocument.uri not found: src/main/scala/br/unb/cic/flang/MonadState.scala
	at java.base/java.util.concurrent.CompletableFuture.encodeThrowable(CompletableFuture.java:332)
	at java.base/java.util.concurrent.CompletableFuture.completeThrowable(CompletableFuture.java:347)
	at java.base/java.util.concurrent.CompletableFuture$UniAccept.tryFire(CompletableFuture.java:708)
	at java.base/java.util.concurrent.CompletableFuture.postComplete(CompletableFuture.java:510)
	at java.base/java.util.concurrent.CompletableFuture.completeExceptionally(CompletableFuture.java:2162)
	at scala.meta.internal.metals.CancelTokens$.$anonfun$future$1(CancelTokens.scala:40)
	at scala.meta.internal.metals.CancelTokens$.$anonfun$future$1$adapted(CancelTokens.scala:38)
	at scala.concurrent.impl.Promise$Transformation.run(Promise.scala:484)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.base/java.lang.Thread.run(Thread.java:833)
Caused by: scala.meta.internal.metals.ScalafixProvider$ScalafixRunException: TextDocument.uri not found: src/main/scala/br/unb/cic/flang/MonadState.scala
	at scala.meta.internal.metals.ScalafixProvider.$anonfun$runScalafixRules$2(ScalafixProvider.scala:130)
	at scala.concurrent.impl.Promise$Transformation.run(Promise.scala:470)
	... 3 more

2024.07.19 01:15:25 INFO  compiling root (2 scala sources)
2024.07.19 01:15:25 INFO  time: compiled root in 0.14s
2024.07.19 01:15:31 INFO  Can not organize imports if file has error
2024.07.19 01:15:31 INFO  compiling root (2 scala sources)
2024.07.19 01:15:31 INFO  time: compiled root in 0.15s
2024.07.19 01:15:34 INFO  Can not organize imports if file has error
2024.07.19 01:15:34 INFO  compiling root (2 scala sources)
2024.07.19 01:15:34 INFO  time: compiled root in 0.21s
2024.07.19 01:16:33 INFO  compiling root (2 scala sources)
2024.07.19 01:16:33 INFO  time: compiled root in 0.2s
2024.07.19 01:16:47 INFO  compiling root (2 scala sources)
2024.07.19 01:16:47 INFO  time: compiled root in 0.24s
2024.07.19 01:16:51 INFO  Can not organize imports if file has error
2024.07.19 01:16:51 INFO  compiling root (2 scala sources)
2024.07.19 01:16:51 INFO  time: compiled root in 0.27s
jul. 19, 2024 1:16:52 AM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
ADVERTÊNCIA: Unmatched cancel notification for request id 8937
jul. 19, 2024 1:16:54 AM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
ADVERTÊNCIA: Unmatched cancel notification for request id 8945
2024.07.19 01:16:54 INFO  compiling root (2 scala sources)
2024.07.19 01:16:54 INFO  time: compiled root in 0.32s
jul. 19, 2024 1:16:56 AM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
ADVERTÊNCIA: Unmatched cancel notification for request id 8955
2024.07.19 01:16:56 INFO  compiling root (2 scala sources)
2024.07.19 01:16:56 INFO  time: compiled root in 0.33s
2024.07.19 01:17:11 INFO  compiling root (2 scala sources)
2024.07.19 01:17:11 INFO  time: compiled root in 0.2s
2024.07.19 01:17:14 INFO  compiling root (2 scala sources)
2024.07.19 01:17:14 INFO  time: compiled root in 0.31s
2024.07.19 01:17:18 INFO  compiling root (2 scala sources)
2024.07.19 01:17:18 INFO  time: compiled root in 0.24s
jul. 19, 2024 1:17:31 AM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
ADVERTÊNCIA: Unmatched cancel notification for request id 9072
2024.07.19 01:17:31 INFO  compiling root (2 scala sources)
2024.07.19 01:17:31 INFO  time: compiled root in 0.3s
jul. 19, 2024 1:17:32 AM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
ADVERTÊNCIA: Unmatched cancel notification for request id 9080
2024.07.19 01:17:39 INFO  compiling root (2 scala sources)
2024.07.19 01:17:39 INFO  time: compiled root in 0.25s
2024.07.19 01:17:46 INFO  compiling root (2 scala sources)
2024.07.19 01:17:46 INFO  time: compiled root in 0.23s
2024.07.19 01:17:47 INFO  compiling root (2 scala sources)
2024.07.19 01:17:47 INFO  time: compiled root in 0.27s
2024.07.19 01:17:48 INFO  compiling root (2 scala sources)
2024.07.19 01:17:48 INFO  time: compiled root in 0.23s
2024.07.19 01:36:11 INFO  Shutting down server
2024.07.19 01:36:11 INFO  shutting down Metals
2024.07.19 01:36:11 INFO  Shut down connection with build server.
2024.07.19 01:36:11 INFO  Shut down connection with build server.
2024.07.19 01:36:11 INFO  Shut down connection with build server.
2024.07.19 01:36:11 INFO  Exiting server
2024.07.19 12:22:22 INFO  Started: Metals version 1.3.3 in folders 'C:\Users\Vinicius\UnB\FLanguage' for client Visual Studio Code 1.91.1.
SLF4J(W): Class path contains multiple SLF4J providers.
SLF4J(W): Found provider [scribe.slf4j.ScribeServiceProvider@72499c44]
SLF4J(W): Found provider [ch.qos.logback.classic.spi.LogbackServiceProvider@6420369]
SLF4J(W): See https://www.slf4j.org/codes.html#multiple_bindings for an explanation.
SLF4J(I): Actual provider is of type [scribe.slf4j.ScribeServiceProvider@72499c44]
2024.07.19 12:22:23 WARN  Flyway upgrade recommended: H2 2.2.224 is newer than this version of Flyway and support has not been tested. The latest supported version of H2 is 2.2.220.
2024.07.19 12:22:25 INFO  no build target found for C:\Users\Vinicius\UnB\FLanguage\src\main\scala\br\unb\cic\flang\MonadState.scala. Using presentation compiler with project's scala-library version: 3.3.3
2024.07.19 12:22:25 INFO  no build target found for C:\Users\Vinicius\UnB\FLanguage\src\main\scala\br\unb\cic\flang\MonadState.scala. Using presentation compiler with project's scala-library version: 3.3.3
2024.07.19 12:22:25 INFO  Attempting to connect to the build server...
2024.07.19 12:22:29 INFO  no build target found for C:\Users\Vinicius\UnB\FLanguage\src\main\scala\br\unb\cic\flang\MonadState.scala. Using presentation compiler with project's scala-library version: 3.3.3
2024.07.19 12:22:29 INFO  no build target found for C:\Users\Vinicius\UnB\FLanguage\src\main\scala\br\unb\cic\flang\MonadState.scala. Using presentation compiler with project's scala-library version: 3.3.3
2024.07.19 12:22:29 INFO  no build target found for C:\Users\Vinicius\UnB\FLanguage\src\main\scala\br\unb\cic\flang\MonadState.scala. Using presentation compiler with project's scala-library version: 3.3.3
2024.07.19 12:22:31 INFO  no build target found for C:\Users\Vinicius\UnB\FLanguage\src\main\scala\br\unb\cic\flang\MonadState.scala. Using presentation compiler with project's scala-library version: 3.3.3
2024.07.19 12:22:31 INFO  no build target found for C:\Users\Vinicius\UnB\FLanguage\src\main\scala\br\unb\cic\flang\MonadState.scala. Using presentation compiler with project's scala-library version: 3.3.3
2024.07.19 12:22:31 INFO  no build target found for C:\Users\Vinicius\UnB\FLanguage\src\main\scala\br\unb\cic\flang\MonadState.scala. Using presentation compiler with project's scala-library version: 3.3.3
2024.07.19 12:22:31 INFO  no build target found for C:\Users\Vinicius\UnB\FLanguage\src\main\scala\br\unb\cic\flang\MonadState.scala. Using presentation compiler with project's scala-library version: 3.3.3
2024.07.19 12:22:32 INFO  no build target found for C:\Users\Vinicius\UnB\FLanguage\src\main\scala\br\unb\cic\flang\MonadState.scala. Using presentation compiler with project's scala-library version: 3.3.3
2024.07.19 12:22:34 INFO  no build target found for C:\Users\Vinicius\UnB\FLanguage\src\main\scala\br\unb\cic\flang\MonadState.scala. Using presentation compiler with project's scala-library version: 3.3.3
2024.07.19 12:22:34 INFO  no build target found for C:\Users\Vinicius\UnB\FLanguage\src\main\scala\br\unb\cic\flang\MonadState.scala. Using presentation compiler with project's scala-library version: 3.3.3
2024.07.19 12:22:34 INFO  no build target found for C:\Users\Vinicius\UnB\FLanguage\src\main\scala\br\unb\cic\flang\MonadState.scala. Using presentation compiler with project's scala-library version: 3.3.3
2024.07.19 12:22:36 INFO  no build target found for C:\Users\Vinicius\UnB\FLanguage\src\main\scala\br\unb\cic\flang\MonadState.scala. Using presentation compiler with project's scala-library version: 3.3.3
2024.07.19 12:22:37 INFO  tracing is disabled for protocol BSP, to enable tracing of incoming and outgoing JSON messages create an empty file at C:\Users\Vinicius\UnB\FLanguage\.metals\bsp.trace.json or C:\Users\Vinicius\AppData\Local\scalameta\metals\cache\bsp.trace.json
2024.07.19 12:22:37 INFO  time: Connected to build server in 12s
2024.07.19 12:22:37 INFO  Connected to Build server: Bloop v1.6.0
2024.07.19 12:22:38 INFO  time: Imported build in 0.22s
2024.07.19 12:22:37 INFO  running doctor check
2024.07.19 12:22:37 INFO  java targets: root-test, root
2024.07.19 12:22:44 WARN  Flyway upgrade recommended: H2 2.2.224 is newer than this version of Flyway and support has not been tested. The latest supported version of H2 is 2.2.220.
2024.07.19 12:22:49 INFO  time: indexed workspace in 11s
2024.07.19 12:22:51 INFO  compiling root (2 scala sources)
2024.07.19 12:22:52 INFO  compiling root (2 scala sources)
2024.07.19 12:22:52 INFO  time: compiled root in 0.99s
2024.07.19 12:22:53 INFO  compiling root (2 scala sources)
2024.07.19 12:22:53 WARN  Could not load snapshot text for C:\Users\Vinicius\UnB\FLanguage\src\main\scala\br\unb\cic\flang\MonadState.scala
2024.07.19 12:22:53 WARN  Could not load snapshot text for C:\Users\Vinicius\UnB\FLanguage\src\main\scala\br\unb\cic\flang\MonadState.scala
2024.07.19 12:22:53 INFO  time: compiled root in 0.22s
2024.07.19 12:22:53 INFO  compiling root (2 scala sources)
2024.07.19 12:22:53 INFO  time: compiled root in 0.19s
2024.07.19 12:22:54 WARN  Could not load snapshot text for C:\Users\Vinicius\UnB\FLanguage\src\main\scala\br\unb\cic\flang\MonadState.scala
2024.07.19 12:22:54 WARN  Could not load snapshot text for C:\Users\Vinicius\UnB\FLanguage\src\main\scala\br\unb\cic\flang\MonadState.scala
2024.07.19 12:22:54 INFO  Can not organize imports if file has error
2024.07.19 12:22:54 INFO  compiling root (2 scala sources)
2024.07.19 12:22:55 INFO  time: compiled root in 1.18s
2024.07.19 12:22:55 INFO  compiling root (2 scala sources)
2024.07.19 12:22:55 INFO  time: compiled root in 0.46s
2024.07.19 12:23:43 INFO  compiling root (2 scala sources)
2024.07.19 12:23:43 INFO  time: compiled root in 0.73s
jul. 19, 2024 12:24:13 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
ADVERTÊNCIA: Unmatched cancel notification for request id 172
jul. 19, 2024 12:24:13 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
ADVERTÊNCIA: Unmatched cancel notification for request id 175
jul. 19, 2024 12:24:13 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
ADVERTÊNCIA: Unmatched cancel notification for request id 177
2024.07.19 12:24:25 INFO  compiling root (2 scala sources)
2024.07.19 12:24:25 INFO  time: compiled root in 0.43s
jul. 19, 2024 12:24:31 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
ADVERTÊNCIA: Unmatched cancel notification for request id 308
2024.07.19 12:24:32 INFO  Can not organize imports if file has error
2024.07.19 12:24:32 INFO  compiling root (2 scala sources)
2024.07.19 12:24:32 INFO  time: compiled root in 0.49s
2024.07.19 12:24:36 INFO  compiling root (2 scala sources)
2024.07.19 12:24:36 INFO  time: compiled root in 0.86s
2024.07.19 12:24:40 WARN  Using indexes to guess the definition of initialState
Exception in thread "pool-8-thread-1" java.lang.InterruptedException
	at scala.meta.internal.metals.FutureCancelToken.checkCanceled(FutureCancelToken.scala:29)
	at scala.meta.internal.pc.CompilerAccess.$anonfun$onCompilerJobQueue$1(CompilerAccess.scala:243)
	at scala.meta.internal.pc.CompilerJobQueue$Job.run(CompilerJobQueue.scala:152)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.base/java.lang.Thread.run(Thread.java:833)
2024.07.19 12:24:50 INFO  compiling root (2 scala sources)
2024.07.19 12:24:50 INFO  time: compiled root in 0.36s
jul. 19, 2024 12:24:51 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
ADVERTÊNCIA: Unmatched cancel notification for request id 380
jul. 19, 2024 12:24:52 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
ADVERTÊNCIA: Unmatched cancel notification for request id 387
jul. 19, 2024 12:24:58 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
ADVERTÊNCIA: Unmatched cancel notification for request id 395
2024.07.19 12:24:58 INFO  compiling root (2 scala sources)
2024.07.19 12:24:58 INFO  time: compiled root in 0.45s
jul. 19, 2024 12:24:59 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
ADVERTÊNCIA: Unmatched cancel notification for request id 403
jul. 19, 2024 12:25:01 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
ADVERTÊNCIA: Unmatched cancel notification for request id 410
2024.07.19 12:25:01 INFO  compiling root (2 scala sources)
2024.07.19 12:25:01 INFO  time: compiled root in 0.41s
jul. 19, 2024 12:25:04 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
ADVERTÊNCIA: Unmatched cancel notification for request id 418
2024.07.19 12:25:04 INFO  compiling root (2 scala sources)
2024.07.19 12:25:04 INFO  time: compiled root in 0.51s
jul. 19, 2024 12:25:05 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
ADVERTÊNCIA: Unmatched cancel notification for request id 426
2024.07.19 12:25:10 WARN  Could not load snapshot text for C:\Users\Vinicius\UnB\FLanguage\src\main\scala\br\unb\cic\flang\MonadState.scala
2024.07.19 12:25:10 WARN  Could not load snapshot text for C:\Users\Vinicius\UnB\FLanguage\src\main\scala\br\unb\cic\flang\MonadState.scala
2024.07.19 12:25:10 INFO  compiling root (2 scala sources)
2024.07.19 12:25:10 INFO  time: compiled root in 0.37s
2024.07.19 12:25:17 INFO  compiling root (2 scala sources)
2024.07.19 12:25:17 INFO  time: compiled root in 0.38s
2024.07.19 12:25:19 INFO  compiling root (2 scala sources)
2024.07.19 12:25:19 INFO  time: compiled root in 0.26s
jul. 19, 2024 12:25:19 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
ADVERTÊNCIA: Unmatched cancel notification for request id 472
2024.07.19 12:25:19 INFO  compiling root (2 scala sources)
2024.07.19 12:25:19 INFO  time: compiled root in 0.32s
2024.07.19 12:25:25 INFO  compiling root (2 scala sources)
2024.07.19 12:25:25 INFO  time: compiled root in 0.26s
jul. 19, 2024 12:25:40 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
ADVERTÊNCIA: Unmatched cancel notification for request id 510
jul. 19, 2024 12:25:40 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
ADVERTÊNCIA: Unmatched cancel notification for request id 509
jul. 19, 2024 12:25:40 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
ADVERTÊNCIA: Unmatched cancel notification for request id 515
jul. 19, 2024 12:25:40 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
ADVERTÊNCIA: Unmatched cancel notification for request id 516
jul. 19, 2024 12:25:40 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
ADVERTÊNCIA: Unmatched cancel notification for request id 512
jul. 19, 2024 12:25:40 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
ADVERTÊNCIA: Unmatched cancel notification for request id 520
2024.07.19 12:25:43 INFO  compiling root (2 scala sources)
2024.07.19 12:25:43 INFO  time: compiled root in 0.25s
jul. 19, 2024 12:26:18 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
ADVERTÊNCIA: Unmatched cancel notification for request id 574
2024.07.19 12:26:18 INFO  compiling root (2 scala sources)
jul. 19, 2024 12:26:18 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
ADVERTÊNCIA: Unmatched cancel notification for request id 578
jul. 19, 2024 12:26:18 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
ADVERTÊNCIA: Unmatched cancel notification for request id 579
2024.07.19 12:26:18 INFO  time: compiled root in 0.33s
jul. 19, 2024 12:26:20 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
ADVERTÊNCIA: Unmatched cancel notification for request id 587
jul. 19, 2024 12:26:21 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
ADVERTÊNCIA: Unmatched cancel notification for request id 594
jul. 19, 2024 12:26:22 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
ADVERTÊNCIA: Unmatched cancel notification for request id 601
2024.07.19 12:26:22 INFO  compiling root (2 scala sources)
2024.07.19 12:26:22 INFO  time: compiled root in 0.26s
jul. 19, 2024 12:26:25 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
ADVERTÊNCIA: Unmatched cancel notification for request id 611
2024.07.19 12:26:25 INFO  compiling root (2 scala sources)
2024.07.19 12:26:25 INFO  time: compiled root in 0.36s
jul. 19, 2024 12:26:35 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
ADVERTÊNCIA: Unmatched cancel notification for request id 681
jul. 19, 2024 12:27:05 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
ADVERTÊNCIA: Unmatched cancel notification for request id 820
jul. 19, 2024 12:27:07 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
ADVERTÊNCIA: Unmatched cancel notification for request id 827
jul. 19, 2024 12:27:08 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
ADVERTÊNCIA: Unmatched cancel notification for request id 834
jul. 19, 2024 12:27:12 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
ADVERTÊNCIA: Unmatched cancel notification for request id 841
jul. 19, 2024 12:27:13 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
ADVERTÊNCIA: Unmatched cancel notification for request id 848
jul. 19, 2024 12:27:16 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
ADVERTÊNCIA: Unmatched cancel notification for request id 855
2024.07.19 12:27:34 WARN  Could not load snapshot text for C:\Users\Vinicius\UnB\FLanguage\src\main\scala\br\unb\cic\flang\MonadState.scala
2024.07.19 12:27:34 WARN  Could not load snapshot text for C:\Users\Vinicius\UnB\FLanguage\src\main\scala\br\unb\cic\flang\MonadState.scala
2024.07.19 12:27:34 WARN  Could not load snapshot text for C:\Users\Vinicius\UnB\FLanguage\src\main\scala\br\unb\cic\flang\MonadState.scala
2024.07.19 12:27:34 WARN  Could not load snapshot text for C:\Users\Vinicius\UnB\FLanguage\src\main\scala\br\unb\cic\flang\MonadState.scala
jul. 19, 2024 12:27:34 PM scala.meta.internal.pc.CompilerAccess handleError
GRAVE: A severe compiler error occurred, full details of the error can be found in the error report C:\Users\Vinicius\UnB\FLanguage\.metals\.reports\metals-full\2024-07-19\r_compiler-error_(root)_12-27-34-304.md
2024.07.19 12:27:34 WARN  Using indexes to guess the definition of pure
2024.07.19 12:27:34 ERROR TextDocument.uri not found: src/main/scala/br/unb/cic/flang/MonadState.scala
scala.meta.internal.metals.ScalafixProvider$ScalafixRunException: TextDocument.uri not found: src/main/scala/br/unb/cic/flang/MonadState.scala
	at scala.meta.internal.metals.ScalafixProvider.$anonfun$runScalafixRules$2(ScalafixProvider.scala:130)
	at scala.concurrent.impl.Promise$Transformation.run(Promise.scala:470)
	at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.lang.Thread.run(Thread.java:833)

jul. 19, 2024 12:27:34 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint fallbackResponseError
GRAVE: Internal error: scala.meta.internal.metals.ScalafixProvider$ScalafixRunException: TextDocument.uri not found: src/main/scala/br/unb/cic/flang/MonadState.scala
java.util.concurrent.CompletionException: scala.meta.internal.metals.ScalafixProvider$ScalafixRunException: TextDocument.uri not found: src/main/scala/br/unb/cic/flang/MonadState.scala
	at java.base/java.util.concurrent.CompletableFuture.encodeThrowable(CompletableFuture.java:332)
	at java.base/java.util.concurrent.CompletableFuture.completeThrowable(CompletableFuture.java:347)
	at java.base/java.util.concurrent.CompletableFuture$UniAccept.tryFire(CompletableFuture.java:708)
	at java.base/java.util.concurrent.CompletableFuture.postComplete(CompletableFuture.java:510)
	at java.base/java.util.concurrent.CompletableFuture.completeExceptionally(CompletableFuture.java:2162)
	at scala.meta.internal.metals.CancelTokens$.$anonfun$future$1(CancelTokens.scala:40)
	at scala.meta.internal.metals.CancelTokens$.$anonfun$future$1$adapted(CancelTokens.scala:38)
	at scala.concurrent.impl.Promise$Transformation.run(Promise.scala:484)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.base/java.lang.Thread.run(Thread.java:833)
Caused by: scala.meta.internal.metals.ScalafixProvider$ScalafixRunException: TextDocument.uri not found: src/main/scala/br/unb/cic/flang/MonadState.scala
	at scala.meta.internal.metals.ScalafixProvider.$anonfun$runScalafixRules$2(ScalafixProvider.scala:130)
	at scala.concurrent.impl.Promise$Transformation.run(Promise.scala:470)
	... 3 more

2024.07.19 12:27:34 INFO  compiling root (2 scala sources)
2024.07.19 12:27:34 INFO  time: compiled root in 0.13s
jul. 19, 2024 12:27:35 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
ADVERTÊNCIA: Unmatched cancel notification for request id 984
2024.07.19 12:27:36 WARN  Could not find semantic tokens for: file:///C:/Users/Vinicius/UnB/FLanguage/src/main/scala/br/unb/cic/flang/MonadState.scala
jul. 19, 2024 12:27:36 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
ADVERTÊNCIA: Unmatched cancel notification for request id 991
jul. 19, 2024 12:27:37 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
ADVERTÊNCIA: Unmatched cancel notification for request id 998
2024.07.19 12:27:37 WARN  Could not find semantic tokens for: file:///C:/Users/Vinicius/UnB/FLanguage/src/main/scala/br/unb/cic/flang/MonadState.scala
jul. 19, 2024 12:27:38 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
ADVERTÊNCIA: Unmatched cancel notification for request id 1005
jul. 19, 2024 12:27:39 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
ADVERTÊNCIA: Unmatched cancel notification for request id 1012
2024.07.19 12:27:39 WARN  Could not find semantic tokens for: file:///C:/Users/Vinicius/UnB/FLanguage/src/main/scala/br/unb/cic/flang/MonadState.scala
jul. 19, 2024 12:27:40 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
ADVERTÊNCIA: Unmatched cancel notification for request id 1022
jul. 19, 2024 12:27:42 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
ADVERTÊNCIA: Unmatched cancel notification for request id 1029
2024.07.19 12:27:43 WARN  Could not find semantic tokens for: file:///C:/Users/Vinicius/UnB/FLanguage/src/main/scala/br/unb/cic/flang/MonadState.scala
jul. 19, 2024 12:27:44 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
ADVERTÊNCIA: Unmatched cancel notification for request id 1036
jul. 19, 2024 12:27:47 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
ADVERTÊNCIA: Unmatched cancel notification for request id 1043
2024.07.19 12:27:47 WARN  Could not find semantic tokens for: file:///C:/Users/Vinicius/UnB/FLanguage/src/main/scala/br/unb/cic/flang/MonadState.scala
2024.07.19 12:27:54 INFO  Can not organize imports if file has error
2024.07.19 12:27:54 INFO  compiling root (2 scala sources)
2024.07.19 12:27:54 INFO  time: compiled root in 0.13s
2024.07.19 12:27:57 INFO  Can not organize imports if file has error
2024.07.19 12:27:57 INFO  compiling root (2 scala sources)
2024.07.19 12:27:57 INFO  time: compiled root in 0.33s
2024.07.19 12:28:12 WARN  Could not load snapshot text for C:\Users\Vinicius\UnB\FLanguage\src\main\scala\br\unb\cic\flang\MonadState.scala
2024.07.19 12:28:22 INFO  Can not organize imports if file has error
2024.07.19 12:28:22 INFO  compiling root (2 scala sources)
2024.07.19 12:28:22 INFO  time: compiled root in 0.21s
2024.07.19 12:28:29 INFO  Can not organize imports if file has error
2024.07.19 12:28:29 INFO  compiling root (2 scala sources)
2024.07.19 12:28:29 INFO  time: compiled root in 0.26s
2024.07.19 12:28:38 WARN  Could not load snapshot text for C:\Users\Vinicius\UnB\FLanguage\src\main\scala\br\unb\cic\flang\Interpreter2.scala
2024.07.19 12:28:40 WARN  Could not load snapshot text for C:\Users\Vinicius\UnB\FLanguage\src\main\scala\br\unb\cic\flang\Interpreter2.scala
2024.07.19 12:28:44 WARN  Could not load snapshot text for C:\Users\Vinicius\UnB\FLanguage\src\main\scala\br\unb\cic\flang\Interpreter2.scala
2024.07.19 12:28:53 WARN  Could not load snapshot text for C:\Users\Vinicius\UnB\FLanguage\src\main\scala\br\unb\cic\flang\MonadState.scala
2024.07.19 12:28:57 INFO  Can not organize imports if file has error
2024.07.19 12:28:57 INFO  compiling root (2 scala sources)
2024.07.19 12:28:57 INFO  time: compiled root in 0.23s
2024.07.19 12:29:00 WARN  Could not load snapshot text for C:\Users\Vinicius\UnB\FLanguage\src\main\scala\br\unb\cic\flang\Interpreter2.scala
2024.07.19 12:29:15 WARN  Could not load snapshot text for C:\Users\Vinicius\UnB\FLanguage\src\main\scala\br\unb\cic\flang\MonadState.scala
2024.07.19 12:29:20 WARN  Could not load snapshot text for C:\Users\Vinicius\UnB\FLanguage\src\main\scala\br\unb\cic\flang\Interpreter2.scala
2024.07.19 12:29:23 WARN  Could not load snapshot text for C:\Users\Vinicius\UnB\FLanguage\src\main\scala\br\unb\cic\flang\Interpreter2.scala
2024.07.19 12:30:53 WARN  Could not load snapshot text for C:\Users\Vinicius\UnB\FLanguage\src\main\scala\br\unb\cic\flang\MonadState.scala
2024.07.19 12:30:57 WARN  Could not load snapshot text for C:\Users\Vinicius\UnB\FLanguage\src\main\scala\br\unb\cic\flang\MonadState.scala
2024.07.19 12:31:00 WARN  Could not load snapshot text for C:\Users\Vinicius\UnB\FLanguage\src\main\scala\br\unb\cic\flang\MonadState.scala
2024.07.19 12:31:06 WARN  Could not load snapshot text for C:\Users\Vinicius\UnB\FLanguage\src\main\scala\br\unb\cic\flang\MonadState.scala
2024.07.19 12:31:08 WARN  Could not load snapshot text for C:\Users\Vinicius\UnB\FLanguage\src\main\scala\br\unb\cic\flang\Interpreter2.scala
2024.07.19 12:31:08 WARN  Could not load snapshot text for C:\Users\Vinicius\UnB\FLanguage\src\main\scala\br\unb\cic\flang\MonadState.scala
2024.07.19 12:31:09 WARN  Could not load snapshot text for C:\Users\Vinicius\UnB\FLanguage\src\main\scala\br\unb\cic\flang\MonadState.scala
2024.07.19 12:31:12 WARN  Could not load snapshot text for C:\Users\Vinicius\UnB\FLanguage\src\main\scala\br\unb\cic\flang\MonadState.scala
2024.07.19 12:31:13 WARN  Could not load snapshot text for C:\Users\Vinicius\UnB\FLanguage\src\main\scala\br\unb\cic\flang\MonadState.scala
2024.07.19 12:31:15 WARN  Could not load snapshot text for C:\Users\Vinicius\UnB\FLanguage\src\main\scala\br\unb\cic\flang\MonadState.scala
2024.07.19 12:31:15 WARN  Could not load snapshot text for C:\Users\Vinicius\UnB\FLanguage\src\main\scala\br\unb\cic\flang\Interpreter2.scala
2024.07.19 12:31:16 WARN  Could not load snapshot text for C:\Users\Vinicius\UnB\FLanguage\src\main\scala\br\unb\cic\flang\MonadState.scala
2024.07.19 12:31:18 WARN  Could not load snapshot text for C:\Users\Vinicius\UnB\FLanguage\src\main\scala\br\unb\cic\flang\MonadState.scala
2024.07.19 12:31:19 WARN  Could not load snapshot text for C:\Users\Vinicius\UnB\FLanguage\src\main\scala\br\unb\cic\flang\MonadState.scala
2024.07.19 12:31:20 WARN  Could not load snapshot text for C:\Users\Vinicius\UnB\FLanguage\src\main\scala\br\unb\cic\flang\MonadState.scala
2024.07.19 12:31:23 WARN  Could not load snapshot text for C:\Users\Vinicius\UnB\FLanguage\src\main\scala\br\unb\cic\flang\MonadState.scala
2024.07.19 12:31:24 WARN  Could not load snapshot text for C:\Users\Vinicius\UnB\FLanguage\src\main\scala\br\unb\cic\flang\MonadState.scala
2024.07.19 12:31:25 WARN  Could not load snapshot text for C:\Users\Vinicius\UnB\FLanguage\src\main\scala\br\unb\cic\flang\MonadState.scala
2024.07.19 12:31:27 WARN  Could not load snapshot text for C:\Users\Vinicius\UnB\FLanguage\src\main\scala\br\unb\cic\flang\MonadState.scala
2024.07.19 12:32:54 WARN  Could not load snapshot text for C:\Users\Vinicius\UnB\FLanguage\src\main\scala\br\unb\cic\flang\MonadState.scala
2024.07.19 12:33:00 WARN  Could not load snapshot text for C:\Users\Vinicius\UnB\FLanguage\src\main\scala\br\unb\cic\flang\MonadState.scala
2024.07.19 12:33:00 WARN  Could not load snapshot text for C:\Users\Vinicius\UnB\FLanguage\src\main\scala\br\unb\cic\flang\MonadState.scala
2024.07.19 12:33:00 WARN  Could not load snapshot text for C:\Users\Vinicius\UnB\FLanguage\src\main\scala\br\unb\cic\flang\MonadState.scala
2024.07.19 12:33:00 WARN  Could not load snapshot text for C:\Users\Vinicius\UnB\FLanguage\src\main\scala\br\unb\cic\flang\MonadState.scala
2024.07.19 12:33:00 WARN  Using indexes to guess the definition of pure
2024.07.19 12:33:01 WARN  Could not load snapshot text for C:\Users\Vinicius\UnB\FLanguage\src\main\scala\br\unb\cic\flang\MonadState.scala
2024.07.19 12:33:02 WARN  Could not load snapshot text for C:\Users\Vinicius\UnB\FLanguage\src\main\scala\br\unb\cic\flang\MonadState.scala
2024.07.19 12:33:03 WARN  Could not load snapshot text for C:\Users\Vinicius\UnB\FLanguage\src\main\scala\br\unb\cic\flang\MonadState.scala
2024.07.19 12:33:03 WARN  Could not load snapshot text for C:\Users\Vinicius\UnB\FLanguage\src\main\scala\br\unb\cic\flang\MonadState.scala
2024.07.19 12:33:04 INFO  Can not organize imports if file has error
2024.07.19 12:33:04 INFO  compiling root (2 scala sources)
2024.07.19 12:33:04 INFO  time: compiled root in 0.27s
2024.07.19 12:33:04 WARN  Could not load snapshot text for C:\Users\Vinicius\UnB\FLanguage\src\main\scala\br\unb\cic\flang\MonadState.scala
2024.07.19 12:33:08 WARN  Could not load snapshot text for C:\Users\Vinicius\UnB\FLanguage\src\main\scala\br\unb\cic\flang\MonadState.scala
2024.07.19 12:33:08 WARN  Could not load snapshot text for C:\Users\Vinicius\UnB\FLanguage\src\main\scala\br\unb\cic\flang\MonadState.scala
2024.07.19 12:33:08 WARN  Could not load snapshot text for C:\Users\Vinicius\UnB\FLanguage\src\main\scala\br\unb\cic\flang\MonadState.scala
2024.07.19 12:33:09 WARN  Could not load snapshot text for C:\Users\Vinicius\UnB\FLanguage\src\main\scala\br\unb\cic\flang\MonadState.scala
2024.07.19 12:33:10 WARN  Could not load snapshot text for C:\Users\Vinicius\UnB\FLanguage\src\main\scala\br\unb\cic\flang\MonadState.scala
2024.07.19 12:33:10 WARN  Could not load snapshot text for C:\Users\Vinicius\UnB\FLanguage\src\main\scala\br\unb\cic\flang\MonadState.scala
2024.07.19 12:33:10 INFO  Can not organize imports if file has error
2024.07.19 12:33:11 INFO  compiling root (2 scala sources)
2024.07.19 12:33:11 INFO  time: compiled root in 0.13s
2024.07.19 12:33:11 WARN  Could not load snapshot text for C:\Users\Vinicius\UnB\FLanguage\src\main\scala\br\unb\cic\flang\MonadState.scala
2024.07.19 12:33:18 WARN  Could not load snapshot text for C:\Users\Vinicius\UnB\FLanguage\src\main\scala\br\unb\cic\flang\MonadState.scala
2024.07.19 12:33:18 WARN  Could not load snapshot text for C:\Users\Vinicius\UnB\FLanguage\src\main\scala\br\unb\cic\flang\MonadState.scala
2024.07.19 12:33:18 WARN  Could not load snapshot text for C:\Users\Vinicius\UnB\FLanguage\src\main\scala\br\unb\cic\flang\MonadState.scala
2024.07.19 12:33:18 WARN  Could not load snapshot text for C:\Users\Vinicius\UnB\FLanguage\src\main\scala\br\unb\cic\flang\MonadState.scala
2024.07.19 12:33:18 WARN  Could not load snapshot text for C:\Users\Vinicius\UnB\FLanguage\src\main\scala\br\unb\cic\flang\MonadState.scala
2024.07.19 12:33:18 WARN  Could not load snapshot text for C:\Users\Vinicius\UnB\FLanguage\src\main\scala\br\unb\cic\flang\MonadState.scala
2024.07.19 12:33:18 WARN  Could not load snapshot text for C:\Users\Vinicius\UnB\FLanguage\src\main\scala\br\unb\cic\flang\MonadState.scala
2024.07.19 12:33:18 WARN  Could not load snapshot text for C:\Users\Vinicius\UnB\FLanguage\src\main\scala\br\unb\cic\flang\MonadState.scala
jul. 19, 2024 12:33:18 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleNotification
ADVERTÊNCIA: Notification threw an exception: {
  "jsonrpc": "2.0",
  "method": "textDocument/didOpen",
  "params": {
    "textDocument": {
      "uri": "jar:file%3A///C%3A/Users/Vinicius/AppData/Local/Coursier/cache/arc/https/github.com/adoptium/temurin17-binaries/releases/download/jdk-17%25252B35/OpenJDK17-jdk_x64_windows_hotspot_17_35.zip/jdk-17%2B35/lib/src.zip%21/java.base/java/lang/Integer.java",
      "languageId": "java",
      "version": 1,
      "text": "/*\n * Copyright (c) 1994, 2021, Oracle and/or its affiliates. All rights reserved.\n * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n *\n * This code is free software; you can redistribute it and/or modify it\n * under the terms of the GNU General Public License version 2 only, as\n * published by the Free Software Foundation.  Oracle designates this\n * particular file as subject to the \"Classpath\" exception as provided\n * by Oracle in the LICENSE file that accompanied this code.\n *\n * This code is distributed in the hope that it will be useful, but WITHOUT\n * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n * version 2 for more details (a copy is included in the LICENSE file that\n * accompanied this code).\n *\n * You should have received a copy of the GNU General Public License version\n * 2 along with this work; if not, write to the Free Software Foundation,\n * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n *\n * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n * or visit www.oracle.com if you need additional information or have any\n * questions.\n */\n\npackage java.lang;\n\nimport java.lang.annotation.Native;\nimport java.lang.invoke.MethodHandles;\nimport java.lang.constant.Constable;\nimport java.lang.constant.ConstantDesc;\nimport java.util.Objects;\nimport java.util.Optional;\n\nimport jdk.internal.misc.CDS;\nimport jdk.internal.misc.VM;\nimport jdk.internal.vm.annotation.IntrinsicCandidate;\n\nimport static java.lang.String.COMPACT_STRINGS;\nimport static java.lang.String.LATIN1;\nimport static java.lang.String.UTF16;\n\n/**\n * The {@code Integer} class wraps a value of the primitive type\n * {@code int} in an object. An object of type {@code Integer}\n * contains a single field whose type is {@code int}.\n *\n * \u003cp\u003eIn addition, this class provides several methods for converting\n * an {@code int} to a {@code String} and a {@code String} to an\n * {@code int}, as well as other constants and methods useful when\n * dealing with an {@code int}.\n *\n * \u003cp\u003eThis is a \u003ca href\u003d\"{@docRoot}/java.base/java/lang/doc-files/ValueBased.html\"\u003evalue-based\u003c/a\u003e\n * class; programmers should treat instances that are\n * {@linkplain #equals(Object) equal} as interchangeable and should not\n * use instances for synchronization, or unpredictable behavior may\n * occur. For example, in a future release, synchronization may fail.\n *\n * \u003cp\u003eImplementation note: The implementations of the \"bit twiddling\"\n * methods (such as {@link #highestOneBit(int) highestOneBit} and\n * {@link #numberOfTrailingZeros(int) numberOfTrailingZeros}) are\n * based on material from Henry S. Warren, Jr.\u0027s \u003ci\u003eHacker\u0027s\n * Delight\u003c/i\u003e, (Addison Wesley, 2002).\n *\n * @author  Lee Boynton\n * @author  Arthur van Hoff\n * @author  Josh Bloch\n * @author  Joseph D. Darcy\n * @since 1.0\n */\n@jdk.internal.ValueBased\npublic final class Integer extends Number\n        implements Comparable\u003cInteger\u003e, Constable, ConstantDesc {\n    /**\n     * A constant holding the minimum value an {@code int} can\n     * have, -2\u003csup\u003e31\u003c/sup\u003e.\n     */\n    @Native public static final int   MIN_VALUE \u003d 0x80000000;\n\n    /**\n     * A constant holding the maximum value an {@code int} can\n     * have, 2\u003csup\u003e31\u003c/sup\u003e-1.\n     */\n    @Native public static final int   MAX_VALUE \u003d 0x7fffffff;\n\n    /**\n     * The {@code Class} instance representing the primitive type\n     * {@code int}.\n     *\n     * @since   1.1\n     */\n    @SuppressWarnings(\"unchecked\")\n    public static final Class\u003cInteger\u003e  TYPE \u003d (Class\u003cInteger\u003e) Class.getPrimitiveClass(\"int\");\n\n    /**\n     * All possible chars for representing a number as a String\n     */\n    static final char[] digits \u003d {\n        \u00270\u0027 , \u00271\u0027 , \u00272\u0027 , \u00273\u0027 , \u00274\u0027 , \u00275\u0027 ,\n        \u00276\u0027 , \u00277\u0027 , \u00278\u0027 , \u00279\u0027 , \u0027a\u0027 , \u0027b\u0027 ,\n        \u0027c\u0027 , \u0027d\u0027 , \u0027e\u0027 , \u0027f\u0027 , \u0027g\u0027 , \u0027h\u0027 ,\n        \u0027i\u0027 , \u0027j\u0027 , \u0027k\u0027 , \u0027l\u0027 , \u0027m\u0027 , \u0027n\u0027 ,\n        \u0027o\u0027 , \u0027p\u0027 , \u0027q\u0027 , \u0027r\u0027 , \u0027s\u0027 , \u0027t\u0027 ,\n        \u0027u\u0027 , \u0027v\u0027 , \u0027w\u0027 , \u0027x\u0027 , \u0027y\u0027 , \u0027z\u0027\n    };\n\n    /**\n     * Returns a string representation of the first argument in the\n     * radix specified by the second argument.\n     *\n     * \u003cp\u003eIf the radix is smaller than {@code Character.MIN_RADIX}\n     * or larger than {@code Character.MAX_RADIX}, then the radix\n     * {@code 10} is used instead.\n     *\n     * \u003cp\u003eIf the first argument is negative, the first element of the\n     * result is the ASCII minus character {@code \u0027-\u0027}\n     * ({@code \u0027\\u005Cu002D\u0027}). If the first argument is not\n     * negative, no sign character appears in the result.\n     *\n     * \u003cp\u003eThe remaining characters of the result represent the magnitude\n     * of the first argument. If the magnitude is zero, it is\n     * represented by a single zero character {@code \u00270\u0027}\n     * ({@code \u0027\\u005Cu0030\u0027}); otherwise, the first character of\n     * the representation of the magnitude will not be the zero\n     * character.  The following ASCII characters are used as digits:\n     *\n     * \u003cblockquote\u003e\n     *   {@code 0123456789abcdefghijklmnopqrstuvwxyz}\n     * \u003c/blockquote\u003e\n     *\n     * These are {@code \u0027\\u005Cu0030\u0027} through\n     * {@code \u0027\\u005Cu0039\u0027} and {@code \u0027\\u005Cu0061\u0027} through\n     * {@code \u0027\\u005Cu007A\u0027}. If {@code radix} is\n     * \u003cvar\u003eN\u003c/var\u003e, then the first \u003cvar\u003eN\u003c/var\u003e of these characters\n     * are used as radix-\u003cvar\u003eN\u003c/var\u003e digits in the order shown. Thus,\n     * the digits for hexadecimal (radix 16) are\n     * {@code 0123456789abcdef}. If uppercase letters are\n     * desired, the {@link java.lang.String#toUpperCase()} method may\n     * be called on the result:\n     *\n     * \u003cblockquote\u003e\n     *  {@code Integer.toString(n, 16).toUpperCase()}\n     * \u003c/blockquote\u003e\n     *\n     * @param   i       an integer to be converted to a string.\n     * @param   radix   the radix to use in the string representation.\n     * @return  a string representation of the argument in the specified radix.\n     * @see     java.lang.Character#MAX_RADIX\n     * @see     java.lang.Character#MIN_RADIX\n     */\n    public static String toString(int i, int radix) {\n        if (radix \u003c Character.MIN_RADIX || radix \u003e Character.MAX_RADIX)\n            radix \u003d 10;\n\n        /* Use the faster version */\n        if (radix \u003d\u003d 10) {\n            return toString(i);\n        }\n\n        if (COMPACT_STRINGS) {\n            byte[] buf \u003d new byte[33];\n            boolean negative \u003d (i \u003c 0);\n            int charPos \u003d 32;\n\n            if (!negative) {\n                i \u003d -i;\n            }\n\n            while (i \u003c\u003d -radix) {\n                buf[charPos--] \u003d (byte)digits[-(i % radix)];\n                i \u003d i / radix;\n            }\n            buf[charPos] \u003d (byte)digits[-i];\n\n            if (negative) {\n                buf[--charPos] \u003d \u0027-\u0027;\n            }\n\n            return StringLatin1.newString(buf, charPos, (33 - charPos));\n        }\n        return toStringUTF16(i, radix);\n    }\n\n    private static String toStringUTF16(int i, int radix) {\n        byte[] buf \u003d new byte[33 * 2];\n        boolean negative \u003d (i \u003c 0);\n        int charPos \u003d 32;\n        if (!negative) {\n            i \u003d -i;\n        }\n        while (i \u003c\u003d -radix) {\n            StringUTF16.putChar(buf, charPos--, digits[-(i % radix)]);\n            i \u003d i / radix;\n        }\n        StringUTF16.putChar(buf, charPos, digits[-i]);\n\n        if (negative) {\n            StringUTF16.putChar(buf, --charPos, \u0027-\u0027);\n        }\n        return StringUTF16.newString(buf, charPos, (33 - charPos));\n    }\n\n    /**\n     * Returns a string representation of the first argument as an\n     * unsigned integer value in the radix specified by the second\n     * argument.\n     *\n     * \u003cp\u003eIf the radix is smaller than {@code Character.MIN_RADIX}\n     * or larger than {@code Character.MAX_RADIX}, then the radix\n     * {@code 10} is used instead.\n     *\n     * \u003cp\u003eNote that since the first argument is treated as an unsigned\n     * value, no leading sign character is printed.\n     *\n     * \u003cp\u003eIf the magnitude is zero, it is represented by a single zero\n     * character {@code \u00270\u0027} ({@code \u0027\\u005Cu0030\u0027}); otherwise,\n     * the first character of the representation of the magnitude will\n     * not be the zero character.\n     *\n     * \u003cp\u003eThe behavior of radixes and the characters used as digits\n     * are the same as {@link #toString(int, int) toString}.\n     *\n     * @param   i       an integer to be converted to an unsigned string.\n     * @param   radix   the radix to use in the string representation.\n     * @return  an unsigned string representation of the argument in the specified radix.\n     * @see     #toString(int, int)\n     * @since 1.8\n     */\n    public static String toUnsignedString(int i, int radix) {\n        return Long.toUnsignedString(toUnsignedLong(i), radix);\n    }\n\n    /**\n     * Returns a string representation of the integer argument as an\n     * unsigned integer in base\u0026nbsp;16.\n     *\n     * \u003cp\u003eThe unsigned integer value is the argument plus 2\u003csup\u003e32\u003c/sup\u003e\n     * if the argument is negative; otherwise, it is equal to the\n     * argument.  This value is converted to a string of ASCII digits\n     * in hexadecimal (base\u0026nbsp;16) with no extra leading\n     * {@code 0}s.\n     *\n     * \u003cp\u003eThe value of the argument can be recovered from the returned\n     * string {@code s} by calling {@link\n     * Integer#parseUnsignedInt(String, int)\n     * Integer.parseUnsignedInt(s, 16)}.\n     *\n     * \u003cp\u003eIf the unsigned magnitude is zero, it is represented by a\n     * single zero character {@code \u00270\u0027} ({@code \u0027\\u005Cu0030\u0027});\n     * otherwise, the first character of the representation of the\n     * unsigned magnitude will not be the zero character. The\n     * following characters are used as hexadecimal digits:\n     *\n     * \u003cblockquote\u003e\n     *  {@code 0123456789abcdef}\n     * \u003c/blockquote\u003e\n     *\n     * These are the characters {@code \u0027\\u005Cu0030\u0027} through\n     * {@code \u0027\\u005Cu0039\u0027} and {@code \u0027\\u005Cu0061\u0027} through\n     * {@code \u0027\\u005Cu0066\u0027}. If uppercase letters are\n     * desired, the {@link java.lang.String#toUpperCase()} method may\n     * be called on the result:\n     *\n     * \u003cblockquote\u003e\n     *  {@code Integer.toHexString(n).toUpperCase()}\n     * \u003c/blockquote\u003e\n     *\n     * @apiNote\n     * The {@link java.util.HexFormat} class provides formatting and parsing\n     * of byte arrays and primitives to return a string or adding to an {@link Appendable}.\n     * {@code HexFormat} formats and parses uppercase or lowercase hexadecimal characters,\n     * with leading zeros and for byte arrays includes for each byte\n     * a delimiter, prefix, and suffix.\n     *\n     * @param   i   an integer to be converted to a string.\n     * @return  the string representation of the unsigned integer value\n     *          represented by the argument in hexadecimal (base\u0026nbsp;16).\n     * @see java.util.HexFormat\n     * @see #parseUnsignedInt(String, int)\n     * @see #toUnsignedString(int, int)\n     * @since   1.0.2\n     */\n    public static String toHexString(int i) {\n        return toUnsignedString0(i, 4);\n    }\n\n    /**\n     * Returns a string representation of the integer argument as an\n     * unsigned integer in base\u0026nbsp;8.\n     *\n     * \u003cp\u003eThe unsigned integer value is the argument plus 2\u003csup\u003e32\u003c/sup\u003e\n     * if the argument is negative; otherwise, it is equal to the\n     * argument.  This value is converted to a string of ASCII digits\n     * in octal (base\u0026nbsp;8) with no extra leading {@code 0}s.\n     *\n     * \u003cp\u003eThe value of the argument can be recovered from the returned\n     * string {@code s} by calling {@link\n     * Integer#parseUnsignedInt(String, int)\n     * Integer.parseUnsignedInt(s, 8)}.\n     *\n     * \u003cp\u003eIf the unsigned magnitude is zero, it is represented by a\n     * single zero character {@code \u00270\u0027} ({@code \u0027\\u005Cu0030\u0027});\n     * otherwise, the first character of the representation of the\n     * unsigned magnitude will not be the zero character. The\n     * following characters are used as octal digits:\n     *\n     * \u003cblockquote\u003e\n     * {@code 01234567}\n     * \u003c/blockquote\u003e\n     *\n     * These are the characters {@code \u0027\\u005Cu0030\u0027} through\n     * {@code \u0027\\u005Cu0037\u0027}.\n     *\n     * @param   i   an integer to be converted to a string.\n     * @return  the string representation of the unsigned integer value\n     *          represented by the argument in octal (base\u0026nbsp;8).\n     * @see #parseUnsignedInt(String, int)\n     * @see #toUnsignedString(int, int)\n     * @since   1.0.2\n     */\n    public static String toOctalString(int i) {\n        return toUnsignedString0(i, 3);\n    }\n\n    /**\n     * Returns a string representation of the integer argument as an\n     * unsigned integer in base\u0026nbsp;2.\n     *\n     * \u003cp\u003eThe unsigned integer value is the argument plus 2\u003csup\u003e32\u003c/sup\u003e\n     * if the argument is negative; otherwise it is equal to the\n     * argument.  This value is converted to a string of ASCII digits\n     * in binary (base\u0026nbsp;2) with no extra leading {@code 0}s.\n     *\n     * \u003cp\u003eThe value of the argument can be recovered from the returned\n     * string {@code s} by calling {@link\n     * Integer#parseUnsignedInt(String, int)\n     * Integer.parseUnsignedInt(s, 2)}.\n     *\n     * \u003cp\u003eIf the unsigned magnitude is zero, it is represented by a\n     * single zero character {@code \u00270\u0027} ({@code \u0027\\u005Cu0030\u0027});\n     * otherwise, the first character of the representation of the\n     * unsigned magnitude will not be the zero character. The\n     * characters {@code \u00270\u0027} ({@code \u0027\\u005Cu0030\u0027}) and {@code\n     * \u00271\u0027} ({@code \u0027\\u005Cu0031\u0027}) are used as binary digits.\n     *\n     * @param   i   an integer to be converted to a string.\n     * @return  the string representation of the unsigned integer value\n     *          represented by the argument in binary (base\u0026nbsp;2).\n     * @see #parseUnsignedInt(String, int)\n     * @see #toUnsignedString(int, int)\n     * @since   1.0.2\n     */\n    public static String toBinaryString(int i) {\n        return toUnsignedString0(i, 1);\n    }\n\n    /**\n     * Convert the integer to an unsigned number.\n     */\n    private static String toUnsignedString0(int val, int shift) {\n        // assert shift \u003e 0 \u0026\u0026 shift \u003c\u003d5 : \"Illegal shift value\";\n        int mag \u003d Integer.SIZE - Integer.numberOfLeadingZeros(val);\n        int chars \u003d Math.max(((mag + (shift - 1)) / shift), 1);\n        if (COMPACT_STRINGS) {\n            byte[] buf \u003d new byte[chars];\n            formatUnsignedInt(val, shift, buf, chars);\n            return new String(buf, LATIN1);\n        } else {\n            byte[] buf \u003d new byte[chars * 2];\n            formatUnsignedIntUTF16(val, shift, buf, chars);\n            return new String(buf, UTF16);\n        }\n    }\n\n    /**\n     * Format an {@code int} (treated as unsigned) into a byte buffer (LATIN1 version). If\n     * {@code len} exceeds the formatted ASCII representation of {@code val},\n     * {@code buf} will be padded with leading zeroes.\n     *\n     * @param val the unsigned int to format\n     * @param shift the log2 of the base to format in (4 for hex, 3 for octal, 1 for binary)\n     * @param buf the byte buffer to write to\n     * @param len the number of characters to write\n     */\n    private static void formatUnsignedInt(int val, int shift, byte[] buf, int len) {\n        int charPos \u003d len;\n        int radix \u003d 1 \u003c\u003c shift;\n        int mask \u003d radix - 1;\n        do {\n            buf[--charPos] \u003d (byte)Integer.digits[val \u0026 mask];\n            val \u003e\u003e\u003e\u003d shift;\n        } while (charPos \u003e 0);\n    }\n\n    /**\n     * Format an {@code int} (treated as unsigned) into a byte buffer (UTF16 version). If\n     * {@code len} exceeds the formatted ASCII representation of {@code val},\n     * {@code buf} will be padded with leading zeroes.\n     *\n     * @param val the unsigned int to format\n     * @param shift the log2 of the base to format in (4 for hex, 3 for octal, 1 for binary)\n     * @param buf the byte buffer to write to\n     * @param len the number of characters to write\n     */\n    private static void formatUnsignedIntUTF16(int val, int shift, byte[] buf, int len) {\n        int charPos \u003d len;\n        int radix \u003d 1 \u003c\u003c shift;\n        int mask \u003d radix - 1;\n        do {\n            StringUTF16.putChar(buf, --charPos, Integer.digits[val \u0026 mask]);\n            val \u003e\u003e\u003e\u003d shift;\n        } while (charPos \u003e 0);\n    }\n\n    static final byte[] DigitTens \u003d {\n        \u00270\u0027, \u00270\u0027, \u00270\u0027, \u00270\u0027, \u00270\u0027, \u00270\u0027, \u00270\u0027, \u00270\u0027, \u00270\u0027, \u00270\u0027,\n        \u00271\u0027, \u00271\u0027, \u00271\u0027, \u00271\u0027, \u00271\u0027, \u00271\u0027, \u00271\u0027, \u00271\u0027, \u00271\u0027, \u00271\u0027,\n        \u00272\u0027, \u00272\u0027, \u00272\u0027, \u00272\u0027, \u00272\u0027, \u00272\u0027, \u00272\u0027, \u00272\u0027, \u00272\u0027, \u00272\u0027,\n        \u00273\u0027, \u00273\u0027, \u00273\u0027, \u00273\u0027, \u00273\u0027, \u00273\u0027, \u00273\u0027, \u00273\u0027, \u00273\u0027, \u00273\u0027,\n        \u00274\u0027, \u00274\u0027, \u00274\u0027, \u00274\u0027, \u00274\u0027, \u00274\u0027, \u00274\u0027, \u00274\u0027, \u00274\u0027, \u00274\u0027,\n        \u00275\u0027, \u00275\u0027, \u00275\u0027, \u00275\u0027, \u00275\u0027, \u00275\u0027, \u00275\u0027, \u00275\u0027, \u00275\u0027, \u00275\u0027,\n        \u00276\u0027, \u00276\u0027, \u00276\u0027, \u00276\u0027, \u00276\u0027, \u00276\u0027, \u00276\u0027, \u00276\u0027, \u00276\u0027, \u00276\u0027,\n        \u00277\u0027, \u00277\u0027, \u00277\u0027, \u00277\u0027, \u00277\u0027, \u00277\u0027, \u00277\u0027, \u00277\u0027, \u00277\u0027, \u00277\u0027,\n        \u00278\u0027, \u00278\u0027, \u00278\u0027, \u00278\u0027, \u00278\u0027, \u00278\u0027, \u00278\u0027, \u00278\u0027, \u00278\u0027, \u00278\u0027,\n        \u00279\u0027, \u00279\u0027, \u00279\u0027, \u00279\u0027, \u00279\u0027, \u00279\u0027, \u00279\u0027, \u00279\u0027, \u00279\u0027, \u00279\u0027,\n        } ;\n\n    static final byte[] DigitOnes \u003d {\n        \u00270\u0027, \u00271\u0027, \u00272\u0027, \u00273\u0027, \u00274\u0027, \u00275\u0027, \u00276\u0027, \u00277\u0027, \u00278\u0027, \u00279\u0027,\n        \u00270\u0027, \u00271\u0027, \u00272\u0027, \u00273\u0027, \u00274\u0027, \u00275\u0027, \u00276\u0027, \u00277\u0027, \u00278\u0027, \u00279\u0027,\n        \u00270\u0027, \u00271\u0027, \u00272\u0027, \u00273\u0027, \u00274\u0027, \u00275\u0027, \u00276\u0027, \u00277\u0027, \u00278\u0027, \u00279\u0027,\n        \u00270\u0027, \u00271\u0027, \u00272\u0027, \u00273\u0027, \u00274\u0027, \u00275\u0027, \u00276\u0027, \u00277\u0027, \u00278\u0027, \u00279\u0027,\n        \u00270\u0027, \u00271\u0027, \u00272\u0027, \u00273\u0027, \u00274\u0027, \u00275\u0027, \u00276\u0027, \u00277\u0027, \u00278\u0027, \u00279\u0027,\n        \u00270\u0027, \u00271\u0027, \u00272\u0027, \u00273\u0027, \u00274\u0027, \u00275\u0027, \u00276\u0027, \u00277\u0027, \u00278\u0027, \u00279\u0027,\n        \u00270\u0027, \u00271\u0027, \u00272\u0027, \u00273\u0027, \u00274\u0027, \u00275\u0027, \u00276\u0027, \u00277\u0027, \u00278\u0027, \u00279\u0027,\n        \u00270\u0027, \u00271\u0027, \u00272\u0027, \u00273\u0027, \u00274\u0027, \u00275\u0027, \u00276\u0027, \u00277\u0027, \u00278\u0027, \u00279\u0027,\n        \u00270\u0027, \u00271\u0027, \u00272\u0027, \u00273\u0027, \u00274\u0027, \u00275\u0027, \u00276\u0027, \u00277\u0027, \u00278\u0027, \u00279\u0027,\n        \u00270\u0027, \u00271\u0027, \u00272\u0027, \u00273\u0027, \u00274\u0027, \u00275\u0027, \u00276\u0027, \u00277\u0027, \u00278\u0027, \u00279\u0027,\n        } ;\n\n\n    /**\n     * Returns a {@code String} object representing the\n     * specified integer. The argument is converted to signed decimal\n     * representation and returned as a string, exactly as if the\n     * argument and radix 10 were given as arguments to the {@link\n     * #toString(int, int)} method.\n     *\n     * @param   i   an integer to be converted.\n     * @return  a string representation of the argument in base\u0026nbsp;10.\n     */\n    @IntrinsicCandidate\n    public static String toString(int i) {\n        int size \u003d stringSize(i);\n        if (COMPACT_STRINGS) {\n            byte[] buf \u003d new byte[size];\n            getChars(i, size, buf);\n            return new String(buf, LATIN1);\n        } else {\n            byte[] buf \u003d new byte[size * 2];\n            StringUTF16.getChars(i, size, buf);\n            return new String(buf, UTF16);\n        }\n    }\n\n    /**\n     * Returns a string representation of the argument as an unsigned\n     * decimal value.\n     *\n     * The argument is converted to unsigned decimal representation\n     * and returned as a string exactly as if the argument and radix\n     * 10 were given as arguments to the {@link #toUnsignedString(int,\n     * int)} method.\n     *\n     * @param   i  an integer to be converted to an unsigned string.\n     * @return  an unsigned string representation of the argument.\n     * @see     #toUnsignedString(int, int)\n     * @since 1.8\n     */\n    public static String toUnsignedString(int i) {\n        return Long.toString(toUnsignedLong(i));\n    }\n\n    /**\n     * Places characters representing the integer i into the\n     * character array buf. The characters are placed into\n     * the buffer backwards starting with the least significant\n     * digit at the specified index (exclusive), and working\n     * backwards from there.\n     *\n     * @implNote This method converts positive inputs into negative\n     * values, to cover the Integer.MIN_VALUE case. Converting otherwise\n     * (negative to positive) will expose -Integer.MIN_VALUE that overflows\n     * integer.\n     *\n     * @param i     value to convert\n     * @param index next index, after the least significant digit\n     * @param buf   target buffer, Latin1-encoded\n     * @return index of the most significant digit or minus sign, if present\n     */\n    static int getChars(int i, int index, byte[] buf) {\n        int q, r;\n        int charPos \u003d index;\n\n        boolean negative \u003d i \u003c 0;\n        if (!negative) {\n            i \u003d -i;\n        }\n\n        // Generate two digits per iteration\n        while (i \u003c\u003d -100) {\n            q \u003d i / 100;\n            r \u003d (q * 100) - i;\n            i \u003d q;\n            buf[--charPos] \u003d DigitOnes[r];\n            buf[--charPos] \u003d DigitTens[r];\n        }\n\n        // We know there are at most two digits left at this point.\n        q \u003d i / 10;\n        r \u003d (q * 10) - i;\n        buf[--charPos] \u003d (byte)(\u00270\u0027 + r);\n\n        // Whatever left is the remaining digit.\n        if (q \u003c 0) {\n            buf[--charPos] \u003d (byte)(\u00270\u0027 - q);\n        }\n\n        if (negative) {\n            buf[--charPos] \u003d (byte)\u0027-\u0027;\n        }\n        return charPos;\n    }\n\n    // Left here for compatibility reasons, see JDK-8143900.\n    static final int [] sizeTable \u003d { 9, 99, 999, 9999, 99999, 999999, 9999999,\n                                      99999999, 999999999, Integer.MAX_VALUE };\n\n    /**\n     * Returns the string representation size for a given int value.\n     *\n     * @param x int value\n     * @return string size\n     *\n     * @implNote There are other ways to compute this: e.g. binary search,\n     * but values are biased heavily towards zero, and therefore linear search\n     * wins. The iteration results are also routinely inlined in the generated\n     * code after loop unrolling.\n     */\n    static int stringSize(int x) {\n        int d \u003d 1;\n        if (x \u003e\u003d 0) {\n            d \u003d 0;\n            x \u003d -x;\n        }\n        int p \u003d -10;\n        for (int i \u003d 1; i \u003c 10; i++) {\n            if (x \u003e p)\n                return i + d;\n            p \u003d 10 * p;\n        }\n        return 10 + d;\n    }\n\n    /**\n     * Parses the string argument as a signed integer in the radix\n     * specified by the second argument. The characters in the string\n     * must all be digits of the specified radix (as determined by\n     * whether {@link java.lang.Character#digit(char, int)} returns a\n     * nonnegative value), except that the first character may be an\n     * ASCII minus sign {@code \u0027-\u0027} ({@code \u0027\\u005Cu002D\u0027}) to\n     * indicate a negative value or an ASCII plus sign {@code \u0027+\u0027}\n     * ({@code \u0027\\u005Cu002B\u0027}) to indicate a positive value. The\n     * resulting integer value is returned.\n     *\n     * \u003cp\u003eAn exception of type {@code NumberFormatException} is\n     * thrown if any of the following situations occurs:\n     * \u003cul\u003e\n     * \u003cli\u003eThe first argument is {@code null} or is a string of\n     * length zero.\n     *\n     * \u003cli\u003eThe radix is either smaller than\n     * {@link java.lang.Character#MIN_RADIX} or\n     * larger than {@link java.lang.Character#MAX_RADIX}.\n     *\n     * \u003cli\u003eAny character of the string is not a digit of the specified\n     * radix, except that the first character may be a minus sign\n     * {@code \u0027-\u0027} ({@code \u0027\\u005Cu002D\u0027}) or plus sign\n     * {@code \u0027+\u0027} ({@code \u0027\\u005Cu002B\u0027}) provided that the\n     * string is longer than length 1.\n     *\n     * \u003cli\u003eThe value represented by the string is not a value of type\n     * {@code int}.\n     * \u003c/ul\u003e\n     *\n     * \u003cp\u003eExamples:\n     * \u003cblockquote\u003e\u003cpre\u003e\n     * parseInt(\"0\", 10) returns 0\n     * parseInt(\"473\", 10) returns 473\n     * parseInt(\"+42\", 10) returns 42\n     * parseInt(\"-0\", 10) returns 0\n     * parseInt(\"-FF\", 16) returns -255\n     * parseInt(\"1100110\", 2) returns 102\n     * parseInt(\"2147483647\", 10) returns 2147483647\n     * parseInt(\"-2147483648\", 10) returns -2147483648\n     * parseInt(\"2147483648\", 10) throws a NumberFormatException\n     * parseInt(\"99\", 8) throws a NumberFormatException\n     * parseInt(\"Kona\", 10) throws a NumberFormatException\n     * parseInt(\"Kona\", 27) returns 411787\n     * \u003c/pre\u003e\u003c/blockquote\u003e\n     *\n     * @param      s   the {@code String} containing the integer\n     *                  representation to be parsed\n     * @param      radix   the radix to be used while parsing {@code s}.\n     * @return     the integer represented by the string argument in the\n     *             specified radix.\n     * @throws     NumberFormatException if the {@code String}\n     *             does not contain a parsable {@code int}.\n     */\n    public static int parseInt(String s, int radix)\n                throws NumberFormatException\n    {\n        /*\n         * WARNING: This method may be invoked early during VM initialization\n         * before IntegerCache is initialized. Care must be taken to not use\n         * the valueOf method.\n         */\n\n        if (s \u003d\u003d null) {\n            throw new NumberFormatException(\"Cannot parse null string\");\n        }\n\n        if (radix \u003c Character.MIN_RADIX) {\n            throw new NumberFormatException(\"radix \" + radix +\n                                            \" less than Character.MIN_RADIX\");\n        }\n\n        if (radix \u003e Character.MAX_RADIX) {\n            throw new NumberFormatException(\"radix \" + radix +\n                                            \" greater than Character.MAX_RADIX\");\n        }\n\n        boolean negative \u003d false;\n        int i \u003d 0, len \u003d s.length();\n        int limit \u003d -Integer.MAX_VALUE;\n\n        if (len \u003e 0) {\n            char firstChar \u003d s.charAt(0);\n            if (firstChar \u003c \u00270\u0027) { // Possible leading \"+\" or \"-\"\n                if (firstChar \u003d\u003d \u0027-\u0027) {\n                    negative \u003d true;\n                    limit \u003d Integer.MIN_VALUE;\n                } else if (firstChar !\u003d \u0027+\u0027) {\n                    throw NumberFormatException.forInputString(s, radix);\n                }\n\n                if (len \u003d\u003d 1) { // Cannot have lone \"+\" or \"-\"\n                    throw NumberFormatException.forInputString(s, radix);\n                }\n                i++;\n            }\n            int multmin \u003d limit / radix;\n            int result \u003d 0;\n            while (i \u003c len) {\n                // Accumulating negatively avoids surprises near MAX_VALUE\n                int digit \u003d Character.digit(s.charAt(i++), radix);\n                if (digit \u003c 0 || result \u003c multmin) {\n                    throw NumberFormatException.forInputString(s, radix);\n                }\n                result *\u003d radix;\n                if (result \u003c limit + digit) {\n                    throw NumberFormatException.forInputString(s, radix);\n                }\n                result -\u003d digit;\n            }\n            return negative ? result : -result;\n        } else {\n            throw NumberFormatException.forInputString(s, radix);\n        }\n    }\n\n    /**\n     * Parses the {@link CharSequence} argument as a signed {@code int} in the\n     * specified {@code radix}, beginning at the specified {@code beginIndex}\n     * and extending to {@code endIndex - 1}.\n     *\n     * \u003cp\u003eThe method does not take steps to guard against the\n     * {@code CharSequence} being mutated while parsing.\n     *\n     * @param      s   the {@code CharSequence} containing the {@code int}\n     *                  representation to be parsed\n     * @param      beginIndex   the beginning index, inclusive.\n     * @param      endIndex     the ending index, exclusive.\n     * @param      radix   the radix to be used while parsing {@code s}.\n     * @return     the signed {@code int} represented by the subsequence in\n     *             the specified radix.\n     * @throws     NullPointerException  if {@code s} is null.\n     * @throws     IndexOutOfBoundsException  if {@code beginIndex} is\n     *             negative, or if {@code beginIndex} is greater than\n     *             {@code endIndex} or if {@code endIndex} is greater than\n     *             {@code s.length()}.\n     * @throws     NumberFormatException  if the {@code CharSequence} does not\n     *             contain a parsable {@code int} in the specified\n     *             {@code radix}, or if {@code radix} is either smaller than\n     *             {@link java.lang.Character#MIN_RADIX} or larger than\n     *             {@link java.lang.Character#MAX_RADIX}.\n     * @since  9\n     */\n    public static int parseInt(CharSequence s, int beginIndex, int endIndex, int radix)\n                throws NumberFormatException {\n        Objects.requireNonNull(s);\n\n        if (beginIndex \u003c 0 || beginIndex \u003e endIndex || endIndex \u003e s.length()) {\n            throw new IndexOutOfBoundsException();\n        }\n        if (radix \u003c Character.MIN_RADIX) {\n            throw new NumberFormatException(\"radix \" + radix +\n                                            \" less than Character.MIN_RADIX\");\n        }\n        if (radix \u003e Character.MAX_RADIX) {\n            throw new NumberFormatException(\"radix \" + radix +\n                                            \" greater than Character.MAX_RADIX\");\n        }\n\n        boolean negative \u003d false;\n        int i \u003d beginIndex;\n        int limit \u003d -Integer.MAX_VALUE;\n\n        if (i \u003c endIndex) {\n            char firstChar \u003d s.charAt(i);\n            if (firstChar \u003c \u00270\u0027) { // Possible leading \"+\" or \"-\"\n                if (firstChar \u003d\u003d \u0027-\u0027) {\n                    negative \u003d true;\n                    limit \u003d Integer.MIN_VALUE;\n                } else if (firstChar !\u003d \u0027+\u0027) {\n                    throw NumberFormatException.forCharSequence(s, beginIndex,\n                            endIndex, i);\n                }\n                i++;\n                if (i \u003d\u003d endIndex) { // Cannot have lone \"+\" or \"-\"\n                    throw NumberFormatException.forCharSequence(s, beginIndex,\n                            endIndex, i);\n                }\n            }\n            int multmin \u003d limit / radix;\n            int result \u003d 0;\n            while (i \u003c endIndex) {\n                // Accumulating negatively avoids surprises near MAX_VALUE\n                int digit \u003d Character.digit(s.charAt(i), radix);\n                if (digit \u003c 0 || result \u003c multmin) {\n                    throw NumberFormatException.forCharSequence(s, beginIndex,\n                            endIndex, i);\n                }\n                result *\u003d radix;\n                if (result \u003c limit + digit) {\n                    throw NumberFormatException.forCharSequence(s, beginIndex,\n                            endIndex, i);\n                }\n                i++;\n                result -\u003d digit;\n            }\n            return negative ? result : -result;\n        } else {\n            throw NumberFormatException.forInputString(\"\", radix);\n        }\n    }\n\n    /**\n     * Parses the string argument as a signed decimal integer. The\n     * characters in the string must all be decimal digits, except\n     * that the first character may be an ASCII minus sign {@code \u0027-\u0027}\n     * ({@code \u0027\\u005Cu002D\u0027}) to indicate a negative value or an\n     * ASCII plus sign {@code \u0027+\u0027} ({@code \u0027\\u005Cu002B\u0027}) to\n     * indicate a positive value. The resulting integer value is\n     * returned, exactly as if the argument and the radix 10 were\n     * given as arguments to the {@link #parseInt(java.lang.String,\n     * int)} method.\n     *\n     * @param s    a {@code String} containing the {@code int}\n     *             representation to be parsed\n     * @return     the integer value represented by the argument in decimal.\n     * @throws     NumberFormatException  if the string does not contain a\n     *               parsable integer.\n     */\n    public static int parseInt(String s) throws NumberFormatException {\n        return parseInt(s,10);\n    }\n\n    /**\n     * Parses the string argument as an unsigned integer in the radix\n     * specified by the second argument.  An unsigned integer maps the\n     * values usually associated with negative numbers to positive\n     * numbers larger than {@code MAX_VALUE}.\n     *\n     * The characters in the string must all be digits of the\n     * specified radix (as determined by whether {@link\n     * java.lang.Character#digit(char, int)} returns a nonnegative\n     * value), except that the first character may be an ASCII plus\n     * sign {@code \u0027+\u0027} ({@code \u0027\\u005Cu002B\u0027}). The resulting\n     * integer value is returned.\n     *\n     * \u003cp\u003eAn exception of type {@code NumberFormatException} is\n     * thrown if any of the following situations occurs:\n     * \u003cul\u003e\n     * \u003cli\u003eThe first argument is {@code null} or is a string of\n     * length zero.\n     *\n     * \u003cli\u003eThe radix is either smaller than\n     * {@link java.lang.Character#MIN_RADIX} or\n     * larger than {@link java.lang.Character#MAX_RADIX}.\n     *\n     * \u003cli\u003eAny character of the string is not a digit of the specified\n     * radix, except that the first character may be a plus sign\n     * {@code \u0027+\u0027} ({@code \u0027\\u005Cu002B\u0027}) provided that the\n     * string is longer than length 1.\n     *\n     * \u003cli\u003eThe value represented by the string is larger than the\n     * largest unsigned {@code int}, 2\u003csup\u003e32\u003c/sup\u003e-1.\n     *\n     * \u003c/ul\u003e\n     *\n     *\n     * @param      s   the {@code String} containing the unsigned integer\n     *                  representation to be parsed\n     * @param      radix   the radix to be used while parsing {@code s}.\n     * @return     the integer represented by the string argument in the\n     *             specified radix.\n     * @throws     NumberFormatException if the {@code String}\n     *             does not contain a parsable {@code int}.\n     * @since 1.8\n     */\n    public static int parseUnsignedInt(String s, int radix)\n                throws NumberFormatException {\n        if (s \u003d\u003d null)  {\n            throw new NumberFormatException(\"Cannot parse null string\");\n        }\n\n        int len \u003d s.length();\n        if (len \u003e 0) {\n            char firstChar \u003d s.charAt(0);\n            if (firstChar \u003d\u003d \u0027-\u0027) {\n                throw new\n                    NumberFormatException(String.format(\"Illegal leading minus sign \" +\n                                                       \"on unsigned string %s.\", s));\n            } else {\n                if (len \u003c\u003d 5 || // Integer.MAX_VALUE in Character.MAX_RADIX is 6 digits\n                    (radix \u003d\u003d 10 \u0026\u0026 len \u003c\u003d 9) ) { // Integer.MAX_VALUE in base 10 is 10 digits\n                    return parseInt(s, radix);\n                } else {\n                    long ell \u003d Long.parseLong(s, radix);\n                    if ((ell \u0026 0xffff_ffff_0000_0000L) \u003d\u003d 0) {\n                        return (int) ell;\n                    } else {\n                        throw new\n                            NumberFormatException(String.format(\"String value %s exceeds \" +\n                                                                \"range of unsigned int.\", s));\n                    }\n                }\n            }\n        } else {\n            throw NumberFormatException.forInputString(s, radix);\n        }\n    }\n\n    /**\n     * Parses the {@link CharSequence} argument as an unsigned {@code int} in\n     * the specified {@code radix}, beginning at the specified\n     * {@code beginIndex} and extending to {@code endIndex - 1}.\n     *\n     * \u003cp\u003eThe method does not take steps to guard against the\n     * {@code CharSequence} being mutated while parsing.\n     *\n     * @param      s   the {@code CharSequence} containing the unsigned\n     *                 {@code int} representation to be parsed\n     * @param      beginIndex   the beginning index, inclusive.\n     * @param      endIndex     the ending index, exclusive.\n     * @param      radix   the radix to be used while parsing {@code s}.\n     * @return     the unsigned {@code int} represented by the subsequence in\n     *             the specified radix.\n     * @throws     NullPointerException  if {@code s} is null.\n     * @throws     IndexOutOfBoundsException  if {@code beginIndex} is\n     *             negative, or if {@code beginIndex} is greater than\n     *             {@code endIndex} or if {@code endIndex} is greater than\n     *             {@code s.length()}.\n     * @throws     NumberFormatException  if the {@code CharSequence} does not\n     *             contain a parsable unsigned {@code int} in the specified\n     *             {@code radix}, or if {@code radix} is either smaller than\n     *             {@link java.lang.Character#MIN_RADIX} or larger than\n     *             {@link java.lang.Character#MAX_RADIX}.\n     * @since  9\n     */\n    public static int parseUnsignedInt(CharSequence s, int beginIndex, int endIndex, int radix)\n                throws NumberFormatException {\n        Objects.requireNonNull(s);\n\n        if (beginIndex \u003c 0 || beginIndex \u003e endIndex || endIndex \u003e s.length()) {\n            throw new IndexOutOfBoundsException();\n        }\n        int start \u003d beginIndex, len \u003d endIndex - beginIndex;\n\n        if (len \u003e 0) {\n            char firstChar \u003d s.charAt(start);\n            if (firstChar \u003d\u003d \u0027-\u0027) {\n                throw new\n                    NumberFormatException(String.format(\"Illegal leading minus sign \" +\n                                                       \"on unsigned string %s.\", s));\n            } else {\n                if (len \u003c\u003d 5 || // Integer.MAX_VALUE in Character.MAX_RADIX is 6 digits\n                        (radix \u003d\u003d 10 \u0026\u0026 len \u003c\u003d 9)) { // Integer.MAX_VALUE in base 10 is 10 digits\n                    return parseInt(s, start, start + len, radix);\n                } else {\n                    long ell \u003d Long.parseLong(s, start, start + len, radix);\n                    if ((ell \u0026 0xffff_ffff_0000_0000L) \u003d\u003d 0) {\n                        return (int) ell;\n                    } else {\n                        throw new\n                            NumberFormatException(String.format(\"String value %s exceeds \" +\n                                                                \"range of unsigned int.\", s));\n                    }\n                }\n            }\n        } else {\n            throw new NumberFormatException(\"\");\n        }\n    }\n\n    /**\n     * Parses the string argument as an unsigned decimal integer. The\n     * characters in the string must all be decimal digits, except\n     * that the first character may be an ASCII plus sign {@code\n     * \u0027+\u0027} ({@code \u0027\\u005Cu002B\u0027}). The resulting integer value\n     * is returned, exactly as if the argument and the radix 10 were\n     * given as arguments to the {@link\n     * #parseUnsignedInt(java.lang.String, int)} method.\n     *\n     * @param s   a {@code String} containing the unsigned {@code int}\n     *            representation to be parsed\n     * @return    the unsigned integer value represented by the argument in decimal.\n     * @throws    NumberFormatException  if the string does not contain a\n     *            parsable unsigned integer.\n     * @since 1.8\n     */\n    public static int parseUnsignedInt(String s) throws NumberFormatException {\n        return parseUnsignedInt(s, 10);\n    }\n\n    /**\n     * Returns an {@code Integer} object holding the value\n     * extracted from the specified {@code String} when parsed\n     * with the radix given by the second argument. The first argument\n     * is interpreted as representing a signed integer in the radix\n     * specified by the second argument, exactly as if the arguments\n     * were given to the {@link #parseInt(java.lang.String, int)}\n     * method. The result is an {@code Integer} object that\n     * represents the integer value specified by the string.\n     *\n     * \u003cp\u003eIn other words, this method returns an {@code Integer}\n     * object equal to the value of:\n     *\n     * \u003cblockquote\u003e\n     *  {@code new Integer(Integer.parseInt(s, radix))}\n     * \u003c/blockquote\u003e\n     *\n     * @param      s   the string to be parsed.\n     * @param      radix the radix to be used in interpreting {@code s}\n     * @return     an {@code Integer} object holding the value\n     *             represented by the string argument in the specified\n     *             radix.\n     * @throws    NumberFormatException if the {@code String}\n     *            does not contain a parsable {@code int}.\n     */\n    public static Integer valueOf(String s, int radix) throws NumberFormatException {\n        return Integer.valueOf(parseInt(s,radix));\n    }\n\n    /**\n     * Returns an {@code Integer} object holding the\n     * value of the specified {@code String}. The argument is\n     * interpreted as representing a signed decimal integer, exactly\n     * as if the argument were given to the {@link\n     * #parseInt(java.lang.String)} method. The result is an\n     * {@code Integer} object that represents the integer value\n     * specified by the string.\n     *\n     * \u003cp\u003eIn other words, this method returns an {@code Integer}\n     * object equal to the value of:\n     *\n     * \u003cblockquote\u003e\n     *  {@code new Integer(Integer.parseInt(s))}\n     * \u003c/blockquote\u003e\n     *\n     * @param      s   the string to be parsed.\n     * @return     an {@code Integer} object holding the value\n     *             represented by the string argument.\n     * @throws     NumberFormatException  if the string cannot be parsed\n     *             as an integer.\n     */\n    public static Integer valueOf(String s) throws NumberFormatException {\n        return Integer.valueOf(parseInt(s, 10));\n    }\n\n    /**\n     * Cache to support the object identity semantics of autoboxing for values between\n     * -128 and 127 (inclusive) as required by JLS.\n     *\n     * The cache is initialized on first usage.  The size of the cache\n     * may be controlled by the {@code -XX:AutoBoxCacheMax\u003d\u003csize\u003e} option.\n     * During VM initialization, java.lang.Integer.IntegerCache.high property\n     * may be set and saved in the private system properties in the\n     * jdk.internal.misc.VM class.\n     *\n     * WARNING: The cache is archived with CDS and reloaded from the shared\n     * archive at runtime. The archived cache (Integer[]) and Integer objects\n     * reside in the closed archive heap regions. Care should be taken when\n     * changing the implementation and the cache array should not be assigned\n     * with new Integer object(s) after initialization.\n     */\n\n    private static class IntegerCache {\n        static final int low \u003d -128;\n        static final int high;\n        static final Integer[] cache;\n        static Integer[] archivedCache;\n\n        static {\n            // high value may be configured by property\n            int h \u003d 127;\n            String integerCacheHighPropValue \u003d\n                VM.getSavedProperty(\"java.lang.Integer.IntegerCache.high\");\n            if (integerCacheHighPropValue !\u003d null) {\n                try {\n                    h \u003d Math.max(parseInt(integerCacheHighPropValue), 127);\n                    // Maximum array size is Integer.MAX_VALUE\n                    h \u003d Math.min(h, Integer.MAX_VALUE - (-low) -1);\n                } catch( NumberFormatException nfe) {\n                    // If the property cannot be parsed into an int, ignore it.\n                }\n            }\n            high \u003d h;\n\n            // Load IntegerCache.archivedCache from archive, if possible\n            CDS.initializeFromArchive(IntegerCache.class);\n            int size \u003d (high - low) + 1;\n\n            // Use the archived cache if it exists and is large enough\n            if (archivedCache \u003d\u003d null || size \u003e archivedCache.length) {\n                Integer[] c \u003d new Integer[size];\n                int j \u003d low;\n                for(int i \u003d 0; i \u003c c.length; i++) {\n                    c[i] \u003d new Integer(j++);\n                }\n                archivedCache \u003d c;\n            }\n            cache \u003d archivedCache;\n            // range [-128, 127] must be interned (JLS7 5.1.7)\n            assert IntegerCache.high \u003e\u003d 127;\n        }\n\n        private IntegerCache() {}\n    }\n\n    /**\n     * Returns an {@code Integer} instance representing the specified\n     * {@code int} value.  If a new {@code Integer} instance is not\n     * required, this method should generally be used in preference to\n     * the constructor {@link #Integer(int)}, as this method is likely\n     * to yield significantly better space and time performance by\n     * caching frequently requested values.\n     *\n     * This method will always cache values in the range -128 to 127,\n     * inclusive, and may cache other values outside of this range.\n     *\n     * @param  i an {@code int} value.\n     * @return an {@code Integer} instance representing {@code i}.\n     * @since  1.5\n     */\n    @IntrinsicCandidate\n    public static Integer valueOf(int i) {\n        if (i \u003e\u003d IntegerCache.low \u0026\u0026 i \u003c\u003d IntegerCache.high)\n            return IntegerCache.cache[i + (-IntegerCache.low)];\n        return new Integer(i);\n    }\n\n    /**\n     * The value of the {@code Integer}.\n     *\n     * @serial\n     */\n    private final int value;\n\n    /**\n     * Constructs a newly allocated {@code Integer} object that\n     * represents the specified {@code int} value.\n     *\n     * @param   value   the value to be represented by the\n     *                  {@code Integer} object.\n     *\n     * @deprecated\n     * It is rarely appropriate to use this constructor. The static factory\n     * {@link #valueOf(int)} is generally a better choice, as it is\n     * likely to yield significantly better space and time performance.\n     */\n    @Deprecated(since\u003d\"9\", forRemoval \u003d true)\n    public Integer(int value) {\n        this.value \u003d value;\n    }\n\n    /**\n     * Constructs a newly allocated {@code Integer} object that\n     * represents the {@code int} value indicated by the\n     * {@code String} parameter. The string is converted to an\n     * {@code int} value in exactly the manner used by the\n     * {@code parseInt} method for radix 10.\n     *\n     * @param   s   the {@code String} to be converted to an {@code Integer}.\n     * @throws      NumberFormatException if the {@code String} does not\n     *              contain a parsable integer.\n     *\n     * @deprecated\n     * It is rarely appropriate to use this constructor.\n     * Use {@link #parseInt(String)} to convert a string to a\n     * {@code int} primitive, or use {@link #valueOf(String)}\n     * to convert a string to an {@code Integer} object.\n     */\n    @Deprecated(since\u003d\"9\", forRemoval \u003d true)\n    public Integer(String s) throws NumberFormatException {\n        this.value \u003d parseInt(s, 10);\n    }\n\n    /**\n     * Returns the value of this {@code Integer} as a {@code byte}\n     * after a narrowing primitive conversion.\n     * @jls 5.1.3 Narrowing Primitive Conversion\n     */\n    public byte byteValue() {\n        return (byte)value;\n    }\n\n    /**\n     * Returns the value of this {@code Integer} as a {@code short}\n     * after a narrowing primitive conversion.\n     * @jls 5.1.3 Narrowing Primitive Conversion\n     */\n    public short shortValue() {\n        return (short)value;\n    }\n\n    /**\n     * Returns the value of this {@code Integer} as an\n     * {@code int}.\n     */\n    @IntrinsicCandidate\n    public int intValue() {\n        return value;\n    }\n\n    /**\n     * Returns the value of this {@code Integer} as a {@code long}\n     * after a widening primitive conversion.\n     * @jls 5.1.2 Widening Primitive Conversion\n     * @see Integer#toUnsignedLong(int)\n     */\n    public long longValue() {\n        return (long)value;\n    }\n\n    /**\n     * Returns the value of this {@code Integer} as a {@code float}\n     * after a widening primitive conversion.\n     * @jls 5.1.2 Widening Primitive Conversion\n     */\n    public float floatValue() {\n        return (float)value;\n    }\n\n    /**\n     * Returns the value of this {@code Integer} as a {@code double}\n     * after a widening primitive conversion.\n     * @jls 5.1.2 Widening Primitive Conversion\n     */\n    public double doubleValue() {\n        return (double)value;\n    }\n\n    /**\n     * Returns a {@code String} object representing this\n     * {@code Integer}\u0027s value. The value is converted to signed\n     * decimal representation and returned as a string, exactly as if\n     * the integer value were given as an argument to the {@link\n     * java.lang.Integer#toString(int)} method.\n     *\n     * @return  a string representation of the value of this object in\n     *          base\u0026nbsp;10.\n     */\n    public String toString() {\n        return toString(value);\n    }\n\n    /**\n     * Returns a hash code for this {@code Integer}.\n     *\n     * @return  a hash code value for this object, equal to the\n     *          primitive {@code int} value represented by this\n     *          {@code Integer} object.\n     */\n    @Override\n    public int hashCode() {\n        return Integer.hashCode(value);\n    }\n\n    /**\n     * Returns a hash code for an {@code int} value; compatible with\n     * {@code Integer.hashCode()}.\n     *\n     * @param value the value to hash\n     * @since 1.8\n     *\n     * @return a hash code value for an {@code int} value.\n     */\n    public static int hashCode(int value) {\n        return value;\n    }\n\n    /**\n     * Compares this object to the specified object.  The result is\n     * {@code true} if and only if the argument is not\n     * {@code null} and is an {@code Integer} object that\n     * contains the same {@code int} value as this object.\n     *\n     * @param   obj   the object to compare with.\n     * @return  {@code true} if the objects are the same;\n     *          {@code false} otherwise.\n     */\n    public boolean equals(Object obj) {\n        if (obj instanceof Integer) {\n            return value \u003d\u003d ((Integer)obj).intValue();\n        }\n        return false;\n    }\n\n    /**\n     * Determines the integer value of the system property with the\n     * specified name.\n     *\n     * \u003cp\u003eThe first argument is treated as the name of a system\n     * property.  System properties are accessible through the {@link\n     * java.lang.System#getProperty(java.lang.String)} method. The\n     * string value of this property is then interpreted as an integer\n     * value using the grammar supported by {@link Integer#decode decode} and\n     * an {@code Integer} object representing this value is returned.\n     *\n     * \u003cp\u003eIf there is no property with the specified name, if the\n     * specified name is empty or {@code null}, or if the property\n     * does not have the correct numeric format, then {@code null} is\n     * returned.\n     *\n     * \u003cp\u003eIn other words, this method returns an {@code Integer}\n     * object equal to the value of:\n     *\n     * \u003cblockquote\u003e\n     *  {@code getInteger(nm, null)}\n     * \u003c/blockquote\u003e\n     *\n     * @param   nm   property name.\n     * @return  the {@code Integer} value of the property.\n     * @throws  SecurityException for the same reasons as\n     *          {@link System#getProperty(String) System.getProperty}\n     * @see     java.lang.System#getProperty(java.lang.String)\n     * @see     java.lang.System#getProperty(java.lang.String, java.lang.String)\n     */\n    public static Integer getInteger(String nm) {\n        return getInteger(nm, null);\n    }\n\n    /**\n     * Determines the integer value of the system property with the\n     * specified name.\n     *\n     * \u003cp\u003eThe first argument is treated as the name of a system\n     * property.  System properties are accessible through the {@link\n     * java.lang.System#getProperty(java.lang.String)} method. The\n     * string value of this property is then interpreted as an integer\n     * value using the grammar supported by {@link Integer#decode decode} and\n     * an {@code Integer} object representing this value is returned.\n     *\n     * \u003cp\u003eThe second argument is the default value. An {@code Integer} object\n     * that represents the value of the second argument is returned if there\n     * is no property of the specified name, if the property does not have\n     * the correct numeric format, or if the specified name is empty or\n     * {@code null}.\n     *\n     * \u003cp\u003eIn other words, this method returns an {@code Integer} object\n     * equal to the value of:\n     *\n     * \u003cblockquote\u003e\n     *  {@code getInteger(nm, new Integer(val))}\n     * \u003c/blockquote\u003e\n     *\n     * but in practice it may be implemented in a manner such as:\n     *\n     * \u003cblockquote\u003e\u003cpre\u003e\n     * Integer result \u003d getInteger(nm, null);\n     * return (result \u003d\u003d null) ? new Integer(val) : result;\n     * \u003c/pre\u003e\u003c/blockquote\u003e\n     *\n     * to avoid the unnecessary allocation of an {@code Integer}\n     * object when the default value is not needed.\n     *\n     * @param   nm   property name.\n     * @param   val   default value.\n     * @return  the {@code Integer} value of the property.\n     * @throws  SecurityException for the same reasons as\n     *          {@link System#getProperty(String) System.getProperty}\n     * @see     java.lang.System#getProperty(java.lang.String)\n     * @see     java.lang.System#getProperty(java.lang.String, java.lang.String)\n     */\n    public static Integer getInteger(String nm, int val) {\n        Integer result \u003d getInteger(nm, null);\n        return (result \u003d\u003d null) ? Integer.valueOf(val) : result;\n    }\n\n    /**\n     * Returns the integer value of the system property with the\n     * specified name.  The first argument is treated as the name of a\n     * system property.  System properties are accessible through the\n     * {@link java.lang.System#getProperty(java.lang.String)} method.\n     * The string value of this property is then interpreted as an\n     * integer value, as per the {@link Integer#decode decode} method,\n     * and an {@code Integer} object representing this value is\n     * returned; in summary:\n     *\n     * \u003cul\u003e\u003cli\u003eIf the property value begins with the two ASCII characters\n     *         {@code 0x} or the ASCII character {@code #}, not\n     *      followed by a minus sign, then the rest of it is parsed as a\n     *      hexadecimal integer exactly as by the method\n     *      {@link #valueOf(java.lang.String, int)} with radix 16.\n     * \u003cli\u003eIf the property value begins with the ASCII character\n     *     {@code 0} followed by another character, it is parsed as an\n     *     octal integer exactly as by the method\n     *     {@link #valueOf(java.lang.String, int)} with radix 8.\n     * \u003cli\u003eOtherwise, the property value is parsed as a decimal integer\n     * exactly as by the method {@link #valueOf(java.lang.String, int)}\n     * with radix 10.\n     * \u003c/ul\u003e\n     *\n     * \u003cp\u003eThe second argument is the default value. The default value is\n     * returned if there is no property of the specified name, if the\n     * property does not have the correct numeric format, or if the\n     * specified name is empty or {@code null}.\n     *\n     * @param   nm   property name.\n     * @param   val   default value.\n     * @return  the {@code Integer} value of the property.\n     * @throws  SecurityException for the same reasons as\n     *          {@link System#getProperty(String) System.getProperty}\n     * @see     System#getProperty(java.lang.String)\n     * @see     System#getProperty(java.lang.String, java.lang.String)\n     */\n    public static Integer getInteger(String nm, Integer val) {\n        String v \u003d null;\n        try {\n            v \u003d System.getProperty(nm);\n        } catch (IllegalArgumentException | NullPointerException e) {\n        }\n        if (v !\u003d null) {\n            try {\n                return Integer.decode(v);\n            } catch (NumberFormatException e) {\n            }\n        }\n        return val;\n    }\n\n    /**\n     * Decodes a {@code String} into an {@code Integer}.\n     * Accepts decimal, hexadecimal, and octal numbers given\n     * by the following grammar:\n     *\n     * \u003cblockquote\u003e\n     * \u003cdl\u003e\n     * \u003cdt\u003e\u003ci\u003eDecodableString:\u003c/i\u003e\n     * \u003cdd\u003e\u003ci\u003eSign\u003csub\u003eopt\u003c/sub\u003e DecimalNumeral\u003c/i\u003e\n     * \u003cdd\u003e\u003ci\u003eSign\u003csub\u003eopt\u003c/sub\u003e\u003c/i\u003e {@code 0x} \u003ci\u003eHexDigits\u003c/i\u003e\n     * \u003cdd\u003e\u003ci\u003eSign\u003csub\u003eopt\u003c/sub\u003e\u003c/i\u003e {@code 0X} \u003ci\u003eHexDigits\u003c/i\u003e\n     * \u003cdd\u003e\u003ci\u003eSign\u003csub\u003eopt\u003c/sub\u003e\u003c/i\u003e {@code #} \u003ci\u003eHexDigits\u003c/i\u003e\n     * \u003cdd\u003e\u003ci\u003eSign\u003csub\u003eopt\u003c/sub\u003e\u003c/i\u003e {@code 0} \u003ci\u003eOctalDigits\u003c/i\u003e\n     *\n     * \u003cdt\u003e\u003ci\u003eSign:\u003c/i\u003e\n     * \u003cdd\u003e{@code -}\n     * \u003cdd\u003e{@code +}\n     * \u003c/dl\u003e\n     * \u003c/blockquote\u003e\n     *\n     * \u003ci\u003eDecimalNumeral\u003c/i\u003e, \u003ci\u003eHexDigits\u003c/i\u003e, and \u003ci\u003eOctalDigits\u003c/i\u003e\n     * are as defined in section {@jls 3.10.1} of\n     * \u003ccite\u003eThe Java Language Specification\u003c/cite\u003e,\n     * except that underscores are not accepted between digits.\n     *\n     * \u003cp\u003eThe sequence of characters following an optional\n     * sign and/or radix specifier (\"{@code 0x}\", \"{@code 0X}\",\n     * \"{@code #}\", or leading zero) is parsed as by the {@code\n     * Integer.parseInt} method with the indicated radix (10, 16, or\n     * 8).  This sequence of characters must represent a positive\n     * value or a {@link NumberFormatException} will be thrown.  The\n     * result is negated if first character of the specified {@code\n     * String} is the minus sign.  No whitespace characters are\n     * permitted in the {@code String}.\n     *\n     * @param     nm the {@code String} to decode.\n     * @return    an {@code Integer} object holding the {@code int}\n     *             value represented by {@code nm}\n     * @throws    NumberFormatException  if the {@code String} does not\n     *            contain a parsable integer.\n     * @see java.lang.Integer#parseInt(java.lang.String, int)\n     */\n    public static Integer decode(String nm) throws NumberFormatException {\n        int radix \u003d 10;\n        int index \u003d 0;\n        boolean negative \u003d false;\n        Integer result;\n\n        if (nm.isEmpty())\n            throw new NumberFormatException(\"Zero length string\");\n        char firstChar \u003d nm.charAt(0);\n        // Handle sign, if present\n        if (firstChar \u003d\u003d \u0027-\u0027) {\n            negative \u003d true;\n            index++;\n        } else if (firstChar \u003d\u003d \u0027+\u0027)\n            index++;\n\n        // Handle radix specifier, if present\n        if (nm.startsWith(\"0x\", index) || nm.startsWith(\"0X\", index)) {\n            index +\u003d 2;\n            radix \u003d 16;\n        }\n        else if (nm.startsWith(\"#\", index)) {\n            index ++;\n            radix \u003d 16;\n        }\n        else if (nm.startsWith(\"0\", index) \u0026\u0026 nm.length() \u003e 1 + index) {\n            index ++;\n            radix \u003d 8;\n        }\n\n        if (nm.startsWith(\"-\", index) || nm.startsWith(\"+\", index))\n            throw new NumberFormatException(\"Sign character in wrong position\");\n\n        try {\n            result \u003d Integer.valueOf(nm.substring(index), radix);\n            result \u003d negative ? Integer.valueOf(-result.intValue()) : result;\n        } catch (NumberFormatException e) {\n            // If number is Integer.MIN_VALUE, we\u0027ll end up here. The next line\n            // handles this case, and causes any genuine format error to be\n            // rethrown.\n            String constant \u003d negative ? (\"-\" + nm.substring(index))\n                                       : nm.substring(index);\n            result \u003d Integer.valueOf(constant, radix);\n        }\n        return result;\n    }\n\n    /**\n     * Compares two {@code Integer} objects numerically.\n     *\n     * @param   anotherInteger   the {@code Integer} to be compared.\n     * @return  the value {@code 0} if this {@code Integer} is\n     *          equal to the argument {@code Integer}; a value less than\n     *          {@code 0} if this {@code Integer} is numerically less\n     *          than the argument {@code Integer}; and a value greater\n     *          than {@code 0} if this {@code Integer} is numerically\n     *           greater than the argument {@code Integer} (signed\n     *           comparison).\n     * @since   1.2\n     */\n    public int compareTo(Integer anotherInteger) {\n        return compare(this.value, anotherInteger.value);\n    }\n\n    /**\n     * Compares two {@code int} values numerically.\n     * The value returned is identical to what would be returned by:\n     * \u003cpre\u003e\n     *    Integer.valueOf(x).compareTo(Integer.valueOf(y))\n     * \u003c/pre\u003e\n     *\n     * @param  x the first {@code int} to compare\n     * @param  y the second {@code int} to compare\n     * @return the value {@code 0} if {@code x \u003d\u003d y};\n     *         a value less than {@code 0} if {@code x \u003c y}; and\n     *         a value greater than {@code 0} if {@code x \u003e y}\n     * @since 1.7\n     */\n    public static int compare(int x, int y) {\n        return (x \u003c y) ? -1 : ((x \u003d\u003d y) ? 0 : 1);\n    }\n\n    /**\n     * Compares two {@code int} values numerically treating the values\n     * as unsigned.\n     *\n     * @param  x the first {@code int} to compare\n     * @param  y the second {@code int} to compare\n     * @return the value {@code 0} if {@code x \u003d\u003d y}; a value less\n     *         than {@code 0} if {@code x \u003c y} as unsigned values; and\n     *         a value greater than {@code 0} if {@code x \u003e y} as\n     *         unsigned values\n     * @since 1.8\n     */\n    public static int compareUnsigned(int x, int y) {\n        return compare(x + MIN_VALUE, y + MIN_VALUE);\n    }\n\n    /**\n     * Converts the argument to a {@code long} by an unsigned\n     * conversion.  In an unsigned conversion to a {@code long}, the\n     * high-order 32 bits of the {@code long} are zero and the\n     * low-order 32 bits are equal to the bits of the integer\n     * argument.\n     *\n     * Consequently, zero and positive {@code int} values are mapped\n     * to a numerically equal {@code long} value and negative {@code\n     * int} values are mapped to a {@code long} value equal to the\n     * input plus 2\u003csup\u003e32\u003c/sup\u003e.\n     *\n     * @param  x the value to convert to an unsigned {@code long}\n     * @return the argument converted to {@code long} by an unsigned\n     *         conversion\n     * @since 1.8\n     */\n    public static long toUnsignedLong(int x) {\n        return ((long) x) \u0026 0xffffffffL;\n    }\n\n    /**\n     * Returns the unsigned quotient of dividing the first argument by\n     * the second where each argument and the result is interpreted as\n     * an unsigned value.\n     *\n     * \u003cp\u003eNote that in two\u0027s complement arithmetic, the three other\n     * basic arithmetic operations of add, subtract, and multiply are\n     * bit-wise identical if the two operands are regarded as both\n     * being signed or both being unsigned.  Therefore separate {@code\n     * addUnsigned}, etc. methods are not provided.\n     *\n     * @param dividend the value to be divided\n     * @param divisor the value doing the dividing\n     * @return the unsigned quotient of the first argument divided by\n     * the second argument\n     * @see #remainderUnsigned\n     * @since 1.8\n     */\n    public static int divideUnsigned(int dividend, int divisor) {\n        // In lieu of tricky code, for now just use long arithmetic.\n        return (int)(toUnsignedLong(dividend) / toUnsignedLong(divisor));\n    }\n\n    /**\n     * Returns the unsigned remainder from dividing the first argument\n     * by the second where each argument and the result is interpreted\n     * as an unsigned value.\n     *\n     * @param dividend the value to be divided\n     * @param divisor the value doing the dividing\n     * @return the unsigned remainder of the first argument divided by\n     * the second argument\n     * @see #divideUnsigned\n     * @since 1.8\n     */\n    public static int remainderUnsigned(int dividend, int divisor) {\n        // In lieu of tricky code, for now just use long arithmetic.\n        return (int)(toUnsignedLong(dividend) % toUnsignedLong(divisor));\n    }\n\n\n    // Bit twiddling\n\n    /**\n     * The number of bits used to represent an {@code int} value in two\u0027s\n     * complement binary form.\n     *\n     * @since 1.5\n     */\n    @Native public static final int SIZE \u003d 32;\n\n    /**\n     * The number of bytes used to represent an {@code int} value in two\u0027s\n     * complement binary form.\n     *\n     * @since 1.8\n     */\n    public static final int BYTES \u003d SIZE / Byte.SIZE;\n\n    /**\n     * Returns an {@code int} value with at most a single one-bit, in the\n     * position of the highest-order (\"leftmost\") one-bit in the specified\n     * {@code int} value.  Returns zero if the specified value has no\n     * one-bits in its two\u0027s complement binary representation, that is, if it\n     * is equal to zero.\n     *\n     * @param i the value whose highest one bit is to be computed\n     * @return an {@code int} value with a single one-bit, in the position\n     *     of the highest-order one-bit in the specified value, or zero if\n     *     the specified value is itself equal to zero.\n     * @since 1.5\n     */\n    public static int highestOneBit(int i) {\n        return i \u0026 (MIN_VALUE \u003e\u003e\u003e numberOfLeadingZeros(i));\n    }\n\n    /**\n     * Returns an {@code int} value with at most a single one-bit, in the\n     * position of the lowest-order (\"rightmost\") one-bit in the specified\n     * {@code int} value.  Returns zero if the specified value has no\n     * one-bits in its two\u0027s complement binary representation, that is, if it\n     * is equal to zero.\n     *\n     * @param i the value whose lowest one bit is to be computed\n     * @return an {@code int} value with a single one-bit, in the position\n     *     of the lowest-order one-bit in the specified value, or zero if\n     *     the specified value is itself equal to zero.\n     * @since 1.5\n     */\n    public static int lowestOneBit(int i) {\n        // HD, Section 2-1\n        return i \u0026 -i;\n    }\n\n    /**\n     * Returns the number of zero bits preceding the highest-order\n     * (\"leftmost\") one-bit in the two\u0027s complement binary representation\n     * of the specified {@code int} value.  Returns 32 if the\n     * specified value has no one-bits in its two\u0027s complement representation,\n     * in other words if it is equal to zero.\n     *\n     * \u003cp\u003eNote that this method is closely related to the logarithm base 2.\n     * For all positive {@code int} values x:\n     * \u003cul\u003e\n     * \u003cli\u003efloor(log\u003csub\u003e2\u003c/sub\u003e(x)) \u003d {@code 31 - numberOfLeadingZeros(x)}\n     * \u003cli\u003eceil(log\u003csub\u003e2\u003c/sub\u003e(x)) \u003d {@code 32 - numberOfLeadingZeros(x - 1)}\n     * \u003c/ul\u003e\n     *\n     * @param i the value whose number of leading zeros is to be computed\n     * @return the number of zero bits preceding the highest-order\n     *     (\"leftmost\") one-bit in the two\u0027s complement binary representation\n     *     of the specified {@code int} value, or 32 if the value\n     *     is equal to zero.\n     * @since 1.5\n     */\n    @IntrinsicCandidate\n    public static int numberOfLeadingZeros(int i) {\n        // HD, Count leading 0\u0027s\n        if (i \u003c\u003d 0)\n            return i \u003d\u003d 0 ? 32 : 0;\n        int n \u003d 31;\n        if (i \u003e\u003d 1 \u003c\u003c 16) { n -\u003d 16; i \u003e\u003e\u003e\u003d 16; }\n        if (i \u003e\u003d 1 \u003c\u003c  8) { n -\u003d  8; i \u003e\u003e\u003e\u003d  8; }\n        if (i \u003e\u003d 1 \u003c\u003c  4) { n -\u003d  4; i \u003e\u003e\u003e\u003d  4; }\n        if (i \u003e\u003d 1 \u003c\u003c  2) { n -\u003d  2; i \u003e\u003e\u003e\u003d  2; }\n        return n - (i \u003e\u003e\u003e 1);\n    }\n\n    /**\n     * Returns the number of zero bits following the lowest-order (\"rightmost\")\n     * one-bit in the two\u0027s complement binary representation of the specified\n     * {@code int} value.  Returns 32 if the specified value has no\n     * one-bits in its two\u0027s complement representation, in other words if it is\n     * equal to zero.\n     *\n     * @param i the value whose number of trailing zeros is to be computed\n     * @return the number of zero bits following the lowest-order (\"rightmost\")\n     *     one-bit in the two\u0027s complement binary representation of the\n     *     specified {@code int} value, or 32 if the value is equal\n     *     to zero.\n     * @since 1.5\n     */\n    @IntrinsicCandidate\n    public static int numberOfTrailingZeros(int i) {\n        // HD, Count trailing 0\u0027s\n        i \u003d ~i \u0026 (i - 1);\n        if (i \u003c\u003d 0) return i \u0026 32;\n        int n \u003d 1;\n        if (i \u003e 1 \u003c\u003c 16) { n +\u003d 16; i \u003e\u003e\u003e\u003d 16; }\n        if (i \u003e 1 \u003c\u003c  8) { n +\u003d  8; i \u003e\u003e\u003e\u003d  8; }\n        if (i \u003e 1 \u003c\u003c  4) { n +\u003d  4; i \u003e\u003e\u003e\u003d  4; }\n        if (i \u003e 1 \u003c\u003c  2) { n +\u003d  2; i \u003e\u003e\u003e\u003d  2; }\n        return n + (i \u003e\u003e\u003e 1);\n    }\n\n    /**\n     * Returns the number of one-bits in the two\u0027s complement binary\n     * representation of the specified {@code int} value.  This function is\n     * sometimes referred to as the \u003ci\u003epopulation count\u003c/i\u003e.\n     *\n     * @param i the value whose bits are to be counted\n     * @return the number of one-bits in the two\u0027s complement binary\n     *     representation of the specified {@code int} value.\n     * @since 1.5\n     */\n    @IntrinsicCandidate\n    public static int bitCount(int i) {\n        // HD, Figure 5-2\n        i \u003d i - ((i \u003e\u003e\u003e 1) \u0026 0x55555555);\n        i \u003d (i \u0026 0x33333333) + ((i \u003e\u003e\u003e 2) \u0026 0x33333333);\n        i \u003d (i + (i \u003e\u003e\u003e 4)) \u0026 0x0f0f0f0f;\n        i \u003d i + (i \u003e\u003e\u003e 8);\n        i \u003d i + (i \u003e\u003e\u003e 16);\n        return i \u0026 0x3f;\n    }\n\n    /**\n     * Returns the value obtained by rotating the two\u0027s complement binary\n     * representation of the specified {@code int} value left by the\n     * specified number of bits.  (Bits shifted out of the left hand, or\n     * high-order, side reenter on the right, or low-order.)\n     *\n     * \u003cp\u003eNote that left rotation with a negative distance is equivalent to\n     * right rotation: {@code rotateLeft(val, -distance) \u003d\u003d rotateRight(val,\n     * distance)}.  Note also that rotation by any multiple of 32 is a\n     * no-op, so all but the last five bits of the rotation distance can be\n     * ignored, even if the distance is negative: {@code rotateLeft(val,\n     * distance) \u003d\u003d rotateLeft(val, distance \u0026 0x1F)}.\n     *\n     * @param i the value whose bits are to be rotated left\n     * @param distance the number of bit positions to rotate left\n     * @return the value obtained by rotating the two\u0027s complement binary\n     *     representation of the specified {@code int} value left by the\n     *     specified number of bits.\n     * @since 1.5\n     */\n    public static int rotateLeft(int i, int distance) {\n        return (i \u003c\u003c distance) | (i \u003e\u003e\u003e -distance);\n    }\n\n    /**\n     * Returns the value obtained by rotating the two\u0027s complement binary\n     * representation of the specified {@code int} value right by the\n     * specified number of bits.  (Bits shifted out of the right hand, or\n     * low-order, side reenter on the left, or high-order.)\n     *\n     * \u003cp\u003eNote that right rotation with a negative distance is equivalent to\n     * left rotation: {@code rotateRight(val, -distance) \u003d\u003d rotateLeft(val,\n     * distance)}.  Note also that rotation by any multiple of 32 is a\n     * no-op, so all but the last five bits of the rotation distance can be\n     * ignored, even if the distance is negative: {@code rotateRight(val,\n     * distance) \u003d\u003d rotateRight(val, distance \u0026 0x1F)}.\n     *\n     * @param i the value whose bits are to be rotated right\n     * @param distance the number of bit positions to rotate right\n     * @return the value obtained by rotating the two\u0027s complement binary\n     *     representation of the specified {@code int} value right by the\n     *     specified number of bits.\n     * @since 1.5\n     */\n    public static int rotateRight(int i, int distance) {\n        return (i \u003e\u003e\u003e distance) | (i \u003c\u003c -distance);\n    }\n\n    /**\n     * Returns the value obtained by reversing the order of the bits in the\n     * two\u0027s complement binary representation of the specified {@code int}\n     * value.\n     *\n     * @param i the value to be reversed\n     * @return the value obtained by reversing order of the bits in the\n     *     specified {@code int} value.\n     * @since 1.5\n     */\n    public static int reverse(int i) {\n        // HD, Figure 7-1\n        i \u003d (i \u0026 0x55555555) \u003c\u003c 1 | (i \u003e\u003e\u003e 1) \u0026 0x55555555;\n        i \u003d (i \u0026 0x33333333) \u003c\u003c 2 | (i \u003e\u003e\u003e 2) \u0026 0x33333333;\n        i \u003d (i \u0026 0x0f0f0f0f) \u003c\u003c 4 | (i \u003e\u003e\u003e 4) \u0026 0x0f0f0f0f;\n\n        return reverseBytes(i);\n    }\n\n    /**\n     * Returns the signum function of the specified {@code int} value.  (The\n     * return value is -1 if the specified value is negative; 0 if the\n     * specified value is zero; and 1 if the specified value is positive.)\n     *\n     * @param i the value whose signum is to be computed\n     * @return the signum function of the specified {@code int} value.\n     * @since 1.5\n     */\n    public static int signum(int i) {\n        // HD, Section 2-7\n        return (i \u003e\u003e 31) | (-i \u003e\u003e\u003e 31);\n    }\n\n    /**\n     * Returns the value obtained by reversing the order of the bytes in the\n     * two\u0027s complement representation of the specified {@code int} value.\n     *\n     * @param i the value whose bytes are to be reversed\n     * @return the value obtained by reversing the bytes in the specified\n     *     {@code int} value.\n     * @since 1.5\n     */\n    @IntrinsicCandidate\n    public static int reverseBytes(int i) {\n        return (i \u003c\u003c 24)            |\n               ((i \u0026 0xff00) \u003c\u003c 8)  |\n               ((i \u003e\u003e\u003e 8) \u0026 0xff00) |\n               (i \u003e\u003e\u003e 24);\n    }\n\n    /**\n     * Adds two integers together as per the + operator.\n     *\n     * @param a the first operand\n     * @param b the second operand\n     * @return the sum of {@code a} and {@code b}\n     * @see java.util.function.BinaryOperator\n     * @since 1.8\n     */\n    public static int sum(int a, int b) {\n        return a + b;\n    }\n\n    /**\n     * Returns the greater of two {@code int} values\n     * as if by calling {@link Math#max(int, int) Math.max}.\n     *\n     * @param a the first operand\n     * @param b the second operand\n     * @return the greater of {@code a} and {@code b}\n     * @see java.util.function.BinaryOperator\n     * @since 1.8\n     */\n    public static int max(int a, int b) {\n        return Math.max(a, b);\n    }\n\n    /**\n     * Returns the smaller of two {@code int} values\n     * as if by calling {@link Math#min(int, int) Math.min}.\n     *\n     * @param a the first operand\n     * @param b the second operand\n     * @return the smaller of {@code a} and {@code b}\n     * @see java.util.function.BinaryOperator\n     * @since 1.8\n     */\n    public static int min(int a, int b) {\n        return Math.min(a, b);\n    }\n\n    /**\n     * Returns an {@link Optional} containing the nominal descriptor for this\n     * instance, which is the instance itself.\n     *\n     * @return an {@link Optional} describing the {@linkplain Integer} instance\n     * @since 12\n     */\n    @Override\n    public Optional\u003cInteger\u003e describeConstable() {\n        return Optional.of(this);\n    }\n\n    /**\n     * Resolves this instance as a {@link ConstantDesc}, the result of which is\n     * the instance itself.\n     *\n     * @param lookup ignored\n     * @return the {@linkplain Integer} instance\n     * @since 12\n     */\n    @Override\n    public Integer resolveConstantDesc(MethodHandles.Lookup lookup) {\n        return this;\n    }\n\n    /** use serialVersionUID from JDK 1.0.2 for interoperability */\n    @java.io.Serial\n    @Native private static final long serialVersionUID \u003d 1360826667806852920L;\n}\n"
    }
  }
}
java.lang.IllegalArgumentException: Illegal character in opaque part at index 188: jar:file:///C:/Users/Vinicius/AppData/Local/Coursier/cache/arc/https/github.com/adoptium/temurin17-binaries/releases/download/jdk-17%2B35/OpenJDK17-jdk_x64_windows_hotspot_17_35.zip/jdk-17 35/lib/src.zip!/java.base/java/lang/Integer.java
	at java.base/java.net.URI.create(URI.java:906)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:178)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.$anonfun$toAbsolutePath$3(MtagsEnrichments.scala:175)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.withTryDecode$1(MtagsEnrichments.scala:153)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:175)
	at scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:756)
	at scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:753)
	at scala.meta.internal.metals.WorkspaceLspService.didOpen(WorkspaceLspService.scala:388)
	at scala.meta.metals.lsp.DelegatingScalaService.didOpen(DelegatingScalaService.scala:39)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:568)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$recursiveFindRpcMethods$0(GenericEndpoint.java:65)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.notify(GenericEndpoint.java:160)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleNotification(RemoteEndpoint.java:231)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:198)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:185)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:97)
	at org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:114)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:539)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.base/java.lang.Thread.run(Thread.java:833)
Caused by: java.net.URISyntaxException: Illegal character in opaque part at index 188: jar:file:///C:/Users/Vinicius/AppData/Local/Coursier/cache/arc/https/github.com/adoptium/temurin17-binaries/releases/download/jdk-17%2B35/OpenJDK17-jdk_x64_windows_hotspot_17_35.zip/jdk-17 35/lib/src.zip!/java.base/java/lang/Integer.java
	at java.base/java.net.URI$Parser.fail(URI.java:2974)
	at java.base/java.net.URI$Parser.checkChars(URI.java:3145)
	at java.base/java.net.URI$Parser.parse(URI.java:3181)
	at java.base/java.net.URI.<init>(URI.java:623)
	at java.base/java.net.URI.create(URI.java:904)
	... 24 more

jul. 19, 2024 12:33:18 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleNotification
ADVERTÊNCIA: Notification threw an exception: {
  "jsonrpc": "2.0",
  "method": "textDocument/didClose",
  "params": {
    "textDocument": {
      "uri": "jar:file%3A///C%3A/Users/Vinicius/AppData/Local/Coursier/cache/arc/https/github.com/adoptium/temurin17-binaries/releases/download/jdk-17%25252B35/OpenJDK17-jdk_x64_windows_hotspot_17_35.zip/jdk-17%2B35/lib/src.zip%21/java.base/java/lang/Integer.java"
    }
  }
}
java.lang.IllegalArgumentException: Illegal character in opaque part at index 188: jar:file:///C:/Users/Vinicius/AppData/Local/Coursier/cache/arc/https/github.com/adoptium/temurin17-binaries/releases/download/jdk-17%2B35/OpenJDK17-jdk_x64_windows_hotspot_17_35.zip/jdk-17 35/lib/src.zip!/java.base/java/lang/Integer.java
	at java.base/java.net.URI.create(URI.java:906)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:178)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.$anonfun$toAbsolutePath$3(MtagsEnrichments.scala:175)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.withTryDecode$1(MtagsEnrichments.scala:153)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:175)
	at scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:756)
	at scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:753)
	at scala.meta.internal.metals.WorkspaceLspService.didClose(WorkspaceLspService.scala:407)
	at scala.meta.metals.lsp.DelegatingScalaService.didClose(DelegatingScalaService.scala:53)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:568)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$recursiveFindRpcMethods$0(GenericEndpoint.java:65)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.notify(GenericEndpoint.java:160)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleNotification(RemoteEndpoint.java:231)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:198)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:185)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:97)
	at org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:114)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:539)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.base/java.lang.Thread.run(Thread.java:833)
Caused by: java.net.URISyntaxException: Illegal character in opaque part at index 188: jar:file:///C:/Users/Vinicius/AppData/Local/Coursier/cache/arc/https/github.com/adoptium/temurin17-binaries/releases/download/jdk-17%2B35/OpenJDK17-jdk_x64_windows_hotspot_17_35.zip/jdk-17 35/lib/src.zip!/java.base/java/lang/Integer.java
	at java.base/java.net.URI$Parser.fail(URI.java:2974)
	at java.base/java.net.URI$Parser.checkChars(URI.java:3145)
	at java.base/java.net.URI$Parser.parse(URI.java:3181)
	at java.base/java.net.URI.<init>(URI.java:623)
	at java.base/java.net.URI.create(URI.java:904)
	... 24 more

2024.07.19 12:33:20 WARN  Could not load snapshot text for C:\Users\Vinicius\UnB\FLanguage\src\main\scala\br\unb\cic\flang\MonadState.scala
2024.07.19 12:33:21 WARN  Could not load snapshot text for C:\Users\Vinicius\UnB\FLanguage\src\main\scala\br\unb\cic\flang\MonadState.scala
2024.07.19 12:33:21 WARN  Could not load snapshot text for C:\Users\Vinicius\UnB\FLanguage\src\main\scala\br\unb\cic\flang\MonadState.scala
2024.07.19 12:33:22 INFO  Can not organize imports if file has error
2024.07.19 12:33:22 INFO  compiling root (2 scala sources)
2024.07.19 12:33:22 INFO  time: compiled root in 0.25s
2024.07.19 12:33:22 WARN  Could not load snapshot text for C:\Users\Vinicius\UnB\FLanguage\src\main\scala\br\unb\cic\flang\MonadState.scala
2024.07.19 12:34:13 WARN  Could not load snapshot text for C:\Users\Vinicius\UnB\FLanguage\src\main\scala\br\unb\cic\flang\MonadState.scala
2024.07.19 12:34:14 WARN  Could not load snapshot text for C:\Users\Vinicius\UnB\FLanguage\src\main\scala\br\unb\cic\flang\MonadState.scala
2024.07.19 12:34:15 WARN  Could not load snapshot text for C:\Users\Vinicius\UnB\FLanguage\src\main\scala\br\unb\cic\flang\MonadState.scala
2024.07.19 12:34:18 WARN  Could not load snapshot text for C:\Users\Vinicius\UnB\FLanguage\src\main\scala\br\unb\cic\flang\MonadState.scala
2024.07.19 12:34:19 WARN  Could not load snapshot text for C:\Users\Vinicius\UnB\FLanguage\src\main\scala\br\unb\cic\flang\MonadState.scala
2024.07.19 12:35:19 WARN  Could not load snapshot text for C:\Users\Vinicius\UnB\FLanguage\src\main\scala\br\unb\cic\flang\MonadState.scala
2024.07.19 12:35:23 WARN  Could not load snapshot text for C:\Users\Vinicius\UnB\FLanguage\src\main\scala\br\unb\cic\flang\MonadState.scala
2024.07.19 12:35:23 WARN  Could not load snapshot text for C:\Users\Vinicius\UnB\FLanguage\src\main\scala\br\unb\cic\flang\MonadState.scala
2024.07.19 12:35:24 WARN  Could not load snapshot text for C:\Users\Vinicius\UnB\FLanguage\src\main\scala\br\unb\cic\flang\MonadState.scala
2024.07.19 12:35:24 WARN  Could not load snapshot text for C:\Users\Vinicius\UnB\FLanguage\src\main\scala\br\unb\cic\flang\MonadState.scala
2024.07.19 12:35:25 WARN  Could not load snapshot text for C:\Users\Vinicius\UnB\FLanguage\src\main\scala\br\unb\cic\flang\MonadState.scala
2024.07.19 12:35:25 INFO  Can not organize imports if file has error
2024.07.19 12:35:26 INFO  compiling root (2 scala sources)
2024.07.19 12:35:26 INFO  time: compiled root in 0.31s
2024.07.19 12:35:26 WARN  Could not load snapshot text for C:\Users\Vinicius\UnB\FLanguage\src\main\scala\br\unb\cic\flang\MonadState.scala
2024.07.19 12:35:26 WARN  Could not load snapshot text for C:\Users\Vinicius\UnB\FLanguage\src\main\scala\br\unb\cic\flang\MonadState.scala
2024.07.19 12:35:27 WARN  Could not load snapshot text for C:\Users\Vinicius\UnB\FLanguage\src\main\scala\br\unb\cic\flang\MonadState.scala
2024.07.19 12:35:28 WARN  Could not load snapshot text for C:\Users\Vinicius\UnB\FLanguage\src\main\scala\br\unb\cic\flang\MonadState.scala
something's wrong: no file:///C:/Users/Vinicius/UnB/FLanguage/src/main/scala/br/unb/cic/flang/MonadState.scala in cats.data.State[br.unb.cic.flang.MonadState.package.S,<error>]RangePosition(file:///C:/Users/Vinicius/UnB/FLanguage/src/main/scala/br/unb/cic/flang/MonadState.scala, 219, 219, 237)
2024.07.19 12:35:27 WARN  Could not load snapshot text for C:\Users\Vinicius\UnB\FLanguage\src\main\scala\br\unb\cic\flang\MonadState.scala
something's wrong: no file:///C:/Users/Vinicius/UnB/FLanguage/src/main/scala/br/unb/cic/flang/MonadState.scala in cats.data.State[br.unb.cic.flang.MonadState.package.S,<error>]RangePosition(file:///C:/Users/Vinicius/UnB/FLanguage/src/main/scala/br/unb/cic/flang/MonadState.scala, 219, 219, 230)
2024.07.19 12:35:28 WARN  Could not load snapshot text for C:\Users\Vinicius\UnB\FLanguage\src\main\scala\br\unb\cic\flang\MonadState.scala
2024.07.19 12:35:29 INFO  Can not organize imports if file has error
2024.07.19 12:35:29 INFO  compiling root (2 scala sources)
2024.07.19 12:35:29 INFO  time: compiled root in 0.25s
2024.07.19 12:35:29 WARN  Could not load snapshot text for C:\Users\Vinicius\UnB\FLanguage\src\main\scala\br\unb\cic\flang\MonadState.scala
jul. 19, 2024 12:35:30 PM scala.meta.internal.pc.CompilerAccess retryWithCleanCompiler
INFORMAÇÕES: compiler crashed due to an error in the Scala compiler, retrying with new compiler instance.
jul. 19, 2024 12:35:30 PM scala.meta.internal.pc.CompilerAccess handleError
GRAVE: A severe compiler error occurred, full details of the error can be found in the error report C:\Users\Vinicius\UnB\FLanguage\.metals\.reports\metals-full\2024-07-19\r_compiler-error_(root)_12-35-30-515.md
2024.07.19 12:35:33 WARN  Could not load snapshot text for C:\Users\Vinicius\UnB\FLanguage\src\main\scala\br\unb\cic\flang\MonadState.scala
2024.07.19 12:35:33 INFO  Can not organize imports if file has error
2024.07.19 12:35:33 INFO  compiling root (2 scala sources)
2024.07.19 12:35:33 INFO  time: compiled root in 0.31s
2024.07.19 12:35:34 WARN  Could not load snapshot text for C:\Users\Vinicius\UnB\FLanguage\src\main\scala\br\unb\cic\flang\MonadState.scala
2024.07.19 12:35:34 WARN  Could not load snapshot text for C:\Users\Vinicius\UnB\FLanguage\src\main\scala\br\unb\cic\flang\MonadState.scala
2024.07.19 12:35:37 WARN  Could not load snapshot text for C:\Users\Vinicius\UnB\FLanguage\src\main\scala\br\unb\cic\flang\MonadState.scala
jul. 19, 2024 12:35:38 PM scala.meta.internal.pc.CompilerAccess retryWithCleanCompiler
INFORMAÇÕES: compiler crashed due to an error in the Scala compiler, retrying with new compiler instance.
jul. 19, 2024 12:35:38 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
ADVERTÊNCIA: Unmatched cancel notification for request id 1944
2024.07.19 12:35:39 WARN  Could not load snapshot text for C:\Users\Vinicius\UnB\FLanguage\src\main\scala\br\unb\cic\flang\MonadState.scala
2024.07.19 12:35:39 WARN  Could not load snapshot text for C:\Users\Vinicius\UnB\FLanguage\src\main\scala\br\unb\cic\flang\MonadState.scala
jul. 19, 2024 12:35:39 PM scala.meta.internal.pc.CompilerAccess retryWithCleanCompiler
INFORMAÇÕES: compiler crashed due to an error in the Scala compiler, retrying with new compiler instance.
2024.07.19 12:35:40 WARN  Could not load snapshot text for C:\Users\Vinicius\UnB\FLanguage\src\main\scala\br\unb\cic\flang\MonadState.scala
2024.07.19 12:35:41 WARN  Could not load snapshot text for C:\Users\Vinicius\UnB\FLanguage\src\main\scala\br\unb\cic\flang\MonadState.scala
2024.07.19 12:35:41 INFO  Can not organize imports if file has error
2024.07.19 12:35:41 INFO  compiling root (2 scala sources)
jul. 19, 2024 12:35:41 PM scala.meta.internal.pc.CompilerAccess retryWithCleanCompiler
INFORMAÇÕES: compiler crashed due to an error in the Scala compiler, retrying with new compiler instance.
2024.07.19 12:35:41 INFO  time: compiled root in 0.34s
jul. 19, 2024 12:35:42 PM scala.meta.internal.pc.CompilerAccess handleError
GRAVE: A severe compiler error occurred, full details of the error can be found in the error report C:\Users\Vinicius\UnB\FLanguage\.metals\.reports\metals-full\2024-07-19\r_compiler-error_(root)_12-35-42-226.md
2024.07.19 12:35:42 WARN  Could not load snapshot text for C:\Users\Vinicius\UnB\FLanguage\src\main\scala\br\unb\cic\flang\MonadState.scala
2024.07.19 12:35:51 WARN  Could not load snapshot text for C:\Users\Vinicius\UnB\FLanguage\src\main\scala\br\unb\cic\flang\MonadState.scala
2024.07.19 12:35:51 WARN  Could not load snapshot text for C:\Users\Vinicius\UnB\FLanguage\src\main\scala\br\unb\cic\flang\MonadState.scala
2024.07.19 12:35:51 WARN  Could not load snapshot text for C:\Users\Vinicius\UnB\FLanguage\src\main\scala\br\unb\cic\flang\MonadState.scala
2024.07.19 12:35:52 INFO  Can not organize imports if file has error
2024.07.19 12:35:52 WARN  Could not load snapshot text for C:\Users\Vinicius\UnB\FLanguage\src\main\scala\br\unb\cic\flang\MonadState.scala
2024.07.19 12:35:52 INFO  compiling root (2 scala sources)
2024.07.19 12:35:52 INFO  time: compiled root in 0.24s
2024.07.19 12:35:53 WARN  Could not load snapshot text for C:\Users\Vinicius\UnB\FLanguage\src\main\scala\br\unb\cic\flang\MonadState.scala
2024.07.19 12:35:59 WARN  Could not load snapshot text for C:\Users\Vinicius\UnB\FLanguage\src\main\scala\br\unb\cic\flang\MonadState.scala
2024.07.19 12:36:04 WARN  Could not load snapshot text for C:\Users\Vinicius\UnB\FLanguage\src\main\scala\br\unb\cic\flang\MonadState.scala
2024.07.19 12:36:34 WARN  Could not load snapshot text for C:\Users\Vinicius\UnB\FLanguage\src\main\scala\br\unb\cic\flang\MonadState.scala
2024.07.19 12:36:39 WARN  Could not load snapshot text for C:\Users\Vinicius\UnB\FLanguage\src\main\scala\br\unb\cic\flang\MonadState.scala
jul. 19, 2024 12:38:21 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
ADVERTÊNCIA: Unmatched cancel notification for request id 2050
jul. 19, 2024 12:38:22 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
ADVERTÊNCIA: Unmatched cancel notification for request id 2058
2024.07.19 12:38:22 WARN  Could not load snapshot text for C:\Users\Vinicius\UnB\FLanguage\src\main\scala\br\unb\cic\flang\MonadState.scala
jul. 19, 2024 12:38:26 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
ADVERTÊNCIA: Unmatched cancel notification for request id 2069
2024.07.19 12:38:26 WARN  Could not load snapshot text for C:\Users\Vinicius\UnB\FLanguage\src\main\scala\br\unb\cic\flang\Interpreter2.scala
jul. 19, 2024 12:38:33 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
ADVERTÊNCIA: Unmatched cancel notification for request id 2085
2024.07.19 12:38:33 WARN  Could not load snapshot text for C:\Users\Vinicius\UnB\FLanguage\src\main\scala\br\unb\cic\flang\Interpreter2.scala
jul. 19, 2024 12:38:35 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
ADVERTÊNCIA: Unmatched cancel notification for request id 2093
jul. 19, 2024 12:38:38 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
ADVERTÊNCIA: Unmatched cancel notification for request id 2101
2024.07.19 12:38:38 WARN  Could not load snapshot text for C:\Users\Vinicius\UnB\FLanguage\src\main\scala\br\unb\cic\flang\Interpreter2.scala
jul. 19, 2024 12:38:39 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
ADVERTÊNCIA: Unmatched cancel notification for request id 2109
jul. 19, 2024 12:38:40 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
ADVERTÊNCIA: Unmatched cancel notification for request id 2117
2024.07.19 12:38:40 WARN  Could not load snapshot text for C:\Users\Vinicius\UnB\FLanguage\src\main\scala\br\unb\cic\flang\Interpreter2.scala
jul. 19, 2024 12:38:41 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
ADVERTÊNCIA: Unmatched cancel notification for request id 2125
jul. 19, 2024 12:38:48 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
ADVERTÊNCIA: Unmatched cancel notification for request id 2136
2024.07.19 12:38:49 WARN  Could not load snapshot text for C:\Users\Vinicius\UnB\FLanguage\src\main\scala\br\unb\cic\flang\Interpreter2.scala
jul. 19, 2024 12:38:49 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
ADVERTÊNCIA: Unmatched cancel notification for request id 2144
jul. 19, 2024 12:39:03 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
ADVERTÊNCIA: Unmatched cancel notification for request id 2161
2024.07.19 12:39:04 WARN  Could not load snapshot text for C:\Users\Vinicius\UnB\FLanguage\src\main\scala\br\unb\cic\flang\MonadState.scala
jul. 19, 2024 12:39:04 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
ADVERTÊNCIA: Unmatched cancel notification for request id 2170
jul. 19, 2024 12:39:05 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
ADVERTÊNCIA: Unmatched cancel notification for request id 2183
2024.07.19 12:39:06 WARN  Could not load snapshot text for C:\Users\Vinicius\UnB\FLanguage\src\main\scala\br\unb\cic\flang\MonadState.scala
2024.07.19 12:39:08 WARN  Could not load snapshot text for C:\Users\Vinicius\UnB\FLanguage\src\main\scala\br\unb\cic\flang\MonadState.scala
2024.07.19 12:39:09 WARN  Could not load snapshot text for C:\Users\Vinicius\UnB\FLanguage\src\main\scala\br\unb\cic\flang\MonadState.scala
2024.07.19 12:39:09 WARN  Could not load snapshot text for C:\Users\Vinicius\UnB\FLanguage\src\main\scala\br\unb\cic\flang\MonadState.scala
2024.07.19 12:39:09 WARN  Could not load snapshot text for C:\Users\Vinicius\UnB\FLanguage\src\main\scala\br\unb\cic\flang\MonadState.scala
2024.07.19 12:39:09 WARN  Could not load snapshot text for C:\Users\Vinicius\UnB\FLanguage\src\main\scala\br\unb\cic\flang\MonadState.scala
2024.07.19 12:39:09 WARN  Could not load snapshot text for C:\Users\Vinicius\UnB\FLanguage\src\main\scala\br\unb\cic\flang\MonadState.scala
2024.07.19 12:39:09 WARN  Could not load snapshot text for C:\Users\Vinicius\UnB\FLanguage\src\main\scala\br\unb\cic\flang\MonadState.scala
Exception in thread "pool-7-thread-1" java.lang.InterruptedException
	at scala.meta.internal.metals.FutureCancelToken.checkCanceled(FutureCancelToken.scala:29)
	at scala.meta.internal.pc.CompilerAccess.$anonfun$onCompilerJobQueue$1(CompilerAccess.scala:243)
	at scala.meta.internal.pc.CompilerJobQueue$Job.run(CompilerJobQueue.scala:152)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.base/java.lang.Thread.run(Thread.java:833)
2024.07.19 12:39:09 WARN  Could not load snapshot text for C:\Users\Vinicius\UnB\FLanguage\src\main\scala\br\unb\cic\flang\MonadState.scala
2024.07.19 12:39:09 WARN  Could not load snapshot text for C:\Users\Vinicius\UnB\FLanguage\src\main\scala\br\unb\cic\flang\MonadState.scala
2024.07.19 12:39:09 WARN  Using indexes to guess the definition of pure
2024.07.19 12:39:09 WARN  Could not load snapshot text for C:\Users\Vinicius\UnB\FLanguage\src\main\scala\br\unb\cic\flang\MonadState.scala
2024.07.19 12:39:09 WARN  Could not load snapshot text for C:\Users\Vinicius\UnB\FLanguage\src\main\scala\br\unb\cic\flang\MonadState.scala
2024.07.19 12:39:09 WARN  Using indexes to guess the definition of pure
2024.07.19 12:39:10 WARN  Could not load snapshot text for C:\Users\Vinicius\UnB\FLanguage\src\main\scala\br\unb\cic\flang\MonadState.scala
2024.07.19 12:39:27 WARN  Could not load snapshot text for C:\Users\Vinicius\UnB\FLanguage\src\main\scala\br\unb\cic\flang\MonadState.scala
2024.07.19 12:39:27 WARN  Could not load snapshot text for C:\Users\Vinicius\UnB\FLanguage\src\main\scala\br\unb\cic\flang\MonadState.scala
2024.07.19 12:39:27 WARN  Using indexes to guess the definition of A
2024.07.19 12:39:28 WARN  Could not load snapshot text for C:\Users\Vinicius\UnB\FLanguage\src\main\scala\br\unb\cic\flang\MonadState.scala
2024.07.19 12:39:28 WARN  Could not load snapshot text for C:\Users\Vinicius\UnB\FLanguage\src\main\scala\br\unb\cic\flang\MonadState.scala
2024.07.19 12:39:29 WARN  Using indexes to guess the definition of A
2024.07.19 12:39:28 WARN  Could not load snapshot text for C:\Users\Vinicius\UnB\FLanguage\src\main\scala\br\unb\cic\flang\MonadState.scala
2024.07.19 12:39:28 WARN  Could not load snapshot text for C:\Users\Vinicius\UnB\FLanguage\src\main\scala\br\unb\cic\flang\MonadState.scala
2024.07.19 12:39:35 WARN  Could not load snapshot text for C:\Users\Vinicius\UnB\FLanguage\src\main\scala\br\unb\cic\flang\MonadState.scala
2024.07.19 12:39:37 INFO  Can not organize imports if file has error
2024.07.19 12:39:37 INFO  compiling root (2 scala sources)
2024.07.19 12:39:37 INFO  time: compiled root in 0.23s
2024.07.19 12:39:38 WARN  Could not load snapshot text for C:\Users\Vinicius\UnB\FLanguage\src\main\scala\br\unb\cic\flang\MonadState.scala
2024.07.19 12:39:46 WARN  Could not load snapshot text for C:\Users\Vinicius\UnB\FLanguage\src\main\scala\br\unb\cic\flang\MonadState.scala
2024.07.19 12:39:46 INFO  Can not organize imports if file has error
2024.07.19 12:39:46 INFO  compiling root (2 scala sources)
2024.07.19 12:39:46 INFO  time: compiled root in 0.23s
2024.07.19 12:39:46 WARN  Could not load snapshot text for C:\Users\Vinicius\UnB\FLanguage\src\main\scala\br\unb\cic\flang\MonadState.scala
2024.07.19 12:40:00 WARN  Could not load snapshot text for C:\Users\Vinicius\UnB\FLanguage\src\main\scala\br\unb\cic\flang\MonadState.scala
2024.07.19 12:40:01 WARN  Could not load snapshot text for C:\Users\Vinicius\UnB\FLanguage\src\main\scala\br\unb\cic\flang\MonadState.scala
2024.07.19 12:40:01 WARN  Could not load snapshot text for C:\Users\Vinicius\UnB\FLanguage\src\main\scala\br\unb\cic\flang\MonadState.scala
2024.07.19 12:40:07 WARN  Could not load snapshot text for C:\Users\Vinicius\UnB\FLanguage\src\main\scala\br\unb\cic\flang\MonadState.scala
2024.07.19 12:40:07 WARN  Could not load snapshot text for C:\Users\Vinicius\UnB\FLanguage\src\main\scala\br\unb\cic\flang\MonadState.scala
2024.07.19 12:40:09 WARN  Could not load snapshot text for C:\Users\Vinicius\UnB\FLanguage\src\main\scala\br\unb\cic\flang\MonadState.scala
2024.07.19 12:40:09 WARN  Could not load snapshot text for C:\Users\Vinicius\UnB\FLanguage\src\main\scala\br\unb\cic\flang\MonadState.scala
2024.07.19 12:40:09 WARN  Could not load snapshot text for C:\Users\Vinicius\UnB\FLanguage\src\main\scala\br\unb\cic\flang\MonadState.scala
jul. 19, 2024 12:40:09 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleNotification
ADVERTÊNCIA: Notification threw an exception: {
  "jsonrpc": "2.0",
  "method": "textDocument/didOpen",
  "params": {
    "textDocument": {
      "uri": "jar:file%3A///C%3A/Users/Vinicius/AppData/Local/Coursier/cache/arc/https/github.com/adoptium/temurin17-binaries/releases/download/jdk-17%25252B35/OpenJDK17-jdk_x64_windows_hotspot_17_35.zip/jdk-17%2B35/lib/src.zip%21/java.base/java/lang/Integer.java",
      "languageId": "java",
      "version": 1,
      "text": "/*\n * Copyright (c) 1994, 2021, Oracle and/or its affiliates. All rights reserved.\n * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n *\n * This code is free software; you can redistribute it and/or modify it\n * under the terms of the GNU General Public License version 2 only, as\n * published by the Free Software Foundation.  Oracle designates this\n * particular file as subject to the \"Classpath\" exception as provided\n * by Oracle in the LICENSE file that accompanied this code.\n *\n * This code is distributed in the hope that it will be useful, but WITHOUT\n * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n * version 2 for more details (a copy is included in the LICENSE file that\n * accompanied this code).\n *\n * You should have received a copy of the GNU General Public License version\n * 2 along with this work; if not, write to the Free Software Foundation,\n * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n *\n * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n * or visit www.oracle.com if you need additional information or have any\n * questions.\n */\n\npackage java.lang;\n\nimport java.lang.annotation.Native;\nimport java.lang.invoke.MethodHandles;\nimport java.lang.constant.Constable;\nimport java.lang.constant.ConstantDesc;\nimport java.util.Objects;\nimport java.util.Optional;\n\nimport jdk.internal.misc.CDS;\nimport jdk.internal.misc.VM;\nimport jdk.internal.vm.annotation.IntrinsicCandidate;\n\nimport static java.lang.String.COMPACT_STRINGS;\nimport static java.lang.String.LATIN1;\nimport static java.lang.String.UTF16;\n\n/**\n * The {@code Integer} class wraps a value of the primitive type\n * {@code int} in an object. An object of type {@code Integer}\n * contains a single field whose type is {@code int}.\n *\n * \u003cp\u003eIn addition, this class provides several methods for converting\n * an {@code int} to a {@code String} and a {@code String} to an\n * {@code int}, as well as other constants and methods useful when\n * dealing with an {@code int}.\n *\n * \u003cp\u003eThis is a \u003ca href\u003d\"{@docRoot}/java.base/java/lang/doc-files/ValueBased.html\"\u003evalue-based\u003c/a\u003e\n * class; programmers should treat instances that are\n * {@linkplain #equals(Object) equal} as interchangeable and should not\n * use instances for synchronization, or unpredictable behavior may\n * occur. For example, in a future release, synchronization may fail.\n *\n * \u003cp\u003eImplementation note: The implementations of the \"bit twiddling\"\n * methods (such as {@link #highestOneBit(int) highestOneBit} and\n * {@link #numberOfTrailingZeros(int) numberOfTrailingZeros}) are\n * based on material from Henry S. Warren, Jr.\u0027s \u003ci\u003eHacker\u0027s\n * Delight\u003c/i\u003e, (Addison Wesley, 2002).\n *\n * @author  Lee Boynton\n * @author  Arthur van Hoff\n * @author  Josh Bloch\n * @author  Joseph D. Darcy\n * @since 1.0\n */\n@jdk.internal.ValueBased\npublic final class Integer extends Number\n        implements Comparable\u003cInteger\u003e, Constable, ConstantDesc {\n    /**\n     * A constant holding the minimum value an {@code int} can\n     * have, -2\u003csup\u003e31\u003c/sup\u003e.\n     */\n    @Native public static final int   MIN_VALUE \u003d 0x80000000;\n\n    /**\n     * A constant holding the maximum value an {@code int} can\n     * have, 2\u003csup\u003e31\u003c/sup\u003e-1.\n     */\n    @Native public static final int   MAX_VALUE \u003d 0x7fffffff;\n\n    /**\n     * The {@code Class} instance representing the primitive type\n     * {@code int}.\n     *\n     * @since   1.1\n     */\n    @SuppressWarnings(\"unchecked\")\n    public static final Class\u003cInteger\u003e  TYPE \u003d (Class\u003cInteger\u003e) Class.getPrimitiveClass(\"int\");\n\n    /**\n     * All possible chars for representing a number as a String\n     */\n    static final char[] digits \u003d {\n        \u00270\u0027 , \u00271\u0027 , \u00272\u0027 , \u00273\u0027 , \u00274\u0027 , \u00275\u0027 ,\n        \u00276\u0027 , \u00277\u0027 , \u00278\u0027 , \u00279\u0027 , \u0027a\u0027 , \u0027b\u0027 ,\n        \u0027c\u0027 , \u0027d\u0027 , \u0027e\u0027 , \u0027f\u0027 , \u0027g\u0027 , \u0027h\u0027 ,\n        \u0027i\u0027 , \u0027j\u0027 , \u0027k\u0027 , \u0027l\u0027 , \u0027m\u0027 , \u0027n\u0027 ,\n        \u0027o\u0027 , \u0027p\u0027 , \u0027q\u0027 , \u0027r\u0027 , \u0027s\u0027 , \u0027t\u0027 ,\n        \u0027u\u0027 , \u0027v\u0027 , \u0027w\u0027 , \u0027x\u0027 , \u0027y\u0027 , \u0027z\u0027\n    };\n\n    /**\n     * Returns a string representation of the first argument in the\n     * radix specified by the second argument.\n     *\n     * \u003cp\u003eIf the radix is smaller than {@code Character.MIN_RADIX}\n     * or larger than {@code Character.MAX_RADIX}, then the radix\n     * {@code 10} is used instead.\n     *\n     * \u003cp\u003eIf the first argument is negative, the first element of the\n     * result is the ASCII minus character {@code \u0027-\u0027}\n     * ({@code \u0027\\u005Cu002D\u0027}). If the first argument is not\n     * negative, no sign character appears in the result.\n     *\n     * \u003cp\u003eThe remaining characters of the result represent the magnitude\n     * of the first argument. If the magnitude is zero, it is\n     * represented by a single zero character {@code \u00270\u0027}\n     * ({@code \u0027\\u005Cu0030\u0027}); otherwise, the first character of\n     * the representation of the magnitude will not be the zero\n     * character.  The following ASCII characters are used as digits:\n     *\n     * \u003cblockquote\u003e\n     *   {@code 0123456789abcdefghijklmnopqrstuvwxyz}\n     * \u003c/blockquote\u003e\n     *\n     * These are {@code \u0027\\u005Cu0030\u0027} through\n     * {@code \u0027\\u005Cu0039\u0027} and {@code \u0027\\u005Cu0061\u0027} through\n     * {@code \u0027\\u005Cu007A\u0027}. If {@code radix} is\n     * \u003cvar\u003eN\u003c/var\u003e, then the first \u003cvar\u003eN\u003c/var\u003e of these characters\n     * are used as radix-\u003cvar\u003eN\u003c/var\u003e digits in the order shown. Thus,\n     * the digits for hexadecimal (radix 16) are\n     * {@code 0123456789abcdef}. If uppercase letters are\n     * desired, the {@link java.lang.String#toUpperCase()} method may\n     * be called on the result:\n     *\n     * \u003cblockquote\u003e\n     *  {@code Integer.toString(n, 16).toUpperCase()}\n     * \u003c/blockquote\u003e\n     *\n     * @param   i       an integer to be converted to a string.\n     * @param   radix   the radix to use in the string representation.\n     * @return  a string representation of the argument in the specified radix.\n     * @see     java.lang.Character#MAX_RADIX\n     * @see     java.lang.Character#MIN_RADIX\n     */\n    public static String toString(int i, int radix) {\n        if (radix \u003c Character.MIN_RADIX || radix \u003e Character.MAX_RADIX)\n            radix \u003d 10;\n\n        /* Use the faster version */\n        if (radix \u003d\u003d 10) {\n            return toString(i);\n        }\n\n        if (COMPACT_STRINGS) {\n            byte[] buf \u003d new byte[33];\n            boolean negative \u003d (i \u003c 0);\n            int charPos \u003d 32;\n\n            if (!negative) {\n                i \u003d -i;\n            }\n\n            while (i \u003c\u003d -radix) {\n                buf[charPos--] \u003d (byte)digits[-(i % radix)];\n                i \u003d i / radix;\n            }\n            buf[charPos] \u003d (byte)digits[-i];\n\n            if (negative) {\n                buf[--charPos] \u003d \u0027-\u0027;\n            }\n\n            return StringLatin1.newString(buf, charPos, (33 - charPos));\n        }\n        return toStringUTF16(i, radix);\n    }\n\n    private static String toStringUTF16(int i, int radix) {\n        byte[] buf \u003d new byte[33 * 2];\n        boolean negative \u003d (i \u003c 0);\n        int charPos \u003d 32;\n        if (!negative) {\n            i \u003d -i;\n        }\n        while (i \u003c\u003d -radix) {\n            StringUTF16.putChar(buf, charPos--, digits[-(i % radix)]);\n            i \u003d i / radix;\n        }\n        StringUTF16.putChar(buf, charPos, digits[-i]);\n\n        if (negative) {\n            StringUTF16.putChar(buf, --charPos, \u0027-\u0027);\n        }\n        return StringUTF16.newString(buf, charPos, (33 - charPos));\n    }\n\n    /**\n     * Returns a string representation of the first argument as an\n     * unsigned integer value in the radix specified by the second\n     * argument.\n     *\n     * \u003cp\u003eIf the radix is smaller than {@code Character.MIN_RADIX}\n     * or larger than {@code Character.MAX_RADIX}, then the radix\n     * {@code 10} is used instead.\n     *\n     * \u003cp\u003eNote that since the first argument is treated as an unsigned\n     * value, no leading sign character is printed.\n     *\n     * \u003cp\u003eIf the magnitude is zero, it is represented by a single zero\n     * character {@code \u00270\u0027} ({@code \u0027\\u005Cu0030\u0027}); otherwise,\n     * the first character of the representation of the magnitude will\n     * not be the zero character.\n     *\n     * \u003cp\u003eThe behavior of radixes and the characters used as digits\n     * are the same as {@link #toString(int, int) toString}.\n     *\n     * @param   i       an integer to be converted to an unsigned string.\n     * @param   radix   the radix to use in the string representation.\n     * @return  an unsigned string representation of the argument in the specified radix.\n     * @see     #toString(int, int)\n     * @since 1.8\n     */\n    public static String toUnsignedString(int i, int radix) {\n        return Long.toUnsignedString(toUnsignedLong(i), radix);\n    }\n\n    /**\n     * Returns a string representation of the integer argument as an\n     * unsigned integer in base\u0026nbsp;16.\n     *\n     * \u003cp\u003eThe unsigned integer value is the argument plus 2\u003csup\u003e32\u003c/sup\u003e\n     * if the argument is negative; otherwise, it is equal to the\n     * argument.  This value is converted to a string of ASCII digits\n     * in hexadecimal (base\u0026nbsp;16) with no extra leading\n     * {@code 0}s.\n     *\n     * \u003cp\u003eThe value of the argument can be recovered from the returned\n     * string {@code s} by calling {@link\n     * Integer#parseUnsignedInt(String, int)\n     * Integer.parseUnsignedInt(s, 16)}.\n     *\n     * \u003cp\u003eIf the unsigned magnitude is zero, it is represented by a\n     * single zero character {@code \u00270\u0027} ({@code \u0027\\u005Cu0030\u0027});\n     * otherwise, the first character of the representation of the\n     * unsigned magnitude will not be the zero character. The\n     * following characters are used as hexadecimal digits:\n     *\n     * \u003cblockquote\u003e\n     *  {@code 0123456789abcdef}\n     * \u003c/blockquote\u003e\n     *\n     * These are the characters {@code \u0027\\u005Cu0030\u0027} through\n     * {@code \u0027\\u005Cu0039\u0027} and {@code \u0027\\u005Cu0061\u0027} through\n     * {@code \u0027\\u005Cu0066\u0027}. If uppercase letters are\n     * desired, the {@link java.lang.String#toUpperCase()} method may\n     * be called on the result:\n     *\n     * \u003cblockquote\u003e\n     *  {@code Integer.toHexString(n).toUpperCase()}\n     * \u003c/blockquote\u003e\n     *\n     * @apiNote\n     * The {@link java.util.HexFormat} class provides formatting and parsing\n     * of byte arrays and primitives to return a string or adding to an {@link Appendable}.\n     * {@code HexFormat} formats and parses uppercase or lowercase hexadecimal characters,\n     * with leading zeros and for byte arrays includes for each byte\n     * a delimiter, prefix, and suffix.\n     *\n     * @param   i   an integer to be converted to a string.\n     * @return  the string representation of the unsigned integer value\n     *          represented by the argument in hexadecimal (base\u0026nbsp;16).\n     * @see java.util.HexFormat\n     * @see #parseUnsignedInt(String, int)\n     * @see #toUnsignedString(int, int)\n     * @since   1.0.2\n     */\n    public static String toHexString(int i) {\n        return toUnsignedString0(i, 4);\n    }\n\n    /**\n     * Returns a string representation of the integer argument as an\n     * unsigned integer in base\u0026nbsp;8.\n     *\n     * \u003cp\u003eThe unsigned integer value is the argument plus 2\u003csup\u003e32\u003c/sup\u003e\n     * if the argument is negative; otherwise, it is equal to the\n     * argument.  This value is converted to a string of ASCII digits\n     * in octal (base\u0026nbsp;8) with no extra leading {@code 0}s.\n     *\n     * \u003cp\u003eThe value of the argument can be recovered from the returned\n     * string {@code s} by calling {@link\n     * Integer#parseUnsignedInt(String, int)\n     * Integer.parseUnsignedInt(s, 8)}.\n     *\n     * \u003cp\u003eIf the unsigned magnitude is zero, it is represented by a\n     * single zero character {@code \u00270\u0027} ({@code \u0027\\u005Cu0030\u0027});\n     * otherwise, the first character of the representation of the\n     * unsigned magnitude will not be the zero character. The\n     * following characters are used as octal digits:\n     *\n     * \u003cblockquote\u003e\n     * {@code 01234567}\n     * \u003c/blockquote\u003e\n     *\n     * These are the characters {@code \u0027\\u005Cu0030\u0027} through\n     * {@code \u0027\\u005Cu0037\u0027}.\n     *\n     * @param   i   an integer to be converted to a string.\n     * @return  the string representation of the unsigned integer value\n     *          represented by the argument in octal (base\u0026nbsp;8).\n     * @see #parseUnsignedInt(String, int)\n     * @see #toUnsignedString(int, int)\n     * @since   1.0.2\n     */\n    public static String toOctalString(int i) {\n        return toUnsignedString0(i, 3);\n    }\n\n    /**\n     * Returns a string representation of the integer argument as an\n     * unsigned integer in base\u0026nbsp;2.\n     *\n     * \u003cp\u003eThe unsigned integer value is the argument plus 2\u003csup\u003e32\u003c/sup\u003e\n     * if the argument is negative; otherwise it is equal to the\n     * argument.  This value is converted to a string of ASCII digits\n     * in binary (base\u0026nbsp;2) with no extra leading {@code 0}s.\n     *\n     * \u003cp\u003eThe value of the argument can be recovered from the returned\n     * string {@code s} by calling {@link\n     * Integer#parseUnsignedInt(String, int)\n     * Integer.parseUnsignedInt(s, 2)}.\n     *\n     * \u003cp\u003eIf the unsigned magnitude is zero, it is represented by a\n     * single zero character {@code \u00270\u0027} ({@code \u0027\\u005Cu0030\u0027});\n     * otherwise, the first character of the representation of the\n     * unsigned magnitude will not be the zero character. The\n     * characters {@code \u00270\u0027} ({@code \u0027\\u005Cu0030\u0027}) and {@code\n     * \u00271\u0027} ({@code \u0027\\u005Cu0031\u0027}) are used as binary digits.\n     *\n     * @param   i   an integer to be converted to a string.\n     * @return  the string representation of the unsigned integer value\n     *          represented by the argument in binary (base\u0026nbsp;2).\n     * @see #parseUnsignedInt(String, int)\n     * @see #toUnsignedString(int, int)\n     * @since   1.0.2\n     */\n    public static String toBinaryString(int i) {\n        return toUnsignedString0(i, 1);\n    }\n\n    /**\n     * Convert the integer to an unsigned number.\n     */\n    private static String toUnsignedString0(int val, int shift) {\n        // assert shift \u003e 0 \u0026\u0026 shift \u003c\u003d5 : \"Illegal shift value\";\n        int mag \u003d Integer.SIZE - Integer.numberOfLeadingZeros(val);\n        int chars \u003d Math.max(((mag + (shift - 1)) / shift), 1);\n        if (COMPACT_STRINGS) {\n            byte[] buf \u003d new byte[chars];\n            formatUnsignedInt(val, shift, buf, chars);\n            return new String(buf, LATIN1);\n        } else {\n            byte[] buf \u003d new byte[chars * 2];\n            formatUnsignedIntUTF16(val, shift, buf, chars);\n            return new String(buf, UTF16);\n        }\n    }\n\n    /**\n     * Format an {@code int} (treated as unsigned) into a byte buffer (LATIN1 version). If\n     * {@code len} exceeds the formatted ASCII representation of {@code val},\n     * {@code buf} will be padded with leading zeroes.\n     *\n     * @param val the unsigned int to format\n     * @param shift the log2 of the base to format in (4 for hex, 3 for octal, 1 for binary)\n     * @param buf the byte buffer to write to\n     * @param len the number of characters to write\n     */\n    private static void formatUnsignedInt(int val, int shift, byte[] buf, int len) {\n        int charPos \u003d len;\n        int radix \u003d 1 \u003c\u003c shift;\n        int mask \u003d radix - 1;\n        do {\n            buf[--charPos] \u003d (byte)Integer.digits[val \u0026 mask];\n            val \u003e\u003e\u003e\u003d shift;\n        } while (charPos \u003e 0);\n    }\n\n    /**\n     * Format an {@code int} (treated as unsigned) into a byte buffer (UTF16 version). If\n     * {@code len} exceeds the formatted ASCII representation of {@code val},\n     * {@code buf} will be padded with leading zeroes.\n     *\n     * @param val the unsigned int to format\n     * @param shift the log2 of the base to format in (4 for hex, 3 for octal, 1 for binary)\n     * @param buf the byte buffer to write to\n     * @param len the number of characters to write\n     */\n    private static void formatUnsignedIntUTF16(int val, int shift, byte[] buf, int len) {\n        int charPos \u003d len;\n        int radix \u003d 1 \u003c\u003c shift;\n        int mask \u003d radix - 1;\n        do {\n            StringUTF16.putChar(buf, --charPos, Integer.digits[val \u0026 mask]);\n            val \u003e\u003e\u003e\u003d shift;\n        } while (charPos \u003e 0);\n    }\n\n    static final byte[] DigitTens \u003d {\n        \u00270\u0027, \u00270\u0027, \u00270\u0027, \u00270\u0027, \u00270\u0027, \u00270\u0027, \u00270\u0027, \u00270\u0027, \u00270\u0027, \u00270\u0027,\n        \u00271\u0027, \u00271\u0027, \u00271\u0027, \u00271\u0027, \u00271\u0027, \u00271\u0027, \u00271\u0027, \u00271\u0027, \u00271\u0027, \u00271\u0027,\n        \u00272\u0027, \u00272\u0027, \u00272\u0027, \u00272\u0027, \u00272\u0027, \u00272\u0027, \u00272\u0027, \u00272\u0027, \u00272\u0027, \u00272\u0027,\n        \u00273\u0027, \u00273\u0027, \u00273\u0027, \u00273\u0027, \u00273\u0027, \u00273\u0027, \u00273\u0027, \u00273\u0027, \u00273\u0027, \u00273\u0027,\n        \u00274\u0027, \u00274\u0027, \u00274\u0027, \u00274\u0027, \u00274\u0027, \u00274\u0027, \u00274\u0027, \u00274\u0027, \u00274\u0027, \u00274\u0027,\n        \u00275\u0027, \u00275\u0027, \u00275\u0027, \u00275\u0027, \u00275\u0027, \u00275\u0027, \u00275\u0027, \u00275\u0027, \u00275\u0027, \u00275\u0027,\n        \u00276\u0027, \u00276\u0027, \u00276\u0027, \u00276\u0027, \u00276\u0027, \u00276\u0027, \u00276\u0027, \u00276\u0027, \u00276\u0027, \u00276\u0027,\n        \u00277\u0027, \u00277\u0027, \u00277\u0027, \u00277\u0027, \u00277\u0027, \u00277\u0027, \u00277\u0027, \u00277\u0027, \u00277\u0027, \u00277\u0027,\n        \u00278\u0027, \u00278\u0027, \u00278\u0027, \u00278\u0027, \u00278\u0027, \u00278\u0027, \u00278\u0027, \u00278\u0027, \u00278\u0027, \u00278\u0027,\n        \u00279\u0027, \u00279\u0027, \u00279\u0027, \u00279\u0027, \u00279\u0027, \u00279\u0027, \u00279\u0027, \u00279\u0027, \u00279\u0027, \u00279\u0027,\n        } ;\n\n    static final byte[] DigitOnes \u003d {\n        \u00270\u0027, \u00271\u0027, \u00272\u0027, \u00273\u0027, \u00274\u0027, \u00275\u0027, \u00276\u0027, \u00277\u0027, \u00278\u0027, \u00279\u0027,\n        \u00270\u0027, \u00271\u0027, \u00272\u0027, \u00273\u0027, \u00274\u0027, \u00275\u0027, \u00276\u0027, \u00277\u0027, \u00278\u0027, \u00279\u0027,\n        \u00270\u0027, \u00271\u0027, \u00272\u0027, \u00273\u0027, \u00274\u0027, \u00275\u0027, \u00276\u0027, \u00277\u0027, \u00278\u0027, \u00279\u0027,\n        \u00270\u0027, \u00271\u0027, \u00272\u0027, \u00273\u0027, \u00274\u0027, \u00275\u0027, \u00276\u0027, \u00277\u0027, \u00278\u0027, \u00279\u0027,\n        \u00270\u0027, \u00271\u0027, \u00272\u0027, \u00273\u0027, \u00274\u0027, \u00275\u0027, \u00276\u0027, \u00277\u0027, \u00278\u0027, \u00279\u0027,\n        \u00270\u0027, \u00271\u0027, \u00272\u0027, \u00273\u0027, \u00274\u0027, \u00275\u0027, \u00276\u0027, \u00277\u0027, \u00278\u0027, \u00279\u0027,\n        \u00270\u0027, \u00271\u0027, \u00272\u0027, \u00273\u0027, \u00274\u0027, \u00275\u0027, \u00276\u0027, \u00277\u0027, \u00278\u0027, \u00279\u0027,\n        \u00270\u0027, \u00271\u0027, \u00272\u0027, \u00273\u0027, \u00274\u0027, \u00275\u0027, \u00276\u0027, \u00277\u0027, \u00278\u0027, \u00279\u0027,\n        \u00270\u0027, \u00271\u0027, \u00272\u0027, \u00273\u0027, \u00274\u0027, \u00275\u0027, \u00276\u0027, \u00277\u0027, \u00278\u0027, \u00279\u0027,\n        \u00270\u0027, \u00271\u0027, \u00272\u0027, \u00273\u0027, \u00274\u0027, \u00275\u0027, \u00276\u0027, \u00277\u0027, \u00278\u0027, \u00279\u0027,\n        } ;\n\n\n    /**\n     * Returns a {@code String} object representing the\n     * specified integer. The argument is converted to signed decimal\n     * representation and returned as a string, exactly as if the\n     * argument and radix 10 were given as arguments to the {@link\n     * #toString(int, int)} method.\n     *\n     * @param   i   an integer to be converted.\n     * @return  a string representation of the argument in base\u0026nbsp;10.\n     */\n    @IntrinsicCandidate\n    public static String toString(int i) {\n        int size \u003d stringSize(i);\n        if (COMPACT_STRINGS) {\n            byte[] buf \u003d new byte[size];\n            getChars(i, size, buf);\n            return new String(buf, LATIN1);\n        } else {\n            byte[] buf \u003d new byte[size * 2];\n            StringUTF16.getChars(i, size, buf);\n            return new String(buf, UTF16);\n        }\n    }\n\n    /**\n     * Returns a string representation of the argument as an unsigned\n     * decimal value.\n     *\n     * The argument is converted to unsigned decimal representation\n     * and returned as a string exactly as if the argument and radix\n     * 10 were given as arguments to the {@link #toUnsignedString(int,\n     * int)} method.\n     *\n     * @param   i  an integer to be converted to an unsigned string.\n     * @return  an unsigned string representation of the argument.\n     * @see     #toUnsignedString(int, int)\n     * @since 1.8\n     */\n    public static String toUnsignedString(int i) {\n        return Long.toString(toUnsignedLong(i));\n    }\n\n    /**\n     * Places characters representing the integer i into the\n     * character array buf. The characters are placed into\n     * the buffer backwards starting with the least significant\n     * digit at the specified index (exclusive), and working\n     * backwards from there.\n     *\n     * @implNote This method converts positive inputs into negative\n     * values, to cover the Integer.MIN_VALUE case. Converting otherwise\n     * (negative to positive) will expose -Integer.MIN_VALUE that overflows\n     * integer.\n     *\n     * @param i     value to convert\n     * @param index next index, after the least significant digit\n     * @param buf   target buffer, Latin1-encoded\n     * @return index of the most significant digit or minus sign, if present\n     */\n    static int getChars(int i, int index, byte[] buf) {\n        int q, r;\n        int charPos \u003d index;\n\n        boolean negative \u003d i \u003c 0;\n        if (!negative) {\n            i \u003d -i;\n        }\n\n        // Generate two digits per iteration\n        while (i \u003c\u003d -100) {\n            q \u003d i / 100;\n            r \u003d (q * 100) - i;\n            i \u003d q;\n            buf[--charPos] \u003d DigitOnes[r];\n            buf[--charPos] \u003d DigitTens[r];\n        }\n\n        // We know there are at most two digits left at this point.\n        q \u003d i / 10;\n        r \u003d (q * 10) - i;\n        buf[--charPos] \u003d (byte)(\u00270\u0027 + r);\n\n        // Whatever left is the remaining digit.\n        if (q \u003c 0) {\n            buf[--charPos] \u003d (byte)(\u00270\u0027 - q);\n        }\n\n        if (negative) {\n            buf[--charPos] \u003d (byte)\u0027-\u0027;\n        }\n        return charPos;\n    }\n\n    // Left here for compatibility reasons, see JDK-8143900.\n    static final int [] sizeTable \u003d { 9, 99, 999, 9999, 99999, 999999, 9999999,\n                                      99999999, 999999999, Integer.MAX_VALUE };\n\n    /**\n     * Returns the string representation size for a given int value.\n     *\n     * @param x int value\n     * @return string size\n     *\n     * @implNote There are other ways to compute this: e.g. binary search,\n     * but values are biased heavily towards zero, and therefore linear search\n     * wins. The iteration results are also routinely inlined in the generated\n     * code after loop unrolling.\n     */\n    static int stringSize(int x) {\n        int d \u003d 1;\n        if (x \u003e\u003d 0) {\n            d \u003d 0;\n            x \u003d -x;\n        }\n        int p \u003d -10;\n        for (int i \u003d 1; i \u003c 10; i++) {\n            if (x \u003e p)\n                return i + d;\n            p \u003d 10 * p;\n        }\n        return 10 + d;\n    }\n\n    /**\n     * Parses the string argument as a signed integer in the radix\n     * specified by the second argument. The characters in the string\n     * must all be digits of the specified radix (as determined by\n     * whether {@link java.lang.Character#digit(char, int)} returns a\n     * nonnegative value), except that the first character may be an\n     * ASCII minus sign {@code \u0027-\u0027} ({@code \u0027\\u005Cu002D\u0027}) to\n     * indicate a negative value or an ASCII plus sign {@code \u0027+\u0027}\n     * ({@code \u0027\\u005Cu002B\u0027}) to indicate a positive value. The\n     * resulting integer value is returned.\n     *\n     * \u003cp\u003eAn exception of type {@code NumberFormatException} is\n     * thrown if any of the following situations occurs:\n     * \u003cul\u003e\n     * \u003cli\u003eThe first argument is {@code null} or is a string of\n     * length zero.\n     *\n     * \u003cli\u003eThe radix is either smaller than\n     * {@link java.lang.Character#MIN_RADIX} or\n     * larger than {@link java.lang.Character#MAX_RADIX}.\n     *\n     * \u003cli\u003eAny character of the string is not a digit of the specified\n     * radix, except that the first character may be a minus sign\n     * {@code \u0027-\u0027} ({@code \u0027\\u005Cu002D\u0027}) or plus sign\n     * {@code \u0027+\u0027} ({@code \u0027\\u005Cu002B\u0027}) provided that the\n     * string is longer than length 1.\n     *\n     * \u003cli\u003eThe value represented by the string is not a value of type\n     * {@code int}.\n     * \u003c/ul\u003e\n     *\n     * \u003cp\u003eExamples:\n     * \u003cblockquote\u003e\u003cpre\u003e\n     * parseInt(\"0\", 10) returns 0\n     * parseInt(\"473\", 10) returns 473\n     * parseInt(\"+42\", 10) returns 42\n     * parseInt(\"-0\", 10) returns 0\n     * parseInt(\"-FF\", 16) returns -255\n     * parseInt(\"1100110\", 2) returns 102\n     * parseInt(\"2147483647\", 10) returns 2147483647\n     * parseInt(\"-2147483648\", 10) returns -2147483648\n     * parseInt(\"2147483648\", 10) throws a NumberFormatException\n     * parseInt(\"99\", 8) throws a NumberFormatException\n     * parseInt(\"Kona\", 10) throws a NumberFormatException\n     * parseInt(\"Kona\", 27) returns 411787\n     * \u003c/pre\u003e\u003c/blockquote\u003e\n     *\n     * @param      s   the {@code String} containing the integer\n     *                  representation to be parsed\n     * @param      radix   the radix to be used while parsing {@code s}.\n     * @return     the integer represented by the string argument in the\n     *             specified radix.\n     * @throws     NumberFormatException if the {@code String}\n     *             does not contain a parsable {@code int}.\n     */\n    public static int parseInt(String s, int radix)\n                throws NumberFormatException\n    {\n        /*\n         * WARNING: This method may be invoked early during VM initialization\n         * before IntegerCache is initialized. Care must be taken to not use\n         * the valueOf method.\n         */\n\n        if (s \u003d\u003d null) {\n            throw new NumberFormatException(\"Cannot parse null string\");\n        }\n\n        if (radix \u003c Character.MIN_RADIX) {\n            throw new NumberFormatException(\"radix \" + radix +\n                                            \" less than Character.MIN_RADIX\");\n        }\n\n        if (radix \u003e Character.MAX_RADIX) {\n            throw new NumberFormatException(\"radix \" + radix +\n                                            \" greater than Character.MAX_RADIX\");\n        }\n\n        boolean negative \u003d false;\n        int i \u003d 0, len \u003d s.length();\n        int limit \u003d -Integer.MAX_VALUE;\n\n        if (len \u003e 0) {\n            char firstChar \u003d s.charAt(0);\n            if (firstChar \u003c \u00270\u0027) { // Possible leading \"+\" or \"-\"\n                if (firstChar \u003d\u003d \u0027-\u0027) {\n                    negative \u003d true;\n                    limit \u003d Integer.MIN_VALUE;\n                } else if (firstChar !\u003d \u0027+\u0027) {\n                    throw NumberFormatException.forInputString(s, radix);\n                }\n\n                if (len \u003d\u003d 1) { // Cannot have lone \"+\" or \"-\"\n                    throw NumberFormatException.forInputString(s, radix);\n                }\n                i++;\n            }\n            int multmin \u003d limit / radix;\n            int result \u003d 0;\n            while (i \u003c len) {\n                // Accumulating negatively avoids surprises near MAX_VALUE\n                int digit \u003d Character.digit(s.charAt(i++), radix);\n                if (digit \u003c 0 || result \u003c multmin) {\n                    throw NumberFormatException.forInputString(s, radix);\n                }\n                result *\u003d radix;\n                if (result \u003c limit + digit) {\n                    throw NumberFormatException.forInputString(s, radix);\n                }\n                result -\u003d digit;\n            }\n            return negative ? result : -result;\n        } else {\n            throw NumberFormatException.forInputString(s, radix);\n        }\n    }\n\n    /**\n     * Parses the {@link CharSequence} argument as a signed {@code int} in the\n     * specified {@code radix}, beginning at the specified {@code beginIndex}\n     * and extending to {@code endIndex - 1}.\n     *\n     * \u003cp\u003eThe method does not take steps to guard against the\n     * {@code CharSequence} being mutated while parsing.\n     *\n     * @param      s   the {@code CharSequence} containing the {@code int}\n     *                  representation to be parsed\n     * @param      beginIndex   the beginning index, inclusive.\n     * @param      endIndex     the ending index, exclusive.\n     * @param      radix   the radix to be used while parsing {@code s}.\n     * @return     the signed {@code int} represented by the subsequence in\n     *             the specified radix.\n     * @throws     NullPointerException  if {@code s} is null.\n     * @throws     IndexOutOfBoundsException  if {@code beginIndex} is\n     *             negative, or if {@code beginIndex} is greater than\n     *             {@code endIndex} or if {@code endIndex} is greater than\n     *             {@code s.length()}.\n     * @throws     NumberFormatException  if the {@code CharSequence} does not\n     *             contain a parsable {@code int} in the specified\n     *             {@code radix}, or if {@code radix} is either smaller than\n     *             {@link java.lang.Character#MIN_RADIX} or larger than\n     *             {@link java.lang.Character#MAX_RADIX}.\n     * @since  9\n     */\n    public static int parseInt(CharSequence s, int beginIndex, int endIndex, int radix)\n                throws NumberFormatException {\n        Objects.requireNonNull(s);\n\n        if (beginIndex \u003c 0 || beginIndex \u003e endIndex || endIndex \u003e s.length()) {\n            throw new IndexOutOfBoundsException();\n        }\n        if (radix \u003c Character.MIN_RADIX) {\n            throw new NumberFormatException(\"radix \" + radix +\n                                            \" less than Character.MIN_RADIX\");\n        }\n        if (radix \u003e Character.MAX_RADIX) {\n            throw new NumberFormatException(\"radix \" + radix +\n                                            \" greater than Character.MAX_RADIX\");\n        }\n\n        boolean negative \u003d false;\n        int i \u003d beginIndex;\n        int limit \u003d -Integer.MAX_VALUE;\n\n        if (i \u003c endIndex) {\n            char firstChar \u003d s.charAt(i);\n            if (firstChar \u003c \u00270\u0027) { // Possible leading \"+\" or \"-\"\n                if (firstChar \u003d\u003d \u0027-\u0027) {\n                    negative \u003d true;\n                    limit \u003d Integer.MIN_VALUE;\n                } else if (firstChar !\u003d \u0027+\u0027) {\n                    throw NumberFormatException.forCharSequence(s, beginIndex,\n                            endIndex, i);\n                }\n                i++;\n                if (i \u003d\u003d endIndex) { // Cannot have lone \"+\" or \"-\"\n                    throw NumberFormatException.forCharSequence(s, beginIndex,\n                            endIndex, i);\n                }\n            }\n            int multmin \u003d limit / radix;\n            int result \u003d 0;\n            while (i \u003c endIndex) {\n                // Accumulating negatively avoids surprises near MAX_VALUE\n                int digit \u003d Character.digit(s.charAt(i), radix);\n                if (digit \u003c 0 || result \u003c multmin) {\n                    throw NumberFormatException.forCharSequence(s, beginIndex,\n                            endIndex, i);\n                }\n                result *\u003d radix;\n                if (result \u003c limit + digit) {\n                    throw NumberFormatException.forCharSequence(s, beginIndex,\n                            endIndex, i);\n                }\n                i++;\n                result -\u003d digit;\n            }\n            return negative ? result : -result;\n        } else {\n            throw NumberFormatException.forInputString(\"\", radix);\n        }\n    }\n\n    /**\n     * Parses the string argument as a signed decimal integer. The\n     * characters in the string must all be decimal digits, except\n     * that the first character may be an ASCII minus sign {@code \u0027-\u0027}\n     * ({@code \u0027\\u005Cu002D\u0027}) to indicate a negative value or an\n     * ASCII plus sign {@code \u0027+\u0027} ({@code \u0027\\u005Cu002B\u0027}) to\n     * indicate a positive value. The resulting integer value is\n     * returned, exactly as if the argument and the radix 10 were\n     * given as arguments to the {@link #parseInt(java.lang.String,\n     * int)} method.\n     *\n     * @param s    a {@code String} containing the {@code int}\n     *             representation to be parsed\n     * @return     the integer value represented by the argument in decimal.\n     * @throws     NumberFormatException  if the string does not contain a\n     *               parsable integer.\n     */\n    public static int parseInt(String s) throws NumberFormatException {\n        return parseInt(s,10);\n    }\n\n    /**\n     * Parses the string argument as an unsigned integer in the radix\n     * specified by the second argument.  An unsigned integer maps the\n     * values usually associated with negative numbers to positive\n     * numbers larger than {@code MAX_VALUE}.\n     *\n     * The characters in the string must all be digits of the\n     * specified radix (as determined by whether {@link\n     * java.lang.Character#digit(char, int)} returns a nonnegative\n     * value), except that the first character may be an ASCII plus\n     * sign {@code \u0027+\u0027} ({@code \u0027\\u005Cu002B\u0027}). The resulting\n     * integer value is returned.\n     *\n     * \u003cp\u003eAn exception of type {@code NumberFormatException} is\n     * thrown if any of the following situations occurs:\n     * \u003cul\u003e\n     * \u003cli\u003eThe first argument is {@code null} or is a string of\n     * length zero.\n     *\n     * \u003cli\u003eThe radix is either smaller than\n     * {@link java.lang.Character#MIN_RADIX} or\n     * larger than {@link java.lang.Character#MAX_RADIX}.\n     *\n     * \u003cli\u003eAny character of the string is not a digit of the specified\n     * radix, except that the first character may be a plus sign\n     * {@code \u0027+\u0027} ({@code \u0027\\u005Cu002B\u0027}) provided that the\n     * string is longer than length 1.\n     *\n     * \u003cli\u003eThe value represented by the string is larger than the\n     * largest unsigned {@code int}, 2\u003csup\u003e32\u003c/sup\u003e-1.\n     *\n     * \u003c/ul\u003e\n     *\n     *\n     * @param      s   the {@code String} containing the unsigned integer\n     *                  representation to be parsed\n     * @param      radix   the radix to be used while parsing {@code s}.\n     * @return     the integer represented by the string argument in the\n     *             specified radix.\n     * @throws     NumberFormatException if the {@code String}\n     *             does not contain a parsable {@code int}.\n     * @since 1.8\n     */\n    public static int parseUnsignedInt(String s, int radix)\n                throws NumberFormatException {\n        if (s \u003d\u003d null)  {\n            throw new NumberFormatException(\"Cannot parse null string\");\n        }\n\n        int len \u003d s.length();\n        if (len \u003e 0) {\n            char firstChar \u003d s.charAt(0);\n            if (firstChar \u003d\u003d \u0027-\u0027) {\n                throw new\n                    NumberFormatException(String.format(\"Illegal leading minus sign \" +\n                                                       \"on unsigned string %s.\", s));\n            } else {\n                if (len \u003c\u003d 5 || // Integer.MAX_VALUE in Character.MAX_RADIX is 6 digits\n                    (radix \u003d\u003d 10 \u0026\u0026 len \u003c\u003d 9) ) { // Integer.MAX_VALUE in base 10 is 10 digits\n                    return parseInt(s, radix);\n                } else {\n                    long ell \u003d Long.parseLong(s, radix);\n                    if ((ell \u0026 0xffff_ffff_0000_0000L) \u003d\u003d 0) {\n                        return (int) ell;\n                    } else {\n                        throw new\n                            NumberFormatException(String.format(\"String value %s exceeds \" +\n                                                                \"range of unsigned int.\", s));\n                    }\n                }\n            }\n        } else {\n            throw NumberFormatException.forInputString(s, radix);\n        }\n    }\n\n    /**\n     * Parses the {@link CharSequence} argument as an unsigned {@code int} in\n     * the specified {@code radix}, beginning at the specified\n     * {@code beginIndex} and extending to {@code endIndex - 1}.\n     *\n     * \u003cp\u003eThe method does not take steps to guard against the\n     * {@code CharSequence} being mutated while parsing.\n     *\n     * @param      s   the {@code CharSequence} containing the unsigned\n     *                 {@code int} representation to be parsed\n     * @param      beginIndex   the beginning index, inclusive.\n     * @param      endIndex     the ending index, exclusive.\n     * @param      radix   the radix to be used while parsing {@code s}.\n     * @return     the unsigned {@code int} represented by the subsequence in\n     *             the specified radix.\n     * @throws     NullPointerException  if {@code s} is null.\n     * @throws     IndexOutOfBoundsException  if {@code beginIndex} is\n     *             negative, or if {@code beginIndex} is greater than\n     *             {@code endIndex} or if {@code endIndex} is greater than\n     *             {@code s.length()}.\n     * @throws     NumberFormatException  if the {@code CharSequence} does not\n     *             contain a parsable unsigned {@code int} in the specified\n     *             {@code radix}, or if {@code radix} is either smaller than\n     *             {@link java.lang.Character#MIN_RADIX} or larger than\n     *             {@link java.lang.Character#MAX_RADIX}.\n     * @since  9\n     */\n    public static int parseUnsignedInt(CharSequence s, int beginIndex, int endIndex, int radix)\n                throws NumberFormatException {\n        Objects.requireNonNull(s);\n\n        if (beginIndex \u003c 0 || beginIndex \u003e endIndex || endIndex \u003e s.length()) {\n            throw new IndexOutOfBoundsException();\n        }\n        int start \u003d beginIndex, len \u003d endIndex - beginIndex;\n\n        if (len \u003e 0) {\n            char firstChar \u003d s.charAt(start);\n            if (firstChar \u003d\u003d \u0027-\u0027) {\n                throw new\n                    NumberFormatException(String.format(\"Illegal leading minus sign \" +\n                                                       \"on unsigned string %s.\", s));\n            } else {\n                if (len \u003c\u003d 5 || // Integer.MAX_VALUE in Character.MAX_RADIX is 6 digits\n                        (radix \u003d\u003d 10 \u0026\u0026 len \u003c\u003d 9)) { // Integer.MAX_VALUE in base 10 is 10 digits\n                    return parseInt(s, start, start + len, radix);\n                } else {\n                    long ell \u003d Long.parseLong(s, start, start + len, radix);\n                    if ((ell \u0026 0xffff_ffff_0000_0000L) \u003d\u003d 0) {\n                        return (int) ell;\n                    } else {\n                        throw new\n                            NumberFormatException(String.format(\"String value %s exceeds \" +\n                                                                \"range of unsigned int.\", s));\n                    }\n                }\n            }\n        } else {\n            throw new NumberFormatException(\"\");\n        }\n    }\n\n    /**\n     * Parses the string argument as an unsigned decimal integer. The\n     * characters in the string must all be decimal digits, except\n     * that the first character may be an ASCII plus sign {@code\n     * \u0027+\u0027} ({@code \u0027\\u005Cu002B\u0027}). The resulting integer value\n     * is returned, exactly as if the argument and the radix 10 were\n     * given as arguments to the {@link\n     * #parseUnsignedInt(java.lang.String, int)} method.\n     *\n     * @param s   a {@code String} containing the unsigned {@code int}\n     *            representation to be parsed\n     * @return    the unsigned integer value represented by the argument in decimal.\n     * @throws    NumberFormatException  if the string does not contain a\n     *            parsable unsigned integer.\n     * @since 1.8\n     */\n    public static int parseUnsignedInt(String s) throws NumberFormatException {\n        return parseUnsignedInt(s, 10);\n    }\n\n    /**\n     * Returns an {@code Integer} object holding the value\n     * extracted from the specified {@code String} when parsed\n     * with the radix given by the second argument. The first argument\n     * is interpreted as representing a signed integer in the radix\n     * specified by the second argument, exactly as if the arguments\n     * were given to the {@link #parseInt(java.lang.String, int)}\n     * method. The result is an {@code Integer} object that\n     * represents the integer value specified by the string.\n     *\n     * \u003cp\u003eIn other words, this method returns an {@code Integer}\n     * object equal to the value of:\n     *\n     * \u003cblockquote\u003e\n     *  {@code new Integer(Integer.parseInt(s, radix))}\n     * \u003c/blockquote\u003e\n     *\n     * @param      s   the string to be parsed.\n     * @param      radix the radix to be used in interpreting {@code s}\n     * @return     an {@code Integer} object holding the value\n     *             represented by the string argument in the specified\n     *             radix.\n     * @throws    NumberFormatException if the {@code String}\n     *            does not contain a parsable {@code int}.\n     */\n    public static Integer valueOf(String s, int radix) throws NumberFormatException {\n        return Integer.valueOf(parseInt(s,radix));\n    }\n\n    /**\n     * Returns an {@code Integer} object holding the\n     * value of the specified {@code String}. The argument is\n     * interpreted as representing a signed decimal integer, exactly\n     * as if the argument were given to the {@link\n     * #parseInt(java.lang.String)} method. The result is an\n     * {@code Integer} object that represents the integer value\n     * specified by the string.\n     *\n     * \u003cp\u003eIn other words, this method returns an {@code Integer}\n     * object equal to the value of:\n     *\n     * \u003cblockquote\u003e\n     *  {@code new Integer(Integer.parseInt(s))}\n     * \u003c/blockquote\u003e\n     *\n     * @param      s   the string to be parsed.\n     * @return     an {@code Integer} object holding the value\n     *             represented by the string argument.\n     * @throws     NumberFormatException  if the string cannot be parsed\n     *             as an integer.\n     */\n    public static Integer valueOf(String s) throws NumberFormatException {\n        return Integer.valueOf(parseInt(s, 10));\n    }\n\n    /**\n     * Cache to support the object identity semantics of autoboxing for values between\n     * -128 and 127 (inclusive) as required by JLS.\n     *\n     * The cache is initialized on first usage.  The size of the cache\n     * may be controlled by the {@code -XX:AutoBoxCacheMax\u003d\u003csize\u003e} option.\n     * During VM initialization, java.lang.Integer.IntegerCache.high property\n     * may be set and saved in the private system properties in the\n     * jdk.internal.misc.VM class.\n     *\n     * WARNING: The cache is archived with CDS and reloaded from the shared\n     * archive at runtime. The archived cache (Integer[]) and Integer objects\n     * reside in the closed archive heap regions. Care should be taken when\n     * changing the implementation and the cache array should not be assigned\n     * with new Integer object(s) after initialization.\n     */\n\n    private static class IntegerCache {\n        static final int low \u003d -128;\n        static final int high;\n        static final Integer[] cache;\n        static Integer[] archivedCache;\n\n        static {\n            // high value may be configured by property\n            int h \u003d 127;\n            String integerCacheHighPropValue \u003d\n                VM.getSavedProperty(\"java.lang.Integer.IntegerCache.high\");\n            if (integerCacheHighPropValue !\u003d null) {\n                try {\n                    h \u003d Math.max(parseInt(integerCacheHighPropValue), 127);\n                    // Maximum array size is Integer.MAX_VALUE\n                    h \u003d Math.min(h, Integer.MAX_VALUE - (-low) -1);\n                } catch( NumberFormatException nfe) {\n                    // If the property cannot be parsed into an int, ignore it.\n                }\n            }\n            high \u003d h;\n\n            // Load IntegerCache.archivedCache from archive, if possible\n            CDS.initializeFromArchive(IntegerCache.class);\n            int size \u003d (high - low) + 1;\n\n            // Use the archived cache if it exists and is large enough\n            if (archivedCache \u003d\u003d null || size \u003e archivedCache.length) {\n                Integer[] c \u003d new Integer[size];\n                int j \u003d low;\n                for(int i \u003d 0; i \u003c c.length; i++) {\n                    c[i] \u003d new Integer(j++);\n                }\n                archivedCache \u003d c;\n            }\n            cache \u003d archivedCache;\n            // range [-128, 127] must be interned (JLS7 5.1.7)\n            assert IntegerCache.high \u003e\u003d 127;\n        }\n\n        private IntegerCache() {}\n    }\n\n    /**\n     * Returns an {@code Integer} instance representing the specified\n     * {@code int} value.  If a new {@code Integer} instance is not\n     * required, this method should generally be used in preference to\n     * the constructor {@link #Integer(int)}, as this method is likely\n     * to yield significantly better space and time performance by\n     * caching frequently requested values.\n     *\n     * This method will always cache values in the range -128 to 127,\n     * inclusive, and may cache other values outside of this range.\n     *\n     * @param  i an {@code int} value.\n     * @return an {@code Integer} instance representing {@code i}.\n     * @since  1.5\n     */\n    @IntrinsicCandidate\n    public static Integer valueOf(int i) {\n        if (i \u003e\u003d IntegerCache.low \u0026\u0026 i \u003c\u003d IntegerCache.high)\n            return IntegerCache.cache[i + (-IntegerCache.low)];\n        return new Integer(i);\n    }\n\n    /**\n     * The value of the {@code Integer}.\n     *\n     * @serial\n     */\n    private final int value;\n\n    /**\n     * Constructs a newly allocated {@code Integer} object that\n     * represents the specified {@code int} value.\n     *\n     * @param   value   the value to be represented by the\n     *                  {@code Integer} object.\n     *\n     * @deprecated\n     * It is rarely appropriate to use this constructor. The static factory\n     * {@link #valueOf(int)} is generally a better choice, as it is\n     * likely to yield significantly better space and time performance.\n     */\n    @Deprecated(since\u003d\"9\", forRemoval \u003d true)\n    public Integer(int value) {\n        this.value \u003d value;\n    }\n\n    /**\n     * Constructs a newly allocated {@code Integer} object that\n     * represents the {@code int} value indicated by the\n     * {@code String} parameter. The string is converted to an\n     * {@code int} value in exactly the manner used by the\n     * {@code parseInt} method for radix 10.\n     *\n     * @param   s   the {@code String} to be converted to an {@code Integer}.\n     * @throws      NumberFormatException if the {@code String} does not\n     *              contain a parsable integer.\n     *\n     * @deprecated\n     * It is rarely appropriate to use this constructor.\n     * Use {@link #parseInt(String)} to convert a string to a\n     * {@code int} primitive, or use {@link #valueOf(String)}\n     * to convert a string to an {@code Integer} object.\n     */\n    @Deprecated(since\u003d\"9\", forRemoval \u003d true)\n    public Integer(String s) throws NumberFormatException {\n        this.value \u003d parseInt(s, 10);\n    }\n\n    /**\n     * Returns the value of this {@code Integer} as a {@code byte}\n     * after a narrowing primitive conversion.\n     * @jls 5.1.3 Narrowing Primitive Conversion\n     */\n    public byte byteValue() {\n        return (byte)value;\n    }\n\n    /**\n     * Returns the value of this {@code Integer} as a {@code short}\n     * after a narrowing primitive conversion.\n     * @jls 5.1.3 Narrowing Primitive Conversion\n     */\n    public short shortValue() {\n        return (short)value;\n    }\n\n    /**\n     * Returns the value of this {@code Integer} as an\n     * {@code int}.\n     */\n    @IntrinsicCandidate\n    public int intValue() {\n        return value;\n    }\n\n    /**\n     * Returns the value of this {@code Integer} as a {@code long}\n     * after a widening primitive conversion.\n     * @jls 5.1.2 Widening Primitive Conversion\n     * @see Integer#toUnsignedLong(int)\n     */\n    public long longValue() {\n        return (long)value;\n    }\n\n    /**\n     * Returns the value of this {@code Integer} as a {@code float}\n     * after a widening primitive conversion.\n     * @jls 5.1.2 Widening Primitive Conversion\n     */\n    public float floatValue() {\n        return (float)value;\n    }\n\n    /**\n     * Returns the value of this {@code Integer} as a {@code double}\n     * after a widening primitive conversion.\n     * @jls 5.1.2 Widening Primitive Conversion\n     */\n    public double doubleValue() {\n        return (double)value;\n    }\n\n    /**\n     * Returns a {@code String} object representing this\n     * {@code Integer}\u0027s value. The value is converted to signed\n     * decimal representation and returned as a string, exactly as if\n     * the integer value were given as an argument to the {@link\n     * java.lang.Integer#toString(int)} method.\n     *\n     * @return  a string representation of the value of this object in\n     *          base\u0026nbsp;10.\n     */\n    public String toString() {\n        return toString(value);\n    }\n\n    /**\n     * Returns a hash code for this {@code Integer}.\n     *\n     * @return  a hash code value for this object, equal to the\n     *          primitive {@code int} value represented by this\n     *          {@code Integer} object.\n     */\n    @Override\n    public int hashCode() {\n        return Integer.hashCode(value);\n    }\n\n    /**\n     * Returns a hash code for an {@code int} value; compatible with\n     * {@code Integer.hashCode()}.\n     *\n     * @param value the value to hash\n     * @since 1.8\n     *\n     * @return a hash code value for an {@code int} value.\n     */\n    public static int hashCode(int value) {\n        return value;\n    }\n\n    /**\n     * Compares this object to the specified object.  The result is\n     * {@code true} if and only if the argument is not\n     * {@code null} and is an {@code Integer} object that\n     * contains the same {@code int} value as this object.\n     *\n     * @param   obj   the object to compare with.\n     * @return  {@code true} if the objects are the same;\n     *          {@code false} otherwise.\n     */\n    public boolean equals(Object obj) {\n        if (obj instanceof Integer) {\n            return value \u003d\u003d ((Integer)obj).intValue();\n        }\n        return false;\n    }\n\n    /**\n     * Determines the integer value of the system property with the\n     * specified name.\n     *\n     * \u003cp\u003eThe first argument is treated as the name of a system\n     * property.  System properties are accessible through the {@link\n     * java.lang.System#getProperty(java.lang.String)} method. The\n     * string value of this property is then interpreted as an integer\n     * value using the grammar supported by {@link Integer#decode decode} and\n     * an {@code Integer} object representing this value is returned.\n     *\n     * \u003cp\u003eIf there is no property with the specified name, if the\n     * specified name is empty or {@code null}, or if the property\n     * does not have the correct numeric format, then {@code null} is\n     * returned.\n     *\n     * \u003cp\u003eIn other words, this method returns an {@code Integer}\n     * object equal to the value of:\n     *\n     * \u003cblockquote\u003e\n     *  {@code getInteger(nm, null)}\n     * \u003c/blockquote\u003e\n     *\n     * @param   nm   property name.\n     * @return  the {@code Integer} value of the property.\n     * @throws  SecurityException for the same reasons as\n     *          {@link System#getProperty(String) System.getProperty}\n     * @see     java.lang.System#getProperty(java.lang.String)\n     * @see     java.lang.System#getProperty(java.lang.String, java.lang.String)\n     */\n    public static Integer getInteger(String nm) {\n        return getInteger(nm, null);\n    }\n\n    /**\n     * Determines the integer value of the system property with the\n     * specified name.\n     *\n     * \u003cp\u003eThe first argument is treated as the name of a system\n     * property.  System properties are accessible through the {@link\n     * java.lang.System#getProperty(java.lang.String)} method. The\n     * string value of this property is then interpreted as an integer\n     * value using the grammar supported by {@link Integer#decode decode} and\n     * an {@code Integer} object representing this value is returned.\n     *\n     * \u003cp\u003eThe second argument is the default value. An {@code Integer} object\n     * that represents the value of the second argument is returned if there\n     * is no property of the specified name, if the property does not have\n     * the correct numeric format, or if the specified name is empty or\n     * {@code null}.\n     *\n     * \u003cp\u003eIn other words, this method returns an {@code Integer} object\n     * equal to the value of:\n     *\n     * \u003cblockquote\u003e\n     *  {@code getInteger(nm, new Integer(val))}\n     * \u003c/blockquote\u003e\n     *\n     * but in practice it may be implemented in a manner such as:\n     *\n     * \u003cblockquote\u003e\u003cpre\u003e\n     * Integer result \u003d getInteger(nm, null);\n     * return (result \u003d\u003d null) ? new Integer(val) : result;\n     * \u003c/pre\u003e\u003c/blockquote\u003e\n     *\n     * to avoid the unnecessary allocation of an {@code Integer}\n     * object when the default value is not needed.\n     *\n     * @param   nm   property name.\n     * @param   val   default value.\n     * @return  the {@code Integer} value of the property.\n     * @throws  SecurityException for the same reasons as\n     *          {@link System#getProperty(String) System.getProperty}\n     * @see     java.lang.System#getProperty(java.lang.String)\n     * @see     java.lang.System#getProperty(java.lang.String, java.lang.String)\n     */\n    public static Integer getInteger(String nm, int val) {\n        Integer result \u003d getInteger(nm, null);\n        return (result \u003d\u003d null) ? Integer.valueOf(val) : result;\n    }\n\n    /**\n     * Returns the integer value of the system property with the\n     * specified name.  The first argument is treated as the name of a\n     * system property.  System properties are accessible through the\n     * {@link java.lang.System#getProperty(java.lang.String)} method.\n     * The string value of this property is then interpreted as an\n     * integer value, as per the {@link Integer#decode decode} method,\n     * and an {@code Integer} object representing this value is\n     * returned; in summary:\n     *\n     * \u003cul\u003e\u003cli\u003eIf the property value begins with the two ASCII characters\n     *         {@code 0x} or the ASCII character {@code #}, not\n     *      followed by a minus sign, then the rest of it is parsed as a\n     *      hexadecimal integer exactly as by the method\n     *      {@link #valueOf(java.lang.String, int)} with radix 16.\n     * \u003cli\u003eIf the property value begins with the ASCII character\n     *     {@code 0} followed by another character, it is parsed as an\n     *     octal integer exactly as by the method\n     *     {@link #valueOf(java.lang.String, int)} with radix 8.\n     * \u003cli\u003eOtherwise, the property value is parsed as a decimal integer\n     * exactly as by the method {@link #valueOf(java.lang.String, int)}\n     * with radix 10.\n     * \u003c/ul\u003e\n     *\n     * \u003cp\u003eThe second argument is the default value. The default value is\n     * returned if there is no property of the specified name, if the\n     * property does not have the correct numeric format, or if the\n     * specified name is empty or {@code null}.\n     *\n     * @param   nm   property name.\n     * @param   val   default value.\n     * @return  the {@code Integer} value of the property.\n     * @throws  SecurityException for the same reasons as\n     *          {@link System#getProperty(String) System.getProperty}\n     * @see     System#getProperty(java.lang.String)\n     * @see     System#getProperty(java.lang.String, java.lang.String)\n     */\n    public static Integer getInteger(String nm, Integer val) {\n        String v \u003d null;\n        try {\n            v \u003d System.getProperty(nm);\n        } catch (IllegalArgumentException | NullPointerException e) {\n        }\n        if (v !\u003d null) {\n            try {\n                return Integer.decode(v);\n            } catch (NumberFormatException e) {\n            }\n        }\n        return val;\n    }\n\n    /**\n     * Decodes a {@code String} into an {@code Integer}.\n     * Accepts decimal, hexadecimal, and octal numbers given\n     * by the following grammar:\n     *\n     * \u003cblockquote\u003e\n     * \u003cdl\u003e\n     * \u003cdt\u003e\u003ci\u003eDecodableString:\u003c/i\u003e\n     * \u003cdd\u003e\u003ci\u003eSign\u003csub\u003eopt\u003c/sub\u003e DecimalNumeral\u003c/i\u003e\n     * \u003cdd\u003e\u003ci\u003eSign\u003csub\u003eopt\u003c/sub\u003e\u003c/i\u003e {@code 0x} \u003ci\u003eHexDigits\u003c/i\u003e\n     * \u003cdd\u003e\u003ci\u003eSign\u003csub\u003eopt\u003c/sub\u003e\u003c/i\u003e {@code 0X} \u003ci\u003eHexDigits\u003c/i\u003e\n     * \u003cdd\u003e\u003ci\u003eSign\u003csub\u003eopt\u003c/sub\u003e\u003c/i\u003e {@code #} \u003ci\u003eHexDigits\u003c/i\u003e\n     * \u003cdd\u003e\u003ci\u003eSign\u003csub\u003eopt\u003c/sub\u003e\u003c/i\u003e {@code 0} \u003ci\u003eOctalDigits\u003c/i\u003e\n     *\n     * \u003cdt\u003e\u003ci\u003eSign:\u003c/i\u003e\n     * \u003cdd\u003e{@code -}\n     * \u003cdd\u003e{@code +}\n     * \u003c/dl\u003e\n     * \u003c/blockquote\u003e\n     *\n     * \u003ci\u003eDecimalNumeral\u003c/i\u003e, \u003ci\u003eHexDigits\u003c/i\u003e, and \u003ci\u003eOctalDigits\u003c/i\u003e\n     * are as defined in section {@jls 3.10.1} of\n     * \u003ccite\u003eThe Java Language Specification\u003c/cite\u003e,\n     * except that underscores are not accepted between digits.\n     *\n     * \u003cp\u003eThe sequence of characters following an optional\n     * sign and/or radix specifier (\"{@code 0x}\", \"{@code 0X}\",\n     * \"{@code #}\", or leading zero) is parsed as by the {@code\n     * Integer.parseInt} method with the indicated radix (10, 16, or\n     * 8).  This sequence of characters must represent a positive\n     * value or a {@link NumberFormatException} will be thrown.  The\n     * result is negated if first character of the specified {@code\n     * String} is the minus sign.  No whitespace characters are\n     * permitted in the {@code String}.\n     *\n     * @param     nm the {@code String} to decode.\n     * @return    an {@code Integer} object holding the {@code int}\n     *             value represented by {@code nm}\n     * @throws    NumberFormatException  if the {@code String} does not\n     *            contain a parsable integer.\n     * @see java.lang.Integer#parseInt(java.lang.String, int)\n     */\n    public static Integer decode(String nm) throws NumberFormatException {\n        int radix \u003d 10;\n        int index \u003d 0;\n        boolean negative \u003d false;\n        Integer result;\n\n        if (nm.isEmpty())\n            throw new NumberFormatException(\"Zero length string\");\n        char firstChar \u003d nm.charAt(0);\n        // Handle sign, if present\n        if (firstChar \u003d\u003d \u0027-\u0027) {\n            negative \u003d true;\n            index++;\n        } else if (firstChar \u003d\u003d \u0027+\u0027)\n            index++;\n\n        // Handle radix specifier, if present\n        if (nm.startsWith(\"0x\", index) || nm.startsWith(\"0X\", index)) {\n            index +\u003d 2;\n            radix \u003d 16;\n        }\n        else if (nm.startsWith(\"#\", index)) {\n            index ++;\n            radix \u003d 16;\n        }\n        else if (nm.startsWith(\"0\", index) \u0026\u0026 nm.length() \u003e 1 + index) {\n            index ++;\n            radix \u003d 8;\n        }\n\n        if (nm.startsWith(\"-\", index) || nm.startsWith(\"+\", index))\n            throw new NumberFormatException(\"Sign character in wrong position\");\n\n        try {\n            result \u003d Integer.valueOf(nm.substring(index), radix);\n            result \u003d negative ? Integer.valueOf(-result.intValue()) : result;\n        } catch (NumberFormatException e) {\n            // If number is Integer.MIN_VALUE, we\u0027ll end up here. The next line\n            // handles this case, and causes any genuine format error to be\n            // rethrown.\n            String constant \u003d negative ? (\"-\" + nm.substring(index))\n                                       : nm.substring(index);\n            result \u003d Integer.valueOf(constant, radix);\n        }\n        return result;\n    }\n\n    /**\n     * Compares two {@code Integer} objects numerically.\n     *\n     * @param   anotherInteger   the {@code Integer} to be compared.\n     * @return  the value {@code 0} if this {@code Integer} is\n     *          equal to the argument {@code Integer}; a value less than\n     *          {@code 0} if this {@code Integer} is numerically less\n     *          than the argument {@code Integer}; and a value greater\n     *          than {@code 0} if this {@code Integer} is numerically\n     *           greater than the argument {@code Integer} (signed\n     *           comparison).\n     * @since   1.2\n     */\n    public int compareTo(Integer anotherInteger) {\n        return compare(this.value, anotherInteger.value);\n    }\n\n    /**\n     * Compares two {@code int} values numerically.\n     * The value returned is identical to what would be returned by:\n     * \u003cpre\u003e\n     *    Integer.valueOf(x).compareTo(Integer.valueOf(y))\n     * \u003c/pre\u003e\n     *\n     * @param  x the first {@code int} to compare\n     * @param  y the second {@code int} to compare\n     * @return the value {@code 0} if {@code x \u003d\u003d y};\n     *         a value less than {@code 0} if {@code x \u003c y}; and\n     *         a value greater than {@code 0} if {@code x \u003e y}\n     * @since 1.7\n     */\n    public static int compare(int x, int y) {\n        return (x \u003c y) ? -1 : ((x \u003d\u003d y) ? 0 : 1);\n    }\n\n    /**\n     * Compares two {@code int} values numerically treating the values\n     * as unsigned.\n     *\n     * @param  x the first {@code int} to compare\n     * @param  y the second {@code int} to compare\n     * @return the value {@code 0} if {@code x \u003d\u003d y}; a value less\n     *         than {@code 0} if {@code x \u003c y} as unsigned values; and\n     *         a value greater than {@code 0} if {@code x \u003e y} as\n     *         unsigned values\n     * @since 1.8\n     */\n    public static int compareUnsigned(int x, int y) {\n        return compare(x + MIN_VALUE, y + MIN_VALUE);\n    }\n\n    /**\n     * Converts the argument to a {@code long} by an unsigned\n     * conversion.  In an unsigned conversion to a {@code long}, the\n     * high-order 32 bits of the {@code long} are zero and the\n     * low-order 32 bits are equal to the bits of the integer\n     * argument.\n     *\n     * Consequently, zero and positive {@code int} values are mapped\n     * to a numerically equal {@code long} value and negative {@code\n     * int} values are mapped to a {@code long} value equal to the\n     * input plus 2\u003csup\u003e32\u003c/sup\u003e.\n     *\n     * @param  x the value to convert to an unsigned {@code long}\n     * @return the argument converted to {@code long} by an unsigned\n     *         conversion\n     * @since 1.8\n     */\n    public static long toUnsignedLong(int x) {\n        return ((long) x) \u0026 0xffffffffL;\n    }\n\n    /**\n     * Returns the unsigned quotient of dividing the first argument by\n     * the second where each argument and the result is interpreted as\n     * an unsigned value.\n     *\n     * \u003cp\u003eNote that in two\u0027s complement arithmetic, the three other\n     * basic arithmetic operations of add, subtract, and multiply are\n     * bit-wise identical if the two operands are regarded as both\n     * being signed or both being unsigned.  Therefore separate {@code\n     * addUnsigned}, etc. methods are not provided.\n     *\n     * @param dividend the value to be divided\n     * @param divisor the value doing the dividing\n     * @return the unsigned quotient of the first argument divided by\n     * the second argument\n     * @see #remainderUnsigned\n     * @since 1.8\n     */\n    public static int divideUnsigned(int dividend, int divisor) {\n        // In lieu of tricky code, for now just use long arithmetic.\n        return (int)(toUnsignedLong(dividend) / toUnsignedLong(divisor));\n    }\n\n    /**\n     * Returns the unsigned remainder from dividing the first argument\n     * by the second where each argument and the result is interpreted\n     * as an unsigned value.\n     *\n     * @param dividend the value to be divided\n     * @param divisor the value doing the dividing\n     * @return the unsigned remainder of the first argument divided by\n     * the second argument\n     * @see #divideUnsigned\n     * @since 1.8\n     */\n    public static int remainderUnsigned(int dividend, int divisor) {\n        // In lieu of tricky code, for now just use long arithmetic.\n        return (int)(toUnsignedLong(dividend) % toUnsignedLong(divisor));\n    }\n\n\n    // Bit twiddling\n\n    /**\n     * The number of bits used to represent an {@code int} value in two\u0027s\n     * complement binary form.\n     *\n     * @since 1.5\n     */\n    @Native public static final int SIZE \u003d 32;\n\n    /**\n     * The number of bytes used to represent an {@code int} value in two\u0027s\n     * complement binary form.\n     *\n     * @since 1.8\n     */\n    public static final int BYTES \u003d SIZE / Byte.SIZE;\n\n    /**\n     * Returns an {@code int} value with at most a single one-bit, in the\n     * position of the highest-order (\"leftmost\") one-bit in the specified\n     * {@code int} value.  Returns zero if the specified value has no\n     * one-bits in its two\u0027s complement binary representation, that is, if it\n     * is equal to zero.\n     *\n     * @param i the value whose highest one bit is to be computed\n     * @return an {@code int} value with a single one-bit, in the position\n     *     of the highest-order one-bit in the specified value, or zero if\n     *     the specified value is itself equal to zero.\n     * @since 1.5\n     */\n    public static int highestOneBit(int i) {\n        return i \u0026 (MIN_VALUE \u003e\u003e\u003e numberOfLeadingZeros(i));\n    }\n\n    /**\n     * Returns an {@code int} value with at most a single one-bit, in the\n     * position of the lowest-order (\"rightmost\") one-bit in the specified\n     * {@code int} value.  Returns zero if the specified value has no\n     * one-bits in its two\u0027s complement binary representation, that is, if it\n     * is equal to zero.\n     *\n     * @param i the value whose lowest one bit is to be computed\n     * @return an {@code int} value with a single one-bit, in the position\n     *     of the lowest-order one-bit in the specified value, or zero if\n     *     the specified value is itself equal to zero.\n     * @since 1.5\n     */\n    public static int lowestOneBit(int i) {\n        // HD, Section 2-1\n        return i \u0026 -i;\n    }\n\n    /**\n     * Returns the number of zero bits preceding the highest-order\n     * (\"leftmost\") one-bit in the two\u0027s complement binary representation\n     * of the specified {@code int} value.  Returns 32 if the\n     * specified value has no one-bits in its two\u0027s complement representation,\n     * in other words if it is equal to zero.\n     *\n     * \u003cp\u003eNote that this method is closely related to the logarithm base 2.\n     * For all positive {@code int} values x:\n     * \u003cul\u003e\n     * \u003cli\u003efloor(log\u003csub\u003e2\u003c/sub\u003e(x)) \u003d {@code 31 - numberOfLeadingZeros(x)}\n     * \u003cli\u003eceil(log\u003csub\u003e2\u003c/sub\u003e(x)) \u003d {@code 32 - numberOfLeadingZeros(x - 1)}\n     * \u003c/ul\u003e\n     *\n     * @param i the value whose number of leading zeros is to be computed\n     * @return the number of zero bits preceding the highest-order\n     *     (\"leftmost\") one-bit in the two\u0027s complement binary representation\n     *     of the specified {@code int} value, or 32 if the value\n     *     is equal to zero.\n     * @since 1.5\n     */\n    @IntrinsicCandidate\n    public static int numberOfLeadingZeros(int i) {\n        // HD, Count leading 0\u0027s\n        if (i \u003c\u003d 0)\n            return i \u003d\u003d 0 ? 32 : 0;\n        int n \u003d 31;\n        if (i \u003e\u003d 1 \u003c\u003c 16) { n -\u003d 16; i \u003e\u003e\u003e\u003d 16; }\n        if (i \u003e\u003d 1 \u003c\u003c  8) { n -\u003d  8; i \u003e\u003e\u003e\u003d  8; }\n        if (i \u003e\u003d 1 \u003c\u003c  4) { n -\u003d  4; i \u003e\u003e\u003e\u003d  4; }\n        if (i \u003e\u003d 1 \u003c\u003c  2) { n -\u003d  2; i \u003e\u003e\u003e\u003d  2; }\n        return n - (i \u003e\u003e\u003e 1);\n    }\n\n    /**\n     * Returns the number of zero bits following the lowest-order (\"rightmost\")\n     * one-bit in the two\u0027s complement binary representation of the specified\n     * {@code int} value.  Returns 32 if the specified value has no\n     * one-bits in its two\u0027s complement representation, in other words if it is\n     * equal to zero.\n     *\n     * @param i the value whose number of trailing zeros is to be computed\n     * @return the number of zero bits following the lowest-order (\"rightmost\")\n     *     one-bit in the two\u0027s complement binary representation of the\n     *     specified {@code int} value, or 32 if the value is equal\n     *     to zero.\n     * @since 1.5\n     */\n    @IntrinsicCandidate\n    public static int numberOfTrailingZeros(int i) {\n        // HD, Count trailing 0\u0027s\n        i \u003d ~i \u0026 (i - 1);\n        if (i \u003c\u003d 0) return i \u0026 32;\n        int n \u003d 1;\n        if (i \u003e 1 \u003c\u003c 16) { n +\u003d 16; i \u003e\u003e\u003e\u003d 16; }\n        if (i \u003e 1 \u003c\u003c  8) { n +\u003d  8; i \u003e\u003e\u003e\u003d  8; }\n        if (i \u003e 1 \u003c\u003c  4) { n +\u003d  4; i \u003e\u003e\u003e\u003d  4; }\n        if (i \u003e 1 \u003c\u003c  2) { n +\u003d  2; i \u003e\u003e\u003e\u003d  2; }\n        return n + (i \u003e\u003e\u003e 1);\n    }\n\n    /**\n     * Returns the number of one-bits in the two\u0027s complement binary\n     * representation of the specified {@code int} value.  This function is\n     * sometimes referred to as the \u003ci\u003epopulation count\u003c/i\u003e.\n     *\n     * @param i the value whose bits are to be counted\n     * @return the number of one-bits in the two\u0027s complement binary\n     *     representation of the specified {@code int} value.\n     * @since 1.5\n     */\n    @IntrinsicCandidate\n    public static int bitCount(int i) {\n        // HD, Figure 5-2\n        i \u003d i - ((i \u003e\u003e\u003e 1) \u0026 0x55555555);\n        i \u003d (i \u0026 0x33333333) + ((i \u003e\u003e\u003e 2) \u0026 0x33333333);\n        i \u003d (i + (i \u003e\u003e\u003e 4)) \u0026 0x0f0f0f0f;\n        i \u003d i + (i \u003e\u003e\u003e 8);\n        i \u003d i + (i \u003e\u003e\u003e 16);\n        return i \u0026 0x3f;\n    }\n\n    /**\n     * Returns the value obtained by rotating the two\u0027s complement binary\n     * representation of the specified {@code int} value left by the\n     * specified number of bits.  (Bits shifted out of the left hand, or\n     * high-order, side reenter on the right, or low-order.)\n     *\n     * \u003cp\u003eNote that left rotation with a negative distance is equivalent to\n     * right rotation: {@code rotateLeft(val, -distance) \u003d\u003d rotateRight(val,\n     * distance)}.  Note also that rotation by any multiple of 32 is a\n     * no-op, so all but the last five bits of the rotation distance can be\n     * ignored, even if the distance is negative: {@code rotateLeft(val,\n     * distance) \u003d\u003d rotateLeft(val, distance \u0026 0x1F)}.\n     *\n     * @param i the value whose bits are to be rotated left\n     * @param distance the number of bit positions to rotate left\n     * @return the value obtained by rotating the two\u0027s complement binary\n     *     representation of the specified {@code int} value left by the\n     *     specified number of bits.\n     * @since 1.5\n     */\n    public static int rotateLeft(int i, int distance) {\n        return (i \u003c\u003c distance) | (i \u003e\u003e\u003e -distance);\n    }\n\n    /**\n     * Returns the value obtained by rotating the two\u0027s complement binary\n     * representation of the specified {@code int} value right by the\n     * specified number of bits.  (Bits shifted out of the right hand, or\n     * low-order, side reenter on the left, or high-order.)\n     *\n     * \u003cp\u003eNote that right rotation with a negative distance is equivalent to\n     * left rotation: {@code rotateRight(val, -distance) \u003d\u003d rotateLeft(val,\n     * distance)}.  Note also that rotation by any multiple of 32 is a\n     * no-op, so all but the last five bits of the rotation distance can be\n     * ignored, even if the distance is negative: {@code rotateRight(val,\n     * distance) \u003d\u003d rotateRight(val, distance \u0026 0x1F)}.\n     *\n     * @param i the value whose bits are to be rotated right\n     * @param distance the number of bit positions to rotate right\n     * @return the value obtained by rotating the two\u0027s complement binary\n     *     representation of the specified {@code int} value right by the\n     *     specified number of bits.\n     * @since 1.5\n     */\n    public static int rotateRight(int i, int distance) {\n        return (i \u003e\u003e\u003e distance) | (i \u003c\u003c -distance);\n    }\n\n    /**\n     * Returns the value obtained by reversing the order of the bits in the\n     * two\u0027s complement binary representation of the specified {@code int}\n     * value.\n     *\n     * @param i the value to be reversed\n     * @return the value obtained by reversing order of the bits in the\n     *     specified {@code int} value.\n     * @since 1.5\n     */\n    public static int reverse(int i) {\n        // HD, Figure 7-1\n        i \u003d (i \u0026 0x55555555) \u003c\u003c 1 | (i \u003e\u003e\u003e 1) \u0026 0x55555555;\n        i \u003d (i \u0026 0x33333333) \u003c\u003c 2 | (i \u003e\u003e\u003e 2) \u0026 0x33333333;\n        i \u003d (i \u0026 0x0f0f0f0f) \u003c\u003c 4 | (i \u003e\u003e\u003e 4) \u0026 0x0f0f0f0f;\n\n        return reverseBytes(i);\n    }\n\n    /**\n     * Returns the signum function of the specified {@code int} value.  (The\n     * return value is -1 if the specified value is negative; 0 if the\n     * specified value is zero; and 1 if the specified value is positive.)\n     *\n     * @param i the value whose signum is to be computed\n     * @return the signum function of the specified {@code int} value.\n     * @since 1.5\n     */\n    public static int signum(int i) {\n        // HD, Section 2-7\n        return (i \u003e\u003e 31) | (-i \u003e\u003e\u003e 31);\n    }\n\n    /**\n     * Returns the value obtained by reversing the order of the bytes in the\n     * two\u0027s complement representation of the specified {@code int} value.\n     *\n     * @param i the value whose bytes are to be reversed\n     * @return the value obtained by reversing the bytes in the specified\n     *     {@code int} value.\n     * @since 1.5\n     */\n    @IntrinsicCandidate\n    public static int reverseBytes(int i) {\n        return (i \u003c\u003c 24)            |\n               ((i \u0026 0xff00) \u003c\u003c 8)  |\n               ((i \u003e\u003e\u003e 8) \u0026 0xff00) |\n               (i \u003e\u003e\u003e 24);\n    }\n\n    /**\n     * Adds two integers together as per the + operator.\n     *\n     * @param a the first operand\n     * @param b the second operand\n     * @return the sum of {@code a} and {@code b}\n     * @see java.util.function.BinaryOperator\n     * @since 1.8\n     */\n    public static int sum(int a, int b) {\n        return a + b;\n    }\n\n    /**\n     * Returns the greater of two {@code int} values\n     * as if by calling {@link Math#max(int, int) Math.max}.\n     *\n     * @param a the first operand\n     * @param b the second operand\n     * @return the greater of {@code a} and {@code b}\n     * @see java.util.function.BinaryOperator\n     * @since 1.8\n     */\n    public static int max(int a, int b) {\n        return Math.max(a, b);\n    }\n\n    /**\n     * Returns the smaller of two {@code int} values\n     * as if by calling {@link Math#min(int, int) Math.min}.\n     *\n     * @param a the first operand\n     * @param b the second operand\n     * @return the smaller of {@code a} and {@code b}\n     * @see java.util.function.BinaryOperator\n     * @since 1.8\n     */\n    public static int min(int a, int b) {\n        return Math.min(a, b);\n    }\n\n    /**\n     * Returns an {@link Optional} containing the nominal descriptor for this\n     * instance, which is the instance itself.\n     *\n     * @return an {@link Optional} describing the {@linkplain Integer} instance\n     * @since 12\n     */\n    @Override\n    public Optional\u003cInteger\u003e describeConstable() {\n        return Optional.of(this);\n    }\n\n    /**\n     * Resolves this instance as a {@link ConstantDesc}, the result of which is\n     * the instance itself.\n     *\n     * @param lookup ignored\n     * @return the {@linkplain Integer} instance\n     * @since 12\n     */\n    @Override\n    public Integer resolveConstantDesc(MethodHandles.Lookup lookup) {\n        return this;\n    }\n\n    /** use serialVersionUID from JDK 1.0.2 for interoperability */\n    @java.io.Serial\n    @Native private static final long serialVersionUID \u003d 1360826667806852920L;\n}\n"
    }
  }
}
java.lang.IllegalArgumentException: Illegal character in opaque part at index 188: jar:file:///C:/Users/Vinicius/AppData/Local/Coursier/cache/arc/https/github.com/adoptium/temurin17-binaries/releases/download/jdk-17%2B35/OpenJDK17-jdk_x64_windows_hotspot_17_35.zip/jdk-17 35/lib/src.zip!/java.base/java/lang/Integer.java
	at java.base/java.net.URI.create(URI.java:906)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:178)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.$anonfun$toAbsolutePath$3(MtagsEnrichments.scala:175)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.withTryDecode$1(MtagsEnrichments.scala:153)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:175)
	at scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:756)
	at scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:753)
	at scala.meta.internal.metals.WorkspaceLspService.didOpen(WorkspaceLspService.scala:388)
	at scala.meta.metals.lsp.DelegatingScalaService.didOpen(DelegatingScalaService.scala:39)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:568)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$recursiveFindRpcMethods$0(GenericEndpoint.java:65)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.notify(GenericEndpoint.java:160)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleNotification(RemoteEndpoint.java:231)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:198)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:185)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:97)
	at org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:114)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:539)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.base/java.lang.Thread.run(Thread.java:833)
Caused by: java.net.URISyntaxException: Illegal character in opaque part at index 188: jar:file:///C:/Users/Vinicius/AppData/Local/Coursier/cache/arc/https/github.com/adoptium/temurin17-binaries/releases/download/jdk-17%2B35/OpenJDK17-jdk_x64_windows_hotspot_17_35.zip/jdk-17 35/lib/src.zip!/java.base/java/lang/Integer.java
	at java.base/java.net.URI$Parser.fail(URI.java:2974)
	at java.base/java.net.URI$Parser.checkChars(URI.java:3145)
	at java.base/java.net.URI$Parser.parse(URI.java:3181)
	at java.base/java.net.URI.<init>(URI.java:623)
	at java.base/java.net.URI.create(URI.java:904)
	... 24 more

jul. 19, 2024 12:40:09 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleNotification
ADVERTÊNCIA: Notification threw an exception: {
  "jsonrpc": "2.0",
  "method": "textDocument/didClose",
  "params": {
    "textDocument": {
      "uri": "jar:file%3A///C%3A/Users/Vinicius/AppData/Local/Coursier/cache/arc/https/github.com/adoptium/temurin17-binaries/releases/download/jdk-17%25252B35/OpenJDK17-jdk_x64_windows_hotspot_17_35.zip/jdk-17%2B35/lib/src.zip%21/java.base/java/lang/Integer.java"
    }
  }
}
java.lang.IllegalArgumentException: Illegal character in opaque part at index 188: jar:file:///C:/Users/Vinicius/AppData/Local/Coursier/cache/arc/https/github.com/adoptium/temurin17-binaries/releases/download/jdk-17%2B35/OpenJDK17-jdk_x64_windows_hotspot_17_35.zip/jdk-17 35/lib/src.zip!/java.base/java/lang/Integer.java
	at java.base/java.net.URI.create(URI.java:906)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:178)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.$anonfun$toAbsolutePath$3(MtagsEnrichments.scala:175)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.withTryDecode$1(MtagsEnrichments.scala:153)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:175)
	at scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:756)
	at scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:753)
	at scala.meta.internal.metals.WorkspaceLspService.didClose(WorkspaceLspService.scala:407)
	at scala.meta.metals.lsp.DelegatingScalaService.didClose(DelegatingScalaService.scala:53)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:568)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$recursiveFindRpcMethods$0(GenericEndpoint.java:65)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.notify(GenericEndpoint.java:160)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleNotification(RemoteEndpoint.java:231)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:198)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:185)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:97)
	at org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:114)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:539)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.base/java.lang.Thread.run(Thread.java:833)
Caused by: java.net.URISyntaxException: Illegal character in opaque part at index 188: jar:file:///C:/Users/Vinicius/AppData/Local/Coursier/cache/arc/https/github.com/adoptium/temurin17-binaries/releases/download/jdk-17%2B35/OpenJDK17-jdk_x64_windows_hotspot_17_35.zip/jdk-17 35/lib/src.zip!/java.base/java/lang/Integer.java
	at java.base/java.net.URI$Parser.fail(URI.java:2974)
	at java.base/java.net.URI$Parser.checkChars(URI.java:3145)
	at java.base/java.net.URI$Parser.parse(URI.java:3181)
	at java.base/java.net.URI.<init>(URI.java:623)
	at java.base/java.net.URI.create(URI.java:904)
	... 24 more

2024.07.19 12:40:10 INFO  compiling root (2 scala sources)
2024.07.19 12:40:10 INFO  time: compiled root in 0.22s
2024.07.19 12:40:10 WARN  Could not load snapshot text for C:\Users\Vinicius\UnB\FLanguage\src\main\scala\br\unb\cic\flang\MonadState.scala
2024.07.19 12:40:11 WARN  Could not load snapshot text for C:\Users\Vinicius\UnB\FLanguage\src\main\scala\br\unb\cic\flang\MonadState.scala
2024.07.19 12:42:07 WARN  Could not load snapshot text for C:\Users\Vinicius\UnB\FLanguage\src\main\scala\br\unb\cic\flang\MonadState.scala
2024.07.19 12:42:31 WARN  Could not load snapshot text for C:\Users\Vinicius\UnB\FLanguage\src\main\scala\br\unb\cic\flang\MonadState.scala
2024.07.19 12:42:31 INFO  Can not organize imports if file has error
2024.07.19 12:42:31 INFO  compiling root (2 scala sources)
2024.07.19 12:42:31 INFO  time: compiled root in 0.24s
2024.07.19 12:42:32 WARN  Could not load snapshot text for C:\Users\Vinicius\UnB\FLanguage\src\main\scala\br\unb\cic\flang\MonadState.scala
2024.07.19 12:42:39 WARN  Could not load snapshot text for C:\Users\Vinicius\UnB\FLanguage\src\main\scala\br\unb\cic\flang\MonadState.scala
jul. 19, 2024 12:43:16 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
ADVERTÊNCIA: Unmatched cancel notification for request id 2404
jul. 19, 2024 12:43:18 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
ADVERTÊNCIA: Unmatched cancel notification for request id 2412
2024.07.19 12:44:08 INFO  compiling root (2 scala sources)
2024.07.19 12:44:08 INFO  time: compiled root in 0.26s
2024.07.19 12:44:19 INFO  compiling root (2 scala sources)
2024.07.19 12:44:19 INFO  time: compiled root in 0.32s
2024.07.19 12:44:24 WARN  Could not load snapshot text for C:\Users\Vinicius\UnB\FLanguage\src\main\scala\br\unb\cic\flang\Interpreter2.scala
2024.07.19 12:44:27 WARN  Could not load snapshot text for C:\Users\Vinicius\UnB\FLanguage\src\main\scala\br\unb\cic\flang\Interpreter2.scala
2024.07.19 12:44:28 WARN  Could not load snapshot text for C:\Users\Vinicius\UnB\FLanguage\src\main\scala\br\unb\cic\flang\Interpreter2.scala
2024.07.19 12:44:30 WARN  Could not load snapshot text for C:\Users\Vinicius\UnB\FLanguage\src\main\scala\br\unb\cic\flang\MonadState.scala
2024.07.19 12:44:49 WARN  Could not load snapshot text for C:\Users\Vinicius\UnB\FLanguage\src\main\scala\br\unb\cic\flang\MonadState.scala
2024.07.19 12:44:51 WARN  Could not load snapshot text for C:\Users\Vinicius\UnB\FLanguage\src\main\scala\br\unb\cic\flang\MonadState.scala
2024.07.19 12:44:55 WARN  Could not load snapshot text for C:\Users\Vinicius\UnB\FLanguage\src\main\scala\br\unb\cic\flang\Interpreter2.scala
2024.07.19 12:44:57 WARN  Could not load snapshot text for C:\Users\Vinicius\UnB\FLanguage\src\main\scala\br\unb\cic\flang\MonadState.scala
2024.07.19 12:45:02 WARN  Could not load snapshot text for C:\Users\Vinicius\UnB\FLanguage\src\main\scala\br\unb\cic\flang\MonadState.scala
2024.07.19 12:45:03 WARN  Could not load snapshot text for C:\Users\Vinicius\UnB\FLanguage\src\main\scala\br\unb\cic\flang\Interpreter2.scala
2024.07.19 12:45:07 WARN  Could not load snapshot text for C:\Users\Vinicius\UnB\FLanguage\src\main\scala\br\unb\cic\flang\MonadState.scala
2024.07.19 12:45:09 WARN  Could not load snapshot text for C:\Users\Vinicius\UnB\FLanguage\src\main\scala\br\unb\cic\flang\Interpreter2.scala
2024.07.19 12:45:10 WARN  Could not load snapshot text for C:\Users\Vinicius\UnB\FLanguage\src\main\scala\br\unb\cic\flang\MonadState.scala
2024.07.19 12:45:39 WARN  Could not load snapshot text for C:\Users\Vinicius\UnB\FLanguage\src\main\scala\br\unb\cic\flang\MonadState.scala
2024.07.19 12:45:48 WARN  Could not load snapshot text for C:\Users\Vinicius\UnB\FLanguage\src\main\scala\br\unb\cic\flang\MonadState.scala
2024.07.19 12:45:50 WARN  Could not load snapshot text for C:\Users\Vinicius\UnB\FLanguage\src\main\scala\br\unb\cic\flang\MonadState.scala
2024.07.19 12:45:55 WARN  Could not load snapshot text for C:\Users\Vinicius\UnB\FLanguage\src\main\scala\br\unb\cic\flang\MonadState.scala
2024.07.19 12:45:55 INFO  Can not organize imports if file has error
2024.07.19 12:45:55 INFO  compiling root (2 scala sources)
2024.07.19 12:45:55 INFO  time: compiled root in 0.22s
2024.07.19 12:45:56 WARN  Could not load snapshot text for C:\Users\Vinicius\UnB\FLanguage\src\main\scala\br\unb\cic\flang\MonadState.scala
2024.07.19 12:46:16 WARN  Could not load snapshot text for C:\Users\Vinicius\UnB\FLanguage\src\main\scala\br\unb\cic\flang\MonadState.scala
2024.07.19 12:46:17 WARN  Could not load snapshot text for C:\Users\Vinicius\UnB\FLanguage\src\main\scala\br\unb\cic\flang\MonadState.scala
2024.07.19 12:46:17 WARN  Could not load snapshot text for C:\Users\Vinicius\UnB\FLanguage\src\main\scala\br\unb\cic\flang\MonadState.scala
2024.07.19 12:46:18 INFO  Can not organize imports if file has error
2024.07.19 12:46:18 INFO  compiling root (2 scala sources)
2024.07.19 12:46:18 INFO  time: compiled root in 0.32s
2024.07.19 12:46:19 WARN  Could not load snapshot text for C:\Users\Vinicius\UnB\FLanguage\src\main\scala\br\unb\cic\flang\MonadState.scala
jul. 19, 2024 12:46:26 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
ADVERTÊNCIA: Unmatched cancel notification for request id 2899
2024.07.19 12:46:27 WARN  Could not load snapshot text for C:\Users\Vinicius\UnB\FLanguage\src\main\scala\br\unb\cic\flang\Interpreter2.scala
2024.07.19 12:46:35 WARN  Could not load snapshot text for C:\Users\Vinicius\UnB\FLanguage\src\main\scala\br\unb\cic\flang\Interpreter2.scala
2024.07.19 12:46:39 WARN  Could not load snapshot text for C:\Users\Vinicius\UnB\FLanguage\src\main\scala\br\unb\cic\flang\Interpreter2.scala
2024.07.19 12:46:40 INFO  Can not organize imports if file has error
2024.07.19 12:46:40 INFO  compiling root (2 scala sources)
2024.07.19 12:46:42 WARN  Could not load snapshot text for C:\Users\Vinicius\UnB\FLanguage\src\main\scala\br\unb\cic\flang\MonadState.scala
2024.07.19 12:46:43 INFO  time: compiled root in 3.1s
2024.07.19 12:46:57 INFO  compiling root (2 scala sources)
2024.07.19 12:46:57 INFO  time: compiled root in 0.15s
2024.07.19 12:47:00 INFO  compiling root (2 scala sources)
2024.07.19 12:47:00 INFO  time: compiled root in 0.13s
2024.07.19 12:47:00 INFO  compiling root (2 scala sources)
2024.07.19 12:47:00 INFO  time: compiled root in 0.14s
jul. 19, 2024 12:47:19 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
ADVERTÊNCIA: Unmatched cancel notification for request id 3037
2024.07.19 12:47:24 INFO  compiling root (2 scala sources)
2024.07.19 12:47:24 INFO  time: compiled root in 0.12s
jul. 19, 2024 12:47:27 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
ADVERTÊNCIA: Unmatched cancel notification for request id 3073
2024.07.19 12:47:27 INFO  compiling root (2 scala sources)
2024.07.19 12:47:27 INFO  time: compiled root in 0.16s
jul. 19, 2024 12:47:31 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
ADVERTÊNCIA: Unmatched cancel notification for request id 3095
jul. 19, 2024 12:47:33 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
ADVERTÊNCIA: Unmatched cancel notification for request id 3106
2024.07.19 12:47:34 INFO  Can not organize imports if file has error
2024.07.19 12:47:35 INFO  compiling root (3 scala sources)
jul. 19, 2024 12:47:36 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
ADVERTÊNCIA: Unmatched cancel notification for request id 3133
2024.07.19 12:47:37 INFO  time: compiled root in 2.22s
2024.07.19 12:47:37 INFO  compiling root-test (2 scala sources)
2024.07.19 12:47:37 INFO  time: compiled root-test in 0.55s
2024.07.19 12:47:38 WARN  Could not load snapshot text for C:\Users\Vinicius\UnB\FLanguage\src\test\scala\br\unb\cic\flang\MonadTest.scala
2024.07.19 12:47:39 INFO  Can not organize imports if file has error
2024.07.19 12:47:39 INFO  compiling root-test (2 scala sources)
2024.07.19 12:47:39 INFO  time: compiled root-test in 0.48s
2024.07.19 12:47:40 WARN  Could not load snapshot text for C:\Users\Vinicius\UnB\FLanguage\src\test\scala\br\unb\cic\flang\MonadTest.scala
2024.07.19 12:47:49 INFO  compiling root-test (2 scala sources)
2024.07.19 12:47:49 WARN  Could not load snapshot text for C:\Users\Vinicius\UnB\FLanguage\src\test\scala\br\unb\cic\flang\MonadTest.scala
2024.07.19 12:47:49 INFO  time: compiled root-test in 0.54s
2024.07.19 12:47:50 WARN  Could not load snapshot text for C:\Users\Vinicius\UnB\FLanguage\src\test\scala\br\unb\cic\flang\MonadTest.scala
2024.07.19 12:47:52 INFO  compiling root-test (2 scala sources)
2024.07.19 12:47:52 WARN  Could not load snapshot text for C:\Users\Vinicius\UnB\FLanguage\src\test\scala\br\unb\cic\flang\MonadTest.scala
2024.07.19 12:47:52 INFO  time: compiled root-test in 0.77s
2024.07.19 12:47:53 WARN  Could not load snapshot text for C:\Users\Vinicius\UnB\FLanguage\src\test\scala\br\unb\cic\flang\MonadTest.scala
2024.07.19 12:48:12 WARN  Could not load snapshot text for C:\Users\Vinicius\UnB\FLanguage\src\test\scala\br\unb\cic\flang\MonadTest.scala
2024.07.19 12:48:13 WARN  Could not load snapshot text for C:\Users\Vinicius\UnB\FLanguage\src\test\scala\br\unb\cic\flang\MonadTest.scala
2024.07.19 12:48:14 WARN  Could not load snapshot text for C:\Users\Vinicius\UnB\FLanguage\src\test\scala\br\unb\cic\flang\MonadTest.scala
2024.07.19 12:48:16 WARN  Could not load snapshot text for C:\Users\Vinicius\UnB\FLanguage\src\test\scala\br\unb\cic\flang\MonadTest.scala
2024.07.19 12:48:17 WARN  Could not load snapshot text for C:\Users\Vinicius\UnB\FLanguage\src\test\scala\br\unb\cic\flang\MonadTest.scala
2024.07.19 12:48:17 WARN  Could not load snapshot text for C:\Users\Vinicius\UnB\FLanguage\src\test\scala\br\unb\cic\flang\MonadTest.scala
2024.07.19 12:48:18 WARN  Could not load snapshot text for C:\Users\Vinicius\UnB\FLanguage\src\test\scala\br\unb\cic\flang\MonadTest.scala
2024.07.19 12:48:26 WARN  Could not load snapshot text for C:\Users\Vinicius\UnB\FLanguage\src\test\scala\br\unb\cic\flang\MonadTest.scala
2024.07.19 12:48:26 WARN  Could not load snapshot text for C:\Users\Vinicius\UnB\FLanguage\src\test\scala\br\unb\cic\flang\MonadTest.scala
2024.07.19 12:48:26 WARN  Using indexes to guess the definition of List
2024.07.19 12:48:26 WARN  Could not load snapshot text for C:\Users\Vinicius\UnB\FLanguage\src\test\scala\br\unb\cic\flang\MonadTest.scala
2024.07.19 12:48:26 WARN  Could not load snapshot text for C:\Users\Vinicius\UnB\FLanguage\src\test\scala\br\unb\cic\flang\MonadTest.scala
2024.07.19 12:48:26 WARN  Could not load snapshot text for C:\Users\Vinicius\UnB\FLanguage\src\test\scala\br\unb\cic\flang\MonadTest.scala
2024.07.19 12:48:26 WARN  Could not load snapshot text for C:\Users\Vinicius\UnB\FLanguage\src\test\scala\br\unb\cic\flang\MonadTest.scala
2024.07.19 12:48:27 WARN  Could not load snapshot text for C:\Users\Vinicius\UnB\FLanguage\src\test\scala\br\unb\cic\flang\MonadTest.scala
2024.07.19 12:48:29 WARN  Could not load snapshot text for C:\Users\Vinicius\UnB\FLanguage\src\test\scala\br\unb\cic\flang\MonadTest.scala
2024.07.19 12:48:29 WARN  Could not load snapshot text for C:\Users\Vinicius\UnB\FLanguage\src\test\scala\br\unb\cic\flang\MonadTest.scala
2024.07.19 12:48:29 INFO  Can not organize imports if file has error
2024.07.19 12:48:30 INFO  compiling root-test (2 scala sources)
2024.07.19 12:48:30 INFO  time: compiled root-test in 0.41s
2024.07.19 12:48:30 WARN  Could not load snapshot text for C:\Users\Vinicius\UnB\FLanguage\src\test\scala\br\unb\cic\flang\MonadTest.scala
2024.07.19 12:48:33 INFO  Can not organize imports if file has error
2024.07.19 12:48:33 INFO  compiling root-test (2 scala sources)
2024.07.19 12:48:33 WARN  Could not load snapshot text for C:\Users\Vinicius\UnB\FLanguage\src\test\scala\br\unb\cic\flang\MonadTest.scala
2024.07.19 12:48:33 INFO  time: compiled root-test in 0.46s
2024.07.19 12:48:34 WARN  Could not load snapshot text for C:\Users\Vinicius\UnB\FLanguage\src\test\scala\br\unb\cic\flang\MonadTest.scala
2024.07.19 12:48:37 WARN  Could not load snapshot text for C:\Users\Vinicius\UnB\FLanguage\src\test\scala\br\unb\cic\flang\MonadTest.scala
jul. 19, 2024 12:48:37 PM scala.meta.internal.pc.CompilerAccess retryWithCleanCompiler
INFORMAÇÕES: compiler crashed due to an error in the Scala compiler, retrying with new compiler instance.
jul. 19, 2024 12:48:38 PM scala.meta.internal.pc.CompilerAccess handleError
GRAVE: A severe compiler error occurred, full details of the error can be found in the error report C:\Users\Vinicius\UnB\FLanguage\.metals\.reports\metals-full\2024-07-19\r_compiler-error_(root-test)_12-48-38-032.md
jul. 19, 2024 12:48:38 PM scala.meta.internal.pc.CompilerAccess retryWithCleanCompiler
INFORMAÇÕES: compiler crashed due to an error in the Scala compiler, retrying with new compiler instance.
2024.07.19 12:48:38 WARN  Could not load snapshot text for C:\Users\Vinicius\UnB\FLanguage\src\test\scala\br\unb\cic\flang\MonadTest.scala
jul. 19, 2024 12:48:38 PM scala.meta.internal.pc.CompilerAccess handleError
GRAVE: A severe compiler error occurred, full details of the error can be found in the error report C:\Users\Vinicius\UnB\FLanguage\.metals\.reports\metals-full\2024-07-19\r_compiler-error_(root-test)_12-48-38-451.md
2024.07.19 12:48:38 INFO  Can not organize imports if file has error
2024.07.19 12:48:38 INFO  compiling root-test (2 scala sources)
2024.07.19 12:48:41 INFO  time: compiled root-test in 2.47s
2024.07.19 12:49:12 INFO  compiling root-test (1 scala source)
2024.07.19 12:49:12 INFO  time: compiled root-test in 0.3s
2024.07.19 12:49:22 INFO  Can not organize imports if file has error
2024.07.19 12:49:22 INFO  compiling root-test (1 scala source)
2024.07.19 12:49:23 INFO  time: compiled root-test in 1.42s
2024.07.19 12:49:28 INFO  compiling root-test (1 scala source)
2024.07.19 12:49:30 INFO  time: compiled root-test in 1.46s
jul. 19, 2024 12:51:18 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
ADVERTÊNCIA: Unmatched cancel notification for request id 3530
2024.07.19 12:51:39 INFO  compiling root-test (1 scala source)
2024.07.19 12:51:41 INFO  time: compiled root-test in 1.34s
jul. 19, 2024 12:51:44 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
ADVERTÊNCIA: Unmatched cancel notification for request id 3581
jul. 19, 2024 12:51:54 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
ADVERTÊNCIA: Unmatched cancel notification for request id 3600
jul. 19, 2024 12:51:54 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
ADVERTÊNCIA: Unmatched cancel notification for request id 3608
jul. 19, 2024 12:51:55 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
ADVERTÊNCIA: Unmatched cancel notification for request id 3616
jul. 19, 2024 12:51:56 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
ADVERTÊNCIA: Unmatched cancel notification for request id 3624
jul. 19, 2024 12:52:01 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
ADVERTÊNCIA: Unmatched cancel notification for request id 3641
jul. 19, 2024 12:52:03 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
ADVERTÊNCIA: Unmatched cancel notification for request id 3651
jul. 19, 2024 12:52:05 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
ADVERTÊNCIA: Unmatched cancel notification for request id 3659
jul. 19, 2024 12:52:05 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
ADVERTÊNCIA: Unmatched cancel notification for request id 3664
jul. 19, 2024 12:52:05 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
ADVERTÊNCIA: Unmatched cancel notification for request id 3666
jul. 19, 2024 12:52:09 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
ADVERTÊNCIA: Unmatched cancel notification for request id 3682
jul. 19, 2024 12:52:27 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
ADVERTÊNCIA: Unmatched cancel notification for request id 3710
jul. 19, 2024 12:52:35 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
ADVERTÊNCIA: Unmatched cancel notification for request id 3723
jul. 19, 2024 12:53:12 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
ADVERTÊNCIA: Unmatched cancel notification for request id 3743
jul. 19, 2024 12:53:15 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
ADVERTÊNCIA: Unmatched cancel notification for request id 3751
jul. 19, 2024 12:53:15 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
ADVERTÊNCIA: Unmatched cancel notification for request id 3759
jul. 19, 2024 12:53:27 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
ADVERTÊNCIA: Unmatched cancel notification for request id 3770
2024.07.19 12:56:30 INFO  compiling root-test (1 scala source)
2024.07.19 12:56:31 INFO  time: compiled root-test in 1.29s
jul. 19, 2024 12:57:44 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
ADVERTÊNCIA: Unmatched cancel notification for request id 3878
jul. 19, 2024 12:57:45 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
ADVERTÊNCIA: Unmatched cancel notification for request id 3886
jul. 19, 2024 12:57:46 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
ADVERTÊNCIA: Unmatched cancel notification for request id 3895
jul. 19, 2024 12:57:49 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
ADVERTÊNCIA: Unmatched cancel notification for request id 3909
jul. 19, 2024 12:57:49 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
ADVERTÊNCIA: Unmatched cancel notification for request id 3918
jul. 19, 2024 12:57:50 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
ADVERTÊNCIA: Unmatched cancel notification for request id 3926
jul. 19, 2024 12:57:50 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
ADVERTÊNCIA: Unmatched cancel notification for request id 3935
jul. 19, 2024 12:57:52 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
ADVERTÊNCIA: Unmatched cancel notification for request id 3943
jul. 19, 2024 12:57:58 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
ADVERTÊNCIA: Unmatched cancel notification for request id 3955
jul. 19, 2024 12:58:07 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
ADVERTÊNCIA: Unmatched cancel notification for request id 3964
jul. 19, 2024 12:58:08 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
ADVERTÊNCIA: Unmatched cancel notification for request id 3973
jul. 19, 2024 12:58:09 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
ADVERTÊNCIA: Unmatched cancel notification for request id 3981
jul. 19, 2024 12:58:14 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
ADVERTÊNCIA: Unmatched cancel notification for request id 3990
jul. 19, 2024 12:58:16 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
ADVERTÊNCIA: Unmatched cancel notification for request id 4000
jul. 19, 2024 12:58:30 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
ADVERTÊNCIA: Unmatched cancel notification for request id 4013
jul. 19, 2024 12:58:57 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
ADVERTÊNCIA: Unmatched cancel notification for request id 4025
jul. 19, 2024 12:59:25 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
ADVERTÊNCIA: Unmatched cancel notification for request id 4042
jul. 19, 2024 12:59:29 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
ADVERTÊNCIA: Unmatched cancel notification for request id 4063
jul. 19, 2024 12:59:29 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
ADVERTÊNCIA: Unmatched cancel notification for request id 4071
jul. 19, 2024 12:59:36 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
ADVERTÊNCIA: Unmatched cancel notification for request id 4086
jul. 19, 2024 12:59:37 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
ADVERTÊNCIA: Unmatched cancel notification for request id 4094
jul. 19, 2024 12:59:38 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
ADVERTÊNCIA: Unmatched cancel notification for request id 4102
jul. 19, 2024 1:01:11 PM scala.meta.internal.pc.CompletionProvider expected$1
ADVERTÊNCIA: offset 229, count -10, length 1097
something's wrong: no file:///C:/Users/Vinicius/UnB/FLanguage/src/main/scala/br/unb/cic/flang/MonadState.scala in cats.data.State[br.unb.cic.flang.MonadState.package.S,<error>]RangePosition(file:///C:/Users/Vinicius/UnB/FLanguage/src/main/scala/br/unb/cic/flang/MonadState.scala, 218, 218, 235)
something's wrong: no file:///C:/Users/Vinicius/UnB/FLanguage/src/main/scala/br/unb/cic/flang/MonadState.scala in cats.data.State[br.unb.cic.flang.MonadState.package.S,<error>]RangePosition(file:///C:/Users/Vinicius/UnB/FLanguage/src/main/scala/br/unb/cic/flang/MonadState.scala, 218, 218, 236)
something's wrong: no file:///C:/Users/Vinicius/UnB/FLanguage/src/main/scala/br/unb/cic/flang/MonadState.scala in cats.data.State[br.unb.cic.flang.MonadState.package.S,<error>]RangePosition(file:///C:/Users/Vinicius/UnB/FLanguage/src/main/scala/br/unb/cic/flang/MonadState.scala, 218, 218, 229)
2024.07.19 13:01:18 INFO  compiling root (1 scala source)
2024.07.19 13:01:18 INFO  time: compiled root in 0.2s
jul. 19, 2024 1:01:18 PM scala.meta.internal.pc.CompilerAccess retryWithCleanCompiler
INFORMAÇÕES: compiler crashed due to an error in the Scala compiler, retrying with new compiler instance.
jul. 19, 2024 1:01:19 PM scala.meta.internal.pc.CompilerAccess handleError
GRAVE: A severe compiler error occurred, full details of the error can be found in the error report C:\Users\Vinicius\UnB\FLanguage\.metals\.reports\metals-full\2024-07-19\r_compiler-error_(root)_13-01-19-231.md
jul. 19, 2024 1:01:20 PM scala.meta.internal.pc.CompilerAccess retryWithCleanCompiler
INFORMAÇÕES: compiler crashed due to an error in the Scala compiler, retrying with new compiler instance.
jul. 19, 2024 1:01:20 PM scala.meta.internal.pc.CompilerAccess handleError
GRAVE: A severe compiler error occurred, full details of the error can be found in the error report C:\Users\Vinicius\UnB\FLanguage\.metals\.reports\metals-full\2024-07-19\r_compiler-error_(root)_13-01-20-708.md
2024.07.19 13:01:22 INFO  Can not organize imports if file has error
2024.07.19 13:01:22 INFO  compiling root (1 scala source)
2024.07.19 13:01:23 WARN  1 deprecation (since 2.11.0); re-run with -deprecation for details
2024.07.19 13:01:23 INFO  time: compiled root in 1.14s
2024.07.19 13:01:47 INFO  compiling root (1 scala source)
2024.07.19 13:01:47 WARN  1 deprecation (since 2.11.0); re-run with -deprecation for details
2024.07.19 13:01:48 INFO  time: compiled root in 1.06s
2024.07.19 13:02:00 INFO  compiling root (1 scala source)
2024.07.19 13:02:00 INFO  time: compiled root in 0.19s
jul. 19, 2024 1:02:03 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
ADVERTÊNCIA: Unmatched cancel notification for request id 4489
jul. 19, 2024 1:02:04 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
ADVERTÊNCIA: Unmatched cancel notification for request id 4497
2024.07.19 13:02:07 INFO  compiling root (2 scala sources)
2024.07.19 13:02:07 INFO  time: compiled root in 0.2s
2024.07.19 13:02:12 INFO  compiling root (2 scala sources)
2024.07.19 13:02:12 INFO  time: compiled root in 0.46s
2024.07.19 13:02:20 INFO  compiling root (2 scala sources)
2024.07.19 13:02:20 INFO  time: compiled root in 0.23s
2024.07.19 13:02:26 INFO  compiling root (2 scala sources)
2024.07.19 13:02:26 INFO  time: compiled root in 0.3s
2024.07.19 13:02:32 INFO  compiling root (2 scala sources)
2024.07.19 13:02:32 INFO  time: compiled root in 0.24s
2024.07.19 13:02:33 WARN  Attempt to organize your imports failed. It looks like you have compilation issues causing your semanticdb to be stale. Ensure everything is compiling and try again.
2024.07.19 13:02:33 INFO  compiling root (2 scala sources)
2024.07.19 13:02:33 INFO  time: compiled root in 0.29s
2024.07.19 13:02:35 INFO  compiling root (2 scala sources)
2024.07.19 13:02:35 INFO  time: compiled root in 0.2s
2024.07.19 13:02:56 WARN  Attempt to organize your imports failed. It looks like you have compilation issues causing your semanticdb to be stale. Ensure everything is compiling and try again.
2024.07.19 13:02:56 INFO  compiling root (2 scala sources)
2024.07.19 13:02:56 INFO  time: compiled root in 0.23s
jul. 19, 2024 1:03:02 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
ADVERTÊNCIA: Unmatched cancel notification for request id 4701
jul. 19, 2024 1:03:04 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
ADVERTÊNCIA: Unmatched cancel notification for request id 4710
jul. 19, 2024 1:03:16 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
ADVERTÊNCIA: Unmatched cancel notification for request id 4728
jul. 19, 2024 1:03:23 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
ADVERTÊNCIA: Unmatched cancel notification for request id 4739
jul. 19, 2024 1:03:27 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
ADVERTÊNCIA: Unmatched cancel notification for request id 4751
2024.07.19 13:03:31 WARN  Using indexes to guess the definition of S2
2024.07.19 13:03:32 INFO  compiling root (2 scala sources)
2024.07.19 13:03:32 INFO  time: compiled root in 0.18s
jul. 19, 2024 1:03:35 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleNotification
ADVERTÊNCIA: Notification threw an exception: {
  "jsonrpc": "2.0",
  "method": "textDocument/didOpen",
  "params": {
    "textDocument": {
      "uri": "jar:file%3A///C%3A/Users/Vinicius/AppData/Local/Coursier/cache/arc/https/github.com/adoptium/temurin17-binaries/releases/download/jdk-17%25252B35/OpenJDK17-jdk_x64_windows_hotspot_17_35.zip/jdk-17%2B35/lib/src.zip%21/java.base/java/lang/Integer.java",
      "languageId": "java",
      "version": 1,
      "text": "/*\n * Copyright (c) 1994, 2021, Oracle and/or its affiliates. All rights reserved.\n * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n *\n * This code is free software; you can redistribute it and/or modify it\n * under the terms of the GNU General Public License version 2 only, as\n * published by the Free Software Foundation.  Oracle designates this\n * particular file as subject to the \"Classpath\" exception as provided\n * by Oracle in the LICENSE file that accompanied this code.\n *\n * This code is distributed in the hope that it will be useful, but WITHOUT\n * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n * version 2 for more details (a copy is included in the LICENSE file that\n * accompanied this code).\n *\n * You should have received a copy of the GNU General Public License version\n * 2 along with this work; if not, write to the Free Software Foundation,\n * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n *\n * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n * or visit www.oracle.com if you need additional information or have any\n * questions.\n */\n\npackage java.lang;\n\nimport java.lang.annotation.Native;\nimport java.lang.invoke.MethodHandles;\nimport java.lang.constant.Constable;\nimport java.lang.constant.ConstantDesc;\nimport java.util.Objects;\nimport java.util.Optional;\n\nimport jdk.internal.misc.CDS;\nimport jdk.internal.misc.VM;\nimport jdk.internal.vm.annotation.IntrinsicCandidate;\n\nimport static java.lang.String.COMPACT_STRINGS;\nimport static java.lang.String.LATIN1;\nimport static java.lang.String.UTF16;\n\n/**\n * The {@code Integer} class wraps a value of the primitive type\n * {@code int} in an object. An object of type {@code Integer}\n * contains a single field whose type is {@code int}.\n *\n * \u003cp\u003eIn addition, this class provides several methods for converting\n * an {@code int} to a {@code String} and a {@code String} to an\n * {@code int}, as well as other constants and methods useful when\n * dealing with an {@code int}.\n *\n * \u003cp\u003eThis is a \u003ca href\u003d\"{@docRoot}/java.base/java/lang/doc-files/ValueBased.html\"\u003evalue-based\u003c/a\u003e\n * class; programmers should treat instances that are\n * {@linkplain #equals(Object) equal} as interchangeable and should not\n * use instances for synchronization, or unpredictable behavior may\n * occur. For example, in a future release, synchronization may fail.\n *\n * \u003cp\u003eImplementation note: The implementations of the \"bit twiddling\"\n * methods (such as {@link #highestOneBit(int) highestOneBit} and\n * {@link #numberOfTrailingZeros(int) numberOfTrailingZeros}) are\n * based on material from Henry S. Warren, Jr.\u0027s \u003ci\u003eHacker\u0027s\n * Delight\u003c/i\u003e, (Addison Wesley, 2002).\n *\n * @author  Lee Boynton\n * @author  Arthur van Hoff\n * @author  Josh Bloch\n * @author  Joseph D. Darcy\n * @since 1.0\n */\n@jdk.internal.ValueBased\npublic final class Integer extends Number\n        implements Comparable\u003cInteger\u003e, Constable, ConstantDesc {\n    /**\n     * A constant holding the minimum value an {@code int} can\n     * have, -2\u003csup\u003e31\u003c/sup\u003e.\n     */\n    @Native public static final int   MIN_VALUE \u003d 0x80000000;\n\n    /**\n     * A constant holding the maximum value an {@code int} can\n     * have, 2\u003csup\u003e31\u003c/sup\u003e-1.\n     */\n    @Native public static final int   MAX_VALUE \u003d 0x7fffffff;\n\n    /**\n     * The {@code Class} instance representing the primitive type\n     * {@code int}.\n     *\n     * @since   1.1\n     */\n    @SuppressWarnings(\"unchecked\")\n    public static final Class\u003cInteger\u003e  TYPE \u003d (Class\u003cInteger\u003e) Class.getPrimitiveClass(\"int\");\n\n    /**\n     * All possible chars for representing a number as a String\n     */\n    static final char[] digits \u003d {\n        \u00270\u0027 , \u00271\u0027 , \u00272\u0027 , \u00273\u0027 , \u00274\u0027 , \u00275\u0027 ,\n        \u00276\u0027 , \u00277\u0027 , \u00278\u0027 , \u00279\u0027 , \u0027a\u0027 , \u0027b\u0027 ,\n        \u0027c\u0027 , \u0027d\u0027 , \u0027e\u0027 , \u0027f\u0027 , \u0027g\u0027 , \u0027h\u0027 ,\n        \u0027i\u0027 , \u0027j\u0027 , \u0027k\u0027 , \u0027l\u0027 , \u0027m\u0027 , \u0027n\u0027 ,\n        \u0027o\u0027 , \u0027p\u0027 , \u0027q\u0027 , \u0027r\u0027 , \u0027s\u0027 , \u0027t\u0027 ,\n        \u0027u\u0027 , \u0027v\u0027 , \u0027w\u0027 , \u0027x\u0027 , \u0027y\u0027 , \u0027z\u0027\n    };\n\n    /**\n     * Returns a string representation of the first argument in the\n     * radix specified by the second argument.\n     *\n     * \u003cp\u003eIf the radix is smaller than {@code Character.MIN_RADIX}\n     * or larger than {@code Character.MAX_RADIX}, then the radix\n     * {@code 10} is used instead.\n     *\n     * \u003cp\u003eIf the first argument is negative, the first element of the\n     * result is the ASCII minus character {@code \u0027-\u0027}\n     * ({@code \u0027\\u005Cu002D\u0027}). If the first argument is not\n     * negative, no sign character appears in the result.\n     *\n     * \u003cp\u003eThe remaining characters of the result represent the magnitude\n     * of the first argument. If the magnitude is zero, it is\n     * represented by a single zero character {@code \u00270\u0027}\n     * ({@code \u0027\\u005Cu0030\u0027}); otherwise, the first character of\n     * the representation of the magnitude will not be the zero\n     * character.  The following ASCII characters are used as digits:\n     *\n     * \u003cblockquote\u003e\n     *   {@code 0123456789abcdefghijklmnopqrstuvwxyz}\n     * \u003c/blockquote\u003e\n     *\n     * These are {@code \u0027\\u005Cu0030\u0027} through\n     * {@code \u0027\\u005Cu0039\u0027} and {@code \u0027\\u005Cu0061\u0027} through\n     * {@code \u0027\\u005Cu007A\u0027}. If {@code radix} is\n     * \u003cvar\u003eN\u003c/var\u003e, then the first \u003cvar\u003eN\u003c/var\u003e of these characters\n     * are used as radix-\u003cvar\u003eN\u003c/var\u003e digits in the order shown. Thus,\n     * the digits for hexadecimal (radix 16) are\n     * {@code 0123456789abcdef}. If uppercase letters are\n     * desired, the {@link java.lang.String#toUpperCase()} method may\n     * be called on the result:\n     *\n     * \u003cblockquote\u003e\n     *  {@code Integer.toString(n, 16).toUpperCase()}\n     * \u003c/blockquote\u003e\n     *\n     * @param   i       an integer to be converted to a string.\n     * @param   radix   the radix to use in the string representation.\n     * @return  a string representation of the argument in the specified radix.\n     * @see     java.lang.Character#MAX_RADIX\n     * @see     java.lang.Character#MIN_RADIX\n     */\n    public static String toString(int i, int radix) {\n        if (radix \u003c Character.MIN_RADIX || radix \u003e Character.MAX_RADIX)\n            radix \u003d 10;\n\n        /* Use the faster version */\n        if (radix \u003d\u003d 10) {\n            return toString(i);\n        }\n\n        if (COMPACT_STRINGS) {\n            byte[] buf \u003d new byte[33];\n            boolean negative \u003d (i \u003c 0);\n            int charPos \u003d 32;\n\n            if (!negative) {\n                i \u003d -i;\n            }\n\n            while (i \u003c\u003d -radix) {\n                buf[charPos--] \u003d (byte)digits[-(i % radix)];\n                i \u003d i / radix;\n            }\n            buf[charPos] \u003d (byte)digits[-i];\n\n            if (negative) {\n                buf[--charPos] \u003d \u0027-\u0027;\n            }\n\n            return StringLatin1.newString(buf, charPos, (33 - charPos));\n        }\n        return toStringUTF16(i, radix);\n    }\n\n    private static String toStringUTF16(int i, int radix) {\n        byte[] buf \u003d new byte[33 * 2];\n        boolean negative \u003d (i \u003c 0);\n        int charPos \u003d 32;\n        if (!negative) {\n            i \u003d -i;\n        }\n        while (i \u003c\u003d -radix) {\n            StringUTF16.putChar(buf, charPos--, digits[-(i % radix)]);\n            i \u003d i / radix;\n        }\n        StringUTF16.putChar(buf, charPos, digits[-i]);\n\n        if (negative) {\n            StringUTF16.putChar(buf, --charPos, \u0027-\u0027);\n        }\n        return StringUTF16.newString(buf, charPos, (33 - charPos));\n    }\n\n    /**\n     * Returns a string representation of the first argument as an\n     * unsigned integer value in the radix specified by the second\n     * argument.\n     *\n     * \u003cp\u003eIf the radix is smaller than {@code Character.MIN_RADIX}\n     * or larger than {@code Character.MAX_RADIX}, then the radix\n     * {@code 10} is used instead.\n     *\n     * \u003cp\u003eNote that since the first argument is treated as an unsigned\n     * value, no leading sign character is printed.\n     *\n     * \u003cp\u003eIf the magnitude is zero, it is represented by a single zero\n     * character {@code \u00270\u0027} ({@code \u0027\\u005Cu0030\u0027}); otherwise,\n     * the first character of the representation of the magnitude will\n     * not be the zero character.\n     *\n     * \u003cp\u003eThe behavior of radixes and the characters used as digits\n     * are the same as {@link #toString(int, int) toString}.\n     *\n     * @param   i       an integer to be converted to an unsigned string.\n     * @param   radix   the radix to use in the string representation.\n     * @return  an unsigned string representation of the argument in the specified radix.\n     * @see     #toString(int, int)\n     * @since 1.8\n     */\n    public static String toUnsignedString(int i, int radix) {\n        return Long.toUnsignedString(toUnsignedLong(i), radix);\n    }\n\n    /**\n     * Returns a string representation of the integer argument as an\n     * unsigned integer in base\u0026nbsp;16.\n     *\n     * \u003cp\u003eThe unsigned integer value is the argument plus 2\u003csup\u003e32\u003c/sup\u003e\n     * if the argument is negative; otherwise, it is equal to the\n     * argument.  This value is converted to a string of ASCII digits\n     * in hexadecimal (base\u0026nbsp;16) with no extra leading\n     * {@code 0}s.\n     *\n     * \u003cp\u003eThe value of the argument can be recovered from the returned\n     * string {@code s} by calling {@link\n     * Integer#parseUnsignedInt(String, int)\n     * Integer.parseUnsignedInt(s, 16)}.\n     *\n     * \u003cp\u003eIf the unsigned magnitude is zero, it is represented by a\n     * single zero character {@code \u00270\u0027} ({@code \u0027\\u005Cu0030\u0027});\n     * otherwise, the first character of the representation of the\n     * unsigned magnitude will not be the zero character. The\n     * following characters are used as hexadecimal digits:\n     *\n     * \u003cblockquote\u003e\n     *  {@code 0123456789abcdef}\n     * \u003c/blockquote\u003e\n     *\n     * These are the characters {@code \u0027\\u005Cu0030\u0027} through\n     * {@code \u0027\\u005Cu0039\u0027} and {@code \u0027\\u005Cu0061\u0027} through\n     * {@code \u0027\\u005Cu0066\u0027}. If uppercase letters are\n     * desired, the {@link java.lang.String#toUpperCase()} method may\n     * be called on the result:\n     *\n     * \u003cblockquote\u003e\n     *  {@code Integer.toHexString(n).toUpperCase()}\n     * \u003c/blockquote\u003e\n     *\n     * @apiNote\n     * The {@link java.util.HexFormat} class provides formatting and parsing\n     * of byte arrays and primitives to return a string or adding to an {@link Appendable}.\n     * {@code HexFormat} formats and parses uppercase or lowercase hexadecimal characters,\n     * with leading zeros and for byte arrays includes for each byte\n     * a delimiter, prefix, and suffix.\n     *\n     * @param   i   an integer to be converted to a string.\n     * @return  the string representation of the unsigned integer value\n     *          represented by the argument in hexadecimal (base\u0026nbsp;16).\n     * @see java.util.HexFormat\n     * @see #parseUnsignedInt(String, int)\n     * @see #toUnsignedString(int, int)\n     * @since   1.0.2\n     */\n    public static String toHexString(int i) {\n        return toUnsignedString0(i, 4);\n    }\n\n    /**\n     * Returns a string representation of the integer argument as an\n     * unsigned integer in base\u0026nbsp;8.\n     *\n     * \u003cp\u003eThe unsigned integer value is the argument plus 2\u003csup\u003e32\u003c/sup\u003e\n     * if the argument is negative; otherwise, it is equal to the\n     * argument.  This value is converted to a string of ASCII digits\n     * in octal (base\u0026nbsp;8) with no extra leading {@code 0}s.\n     *\n     * \u003cp\u003eThe value of the argument can be recovered from the returned\n     * string {@code s} by calling {@link\n     * Integer#parseUnsignedInt(String, int)\n     * Integer.parseUnsignedInt(s, 8)}.\n     *\n     * \u003cp\u003eIf the unsigned magnitude is zero, it is represented by a\n     * single zero character {@code \u00270\u0027} ({@code \u0027\\u005Cu0030\u0027});\n     * otherwise, the first character of the representation of the\n     * unsigned magnitude will not be the zero character. The\n     * following characters are used as octal digits:\n     *\n     * \u003cblockquote\u003e\n     * {@code 01234567}\n     * \u003c/blockquote\u003e\n     *\n     * These are the characters {@code \u0027\\u005Cu0030\u0027} through\n     * {@code \u0027\\u005Cu0037\u0027}.\n     *\n     * @param   i   an integer to be converted to a string.\n     * @return  the string representation of the unsigned integer value\n     *          represented by the argument in octal (base\u0026nbsp;8).\n     * @see #parseUnsignedInt(String, int)\n     * @see #toUnsignedString(int, int)\n     * @since   1.0.2\n     */\n    public static String toOctalString(int i) {\n        return toUnsignedString0(i, 3);\n    }\n\n    /**\n     * Returns a string representation of the integer argument as an\n     * unsigned integer in base\u0026nbsp;2.\n     *\n     * \u003cp\u003eThe unsigned integer value is the argument plus 2\u003csup\u003e32\u003c/sup\u003e\n     * if the argument is negative; otherwise it is equal to the\n     * argument.  This value is converted to a string of ASCII digits\n     * in binary (base\u0026nbsp;2) with no extra leading {@code 0}s.\n     *\n     * \u003cp\u003eThe value of the argument can be recovered from the returned\n     * string {@code s} by calling {@link\n     * Integer#parseUnsignedInt(String, int)\n     * Integer.parseUnsignedInt(s, 2)}.\n     *\n     * \u003cp\u003eIf the unsigned magnitude is zero, it is represented by a\n     * single zero character {@code \u00270\u0027} ({@code \u0027\\u005Cu0030\u0027});\n     * otherwise, the first character of the representation of the\n     * unsigned magnitude will not be the zero character. The\n     * characters {@code \u00270\u0027} ({@code \u0027\\u005Cu0030\u0027}) and {@code\n     * \u00271\u0027} ({@code \u0027\\u005Cu0031\u0027}) are used as binary digits.\n     *\n     * @param   i   an integer to be converted to a string.\n     * @return  the string representation of the unsigned integer value\n     *          represented by the argument in binary (base\u0026nbsp;2).\n     * @see #parseUnsignedInt(String, int)\n     * @see #toUnsignedString(int, int)\n     * @since   1.0.2\n     */\n    public static String toBinaryString(int i) {\n        return toUnsignedString0(i, 1);\n    }\n\n    /**\n     * Convert the integer to an unsigned number.\n     */\n    private static String toUnsignedString0(int val, int shift) {\n        // assert shift \u003e 0 \u0026\u0026 shift \u003c\u003d5 : \"Illegal shift value\";\n        int mag \u003d Integer.SIZE - Integer.numberOfLeadingZeros(val);\n        int chars \u003d Math.max(((mag + (shift - 1)) / shift), 1);\n        if (COMPACT_STRINGS) {\n            byte[] buf \u003d new byte[chars];\n            formatUnsignedInt(val, shift, buf, chars);\n            return new String(buf, LATIN1);\n        } else {\n            byte[] buf \u003d new byte[chars * 2];\n            formatUnsignedIntUTF16(val, shift, buf, chars);\n            return new String(buf, UTF16);\n        }\n    }\n\n    /**\n     * Format an {@code int} (treated as unsigned) into a byte buffer (LATIN1 version). If\n     * {@code len} exceeds the formatted ASCII representation of {@code val},\n     * {@code buf} will be padded with leading zeroes.\n     *\n     * @param val the unsigned int to format\n     * @param shift the log2 of the base to format in (4 for hex, 3 for octal, 1 for binary)\n     * @param buf the byte buffer to write to\n     * @param len the number of characters to write\n     */\n    private static void formatUnsignedInt(int val, int shift, byte[] buf, int len) {\n        int charPos \u003d len;\n        int radix \u003d 1 \u003c\u003c shift;\n        int mask \u003d radix - 1;\n        do {\n            buf[--charPos] \u003d (byte)Integer.digits[val \u0026 mask];\n            val \u003e\u003e\u003e\u003d shift;\n        } while (charPos \u003e 0);\n    }\n\n    /**\n     * Format an {@code int} (treated as unsigned) into a byte buffer (UTF16 version). If\n     * {@code len} exceeds the formatted ASCII representation of {@code val},\n     * {@code buf} will be padded with leading zeroes.\n     *\n     * @param val the unsigned int to format\n     * @param shift the log2 of the base to format in (4 for hex, 3 for octal, 1 for binary)\n     * @param buf the byte buffer to write to\n     * @param len the number of characters to write\n     */\n    private static void formatUnsignedIntUTF16(int val, int shift, byte[] buf, int len) {\n        int charPos \u003d len;\n        int radix \u003d 1 \u003c\u003c shift;\n        int mask \u003d radix - 1;\n        do {\n            StringUTF16.putChar(buf, --charPos, Integer.digits[val \u0026 mask]);\n            val \u003e\u003e\u003e\u003d shift;\n        } while (charPos \u003e 0);\n    }\n\n    static final byte[] DigitTens \u003d {\n        \u00270\u0027, \u00270\u0027, \u00270\u0027, \u00270\u0027, \u00270\u0027, \u00270\u0027, \u00270\u0027, \u00270\u0027, \u00270\u0027, \u00270\u0027,\n        \u00271\u0027, \u00271\u0027, \u00271\u0027, \u00271\u0027, \u00271\u0027, \u00271\u0027, \u00271\u0027, \u00271\u0027, \u00271\u0027, \u00271\u0027,\n        \u00272\u0027, \u00272\u0027, \u00272\u0027, \u00272\u0027, \u00272\u0027, \u00272\u0027, \u00272\u0027, \u00272\u0027, \u00272\u0027, \u00272\u0027,\n        \u00273\u0027, \u00273\u0027, \u00273\u0027, \u00273\u0027, \u00273\u0027, \u00273\u0027, \u00273\u0027, \u00273\u0027, \u00273\u0027, \u00273\u0027,\n        \u00274\u0027, \u00274\u0027, \u00274\u0027, \u00274\u0027, \u00274\u0027, \u00274\u0027, \u00274\u0027, \u00274\u0027, \u00274\u0027, \u00274\u0027,\n        \u00275\u0027, \u00275\u0027, \u00275\u0027, \u00275\u0027, \u00275\u0027, \u00275\u0027, \u00275\u0027, \u00275\u0027, \u00275\u0027, \u00275\u0027,\n        \u00276\u0027, \u00276\u0027, \u00276\u0027, \u00276\u0027, \u00276\u0027, \u00276\u0027, \u00276\u0027, \u00276\u0027, \u00276\u0027, \u00276\u0027,\n        \u00277\u0027, \u00277\u0027, \u00277\u0027, \u00277\u0027, \u00277\u0027, \u00277\u0027, \u00277\u0027, \u00277\u0027, \u00277\u0027, \u00277\u0027,\n        \u00278\u0027, \u00278\u0027, \u00278\u0027, \u00278\u0027, \u00278\u0027, \u00278\u0027, \u00278\u0027, \u00278\u0027, \u00278\u0027, \u00278\u0027,\n        \u00279\u0027, \u00279\u0027, \u00279\u0027, \u00279\u0027, \u00279\u0027, \u00279\u0027, \u00279\u0027, \u00279\u0027, \u00279\u0027, \u00279\u0027,\n        } ;\n\n    static final byte[] DigitOnes \u003d {\n        \u00270\u0027, \u00271\u0027, \u00272\u0027, \u00273\u0027, \u00274\u0027, \u00275\u0027, \u00276\u0027, \u00277\u0027, \u00278\u0027, \u00279\u0027,\n        \u00270\u0027, \u00271\u0027, \u00272\u0027, \u00273\u0027, \u00274\u0027, \u00275\u0027, \u00276\u0027, \u00277\u0027, \u00278\u0027, \u00279\u0027,\n        \u00270\u0027, \u00271\u0027, \u00272\u0027, \u00273\u0027, \u00274\u0027, \u00275\u0027, \u00276\u0027, \u00277\u0027, \u00278\u0027, \u00279\u0027,\n        \u00270\u0027, \u00271\u0027, \u00272\u0027, \u00273\u0027, \u00274\u0027, \u00275\u0027, \u00276\u0027, \u00277\u0027, \u00278\u0027, \u00279\u0027,\n        \u00270\u0027, \u00271\u0027, \u00272\u0027, \u00273\u0027, \u00274\u0027, \u00275\u0027, \u00276\u0027, \u00277\u0027, \u00278\u0027, \u00279\u0027,\n        \u00270\u0027, \u00271\u0027, \u00272\u0027, \u00273\u0027, \u00274\u0027, \u00275\u0027, \u00276\u0027, \u00277\u0027, \u00278\u0027, \u00279\u0027,\n        \u00270\u0027, \u00271\u0027, \u00272\u0027, \u00273\u0027, \u00274\u0027, \u00275\u0027, \u00276\u0027, \u00277\u0027, \u00278\u0027, \u00279\u0027,\n        \u00270\u0027, \u00271\u0027, \u00272\u0027, \u00273\u0027, \u00274\u0027, \u00275\u0027, \u00276\u0027, \u00277\u0027, \u00278\u0027, \u00279\u0027,\n        \u00270\u0027, \u00271\u0027, \u00272\u0027, \u00273\u0027, \u00274\u0027, \u00275\u0027, \u00276\u0027, \u00277\u0027, \u00278\u0027, \u00279\u0027,\n        \u00270\u0027, \u00271\u0027, \u00272\u0027, \u00273\u0027, \u00274\u0027, \u00275\u0027, \u00276\u0027, \u00277\u0027, \u00278\u0027, \u00279\u0027,\n        } ;\n\n\n    /**\n     * Returns a {@code String} object representing the\n     * specified integer. The argument is converted to signed decimal\n     * representation and returned as a string, exactly as if the\n     * argument and radix 10 were given as arguments to the {@link\n     * #toString(int, int)} method.\n     *\n     * @param   i   an integer to be converted.\n     * @return  a string representation of the argument in base\u0026nbsp;10.\n     */\n    @IntrinsicCandidate\n    public static String toString(int i) {\n        int size \u003d stringSize(i);\n        if (COMPACT_STRINGS) {\n            byte[] buf \u003d new byte[size];\n            getChars(i, size, buf);\n            return new String(buf, LATIN1);\n        } else {\n            byte[] buf \u003d new byte[size * 2];\n            StringUTF16.getChars(i, size, buf);\n            return new String(buf, UTF16);\n        }\n    }\n\n    /**\n     * Returns a string representation of the argument as an unsigned\n     * decimal value.\n     *\n     * The argument is converted to unsigned decimal representation\n     * and returned as a string exactly as if the argument and radix\n     * 10 were given as arguments to the {@link #toUnsignedString(int,\n     * int)} method.\n     *\n     * @param   i  an integer to be converted to an unsigned string.\n     * @return  an unsigned string representation of the argument.\n     * @see     #toUnsignedString(int, int)\n     * @since 1.8\n     */\n    public static String toUnsignedString(int i) {\n        return Long.toString(toUnsignedLong(i));\n    }\n\n    /**\n     * Places characters representing the integer i into the\n     * character array buf. The characters are placed into\n     * the buffer backwards starting with the least significant\n     * digit at the specified index (exclusive), and working\n     * backwards from there.\n     *\n     * @implNote This method converts positive inputs into negative\n     * values, to cover the Integer.MIN_VALUE case. Converting otherwise\n     * (negative to positive) will expose -Integer.MIN_VALUE that overflows\n     * integer.\n     *\n     * @param i     value to convert\n     * @param index next index, after the least significant digit\n     * @param buf   target buffer, Latin1-encoded\n     * @return index of the most significant digit or minus sign, if present\n     */\n    static int getChars(int i, int index, byte[] buf) {\n        int q, r;\n        int charPos \u003d index;\n\n        boolean negative \u003d i \u003c 0;\n        if (!negative) {\n            i \u003d -i;\n        }\n\n        // Generate two digits per iteration\n        while (i \u003c\u003d -100) {\n            q \u003d i / 100;\n            r \u003d (q * 100) - i;\n            i \u003d q;\n            buf[--charPos] \u003d DigitOnes[r];\n            buf[--charPos] \u003d DigitTens[r];\n        }\n\n        // We know there are at most two digits left at this point.\n        q \u003d i / 10;\n        r \u003d (q * 10) - i;\n        buf[--charPos] \u003d (byte)(\u00270\u0027 + r);\n\n        // Whatever left is the remaining digit.\n        if (q \u003c 0) {\n            buf[--charPos] \u003d (byte)(\u00270\u0027 - q);\n        }\n\n        if (negative) {\n            buf[--charPos] \u003d (byte)\u0027-\u0027;\n        }\n        return charPos;\n    }\n\n    // Left here for compatibility reasons, see JDK-8143900.\n    static final int [] sizeTable \u003d { 9, 99, 999, 9999, 99999, 999999, 9999999,\n                                      99999999, 999999999, Integer.MAX_VALUE };\n\n    /**\n     * Returns the string representation size for a given int value.\n     *\n     * @param x int value\n     * @return string size\n     *\n     * @implNote There are other ways to compute this: e.g. binary search,\n     * but values are biased heavily towards zero, and therefore linear search\n     * wins. The iteration results are also routinely inlined in the generated\n     * code after loop unrolling.\n     */\n    static int stringSize(int x) {\n        int d \u003d 1;\n        if (x \u003e\u003d 0) {\n            d \u003d 0;\n            x \u003d -x;\n        }\n        int p \u003d -10;\n        for (int i \u003d 1; i \u003c 10; i++) {\n            if (x \u003e p)\n                return i + d;\n            p \u003d 10 * p;\n        }\n        return 10 + d;\n    }\n\n    /**\n     * Parses the string argument as a signed integer in the radix\n     * specified by the second argument. The characters in the string\n     * must all be digits of the specified radix (as determined by\n     * whether {@link java.lang.Character#digit(char, int)} returns a\n     * nonnegative value), except that the first character may be an\n     * ASCII minus sign {@code \u0027-\u0027} ({@code \u0027\\u005Cu002D\u0027}) to\n     * indicate a negative value or an ASCII plus sign {@code \u0027+\u0027}\n     * ({@code \u0027\\u005Cu002B\u0027}) to indicate a positive value. The\n     * resulting integer value is returned.\n     *\n     * \u003cp\u003eAn exception of type {@code NumberFormatException} is\n     * thrown if any of the following situations occurs:\n     * \u003cul\u003e\n     * \u003cli\u003eThe first argument is {@code null} or is a string of\n     * length zero.\n     *\n     * \u003cli\u003eThe radix is either smaller than\n     * {@link java.lang.Character#MIN_RADIX} or\n     * larger than {@link java.lang.Character#MAX_RADIX}.\n     *\n     * \u003cli\u003eAny character of the string is not a digit of the specified\n     * radix, except that the first character may be a minus sign\n     * {@code \u0027-\u0027} ({@code \u0027\\u005Cu002D\u0027}) or plus sign\n     * {@code \u0027+\u0027} ({@code \u0027\\u005Cu002B\u0027}) provided that the\n     * string is longer than length 1.\n     *\n     * \u003cli\u003eThe value represented by the string is not a value of type\n     * {@code int}.\n     * \u003c/ul\u003e\n     *\n     * \u003cp\u003eExamples:\n     * \u003cblockquote\u003e\u003cpre\u003e\n     * parseInt(\"0\", 10) returns 0\n     * parseInt(\"473\", 10) returns 473\n     * parseInt(\"+42\", 10) returns 42\n     * parseInt(\"-0\", 10) returns 0\n     * parseInt(\"-FF\", 16) returns -255\n     * parseInt(\"1100110\", 2) returns 102\n     * parseInt(\"2147483647\", 10) returns 2147483647\n     * parseInt(\"-2147483648\", 10) returns -2147483648\n     * parseInt(\"2147483648\", 10) throws a NumberFormatException\n     * parseInt(\"99\", 8) throws a NumberFormatException\n     * parseInt(\"Kona\", 10) throws a NumberFormatException\n     * parseInt(\"Kona\", 27) returns 411787\n     * \u003c/pre\u003e\u003c/blockquote\u003e\n     *\n     * @param      s   the {@code String} containing the integer\n     *                  representation to be parsed\n     * @param      radix   the radix to be used while parsing {@code s}.\n     * @return     the integer represented by the string argument in the\n     *             specified radix.\n     * @throws     NumberFormatException if the {@code String}\n     *             does not contain a parsable {@code int}.\n     */\n    public static int parseInt(String s, int radix)\n                throws NumberFormatException\n    {\n        /*\n         * WARNING: This method may be invoked early during VM initialization\n         * before IntegerCache is initialized. Care must be taken to not use\n         * the valueOf method.\n         */\n\n        if (s \u003d\u003d null) {\n            throw new NumberFormatException(\"Cannot parse null string\");\n        }\n\n        if (radix \u003c Character.MIN_RADIX) {\n            throw new NumberFormatException(\"radix \" + radix +\n                                            \" less than Character.MIN_RADIX\");\n        }\n\n        if (radix \u003e Character.MAX_RADIX) {\n            throw new NumberFormatException(\"radix \" + radix +\n                                            \" greater than Character.MAX_RADIX\");\n        }\n\n        boolean negative \u003d false;\n        int i \u003d 0, len \u003d s.length();\n        int limit \u003d -Integer.MAX_VALUE;\n\n        if (len \u003e 0) {\n            char firstChar \u003d s.charAt(0);\n            if (firstChar \u003c \u00270\u0027) { // Possible leading \"+\" or \"-\"\n                if (firstChar \u003d\u003d \u0027-\u0027) {\n                    negative \u003d true;\n                    limit \u003d Integer.MIN_VALUE;\n                } else if (firstChar !\u003d \u0027+\u0027) {\n                    throw NumberFormatException.forInputString(s, radix);\n                }\n\n                if (len \u003d\u003d 1) { // Cannot have lone \"+\" or \"-\"\n                    throw NumberFormatException.forInputString(s, radix);\n                }\n                i++;\n            }\n            int multmin \u003d limit / radix;\n            int result \u003d 0;\n            while (i \u003c len) {\n                // Accumulating negatively avoids surprises near MAX_VALUE\n                int digit \u003d Character.digit(s.charAt(i++), radix);\n                if (digit \u003c 0 || result \u003c multmin) {\n                    throw NumberFormatException.forInputString(s, radix);\n                }\n                result *\u003d radix;\n                if (result \u003c limit + digit) {\n                    throw NumberFormatException.forInputString(s, radix);\n                }\n                result -\u003d digit;\n            }\n            return negative ? result : -result;\n        } else {\n            throw NumberFormatException.forInputString(s, radix);\n        }\n    }\n\n    /**\n     * Parses the {@link CharSequence} argument as a signed {@code int} in the\n     * specified {@code radix}, beginning at the specified {@code beginIndex}\n     * and extending to {@code endIndex - 1}.\n     *\n     * \u003cp\u003eThe method does not take steps to guard against the\n     * {@code CharSequence} being mutated while parsing.\n     *\n     * @param      s   the {@code CharSequence} containing the {@code int}\n     *                  representation to be parsed\n     * @param      beginIndex   the beginning index, inclusive.\n     * @param      endIndex     the ending index, exclusive.\n     * @param      radix   the radix to be used while parsing {@code s}.\n     * @return     the signed {@code int} represented by the subsequence in\n     *             the specified radix.\n     * @throws     NullPointerException  if {@code s} is null.\n     * @throws     IndexOutOfBoundsException  if {@code beginIndex} is\n     *             negative, or if {@code beginIndex} is greater than\n     *             {@code endIndex} or if {@code endIndex} is greater than\n     *             {@code s.length()}.\n     * @throws     NumberFormatException  if the {@code CharSequence} does not\n     *             contain a parsable {@code int} in the specified\n     *             {@code radix}, or if {@code radix} is either smaller than\n     *             {@link java.lang.Character#MIN_RADIX} or larger than\n     *             {@link java.lang.Character#MAX_RADIX}.\n     * @since  9\n     */\n    public static int parseInt(CharSequence s, int beginIndex, int endIndex, int radix)\n                throws NumberFormatException {\n        Objects.requireNonNull(s);\n\n        if (beginIndex \u003c 0 || beginIndex \u003e endIndex || endIndex \u003e s.length()) {\n            throw new IndexOutOfBoundsException();\n        }\n        if (radix \u003c Character.MIN_RADIX) {\n            throw new NumberFormatException(\"radix \" + radix +\n                                            \" less than Character.MIN_RADIX\");\n        }\n        if (radix \u003e Character.MAX_RADIX) {\n            throw new NumberFormatException(\"radix \" + radix +\n                                            \" greater than Character.MAX_RADIX\");\n        }\n\n        boolean negative \u003d false;\n        int i \u003d beginIndex;\n        int limit \u003d -Integer.MAX_VALUE;\n\n        if (i \u003c endIndex) {\n            char firstChar \u003d s.charAt(i);\n            if (firstChar \u003c \u00270\u0027) { // Possible leading \"+\" or \"-\"\n                if (firstChar \u003d\u003d \u0027-\u0027) {\n                    negative \u003d true;\n                    limit \u003d Integer.MIN_VALUE;\n                } else if (firstChar !\u003d \u0027+\u0027) {\n                    throw NumberFormatException.forCharSequence(s, beginIndex,\n                            endIndex, i);\n                }\n                i++;\n                if (i \u003d\u003d endIndex) { // Cannot have lone \"+\" or \"-\"\n                    throw NumberFormatException.forCharSequence(s, beginIndex,\n                            endIndex, i);\n                }\n            }\n            int multmin \u003d limit / radix;\n            int result \u003d 0;\n            while (i \u003c endIndex) {\n                // Accumulating negatively avoids surprises near MAX_VALUE\n                int digit \u003d Character.digit(s.charAt(i), radix);\n                if (digit \u003c 0 || result \u003c multmin) {\n                    throw NumberFormatException.forCharSequence(s, beginIndex,\n                            endIndex, i);\n                }\n                result *\u003d radix;\n                if (result \u003c limit + digit) {\n                    throw NumberFormatException.forCharSequence(s, beginIndex,\n                            endIndex, i);\n                }\n                i++;\n                result -\u003d digit;\n            }\n            return negative ? result : -result;\n        } else {\n            throw NumberFormatException.forInputString(\"\", radix);\n        }\n    }\n\n    /**\n     * Parses the string argument as a signed decimal integer. The\n     * characters in the string must all be decimal digits, except\n     * that the first character may be an ASCII minus sign {@code \u0027-\u0027}\n     * ({@code \u0027\\u005Cu002D\u0027}) to indicate a negative value or an\n     * ASCII plus sign {@code \u0027+\u0027} ({@code \u0027\\u005Cu002B\u0027}) to\n     * indicate a positive value. The resulting integer value is\n     * returned, exactly as if the argument and the radix 10 were\n     * given as arguments to the {@link #parseInt(java.lang.String,\n     * int)} method.\n     *\n     * @param s    a {@code String} containing the {@code int}\n     *             representation to be parsed\n     * @return     the integer value represented by the argument in decimal.\n     * @throws     NumberFormatException  if the string does not contain a\n     *               parsable integer.\n     */\n    public static int parseInt(String s) throws NumberFormatException {\n        return parseInt(s,10);\n    }\n\n    /**\n     * Parses the string argument as an unsigned integer in the radix\n     * specified by the second argument.  An unsigned integer maps the\n     * values usually associated with negative numbers to positive\n     * numbers larger than {@code MAX_VALUE}.\n     *\n     * The characters in the string must all be digits of the\n     * specified radix (as determined by whether {@link\n     * java.lang.Character#digit(char, int)} returns a nonnegative\n     * value), except that the first character may be an ASCII plus\n     * sign {@code \u0027+\u0027} ({@code \u0027\\u005Cu002B\u0027}). The resulting\n     * integer value is returned.\n     *\n     * \u003cp\u003eAn exception of type {@code NumberFormatException} is\n     * thrown if any of the following situations occurs:\n     * \u003cul\u003e\n     * \u003cli\u003eThe first argument is {@code null} or is a string of\n     * length zero.\n     *\n     * \u003cli\u003eThe radix is either smaller than\n     * {@link java.lang.Character#MIN_RADIX} or\n     * larger than {@link java.lang.Character#MAX_RADIX}.\n     *\n     * \u003cli\u003eAny character of the string is not a digit of the specified\n     * radix, except that the first character may be a plus sign\n     * {@code \u0027+\u0027} ({@code \u0027\\u005Cu002B\u0027}) provided that the\n     * string is longer than length 1.\n     *\n     * \u003cli\u003eThe value represented by the string is larger than the\n     * largest unsigned {@code int}, 2\u003csup\u003e32\u003c/sup\u003e-1.\n     *\n     * \u003c/ul\u003e\n     *\n     *\n     * @param      s   the {@code String} containing the unsigned integer\n     *                  representation to be parsed\n     * @param      radix   the radix to be used while parsing {@code s}.\n     * @return     the integer represented by the string argument in the\n     *             specified radix.\n     * @throws     NumberFormatException if the {@code String}\n     *             does not contain a parsable {@code int}.\n     * @since 1.8\n     */\n    public static int parseUnsignedInt(String s, int radix)\n                throws NumberFormatException {\n        if (s \u003d\u003d null)  {\n            throw new NumberFormatException(\"Cannot parse null string\");\n        }\n\n        int len \u003d s.length();\n        if (len \u003e 0) {\n            char firstChar \u003d s.charAt(0);\n            if (firstChar \u003d\u003d \u0027-\u0027) {\n                throw new\n                    NumberFormatException(String.format(\"Illegal leading minus sign \" +\n                                                       \"on unsigned string %s.\", s));\n            } else {\n                if (len \u003c\u003d 5 || // Integer.MAX_VALUE in Character.MAX_RADIX is 6 digits\n                    (radix \u003d\u003d 10 \u0026\u0026 len \u003c\u003d 9) ) { // Integer.MAX_VALUE in base 10 is 10 digits\n                    return parseInt(s, radix);\n                } else {\n                    long ell \u003d Long.parseLong(s, radix);\n                    if ((ell \u0026 0xffff_ffff_0000_0000L) \u003d\u003d 0) {\n                        return (int) ell;\n                    } else {\n                        throw new\n                            NumberFormatException(String.format(\"String value %s exceeds \" +\n                                                                \"range of unsigned int.\", s));\n                    }\n                }\n            }\n        } else {\n            throw NumberFormatException.forInputString(s, radix);\n        }\n    }\n\n    /**\n     * Parses the {@link CharSequence} argument as an unsigned {@code int} in\n     * the specified {@code radix}, beginning at the specified\n     * {@code beginIndex} and extending to {@code endIndex - 1}.\n     *\n     * \u003cp\u003eThe method does not take steps to guard against the\n     * {@code CharSequence} being mutated while parsing.\n     *\n     * @param      s   the {@code CharSequence} containing the unsigned\n     *                 {@code int} representation to be parsed\n     * @param      beginIndex   the beginning index, inclusive.\n     * @param      endIndex     the ending index, exclusive.\n     * @param      radix   the radix to be used while parsing {@code s}.\n     * @return     the unsigned {@code int} represented by the subsequence in\n     *             the specified radix.\n     * @throws     NullPointerException  if {@code s} is null.\n     * @throws     IndexOutOfBoundsException  if {@code beginIndex} is\n     *             negative, or if {@code beginIndex} is greater than\n     *             {@code endIndex} or if {@code endIndex} is greater than\n     *             {@code s.length()}.\n     * @throws     NumberFormatException  if the {@code CharSequence} does not\n     *             contain a parsable unsigned {@code int} in the specified\n     *             {@code radix}, or if {@code radix} is either smaller than\n     *             {@link java.lang.Character#MIN_RADIX} or larger than\n     *             {@link java.lang.Character#MAX_RADIX}.\n     * @since  9\n     */\n    public static int parseUnsignedInt(CharSequence s, int beginIndex, int endIndex, int radix)\n                throws NumberFormatException {\n        Objects.requireNonNull(s);\n\n        if (beginIndex \u003c 0 || beginIndex \u003e endIndex || endIndex \u003e s.length()) {\n            throw new IndexOutOfBoundsException();\n        }\n        int start \u003d beginIndex, len \u003d endIndex - beginIndex;\n\n        if (len \u003e 0) {\n            char firstChar \u003d s.charAt(start);\n            if (firstChar \u003d\u003d \u0027-\u0027) {\n                throw new\n                    NumberFormatException(String.format(\"Illegal leading minus sign \" +\n                                                       \"on unsigned string %s.\", s));\n            } else {\n                if (len \u003c\u003d 5 || // Integer.MAX_VALUE in Character.MAX_RADIX is 6 digits\n                        (radix \u003d\u003d 10 \u0026\u0026 len \u003c\u003d 9)) { // Integer.MAX_VALUE in base 10 is 10 digits\n                    return parseInt(s, start, start + len, radix);\n                } else {\n                    long ell \u003d Long.parseLong(s, start, start + len, radix);\n                    if ((ell \u0026 0xffff_ffff_0000_0000L) \u003d\u003d 0) {\n                        return (int) ell;\n                    } else {\n                        throw new\n                            NumberFormatException(String.format(\"String value %s exceeds \" +\n                                                                \"range of unsigned int.\", s));\n                    }\n                }\n            }\n        } else {\n            throw new NumberFormatException(\"\");\n        }\n    }\n\n    /**\n     * Parses the string argument as an unsigned decimal integer. The\n     * characters in the string must all be decimal digits, except\n     * that the first character may be an ASCII plus sign {@code\n     * \u0027+\u0027} ({@code \u0027\\u005Cu002B\u0027}). The resulting integer value\n     * is returned, exactly as if the argument and the radix 10 were\n     * given as arguments to the {@link\n     * #parseUnsignedInt(java.lang.String, int)} method.\n     *\n     * @param s   a {@code String} containing the unsigned {@code int}\n     *            representation to be parsed\n     * @return    the unsigned integer value represented by the argument in decimal.\n     * @throws    NumberFormatException  if the string does not contain a\n     *            parsable unsigned integer.\n     * @since 1.8\n     */\n    public static int parseUnsignedInt(String s) throws NumberFormatException {\n        return parseUnsignedInt(s, 10);\n    }\n\n    /**\n     * Returns an {@code Integer} object holding the value\n     * extracted from the specified {@code String} when parsed\n     * with the radix given by the second argument. The first argument\n     * is interpreted as representing a signed integer in the radix\n     * specified by the second argument, exactly as if the arguments\n     * were given to the {@link #parseInt(java.lang.String, int)}\n     * method. The result is an {@code Integer} object that\n     * represents the integer value specified by the string.\n     *\n     * \u003cp\u003eIn other words, this method returns an {@code Integer}\n     * object equal to the value of:\n     *\n     * \u003cblockquote\u003e\n     *  {@code new Integer(Integer.parseInt(s, radix))}\n     * \u003c/blockquote\u003e\n     *\n     * @param      s   the string to be parsed.\n     * @param      radix the radix to be used in interpreting {@code s}\n     * @return     an {@code Integer} object holding the value\n     *             represented by the string argument in the specified\n     *             radix.\n     * @throws    NumberFormatException if the {@code String}\n     *            does not contain a parsable {@code int}.\n     */\n    public static Integer valueOf(String s, int radix) throws NumberFormatException {\n        return Integer.valueOf(parseInt(s,radix));\n    }\n\n    /**\n     * Returns an {@code Integer} object holding the\n     * value of the specified {@code String}. The argument is\n     * interpreted as representing a signed decimal integer, exactly\n     * as if the argument were given to the {@link\n     * #parseInt(java.lang.String)} method. The result is an\n     * {@code Integer} object that represents the integer value\n     * specified by the string.\n     *\n     * \u003cp\u003eIn other words, this method returns an {@code Integer}\n     * object equal to the value of:\n     *\n     * \u003cblockquote\u003e\n     *  {@code new Integer(Integer.parseInt(s))}\n     * \u003c/blockquote\u003e\n     *\n     * @param      s   the string to be parsed.\n     * @return     an {@code Integer} object holding the value\n     *             represented by the string argument.\n     * @throws     NumberFormatException  if the string cannot be parsed\n     *             as an integer.\n     */\n    public static Integer valueOf(String s) throws NumberFormatException {\n        return Integer.valueOf(parseInt(s, 10));\n    }\n\n    /**\n     * Cache to support the object identity semantics of autoboxing for values between\n     * -128 and 127 (inclusive) as required by JLS.\n     *\n     * The cache is initialized on first usage.  The size of the cache\n     * may be controlled by the {@code -XX:AutoBoxCacheMax\u003d\u003csize\u003e} option.\n     * During VM initialization, java.lang.Integer.IntegerCache.high property\n     * may be set and saved in the private system properties in the\n     * jdk.internal.misc.VM class.\n     *\n     * WARNING: The cache is archived with CDS and reloaded from the shared\n     * archive at runtime. The archived cache (Integer[]) and Integer objects\n     * reside in the closed archive heap regions. Care should be taken when\n     * changing the implementation and the cache array should not be assigned\n     * with new Integer object(s) after initialization.\n     */\n\n    private static class IntegerCache {\n        static final int low \u003d -128;\n        static final int high;\n        static final Integer[] cache;\n        static Integer[] archivedCache;\n\n        static {\n            // high value may be configured by property\n            int h \u003d 127;\n            String integerCacheHighPropValue \u003d\n                VM.getSavedProperty(\"java.lang.Integer.IntegerCache.high\");\n            if (integerCacheHighPropValue !\u003d null) {\n                try {\n                    h \u003d Math.max(parseInt(integerCacheHighPropValue), 127);\n                    // Maximum array size is Integer.MAX_VALUE\n                    h \u003d Math.min(h, Integer.MAX_VALUE - (-low) -1);\n                } catch( NumberFormatException nfe) {\n                    // If the property cannot be parsed into an int, ignore it.\n                }\n            }\n            high \u003d h;\n\n            // Load IntegerCache.archivedCache from archive, if possible\n            CDS.initializeFromArchive(IntegerCache.class);\n            int size \u003d (high - low) + 1;\n\n            // Use the archived cache if it exists and is large enough\n            if (archivedCache \u003d\u003d null || size \u003e archivedCache.length) {\n                Integer[] c \u003d new Integer[size];\n                int j \u003d low;\n                for(int i \u003d 0; i \u003c c.length; i++) {\n                    c[i] \u003d new Integer(j++);\n                }\n                archivedCache \u003d c;\n            }\n            cache \u003d archivedCache;\n            // range [-128, 127] must be interned (JLS7 5.1.7)\n            assert IntegerCache.high \u003e\u003d 127;\n        }\n\n        private IntegerCache() {}\n    }\n\n    /**\n     * Returns an {@code Integer} instance representing the specified\n     * {@code int} value.  If a new {@code Integer} instance is not\n     * required, this method should generally be used in preference to\n     * the constructor {@link #Integer(int)}, as this method is likely\n     * to yield significantly better space and time performance by\n     * caching frequently requested values.\n     *\n     * This method will always cache values in the range -128 to 127,\n     * inclusive, and may cache other values outside of this range.\n     *\n     * @param  i an {@code int} value.\n     * @return an {@code Integer} instance representing {@code i}.\n     * @since  1.5\n     */\n    @IntrinsicCandidate\n    public static Integer valueOf(int i) {\n        if (i \u003e\u003d IntegerCache.low \u0026\u0026 i \u003c\u003d IntegerCache.high)\n            return IntegerCache.cache[i + (-IntegerCache.low)];\n        return new Integer(i);\n    }\n\n    /**\n     * The value of the {@code Integer}.\n     *\n     * @serial\n     */\n    private final int value;\n\n    /**\n     * Constructs a newly allocated {@code Integer} object that\n     * represents the specified {@code int} value.\n     *\n     * @param   value   the value to be represented by the\n     *                  {@code Integer} object.\n     *\n     * @deprecated\n     * It is rarely appropriate to use this constructor. The static factory\n     * {@link #valueOf(int)} is generally a better choice, as it is\n     * likely to yield significantly better space and time performance.\n     */\n    @Deprecated(since\u003d\"9\", forRemoval \u003d true)\n    public Integer(int value) {\n        this.value \u003d value;\n    }\n\n    /**\n     * Constructs a newly allocated {@code Integer} object that\n     * represents the {@code int} value indicated by the\n     * {@code String} parameter. The string is converted to an\n     * {@code int} value in exactly the manner used by the\n     * {@code parseInt} method for radix 10.\n     *\n     * @param   s   the {@code String} to be converted to an {@code Integer}.\n     * @throws      NumberFormatException if the {@code String} does not\n     *              contain a parsable integer.\n     *\n     * @deprecated\n     * It is rarely appropriate to use this constructor.\n     * Use {@link #parseInt(String)} to convert a string to a\n     * {@code int} primitive, or use {@link #valueOf(String)}\n     * to convert a string to an {@code Integer} object.\n     */\n    @Deprecated(since\u003d\"9\", forRemoval \u003d true)\n    public Integer(String s) throws NumberFormatException {\n        this.value \u003d parseInt(s, 10);\n    }\n\n    /**\n     * Returns the value of this {@code Integer} as a {@code byte}\n     * after a narrowing primitive conversion.\n     * @jls 5.1.3 Narrowing Primitive Conversion\n     */\n    public byte byteValue() {\n        return (byte)value;\n    }\n\n    /**\n     * Returns the value of this {@code Integer} as a {@code short}\n     * after a narrowing primitive conversion.\n     * @jls 5.1.3 Narrowing Primitive Conversion\n     */\n    public short shortValue() {\n        return (short)value;\n    }\n\n    /**\n     * Returns the value of this {@code Integer} as an\n     * {@code int}.\n     */\n    @IntrinsicCandidate\n    public int intValue() {\n        return value;\n    }\n\n    /**\n     * Returns the value of this {@code Integer} as a {@code long}\n     * after a widening primitive conversion.\n     * @jls 5.1.2 Widening Primitive Conversion\n     * @see Integer#toUnsignedLong(int)\n     */\n    public long longValue() {\n        return (long)value;\n    }\n\n    /**\n     * Returns the value of this {@code Integer} as a {@code float}\n     * after a widening primitive conversion.\n     * @jls 5.1.2 Widening Primitive Conversion\n     */\n    public float floatValue() {\n        return (float)value;\n    }\n\n    /**\n     * Returns the value of this {@code Integer} as a {@code double}\n     * after a widening primitive conversion.\n     * @jls 5.1.2 Widening Primitive Conversion\n     */\n    public double doubleValue() {\n        return (double)value;\n    }\n\n    /**\n     * Returns a {@code String} object representing this\n     * {@code Integer}\u0027s value. The value is converted to signed\n     * decimal representation and returned as a string, exactly as if\n     * the integer value were given as an argument to the {@link\n     * java.lang.Integer#toString(int)} method.\n     *\n     * @return  a string representation of the value of this object in\n     *          base\u0026nbsp;10.\n     */\n    public String toString() {\n        return toString(value);\n    }\n\n    /**\n     * Returns a hash code for this {@code Integer}.\n     *\n     * @return  a hash code value for this object, equal to the\n     *          primitive {@code int} value represented by this\n     *          {@code Integer} object.\n     */\n    @Override\n    public int hashCode() {\n        return Integer.hashCode(value);\n    }\n\n    /**\n     * Returns a hash code for an {@code int} value; compatible with\n     * {@code Integer.hashCode()}.\n     *\n     * @param value the value to hash\n     * @since 1.8\n     *\n     * @return a hash code value for an {@code int} value.\n     */\n    public static int hashCode(int value) {\n        return value;\n    }\n\n    /**\n     * Compares this object to the specified object.  The result is\n     * {@code true} if and only if the argument is not\n     * {@code null} and is an {@code Integer} object that\n     * contains the same {@code int} value as this object.\n     *\n     * @param   obj   the object to compare with.\n     * @return  {@code true} if the objects are the same;\n     *          {@code false} otherwise.\n     */\n    public boolean equals(Object obj) {\n        if (obj instanceof Integer) {\n            return value \u003d\u003d ((Integer)obj).intValue();\n        }\n        return false;\n    }\n\n    /**\n     * Determines the integer value of the system property with the\n     * specified name.\n     *\n     * \u003cp\u003eThe first argument is treated as the name of a system\n     * property.  System properties are accessible through the {@link\n     * java.lang.System#getProperty(java.lang.String)} method. The\n     * string value of this property is then interpreted as an integer\n     * value using the grammar supported by {@link Integer#decode decode} and\n     * an {@code Integer} object representing this value is returned.\n     *\n     * \u003cp\u003eIf there is no property with the specified name, if the\n     * specified name is empty or {@code null}, or if the property\n     * does not have the correct numeric format, then {@code null} is\n     * returned.\n     *\n     * \u003cp\u003eIn other words, this method returns an {@code Integer}\n     * object equal to the value of:\n     *\n     * \u003cblockquote\u003e\n     *  {@code getInteger(nm, null)}\n     * \u003c/blockquote\u003e\n     *\n     * @param   nm   property name.\n     * @return  the {@code Integer} value of the property.\n     * @throws  SecurityException for the same reasons as\n     *          {@link System#getProperty(String) System.getProperty}\n     * @see     java.lang.System#getProperty(java.lang.String)\n     * @see     java.lang.System#getProperty(java.lang.String, java.lang.String)\n     */\n    public static Integer getInteger(String nm) {\n        return getInteger(nm, null);\n    }\n\n    /**\n     * Determines the integer value of the system property with the\n     * specified name.\n     *\n     * \u003cp\u003eThe first argument is treated as the name of a system\n     * property.  System properties are accessible through the {@link\n     * java.lang.System#getProperty(java.lang.String)} method. The\n     * string value of this property is then interpreted as an integer\n     * value using the grammar supported by {@link Integer#decode decode} and\n     * an {@code Integer} object representing this value is returned.\n     *\n     * \u003cp\u003eThe second argument is the default value. An {@code Integer} object\n     * that represents the value of the second argument is returned if there\n     * is no property of the specified name, if the property does not have\n     * the correct numeric format, or if the specified name is empty or\n     * {@code null}.\n     *\n     * \u003cp\u003eIn other words, this method returns an {@code Integer} object\n     * equal to the value of:\n     *\n     * \u003cblockquote\u003e\n     *  {@code getInteger(nm, new Integer(val))}\n     * \u003c/blockquote\u003e\n     *\n     * but in practice it may be implemented in a manner such as:\n     *\n     * \u003cblockquote\u003e\u003cpre\u003e\n     * Integer result \u003d getInteger(nm, null);\n     * return (result \u003d\u003d null) ? new Integer(val) : result;\n     * \u003c/pre\u003e\u003c/blockquote\u003e\n     *\n     * to avoid the unnecessary allocation of an {@code Integer}\n     * object when the default value is not needed.\n     *\n     * @param   nm   property name.\n     * @param   val   default value.\n     * @return  the {@code Integer} value of the property.\n     * @throws  SecurityException for the same reasons as\n     *          {@link System#getProperty(String) System.getProperty}\n     * @see     java.lang.System#getProperty(java.lang.String)\n     * @see     java.lang.System#getProperty(java.lang.String, java.lang.String)\n     */\n    public static Integer getInteger(String nm, int val) {\n        Integer result \u003d getInteger(nm, null);\n        return (result \u003d\u003d null) ? Integer.valueOf(val) : result;\n    }\n\n    /**\n     * Returns the integer value of the system property with the\n     * specified name.  The first argument is treated as the name of a\n     * system property.  System properties are accessible through the\n     * {@link java.lang.System#getProperty(java.lang.String)} method.\n     * The string value of this property is then interpreted as an\n     * integer value, as per the {@link Integer#decode decode} method,\n     * and an {@code Integer} object representing this value is\n     * returned; in summary:\n     *\n     * \u003cul\u003e\u003cli\u003eIf the property value begins with the two ASCII characters\n     *         {@code 0x} or the ASCII character {@code #}, not\n     *      followed by a minus sign, then the rest of it is parsed as a\n     *      hexadecimal integer exactly as by the method\n     *      {@link #valueOf(java.lang.String, int)} with radix 16.\n     * \u003cli\u003eIf the property value begins with the ASCII character\n     *     {@code 0} followed by another character, it is parsed as an\n     *     octal integer exactly as by the method\n     *     {@link #valueOf(java.lang.String, int)} with radix 8.\n     * \u003cli\u003eOtherwise, the property value is parsed as a decimal integer\n     * exactly as by the method {@link #valueOf(java.lang.String, int)}\n     * with radix 10.\n     * \u003c/ul\u003e\n     *\n     * \u003cp\u003eThe second argument is the default value. The default value is\n     * returned if there is no property of the specified name, if the\n     * property does not have the correct numeric format, or if the\n     * specified name is empty or {@code null}.\n     *\n     * @param   nm   property name.\n     * @param   val   default value.\n     * @return  the {@code Integer} value of the property.\n     * @throws  SecurityException for the same reasons as\n     *          {@link System#getProperty(String) System.getProperty}\n     * @see     System#getProperty(java.lang.String)\n     * @see     System#getProperty(java.lang.String, java.lang.String)\n     */\n    public static Integer getInteger(String nm, Integer val) {\n        String v \u003d null;\n        try {\n            v \u003d System.getProperty(nm);\n        } catch (IllegalArgumentException | NullPointerException e) {\n        }\n        if (v !\u003d null) {\n            try {\n                return Integer.decode(v);\n            } catch (NumberFormatException e) {\n            }\n        }\n        return val;\n    }\n\n    /**\n     * Decodes a {@code String} into an {@code Integer}.\n     * Accepts decimal, hexadecimal, and octal numbers given\n     * by the following grammar:\n     *\n     * \u003cblockquote\u003e\n     * \u003cdl\u003e\n     * \u003cdt\u003e\u003ci\u003eDecodableString:\u003c/i\u003e\n     * \u003cdd\u003e\u003ci\u003eSign\u003csub\u003eopt\u003c/sub\u003e DecimalNumeral\u003c/i\u003e\n     * \u003cdd\u003e\u003ci\u003eSign\u003csub\u003eopt\u003c/sub\u003e\u003c/i\u003e {@code 0x} \u003ci\u003eHexDigits\u003c/i\u003e\n     * \u003cdd\u003e\u003ci\u003eSign\u003csub\u003eopt\u003c/sub\u003e\u003c/i\u003e {@code 0X} \u003ci\u003eHexDigits\u003c/i\u003e\n     * \u003cdd\u003e\u003ci\u003eSign\u003csub\u003eopt\u003c/sub\u003e\u003c/i\u003e {@code #} \u003ci\u003eHexDigits\u003c/i\u003e\n     * \u003cdd\u003e\u003ci\u003eSign\u003csub\u003eopt\u003c/sub\u003e\u003c/i\u003e {@code 0} \u003ci\u003eOctalDigits\u003c/i\u003e\n     *\n     * \u003cdt\u003e\u003ci\u003eSign:\u003c/i\u003e\n     * \u003cdd\u003e{@code -}\n     * \u003cdd\u003e{@code +}\n     * \u003c/dl\u003e\n     * \u003c/blockquote\u003e\n     *\n     * \u003ci\u003eDecimalNumeral\u003c/i\u003e, \u003ci\u003eHexDigits\u003c/i\u003e, and \u003ci\u003eOctalDigits\u003c/i\u003e\n     * are as defined in section {@jls 3.10.1} of\n     * \u003ccite\u003eThe Java Language Specification\u003c/cite\u003e,\n     * except that underscores are not accepted between digits.\n     *\n     * \u003cp\u003eThe sequence of characters following an optional\n     * sign and/or radix specifier (\"{@code 0x}\", \"{@code 0X}\",\n     * \"{@code #}\", or leading zero) is parsed as by the {@code\n     * Integer.parseInt} method with the indicated radix (10, 16, or\n     * 8).  This sequence of characters must represent a positive\n     * value or a {@link NumberFormatException} will be thrown.  The\n     * result is negated if first character of the specified {@code\n     * String} is the minus sign.  No whitespace characters are\n     * permitted in the {@code String}.\n     *\n     * @param     nm the {@code String} to decode.\n     * @return    an {@code Integer} object holding the {@code int}\n     *             value represented by {@code nm}\n     * @throws    NumberFormatException  if the {@code String} does not\n     *            contain a parsable integer.\n     * @see java.lang.Integer#parseInt(java.lang.String, int)\n     */\n    public static Integer decode(String nm) throws NumberFormatException {\n        int radix \u003d 10;\n        int index \u003d 0;\n        boolean negative \u003d false;\n        Integer result;\n\n        if (nm.isEmpty())\n            throw new NumberFormatException(\"Zero length string\");\n        char firstChar \u003d nm.charAt(0);\n        // Handle sign, if present\n        if (firstChar \u003d\u003d \u0027-\u0027) {\n            negative \u003d true;\n            index++;\n        } else if (firstChar \u003d\u003d \u0027+\u0027)\n            index++;\n\n        // Handle radix specifier, if present\n        if (nm.startsWith(\"0x\", index) || nm.startsWith(\"0X\", index)) {\n            index +\u003d 2;\n            radix \u003d 16;\n        }\n        else if (nm.startsWith(\"#\", index)) {\n            index ++;\n            radix \u003d 16;\n        }\n        else if (nm.startsWith(\"0\", index) \u0026\u0026 nm.length() \u003e 1 + index) {\n            index ++;\n            radix \u003d 8;\n        }\n\n        if (nm.startsWith(\"-\", index) || nm.startsWith(\"+\", index))\n            throw new NumberFormatException(\"Sign character in wrong position\");\n\n        try {\n            result \u003d Integer.valueOf(nm.substring(index), radix);\n            result \u003d negative ? Integer.valueOf(-result.intValue()) : result;\n        } catch (NumberFormatException e) {\n            // If number is Integer.MIN_VALUE, we\u0027ll end up here. The next line\n            // handles this case, and causes any genuine format error to be\n            // rethrown.\n            String constant \u003d negative ? (\"-\" + nm.substring(index))\n                                       : nm.substring(index);\n            result \u003d Integer.valueOf(constant, radix);\n        }\n        return result;\n    }\n\n    /**\n     * Compares two {@code Integer} objects numerically.\n     *\n     * @param   anotherInteger   the {@code Integer} to be compared.\n     * @return  the value {@code 0} if this {@code Integer} is\n     *          equal to the argument {@code Integer}; a value less than\n     *          {@code 0} if this {@code Integer} is numerically less\n     *          than the argument {@code Integer}; and a value greater\n     *          than {@code 0} if this {@code Integer} is numerically\n     *           greater than the argument {@code Integer} (signed\n     *           comparison).\n     * @since   1.2\n     */\n    public int compareTo(Integer anotherInteger) {\n        return compare(this.value, anotherInteger.value);\n    }\n\n    /**\n     * Compares two {@code int} values numerically.\n     * The value returned is identical to what would be returned by:\n     * \u003cpre\u003e\n     *    Integer.valueOf(x).compareTo(Integer.valueOf(y))\n     * \u003c/pre\u003e\n     *\n     * @param  x the first {@code int} to compare\n     * @param  y the second {@code int} to compare\n     * @return the value {@code 0} if {@code x \u003d\u003d y};\n     *         a value less than {@code 0} if {@code x \u003c y}; and\n     *         a value greater than {@code 0} if {@code x \u003e y}\n     * @since 1.7\n     */\n    public static int compare(int x, int y) {\n        return (x \u003c y) ? -1 : ((x \u003d\u003d y) ? 0 : 1);\n    }\n\n    /**\n     * Compares two {@code int} values numerically treating the values\n     * as unsigned.\n     *\n     * @param  x the first {@code int} to compare\n     * @param  y the second {@code int} to compare\n     * @return the value {@code 0} if {@code x \u003d\u003d y}; a value less\n     *         than {@code 0} if {@code x \u003c y} as unsigned values; and\n     *         a value greater than {@code 0} if {@code x \u003e y} as\n     *         unsigned values\n     * @since 1.8\n     */\n    public static int compareUnsigned(int x, int y) {\n        return compare(x + MIN_VALUE, y + MIN_VALUE);\n    }\n\n    /**\n     * Converts the argument to a {@code long} by an unsigned\n     * conversion.  In an unsigned conversion to a {@code long}, the\n     * high-order 32 bits of the {@code long} are zero and the\n     * low-order 32 bits are equal to the bits of the integer\n     * argument.\n     *\n     * Consequently, zero and positive {@code int} values are mapped\n     * to a numerically equal {@code long} value and negative {@code\n     * int} values are mapped to a {@code long} value equal to the\n     * input plus 2\u003csup\u003e32\u003c/sup\u003e.\n     *\n     * @param  x the value to convert to an unsigned {@code long}\n     * @return the argument converted to {@code long} by an unsigned\n     *         conversion\n     * @since 1.8\n     */\n    public static long toUnsignedLong(int x) {\n        return ((long) x) \u0026 0xffffffffL;\n    }\n\n    /**\n     * Returns the unsigned quotient of dividing the first argument by\n     * the second where each argument and the result is interpreted as\n     * an unsigned value.\n     *\n     * \u003cp\u003eNote that in two\u0027s complement arithmetic, the three other\n     * basic arithmetic operations of add, subtract, and multiply are\n     * bit-wise identical if the two operands are regarded as both\n     * being signed or both being unsigned.  Therefore separate {@code\n     * addUnsigned}, etc. methods are not provided.\n     *\n     * @param dividend the value to be divided\n     * @param divisor the value doing the dividing\n     * @return the unsigned quotient of the first argument divided by\n     * the second argument\n     * @see #remainderUnsigned\n     * @since 1.8\n     */\n    public static int divideUnsigned(int dividend, int divisor) {\n        // In lieu of tricky code, for now just use long arithmetic.\n        return (int)(toUnsignedLong(dividend) / toUnsignedLong(divisor));\n    }\n\n    /**\n     * Returns the unsigned remainder from dividing the first argument\n     * by the second where each argument and the result is interpreted\n     * as an unsigned value.\n     *\n     * @param dividend the value to be divided\n     * @param divisor the value doing the dividing\n     * @return the unsigned remainder of the first argument divided by\n     * the second argument\n     * @see #divideUnsigned\n     * @since 1.8\n     */\n    public static int remainderUnsigned(int dividend, int divisor) {\n        // In lieu of tricky code, for now just use long arithmetic.\n        return (int)(toUnsignedLong(dividend) % toUnsignedLong(divisor));\n    }\n\n\n    // Bit twiddling\n\n    /**\n     * The number of bits used to represent an {@code int} value in two\u0027s\n     * complement binary form.\n     *\n     * @since 1.5\n     */\n    @Native public static final int SIZE \u003d 32;\n\n    /**\n     * The number of bytes used to represent an {@code int} value in two\u0027s\n     * complement binary form.\n     *\n     * @since 1.8\n     */\n    public static final int BYTES \u003d SIZE / Byte.SIZE;\n\n    /**\n     * Returns an {@code int} value with at most a single one-bit, in the\n     * position of the highest-order (\"leftmost\") one-bit in the specified\n     * {@code int} value.  Returns zero if the specified value has no\n     * one-bits in its two\u0027s complement binary representation, that is, if it\n     * is equal to zero.\n     *\n     * @param i the value whose highest one bit is to be computed\n     * @return an {@code int} value with a single one-bit, in the position\n     *     of the highest-order one-bit in the specified value, or zero if\n     *     the specified value is itself equal to zero.\n     * @since 1.5\n     */\n    public static int highestOneBit(int i) {\n        return i \u0026 (MIN_VALUE \u003e\u003e\u003e numberOfLeadingZeros(i));\n    }\n\n    /**\n     * Returns an {@code int} value with at most a single one-bit, in the\n     * position of the lowest-order (\"rightmost\") one-bit in the specified\n     * {@code int} value.  Returns zero if the specified value has no\n     * one-bits in its two\u0027s complement binary representation, that is, if it\n     * is equal to zero.\n     *\n     * @param i the value whose lowest one bit is to be computed\n     * @return an {@code int} value with a single one-bit, in the position\n     *     of the lowest-order one-bit in the specified value, or zero if\n     *     the specified value is itself equal to zero.\n     * @since 1.5\n     */\n    public static int lowestOneBit(int i) {\n        // HD, Section 2-1\n        return i \u0026 -i;\n    }\n\n    /**\n     * Returns the number of zero bits preceding the highest-order\n     * (\"leftmost\") one-bit in the two\u0027s complement binary representation\n     * of the specified {@code int} value.  Returns 32 if the\n     * specified value has no one-bits in its two\u0027s complement representation,\n     * in other words if it is equal to zero.\n     *\n     * \u003cp\u003eNote that this method is closely related to the logarithm base 2.\n     * For all positive {@code int} values x:\n     * \u003cul\u003e\n     * \u003cli\u003efloor(log\u003csub\u003e2\u003c/sub\u003e(x)) \u003d {@code 31 - numberOfLeadingZeros(x)}\n     * \u003cli\u003eceil(log\u003csub\u003e2\u003c/sub\u003e(x)) \u003d {@code 32 - numberOfLeadingZeros(x - 1)}\n     * \u003c/ul\u003e\n     *\n     * @param i the value whose number of leading zeros is to be computed\n     * @return the number of zero bits preceding the highest-order\n     *     (\"leftmost\") one-bit in the two\u0027s complement binary representation\n     *     of the specified {@code int} value, or 32 if the value\n     *     is equal to zero.\n     * @since 1.5\n     */\n    @IntrinsicCandidate\n    public static int numberOfLeadingZeros(int i) {\n        // HD, Count leading 0\u0027s\n        if (i \u003c\u003d 0)\n            return i \u003d\u003d 0 ? 32 : 0;\n        int n \u003d 31;\n        if (i \u003e\u003d 1 \u003c\u003c 16) { n -\u003d 16; i \u003e\u003e\u003e\u003d 16; }\n        if (i \u003e\u003d 1 \u003c\u003c  8) { n -\u003d  8; i \u003e\u003e\u003e\u003d  8; }\n        if (i \u003e\u003d 1 \u003c\u003c  4) { n -\u003d  4; i \u003e\u003e\u003e\u003d  4; }\n        if (i \u003e\u003d 1 \u003c\u003c  2) { n -\u003d  2; i \u003e\u003e\u003e\u003d  2; }\n        return n - (i \u003e\u003e\u003e 1);\n    }\n\n    /**\n     * Returns the number of zero bits following the lowest-order (\"rightmost\")\n     * one-bit in the two\u0027s complement binary representation of the specified\n     * {@code int} value.  Returns 32 if the specified value has no\n     * one-bits in its two\u0027s complement representation, in other words if it is\n     * equal to zero.\n     *\n     * @param i the value whose number of trailing zeros is to be computed\n     * @return the number of zero bits following the lowest-order (\"rightmost\")\n     *     one-bit in the two\u0027s complement binary representation of the\n     *     specified {@code int} value, or 32 if the value is equal\n     *     to zero.\n     * @since 1.5\n     */\n    @IntrinsicCandidate\n    public static int numberOfTrailingZeros(int i) {\n        // HD, Count trailing 0\u0027s\n        i \u003d ~i \u0026 (i - 1);\n        if (i \u003c\u003d 0) return i \u0026 32;\n        int n \u003d 1;\n        if (i \u003e 1 \u003c\u003c 16) { n +\u003d 16; i \u003e\u003e\u003e\u003d 16; }\n        if (i \u003e 1 \u003c\u003c  8) { n +\u003d  8; i \u003e\u003e\u003e\u003d  8; }\n        if (i \u003e 1 \u003c\u003c  4) { n +\u003d  4; i \u003e\u003e\u003e\u003d  4; }\n        if (i \u003e 1 \u003c\u003c  2) { n +\u003d  2; i \u003e\u003e\u003e\u003d  2; }\n        return n + (i \u003e\u003e\u003e 1);\n    }\n\n    /**\n     * Returns the number of one-bits in the two\u0027s complement binary\n     * representation of the specified {@code int} value.  This function is\n     * sometimes referred to as the \u003ci\u003epopulation count\u003c/i\u003e.\n     *\n     * @param i the value whose bits are to be counted\n     * @return the number of one-bits in the two\u0027s complement binary\n     *     representation of the specified {@code int} value.\n     * @since 1.5\n     */\n    @IntrinsicCandidate\n    public static int bitCount(int i) {\n        // HD, Figure 5-2\n        i \u003d i - ((i \u003e\u003e\u003e 1) \u0026 0x55555555);\n        i \u003d (i \u0026 0x33333333) + ((i \u003e\u003e\u003e 2) \u0026 0x33333333);\n        i \u003d (i + (i \u003e\u003e\u003e 4)) \u0026 0x0f0f0f0f;\n        i \u003d i + (i \u003e\u003e\u003e 8);\n        i \u003d i + (i \u003e\u003e\u003e 16);\n        return i \u0026 0x3f;\n    }\n\n    /**\n     * Returns the value obtained by rotating the two\u0027s complement binary\n     * representation of the specified {@code int} value left by the\n     * specified number of bits.  (Bits shifted out of the left hand, or\n     * high-order, side reenter on the right, or low-order.)\n     *\n     * \u003cp\u003eNote that left rotation with a negative distance is equivalent to\n     * right rotation: {@code rotateLeft(val, -distance) \u003d\u003d rotateRight(val,\n     * distance)}.  Note also that rotation by any multiple of 32 is a\n     * no-op, so all but the last five bits of the rotation distance can be\n     * ignored, even if the distance is negative: {@code rotateLeft(val,\n     * distance) \u003d\u003d rotateLeft(val, distance \u0026 0x1F)}.\n     *\n     * @param i the value whose bits are to be rotated left\n     * @param distance the number of bit positions to rotate left\n     * @return the value obtained by rotating the two\u0027s complement binary\n     *     representation of the specified {@code int} value left by the\n     *     specified number of bits.\n     * @since 1.5\n     */\n    public static int rotateLeft(int i, int distance) {\n        return (i \u003c\u003c distance) | (i \u003e\u003e\u003e -distance);\n    }\n\n    /**\n     * Returns the value obtained by rotating the two\u0027s complement binary\n     * representation of the specified {@code int} value right by the\n     * specified number of bits.  (Bits shifted out of the right hand, or\n     * low-order, side reenter on the left, or high-order.)\n     *\n     * \u003cp\u003eNote that right rotation with a negative distance is equivalent to\n     * left rotation: {@code rotateRight(val, -distance) \u003d\u003d rotateLeft(val,\n     * distance)}.  Note also that rotation by any multiple of 32 is a\n     * no-op, so all but the last five bits of the rotation distance can be\n     * ignored, even if the distance is negative: {@code rotateRight(val,\n     * distance) \u003d\u003d rotateRight(val, distance \u0026 0x1F)}.\n     *\n     * @param i the value whose bits are to be rotated right\n     * @param distance the number of bit positions to rotate right\n     * @return the value obtained by rotating the two\u0027s complement binary\n     *     representation of the specified {@code int} value right by the\n     *     specified number of bits.\n     * @since 1.5\n     */\n    public static int rotateRight(int i, int distance) {\n        return (i \u003e\u003e\u003e distance) | (i \u003c\u003c -distance);\n    }\n\n    /**\n     * Returns the value obtained by reversing the order of the bits in the\n     * two\u0027s complement binary representation of the specified {@code int}\n     * value.\n     *\n     * @param i the value to be reversed\n     * @return the value obtained by reversing order of the bits in the\n     *     specified {@code int} value.\n     * @since 1.5\n     */\n    public static int reverse(int i) {\n        // HD, Figure 7-1\n        i \u003d (i \u0026 0x55555555) \u003c\u003c 1 | (i \u003e\u003e\u003e 1) \u0026 0x55555555;\n        i \u003d (i \u0026 0x33333333) \u003c\u003c 2 | (i \u003e\u003e\u003e 2) \u0026 0x33333333;\n        i \u003d (i \u0026 0x0f0f0f0f) \u003c\u003c 4 | (i \u003e\u003e\u003e 4) \u0026 0x0f0f0f0f;\n\n        return reverseBytes(i);\n    }\n\n    /**\n     * Returns the signum function of the specified {@code int} value.  (The\n     * return value is -1 if the specified value is negative; 0 if the\n     * specified value is zero; and 1 if the specified value is positive.)\n     *\n     * @param i the value whose signum is to be computed\n     * @return the signum function of the specified {@code int} value.\n     * @since 1.5\n     */\n    public static int signum(int i) {\n        // HD, Section 2-7\n        return (i \u003e\u003e 31) | (-i \u003e\u003e\u003e 31);\n    }\n\n    /**\n     * Returns the value obtained by reversing the order of the bytes in the\n     * two\u0027s complement representation of the specified {@code int} value.\n     *\n     * @param i the value whose bytes are to be reversed\n     * @return the value obtained by reversing the bytes in the specified\n     *     {@code int} value.\n     * @since 1.5\n     */\n    @IntrinsicCandidate\n    public static int reverseBytes(int i) {\n        return (i \u003c\u003c 24)            |\n               ((i \u0026 0xff00) \u003c\u003c 8)  |\n               ((i \u003e\u003e\u003e 8) \u0026 0xff00) |\n               (i \u003e\u003e\u003e 24);\n    }\n\n    /**\n     * Adds two integers together as per the + operator.\n     *\n     * @param a the first operand\n     * @param b the second operand\n     * @return the sum of {@code a} and {@code b}\n     * @see java.util.function.BinaryOperator\n     * @since 1.8\n     */\n    public static int sum(int a, int b) {\n        return a + b;\n    }\n\n    /**\n     * Returns the greater of two {@code int} values\n     * as if by calling {@link Math#max(int, int) Math.max}.\n     *\n     * @param a the first operand\n     * @param b the second operand\n     * @return the greater of {@code a} and {@code b}\n     * @see java.util.function.BinaryOperator\n     * @since 1.8\n     */\n    public static int max(int a, int b) {\n        return Math.max(a, b);\n    }\n\n    /**\n     * Returns the smaller of two {@code int} values\n     * as if by calling {@link Math#min(int, int) Math.min}.\n     *\n     * @param a the first operand\n     * @param b the second operand\n     * @return the smaller of {@code a} and {@code b}\n     * @see java.util.function.BinaryOperator\n     * @since 1.8\n     */\n    public static int min(int a, int b) {\n        return Math.min(a, b);\n    }\n\n    /**\n     * Returns an {@link Optional} containing the nominal descriptor for this\n     * instance, which is the instance itself.\n     *\n     * @return an {@link Optional} describing the {@linkplain Integer} instance\n     * @since 12\n     */\n    @Override\n    public Optional\u003cInteger\u003e describeConstable() {\n        return Optional.of(this);\n    }\n\n    /**\n     * Resolves this instance as a {@link ConstantDesc}, the result of which is\n     * the instance itself.\n     *\n     * @param lookup ignored\n     * @return the {@linkplain Integer} instance\n     * @since 12\n     */\n    @Override\n    public Integer resolveConstantDesc(MethodHandles.Lookup lookup) {\n        return this;\n    }\n\n    /** use serialVersionUID from JDK 1.0.2 for interoperability */\n    @java.io.Serial\n    @Native private static final long serialVersionUID \u003d 1360826667806852920L;\n}\n"
    }
  }
}
java.lang.IllegalArgumentException: Illegal character in opaque part at index 188: jar:file:///C:/Users/Vinicius/AppData/Local/Coursier/cache/arc/https/github.com/adoptium/temurin17-binaries/releases/download/jdk-17%2B35/OpenJDK17-jdk_x64_windows_hotspot_17_35.zip/jdk-17 35/lib/src.zip!/java.base/java/lang/Integer.java
	at java.base/java.net.URI.create(URI.java:906)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:178)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.$anonfun$toAbsolutePath$3(MtagsEnrichments.scala:175)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.withTryDecode$1(MtagsEnrichments.scala:153)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:175)
	at scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:756)
	at scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:753)
	at scala.meta.internal.metals.WorkspaceLspService.didOpen(WorkspaceLspService.scala:388)
	at scala.meta.metals.lsp.DelegatingScalaService.didOpen(DelegatingScalaService.scala:39)
	at jdk.internal.reflect.GeneratedMethodAccessor23.invoke(Unknown Source)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:568)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$recursiveFindRpcMethods$0(GenericEndpoint.java:65)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.notify(GenericEndpoint.java:160)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleNotification(RemoteEndpoint.java:231)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:198)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:185)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:97)
	at org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:114)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:539)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.base/java.lang.Thread.run(Thread.java:833)
Caused by: java.net.URISyntaxException: Illegal character in opaque part at index 188: jar:file:///C:/Users/Vinicius/AppData/Local/Coursier/cache/arc/https/github.com/adoptium/temurin17-binaries/releases/download/jdk-17%2B35/OpenJDK17-jdk_x64_windows_hotspot_17_35.zip/jdk-17 35/lib/src.zip!/java.base/java/lang/Integer.java
	at java.base/java.net.URI$Parser.fail(URI.java:2974)
	at java.base/java.net.URI$Parser.checkChars(URI.java:3145)
	at java.base/java.net.URI$Parser.parse(URI.java:3181)
	at java.base/java.net.URI.<init>(URI.java:623)
	at java.base/java.net.URI.create(URI.java:904)
	... 23 more

jul. 19, 2024 1:03:35 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleNotification
ADVERTÊNCIA: Notification threw an exception: {
  "jsonrpc": "2.0",
  "method": "textDocument/didClose",
  "params": {
    "textDocument": {
      "uri": "jar:file%3A///C%3A/Users/Vinicius/AppData/Local/Coursier/cache/arc/https/github.com/adoptium/temurin17-binaries/releases/download/jdk-17%25252B35/OpenJDK17-jdk_x64_windows_hotspot_17_35.zip/jdk-17%2B35/lib/src.zip%21/java.base/java/lang/Integer.java"
    }
  }
}
java.lang.IllegalArgumentException: Illegal character in opaque part at index 188: jar:file:///C:/Users/Vinicius/AppData/Local/Coursier/cache/arc/https/github.com/adoptium/temurin17-binaries/releases/download/jdk-17%2B35/OpenJDK17-jdk_x64_windows_hotspot_17_35.zip/jdk-17 35/lib/src.zip!/java.base/java/lang/Integer.java
	at java.base/java.net.URI.create(URI.java:906)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:178)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.$anonfun$toAbsolutePath$3(MtagsEnrichments.scala:175)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.withTryDecode$1(MtagsEnrichments.scala:153)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:175)
	at scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:756)
	at scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:753)
	at scala.meta.internal.metals.WorkspaceLspService.didClose(WorkspaceLspService.scala:407)
	at scala.meta.metals.lsp.DelegatingScalaService.didClose(DelegatingScalaService.scala:53)
	at jdk.internal.reflect.GeneratedMethodAccessor26.invoke(Unknown Source)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:568)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$recursiveFindRpcMethods$0(GenericEndpoint.java:65)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.notify(GenericEndpoint.java:160)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleNotification(RemoteEndpoint.java:231)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:198)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:185)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:97)
	at org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:114)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:539)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.base/java.lang.Thread.run(Thread.java:833)
Caused by: java.net.URISyntaxException: Illegal character in opaque part at index 188: jar:file:///C:/Users/Vinicius/AppData/Local/Coursier/cache/arc/https/github.com/adoptium/temurin17-binaries/releases/download/jdk-17%2B35/OpenJDK17-jdk_x64_windows_hotspot_17_35.zip/jdk-17 35/lib/src.zip!/java.base/java/lang/Integer.java
	at java.base/java.net.URI$Parser.fail(URI.java:2974)
	at java.base/java.net.URI$Parser.checkChars(URI.java:3145)
	at java.base/java.net.URI$Parser.parse(URI.java:3181)
	at java.base/java.net.URI.<init>(URI.java:623)
	at java.base/java.net.URI.create(URI.java:904)
	... 23 more

2024.07.19 13:03:35 INFO  Can not organize imports if file has error
2024.07.19 13:03:35 INFO  compiling root (2 scala sources)
2024.07.19 13:03:35 INFO  time: compiled root in 0.21s
2024.07.19 13:03:45 WARN  Using indexes to guess the definition of pure
2024.07.19 13:03:45 WARN  Using indexes to guess the definition of pure
2024.07.19 13:03:45 WARN  Using indexes to guess the definition of pure
jul. 19, 2024 1:03:45 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
ADVERTÊNCIA: Unmatched cancel notification for request id 4824
2024.07.19 13:03:45 WARN  Using indexes to guess the definition of S2
2024.07.19 13:03:46 INFO  compiling root (2 scala sources)
2024.07.19 13:03:46 INFO  time: compiled root in 0.24s
2024.07.19 13:04:17 INFO  Can not organize imports if file has error
2024.07.19 13:04:17 INFO  compiling root (2 scala sources)
2024.07.19 13:04:17 INFO  time: compiled root in 0.23s
2024.07.19 13:04:19 INFO  Can not organize imports if file has error
2024.07.19 13:04:19 INFO  compiling root (2 scala sources)
2024.07.19 13:04:19 INFO  time: compiled root in 0.23s
2024.07.19 13:04:40 INFO  Can not organize imports if file has error
2024.07.19 13:04:40 INFO  compiling root (2 scala sources)
2024.07.19 13:04:40 INFO  time: compiled root in 0.21s
2024.07.19 13:04:41 INFO  Can not organize imports if file has error
2024.07.19 13:04:41 INFO  compiling root (2 scala sources)
2024.07.19 13:04:41 INFO  time: compiled root in 0.28s
jul. 19, 2024 1:04:52 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleNotification
ADVERTÊNCIA: Notification threw an exception: {
  "jsonrpc": "2.0",
  "method": "textDocument/didOpen",
  "params": {
    "textDocument": {
      "uri": "jar:file%3A///C%3A/Users/Vinicius/AppData/Local/Coursier/cache/arc/https/github.com/adoptium/temurin17-binaries/releases/download/jdk-17%25252B35/OpenJDK17-jdk_x64_windows_hotspot_17_35.zip/jdk-17%2B35/lib/src.zip%21/java.base/java/lang/Integer.java",
      "languageId": "java",
      "version": 1,
      "text": "/*\n * Copyright (c) 1994, 2021, Oracle and/or its affiliates. All rights reserved.\n * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n *\n * This code is free software; you can redistribute it and/or modify it\n * under the terms of the GNU General Public License version 2 only, as\n * published by the Free Software Foundation.  Oracle designates this\n * particular file as subject to the \"Classpath\" exception as provided\n * by Oracle in the LICENSE file that accompanied this code.\n *\n * This code is distributed in the hope that it will be useful, but WITHOUT\n * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n * version 2 for more details (a copy is included in the LICENSE file that\n * accompanied this code).\n *\n * You should have received a copy of the GNU General Public License version\n * 2 along with this work; if not, write to the Free Software Foundation,\n * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n *\n * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n * or visit www.oracle.com if you need additional information or have any\n * questions.\n */\n\npackage java.lang;\n\nimport java.lang.annotation.Native;\nimport java.lang.invoke.MethodHandles;\nimport java.lang.constant.Constable;\nimport java.lang.constant.ConstantDesc;\nimport java.util.Objects;\nimport java.util.Optional;\n\nimport jdk.internal.misc.CDS;\nimport jdk.internal.misc.VM;\nimport jdk.internal.vm.annotation.IntrinsicCandidate;\n\nimport static java.lang.String.COMPACT_STRINGS;\nimport static java.lang.String.LATIN1;\nimport static java.lang.String.UTF16;\n\n/**\n * The {@code Integer} class wraps a value of the primitive type\n * {@code int} in an object. An object of type {@code Integer}\n * contains a single field whose type is {@code int}.\n *\n * \u003cp\u003eIn addition, this class provides several methods for converting\n * an {@code int} to a {@code String} and a {@code String} to an\n * {@code int}, as well as other constants and methods useful when\n * dealing with an {@code int}.\n *\n * \u003cp\u003eThis is a \u003ca href\u003d\"{@docRoot}/java.base/java/lang/doc-files/ValueBased.html\"\u003evalue-based\u003c/a\u003e\n * class; programmers should treat instances that are\n * {@linkplain #equals(Object) equal} as interchangeable and should not\n * use instances for synchronization, or unpredictable behavior may\n * occur. For example, in a future release, synchronization may fail.\n *\n * \u003cp\u003eImplementation note: The implementations of the \"bit twiddling\"\n * methods (such as {@link #highestOneBit(int) highestOneBit} and\n * {@link #numberOfTrailingZeros(int) numberOfTrailingZeros}) are\n * based on material from Henry S. Warren, Jr.\u0027s \u003ci\u003eHacker\u0027s\n * Delight\u003c/i\u003e, (Addison Wesley, 2002).\n *\n * @author  Lee Boynton\n * @author  Arthur van Hoff\n * @author  Josh Bloch\n * @author  Joseph D. Darcy\n * @since 1.0\n */\n@jdk.internal.ValueBased\npublic final class Integer extends Number\n        implements Comparable\u003cInteger\u003e, Constable, ConstantDesc {\n    /**\n     * A constant holding the minimum value an {@code int} can\n     * have, -2\u003csup\u003e31\u003c/sup\u003e.\n     */\n    @Native public static final int   MIN_VALUE \u003d 0x80000000;\n\n    /**\n     * A constant holding the maximum value an {@code int} can\n     * have, 2\u003csup\u003e31\u003c/sup\u003e-1.\n     */\n    @Native public static final int   MAX_VALUE \u003d 0x7fffffff;\n\n    /**\n     * The {@code Class} instance representing the primitive type\n     * {@code int}.\n     *\n     * @since   1.1\n     */\n    @SuppressWarnings(\"unchecked\")\n    public static final Class\u003cInteger\u003e  TYPE \u003d (Class\u003cInteger\u003e) Class.getPrimitiveClass(\"int\");\n\n    /**\n     * All possible chars for representing a number as a String\n     */\n    static final char[] digits \u003d {\n        \u00270\u0027 , \u00271\u0027 , \u00272\u0027 , \u00273\u0027 , \u00274\u0027 , \u00275\u0027 ,\n        \u00276\u0027 , \u00277\u0027 , \u00278\u0027 , \u00279\u0027 , \u0027a\u0027 , \u0027b\u0027 ,\n        \u0027c\u0027 , \u0027d\u0027 , \u0027e\u0027 , \u0027f\u0027 , \u0027g\u0027 , \u0027h\u0027 ,\n        \u0027i\u0027 , \u0027j\u0027 , \u0027k\u0027 , \u0027l\u0027 , \u0027m\u0027 , \u0027n\u0027 ,\n        \u0027o\u0027 , \u0027p\u0027 , \u0027q\u0027 , \u0027r\u0027 , \u0027s\u0027 , \u0027t\u0027 ,\n        \u0027u\u0027 , \u0027v\u0027 , \u0027w\u0027 , \u0027x\u0027 , \u0027y\u0027 , \u0027z\u0027\n    };\n\n    /**\n     * Returns a string representation of the first argument in the\n     * radix specified by the second argument.\n     *\n     * \u003cp\u003eIf the radix is smaller than {@code Character.MIN_RADIX}\n     * or larger than {@code Character.MAX_RADIX}, then the radix\n     * {@code 10} is used instead.\n     *\n     * \u003cp\u003eIf the first argument is negative, the first element of the\n     * result is the ASCII minus character {@code \u0027-\u0027}\n     * ({@code \u0027\\u005Cu002D\u0027}). If the first argument is not\n     * negative, no sign character appears in the result.\n     *\n     * \u003cp\u003eThe remaining characters of the result represent the magnitude\n     * of the first argument. If the magnitude is zero, it is\n     * represented by a single zero character {@code \u00270\u0027}\n     * ({@code \u0027\\u005Cu0030\u0027}); otherwise, the first character of\n     * the representation of the magnitude will not be the zero\n     * character.  The following ASCII characters are used as digits:\n     *\n     * \u003cblockquote\u003e\n     *   {@code 0123456789abcdefghijklmnopqrstuvwxyz}\n     * \u003c/blockquote\u003e\n     *\n     * These are {@code \u0027\\u005Cu0030\u0027} through\n     * {@code \u0027\\u005Cu0039\u0027} and {@code \u0027\\u005Cu0061\u0027} through\n     * {@code \u0027\\u005Cu007A\u0027}. If {@code radix} is\n     * \u003cvar\u003eN\u003c/var\u003e, then the first \u003cvar\u003eN\u003c/var\u003e of these characters\n     * are used as radix-\u003cvar\u003eN\u003c/var\u003e digits in the order shown. Thus,\n     * the digits for hexadecimal (radix 16) are\n     * {@code 0123456789abcdef}. If uppercase letters are\n     * desired, the {@link java.lang.String#toUpperCase()} method may\n     * be called on the result:\n     *\n     * \u003cblockquote\u003e\n     *  {@code Integer.toString(n, 16).toUpperCase()}\n     * \u003c/blockquote\u003e\n     *\n     * @param   i       an integer to be converted to a string.\n     * @param   radix   the radix to use in the string representation.\n     * @return  a string representation of the argument in the specified radix.\n     * @see     java.lang.Character#MAX_RADIX\n     * @see     java.lang.Character#MIN_RADIX\n     */\n    public static String toString(int i, int radix) {\n        if (radix \u003c Character.MIN_RADIX || radix \u003e Character.MAX_RADIX)\n            radix \u003d 10;\n\n        /* Use the faster version */\n        if (radix \u003d\u003d 10) {\n            return toString(i);\n        }\n\n        if (COMPACT_STRINGS) {\n            byte[] buf \u003d new byte[33];\n            boolean negative \u003d (i \u003c 0);\n            int charPos \u003d 32;\n\n            if (!negative) {\n                i \u003d -i;\n            }\n\n            while (i \u003c\u003d -radix) {\n                buf[charPos--] \u003d (byte)digits[-(i % radix)];\n                i \u003d i / radix;\n            }\n            buf[charPos] \u003d (byte)digits[-i];\n\n            if (negative) {\n                buf[--charPos] \u003d \u0027-\u0027;\n            }\n\n            return StringLatin1.newString(buf, charPos, (33 - charPos));\n        }\n        return toStringUTF16(i, radix);\n    }\n\n    private static String toStringUTF16(int i, int radix) {\n        byte[] buf \u003d new byte[33 * 2];\n        boolean negative \u003d (i \u003c 0);\n        int charPos \u003d 32;\n        if (!negative) {\n            i \u003d -i;\n        }\n        while (i \u003c\u003d -radix) {\n            StringUTF16.putChar(buf, charPos--, digits[-(i % radix)]);\n            i \u003d i / radix;\n        }\n        StringUTF16.putChar(buf, charPos, digits[-i]);\n\n        if (negative) {\n            StringUTF16.putChar(buf, --charPos, \u0027-\u0027);\n        }\n        return StringUTF16.newString(buf, charPos, (33 - charPos));\n    }\n\n    /**\n     * Returns a string representation of the first argument as an\n     * unsigned integer value in the radix specified by the second\n     * argument.\n     *\n     * \u003cp\u003eIf the radix is smaller than {@code Character.MIN_RADIX}\n     * or larger than {@code Character.MAX_RADIX}, then the radix\n     * {@code 10} is used instead.\n     *\n     * \u003cp\u003eNote that since the first argument is treated as an unsigned\n     * value, no leading sign character is printed.\n     *\n     * \u003cp\u003eIf the magnitude is zero, it is represented by a single zero\n     * character {@code \u00270\u0027} ({@code \u0027\\u005Cu0030\u0027}); otherwise,\n     * the first character of the representation of the magnitude will\n     * not be the zero character.\n     *\n     * \u003cp\u003eThe behavior of radixes and the characters used as digits\n     * are the same as {@link #toString(int, int) toString}.\n     *\n     * @param   i       an integer to be converted to an unsigned string.\n     * @param   radix   the radix to use in the string representation.\n     * @return  an unsigned string representation of the argument in the specified radix.\n     * @see     #toString(int, int)\n     * @since 1.8\n     */\n    public static String toUnsignedString(int i, int radix) {\n        return Long.toUnsignedString(toUnsignedLong(i), radix);\n    }\n\n    /**\n     * Returns a string representation of the integer argument as an\n     * unsigned integer in base\u0026nbsp;16.\n     *\n     * \u003cp\u003eThe unsigned integer value is the argument plus 2\u003csup\u003e32\u003c/sup\u003e\n     * if the argument is negative; otherwise, it is equal to the\n     * argument.  This value is converted to a string of ASCII digits\n     * in hexadecimal (base\u0026nbsp;16) with no extra leading\n     * {@code 0}s.\n     *\n     * \u003cp\u003eThe value of the argument can be recovered from the returned\n     * string {@code s} by calling {@link\n     * Integer#parseUnsignedInt(String, int)\n     * Integer.parseUnsignedInt(s, 16)}.\n     *\n     * \u003cp\u003eIf the unsigned magnitude is zero, it is represented by a\n     * single zero character {@code \u00270\u0027} ({@code \u0027\\u005Cu0030\u0027});\n     * otherwise, the first character of the representation of the\n     * unsigned magnitude will not be the zero character. The\n     * following characters are used as hexadecimal digits:\n     *\n     * \u003cblockquote\u003e\n     *  {@code 0123456789abcdef}\n     * \u003c/blockquote\u003e\n     *\n     * These are the characters {@code \u0027\\u005Cu0030\u0027} through\n     * {@code \u0027\\u005Cu0039\u0027} and {@code \u0027\\u005Cu0061\u0027} through\n     * {@code \u0027\\u005Cu0066\u0027}. If uppercase letters are\n     * desired, the {@link java.lang.String#toUpperCase()} method may\n     * be called on the result:\n     *\n     * \u003cblockquote\u003e\n     *  {@code Integer.toHexString(n).toUpperCase()}\n     * \u003c/blockquote\u003e\n     *\n     * @apiNote\n     * The {@link java.util.HexFormat} class provides formatting and parsing\n     * of byte arrays and primitives to return a string or adding to an {@link Appendable}.\n     * {@code HexFormat} formats and parses uppercase or lowercase hexadecimal characters,\n     * with leading zeros and for byte arrays includes for each byte\n     * a delimiter, prefix, and suffix.\n     *\n     * @param   i   an integer to be converted to a string.\n     * @return  the string representation of the unsigned integer value\n     *          represented by the argument in hexadecimal (base\u0026nbsp;16).\n     * @see java.util.HexFormat\n     * @see #parseUnsignedInt(String, int)\n     * @see #toUnsignedString(int, int)\n     * @since   1.0.2\n     */\n    public static String toHexString(int i) {\n        return toUnsignedString0(i, 4);\n    }\n\n    /**\n     * Returns a string representation of the integer argument as an\n     * unsigned integer in base\u0026nbsp;8.\n     *\n     * \u003cp\u003eThe unsigned integer value is the argument plus 2\u003csup\u003e32\u003c/sup\u003e\n     * if the argument is negative; otherwise, it is equal to the\n     * argument.  This value is converted to a string of ASCII digits\n     * in octal (base\u0026nbsp;8) with no extra leading {@code 0}s.\n     *\n     * \u003cp\u003eThe value of the argument can be recovered from the returned\n     * string {@code s} by calling {@link\n     * Integer#parseUnsignedInt(String, int)\n     * Integer.parseUnsignedInt(s, 8)}.\n     *\n     * \u003cp\u003eIf the unsigned magnitude is zero, it is represented by a\n     * single zero character {@code \u00270\u0027} ({@code \u0027\\u005Cu0030\u0027});\n     * otherwise, the first character of the representation of the\n     * unsigned magnitude will not be the zero character. The\n     * following characters are used as octal digits:\n     *\n     * \u003cblockquote\u003e\n     * {@code 01234567}\n     * \u003c/blockquote\u003e\n     *\n     * These are the characters {@code \u0027\\u005Cu0030\u0027} through\n     * {@code \u0027\\u005Cu0037\u0027}.\n     *\n     * @param   i   an integer to be converted to a string.\n     * @return  the string representation of the unsigned integer value\n     *          represented by the argument in octal (base\u0026nbsp;8).\n     * @see #parseUnsignedInt(String, int)\n     * @see #toUnsignedString(int, int)\n     * @since   1.0.2\n     */\n    public static String toOctalString(int i) {\n        return toUnsignedString0(i, 3);\n    }\n\n    /**\n     * Returns a string representation of the integer argument as an\n     * unsigned integer in base\u0026nbsp;2.\n     *\n     * \u003cp\u003eThe unsigned integer value is the argument plus 2\u003csup\u003e32\u003c/sup\u003e\n     * if the argument is negative; otherwise it is equal to the\n     * argument.  This value is converted to a string of ASCII digits\n     * in binary (base\u0026nbsp;2) with no extra leading {@code 0}s.\n     *\n     * \u003cp\u003eThe value of the argument can be recovered from the returned\n     * string {@code s} by calling {@link\n     * Integer#parseUnsignedInt(String, int)\n     * Integer.parseUnsignedInt(s, 2)}.\n     *\n     * \u003cp\u003eIf the unsigned magnitude is zero, it is represented by a\n     * single zero character {@code \u00270\u0027} ({@code \u0027\\u005Cu0030\u0027});\n     * otherwise, the first character of the representation of the\n     * unsigned magnitude will not be the zero character. The\n     * characters {@code \u00270\u0027} ({@code \u0027\\u005Cu0030\u0027}) and {@code\n     * \u00271\u0027} ({@code \u0027\\u005Cu0031\u0027}) are used as binary digits.\n     *\n     * @param   i   an integer to be converted to a string.\n     * @return  the string representation of the unsigned integer value\n     *          represented by the argument in binary (base\u0026nbsp;2).\n     * @see #parseUnsignedInt(String, int)\n     * @see #toUnsignedString(int, int)\n     * @since   1.0.2\n     */\n    public static String toBinaryString(int i) {\n        return toUnsignedString0(i, 1);\n    }\n\n    /**\n     * Convert the integer to an unsigned number.\n     */\n    private static String toUnsignedString0(int val, int shift) {\n        // assert shift \u003e 0 \u0026\u0026 shift \u003c\u003d5 : \"Illegal shift value\";\n        int mag \u003d Integer.SIZE - Integer.numberOfLeadingZeros(val);\n        int chars \u003d Math.max(((mag + (shift - 1)) / shift), 1);\n        if (COMPACT_STRINGS) {\n            byte[] buf \u003d new byte[chars];\n            formatUnsignedInt(val, shift, buf, chars);\n            return new String(buf, LATIN1);\n        } else {\n            byte[] buf \u003d new byte[chars * 2];\n            formatUnsignedIntUTF16(val, shift, buf, chars);\n            return new String(buf, UTF16);\n        }\n    }\n\n    /**\n     * Format an {@code int} (treated as unsigned) into a byte buffer (LATIN1 version). If\n     * {@code len} exceeds the formatted ASCII representation of {@code val},\n     * {@code buf} will be padded with leading zeroes.\n     *\n     * @param val the unsigned int to format\n     * @param shift the log2 of the base to format in (4 for hex, 3 for octal, 1 for binary)\n     * @param buf the byte buffer to write to\n     * @param len the number of characters to write\n     */\n    private static void formatUnsignedInt(int val, int shift, byte[] buf, int len) {\n        int charPos \u003d len;\n        int radix \u003d 1 \u003c\u003c shift;\n        int mask \u003d radix - 1;\n        do {\n            buf[--charPos] \u003d (byte)Integer.digits[val \u0026 mask];\n            val \u003e\u003e\u003e\u003d shift;\n        } while (charPos \u003e 0);\n    }\n\n    /**\n     * Format an {@code int} (treated as unsigned) into a byte buffer (UTF16 version). If\n     * {@code len} exceeds the formatted ASCII representation of {@code val},\n     * {@code buf} will be padded with leading zeroes.\n     *\n     * @param val the unsigned int to format\n     * @param shift the log2 of the base to format in (4 for hex, 3 for octal, 1 for binary)\n     * @param buf the byte buffer to write to\n     * @param len the number of characters to write\n     */\n    private static void formatUnsignedIntUTF16(int val, int shift, byte[] buf, int len) {\n        int charPos \u003d len;\n        int radix \u003d 1 \u003c\u003c shift;\n        int mask \u003d radix - 1;\n        do {\n            StringUTF16.putChar(buf, --charPos, Integer.digits[val \u0026 mask]);\n            val \u003e\u003e\u003e\u003d shift;\n        } while (charPos \u003e 0);\n    }\n\n    static final byte[] DigitTens \u003d {\n        \u00270\u0027, \u00270\u0027, \u00270\u0027, \u00270\u0027, \u00270\u0027, \u00270\u0027, \u00270\u0027, \u00270\u0027, \u00270\u0027, \u00270\u0027,\n        \u00271\u0027, \u00271\u0027, \u00271\u0027, \u00271\u0027, \u00271\u0027, \u00271\u0027, \u00271\u0027, \u00271\u0027, \u00271\u0027, \u00271\u0027,\n        \u00272\u0027, \u00272\u0027, \u00272\u0027, \u00272\u0027, \u00272\u0027, \u00272\u0027, \u00272\u0027, \u00272\u0027, \u00272\u0027, \u00272\u0027,\n        \u00273\u0027, \u00273\u0027, \u00273\u0027, \u00273\u0027, \u00273\u0027, \u00273\u0027, \u00273\u0027, \u00273\u0027, \u00273\u0027, \u00273\u0027,\n        \u00274\u0027, \u00274\u0027, \u00274\u0027, \u00274\u0027, \u00274\u0027, \u00274\u0027, \u00274\u0027, \u00274\u0027, \u00274\u0027, \u00274\u0027,\n        \u00275\u0027, \u00275\u0027, \u00275\u0027, \u00275\u0027, \u00275\u0027, \u00275\u0027, \u00275\u0027, \u00275\u0027, \u00275\u0027, \u00275\u0027,\n        \u00276\u0027, \u00276\u0027, \u00276\u0027, \u00276\u0027, \u00276\u0027, \u00276\u0027, \u00276\u0027, \u00276\u0027, \u00276\u0027, \u00276\u0027,\n        \u00277\u0027, \u00277\u0027, \u00277\u0027, \u00277\u0027, \u00277\u0027, \u00277\u0027, \u00277\u0027, \u00277\u0027, \u00277\u0027, \u00277\u0027,\n        \u00278\u0027, \u00278\u0027, \u00278\u0027, \u00278\u0027, \u00278\u0027, \u00278\u0027, \u00278\u0027, \u00278\u0027, \u00278\u0027, \u00278\u0027,\n        \u00279\u0027, \u00279\u0027, \u00279\u0027, \u00279\u0027, \u00279\u0027, \u00279\u0027, \u00279\u0027, \u00279\u0027, \u00279\u0027, \u00279\u0027,\n        } ;\n\n    static final byte[] DigitOnes \u003d {\n        \u00270\u0027, \u00271\u0027, \u00272\u0027, \u00273\u0027, \u00274\u0027, \u00275\u0027, \u00276\u0027, \u00277\u0027, \u00278\u0027, \u00279\u0027,\n        \u00270\u0027, \u00271\u0027, \u00272\u0027, \u00273\u0027, \u00274\u0027, \u00275\u0027, \u00276\u0027, \u00277\u0027, \u00278\u0027, \u00279\u0027,\n        \u00270\u0027, \u00271\u0027, \u00272\u0027, \u00273\u0027, \u00274\u0027, \u00275\u0027, \u00276\u0027, \u00277\u0027, \u00278\u0027, \u00279\u0027,\n        \u00270\u0027, \u00271\u0027, \u00272\u0027, \u00273\u0027, \u00274\u0027, \u00275\u0027, \u00276\u0027, \u00277\u0027, \u00278\u0027, \u00279\u0027,\n        \u00270\u0027, \u00271\u0027, \u00272\u0027, \u00273\u0027, \u00274\u0027, \u00275\u0027, \u00276\u0027, \u00277\u0027, \u00278\u0027, \u00279\u0027,\n        \u00270\u0027, \u00271\u0027, \u00272\u0027, \u00273\u0027, \u00274\u0027, \u00275\u0027, \u00276\u0027, \u00277\u0027, \u00278\u0027, \u00279\u0027,\n        \u00270\u0027, \u00271\u0027, \u00272\u0027, \u00273\u0027, \u00274\u0027, \u00275\u0027, \u00276\u0027, \u00277\u0027, \u00278\u0027, \u00279\u0027,\n        \u00270\u0027, \u00271\u0027, \u00272\u0027, \u00273\u0027, \u00274\u0027, \u00275\u0027, \u00276\u0027, \u00277\u0027, \u00278\u0027, \u00279\u0027,\n        \u00270\u0027, \u00271\u0027, \u00272\u0027, \u00273\u0027, \u00274\u0027, \u00275\u0027, \u00276\u0027, \u00277\u0027, \u00278\u0027, \u00279\u0027,\n        \u00270\u0027, \u00271\u0027, \u00272\u0027, \u00273\u0027, \u00274\u0027, \u00275\u0027, \u00276\u0027, \u00277\u0027, \u00278\u0027, \u00279\u0027,\n        } ;\n\n\n    /**\n     * Returns a {@code String} object representing the\n     * specified integer. The argument is converted to signed decimal\n     * representation and returned as a string, exactly as if the\n     * argument and radix 10 were given as arguments to the {@link\n     * #toString(int, int)} method.\n     *\n     * @param   i   an integer to be converted.\n     * @return  a string representation of the argument in base\u0026nbsp;10.\n     */\n    @IntrinsicCandidate\n    public static String toString(int i) {\n        int size \u003d stringSize(i);\n        if (COMPACT_STRINGS) {\n            byte[] buf \u003d new byte[size];\n            getChars(i, size, buf);\n            return new String(buf, LATIN1);\n        } else {\n            byte[] buf \u003d new byte[size * 2];\n            StringUTF16.getChars(i, size, buf);\n            return new String(buf, UTF16);\n        }\n    }\n\n    /**\n     * Returns a string representation of the argument as an unsigned\n     * decimal value.\n     *\n     * The argument is converted to unsigned decimal representation\n     * and returned as a string exactly as if the argument and radix\n     * 10 were given as arguments to the {@link #toUnsignedString(int,\n     * int)} method.\n     *\n     * @param   i  an integer to be converted to an unsigned string.\n     * @return  an unsigned string representation of the argument.\n     * @see     #toUnsignedString(int, int)\n     * @since 1.8\n     */\n    public static String toUnsignedString(int i) {\n        return Long.toString(toUnsignedLong(i));\n    }\n\n    /**\n     * Places characters representing the integer i into the\n     * character array buf. The characters are placed into\n     * the buffer backwards starting with the least significant\n     * digit at the specified index (exclusive), and working\n     * backwards from there.\n     *\n     * @implNote This method converts positive inputs into negative\n     * values, to cover the Integer.MIN_VALUE case. Converting otherwise\n     * (negative to positive) will expose -Integer.MIN_VALUE that overflows\n     * integer.\n     *\n     * @param i     value to convert\n     * @param index next index, after the least significant digit\n     * @param buf   target buffer, Latin1-encoded\n     * @return index of the most significant digit or minus sign, if present\n     */\n    static int getChars(int i, int index, byte[] buf) {\n        int q, r;\n        int charPos \u003d index;\n\n        boolean negative \u003d i \u003c 0;\n        if (!negative) {\n            i \u003d -i;\n        }\n\n        // Generate two digits per iteration\n        while (i \u003c\u003d -100) {\n            q \u003d i / 100;\n            r \u003d (q * 100) - i;\n            i \u003d q;\n            buf[--charPos] \u003d DigitOnes[r];\n            buf[--charPos] \u003d DigitTens[r];\n        }\n\n        // We know there are at most two digits left at this point.\n        q \u003d i / 10;\n        r \u003d (q * 10) - i;\n        buf[--charPos] \u003d (byte)(\u00270\u0027 + r);\n\n        // Whatever left is the remaining digit.\n        if (q \u003c 0) {\n            buf[--charPos] \u003d (byte)(\u00270\u0027 - q);\n        }\n\n        if (negative) {\n            buf[--charPos] \u003d (byte)\u0027-\u0027;\n        }\n        return charPos;\n    }\n\n    // Left here for compatibility reasons, see JDK-8143900.\n    static final int [] sizeTable \u003d { 9, 99, 999, 9999, 99999, 999999, 9999999,\n                                      99999999, 999999999, Integer.MAX_VALUE };\n\n    /**\n     * Returns the string representation size for a given int value.\n     *\n     * @param x int value\n     * @return string size\n     *\n     * @implNote There are other ways to compute this: e.g. binary search,\n     * but values are biased heavily towards zero, and therefore linear search\n     * wins. The iteration results are also routinely inlined in the generated\n     * code after loop unrolling.\n     */\n    static int stringSize(int x) {\n        int d \u003d 1;\n        if (x \u003e\u003d 0) {\n            d \u003d 0;\n            x \u003d -x;\n        }\n        int p \u003d -10;\n        for (int i \u003d 1; i \u003c 10; i++) {\n            if (x \u003e p)\n                return i + d;\n            p \u003d 10 * p;\n        }\n        return 10 + d;\n    }\n\n    /**\n     * Parses the string argument as a signed integer in the radix\n     * specified by the second argument. The characters in the string\n     * must all be digits of the specified radix (as determined by\n     * whether {@link java.lang.Character#digit(char, int)} returns a\n     * nonnegative value), except that the first character may be an\n     * ASCII minus sign {@code \u0027-\u0027} ({@code \u0027\\u005Cu002D\u0027}) to\n     * indicate a negative value or an ASCII plus sign {@code \u0027+\u0027}\n     * ({@code \u0027\\u005Cu002B\u0027}) to indicate a positive value. The\n     * resulting integer value is returned.\n     *\n     * \u003cp\u003eAn exception of type {@code NumberFormatException} is\n     * thrown if any of the following situations occurs:\n     * \u003cul\u003e\n     * \u003cli\u003eThe first argument is {@code null} or is a string of\n     * length zero.\n     *\n     * \u003cli\u003eThe radix is either smaller than\n     * {@link java.lang.Character#MIN_RADIX} or\n     * larger than {@link java.lang.Character#MAX_RADIX}.\n     *\n     * \u003cli\u003eAny character of the string is not a digit of the specified\n     * radix, except that the first character may be a minus sign\n     * {@code \u0027-\u0027} ({@code \u0027\\u005Cu002D\u0027}) or plus sign\n     * {@code \u0027+\u0027} ({@code \u0027\\u005Cu002B\u0027}) provided that the\n     * string is longer than length 1.\n     *\n     * \u003cli\u003eThe value represented by the string is not a value of type\n     * {@code int}.\n     * \u003c/ul\u003e\n     *\n     * \u003cp\u003eExamples:\n     * \u003cblockquote\u003e\u003cpre\u003e\n     * parseInt(\"0\", 10) returns 0\n     * parseInt(\"473\", 10) returns 473\n     * parseInt(\"+42\", 10) returns 42\n     * parseInt(\"-0\", 10) returns 0\n     * parseInt(\"-FF\", 16) returns -255\n     * parseInt(\"1100110\", 2) returns 102\n     * parseInt(\"2147483647\", 10) returns 2147483647\n     * parseInt(\"-2147483648\", 10) returns -2147483648\n     * parseInt(\"2147483648\", 10) throws a NumberFormatException\n     * parseInt(\"99\", 8) throws a NumberFormatException\n     * parseInt(\"Kona\", 10) throws a NumberFormatException\n     * parseInt(\"Kona\", 27) returns 411787\n     * \u003c/pre\u003e\u003c/blockquote\u003e\n     *\n     * @param      s   the {@code String} containing the integer\n     *                  representation to be parsed\n     * @param      radix   the radix to be used while parsing {@code s}.\n     * @return     the integer represented by the string argument in the\n     *             specified radix.\n     * @throws     NumberFormatException if the {@code String}\n     *             does not contain a parsable {@code int}.\n     */\n    public static int parseInt(String s, int radix)\n                throws NumberFormatException\n    {\n        /*\n         * WARNING: This method may be invoked early during VM initialization\n         * before IntegerCache is initialized. Care must be taken to not use\n         * the valueOf method.\n         */\n\n        if (s \u003d\u003d null) {\n            throw new NumberFormatException(\"Cannot parse null string\");\n        }\n\n        if (radix \u003c Character.MIN_RADIX) {\n            throw new NumberFormatException(\"radix \" + radix +\n                                            \" less than Character.MIN_RADIX\");\n        }\n\n        if (radix \u003e Character.MAX_RADIX) {\n            throw new NumberFormatException(\"radix \" + radix +\n                                            \" greater than Character.MAX_RADIX\");\n        }\n\n        boolean negative \u003d false;\n        int i \u003d 0, len \u003d s.length();\n        int limit \u003d -Integer.MAX_VALUE;\n\n        if (len \u003e 0) {\n            char firstChar \u003d s.charAt(0);\n            if (firstChar \u003c \u00270\u0027) { // Possible leading \"+\" or \"-\"\n                if (firstChar \u003d\u003d \u0027-\u0027) {\n                    negative \u003d true;\n                    limit \u003d Integer.MIN_VALUE;\n                } else if (firstChar !\u003d \u0027+\u0027) {\n                    throw NumberFormatException.forInputString(s, radix);\n                }\n\n                if (len \u003d\u003d 1) { // Cannot have lone \"+\" or \"-\"\n                    throw NumberFormatException.forInputString(s, radix);\n                }\n                i++;\n            }\n            int multmin \u003d limit / radix;\n            int result \u003d 0;\n            while (i \u003c len) {\n                // Accumulating negatively avoids surprises near MAX_VALUE\n                int digit \u003d Character.digit(s.charAt(i++), radix);\n                if (digit \u003c 0 || result \u003c multmin) {\n                    throw NumberFormatException.forInputString(s, radix);\n                }\n                result *\u003d radix;\n                if (result \u003c limit + digit) {\n                    throw NumberFormatException.forInputString(s, radix);\n                }\n                result -\u003d digit;\n            }\n            return negative ? result : -result;\n        } else {\n            throw NumberFormatException.forInputString(s, radix);\n        }\n    }\n\n    /**\n     * Parses the {@link CharSequence} argument as a signed {@code int} in the\n     * specified {@code radix}, beginning at the specified {@code beginIndex}\n     * and extending to {@code endIndex - 1}.\n     *\n     * \u003cp\u003eThe method does not take steps to guard against the\n     * {@code CharSequence} being mutated while parsing.\n     *\n     * @param      s   the {@code CharSequence} containing the {@code int}\n     *                  representation to be parsed\n     * @param      beginIndex   the beginning index, inclusive.\n     * @param      endIndex     the ending index, exclusive.\n     * @param      radix   the radix to be used while parsing {@code s}.\n     * @return     the signed {@code int} represented by the subsequence in\n     *             the specified radix.\n     * @throws     NullPointerException  if {@code s} is null.\n     * @throws     IndexOutOfBoundsException  if {@code beginIndex} is\n     *             negative, or if {@code beginIndex} is greater than\n     *             {@code endIndex} or if {@code endIndex} is greater than\n     *             {@code s.length()}.\n     * @throws     NumberFormatException  if the {@code CharSequence} does not\n     *             contain a parsable {@code int} in the specified\n     *             {@code radix}, or if {@code radix} is either smaller than\n     *             {@link java.lang.Character#MIN_RADIX} or larger than\n     *             {@link java.lang.Character#MAX_RADIX}.\n     * @since  9\n     */\n    public static int parseInt(CharSequence s, int beginIndex, int endIndex, int radix)\n                throws NumberFormatException {\n        Objects.requireNonNull(s);\n\n        if (beginIndex \u003c 0 || beginIndex \u003e endIndex || endIndex \u003e s.length()) {\n            throw new IndexOutOfBoundsException();\n        }\n        if (radix \u003c Character.MIN_RADIX) {\n            throw new NumberFormatException(\"radix \" + radix +\n                                            \" less than Character.MIN_RADIX\");\n        }\n        if (radix \u003e Character.MAX_RADIX) {\n            throw new NumberFormatException(\"radix \" + radix +\n                                            \" greater than Character.MAX_RADIX\");\n        }\n\n        boolean negative \u003d false;\n        int i \u003d beginIndex;\n        int limit \u003d -Integer.MAX_VALUE;\n\n        if (i \u003c endIndex) {\n            char firstChar \u003d s.charAt(i);\n            if (firstChar \u003c \u00270\u0027) { // Possible leading \"+\" or \"-\"\n                if (firstChar \u003d\u003d \u0027-\u0027) {\n                    negative \u003d true;\n                    limit \u003d Integer.MIN_VALUE;\n                } else if (firstChar !\u003d \u0027+\u0027) {\n                    throw NumberFormatException.forCharSequence(s, beginIndex,\n                            endIndex, i);\n                }\n                i++;\n                if (i \u003d\u003d endIndex) { // Cannot have lone \"+\" or \"-\"\n                    throw NumberFormatException.forCharSequence(s, beginIndex,\n                            endIndex, i);\n                }\n            }\n            int multmin \u003d limit / radix;\n            int result \u003d 0;\n            while (i \u003c endIndex) {\n                // Accumulating negatively avoids surprises near MAX_VALUE\n                int digit \u003d Character.digit(s.charAt(i), radix);\n                if (digit \u003c 0 || result \u003c multmin) {\n                    throw NumberFormatException.forCharSequence(s, beginIndex,\n                            endIndex, i);\n                }\n                result *\u003d radix;\n                if (result \u003c limit + digit) {\n                    throw NumberFormatException.forCharSequence(s, beginIndex,\n                            endIndex, i);\n                }\n                i++;\n                result -\u003d digit;\n            }\n            return negative ? result : -result;\n        } else {\n            throw NumberFormatException.forInputString(\"\", radix);\n        }\n    }\n\n    /**\n     * Parses the string argument as a signed decimal integer. The\n     * characters in the string must all be decimal digits, except\n     * that the first character may be an ASCII minus sign {@code \u0027-\u0027}\n     * ({@code \u0027\\u005Cu002D\u0027}) to indicate a negative value or an\n     * ASCII plus sign {@code \u0027+\u0027} ({@code \u0027\\u005Cu002B\u0027}) to\n     * indicate a positive value. The resulting integer value is\n     * returned, exactly as if the argument and the radix 10 were\n     * given as arguments to the {@link #parseInt(java.lang.String,\n     * int)} method.\n     *\n     * @param s    a {@code String} containing the {@code int}\n     *             representation to be parsed\n     * @return     the integer value represented by the argument in decimal.\n     * @throws     NumberFormatException  if the string does not contain a\n     *               parsable integer.\n     */\n    public static int parseInt(String s) throws NumberFormatException {\n        return parseInt(s,10);\n    }\n\n    /**\n     * Parses the string argument as an unsigned integer in the radix\n     * specified by the second argument.  An unsigned integer maps the\n     * values usually associated with negative numbers to positive\n     * numbers larger than {@code MAX_VALUE}.\n     *\n     * The characters in the string must all be digits of the\n     * specified radix (as determined by whether {@link\n     * java.lang.Character#digit(char, int)} returns a nonnegative\n     * value), except that the first character may be an ASCII plus\n     * sign {@code \u0027+\u0027} ({@code \u0027\\u005Cu002B\u0027}). The resulting\n     * integer value is returned.\n     *\n     * \u003cp\u003eAn exception of type {@code NumberFormatException} is\n     * thrown if any of the following situations occurs:\n     * \u003cul\u003e\n     * \u003cli\u003eThe first argument is {@code null} or is a string of\n     * length zero.\n     *\n     * \u003cli\u003eThe radix is either smaller than\n     * {@link java.lang.Character#MIN_RADIX} or\n     * larger than {@link java.lang.Character#MAX_RADIX}.\n     *\n     * \u003cli\u003eAny character of the string is not a digit of the specified\n     * radix, except that the first character may be a plus sign\n     * {@code \u0027+\u0027} ({@code \u0027\\u005Cu002B\u0027}) provided that the\n     * string is longer than length 1.\n     *\n     * \u003cli\u003eThe value represented by the string is larger than the\n     * largest unsigned {@code int}, 2\u003csup\u003e32\u003c/sup\u003e-1.\n     *\n     * \u003c/ul\u003e\n     *\n     *\n     * @param      s   the {@code String} containing the unsigned integer\n     *                  representation to be parsed\n     * @param      radix   the radix to be used while parsing {@code s}.\n     * @return     the integer represented by the string argument in the\n     *             specified radix.\n     * @throws     NumberFormatException if the {@code String}\n     *             does not contain a parsable {@code int}.\n     * @since 1.8\n     */\n    public static int parseUnsignedInt(String s, int radix)\n                throws NumberFormatException {\n        if (s \u003d\u003d null)  {\n            throw new NumberFormatException(\"Cannot parse null string\");\n        }\n\n        int len \u003d s.length();\n        if (len \u003e 0) {\n            char firstChar \u003d s.charAt(0);\n            if (firstChar \u003d\u003d \u0027-\u0027) {\n                throw new\n                    NumberFormatException(String.format(\"Illegal leading minus sign \" +\n                                                       \"on unsigned string %s.\", s));\n            } else {\n                if (len \u003c\u003d 5 || // Integer.MAX_VALUE in Character.MAX_RADIX is 6 digits\n                    (radix \u003d\u003d 10 \u0026\u0026 len \u003c\u003d 9) ) { // Integer.MAX_VALUE in base 10 is 10 digits\n                    return parseInt(s, radix);\n                } else {\n                    long ell \u003d Long.parseLong(s, radix);\n                    if ((ell \u0026 0xffff_ffff_0000_0000L) \u003d\u003d 0) {\n                        return (int) ell;\n                    } else {\n                        throw new\n                            NumberFormatException(String.format(\"String value %s exceeds \" +\n                                                                \"range of unsigned int.\", s));\n                    }\n                }\n            }\n        } else {\n            throw NumberFormatException.forInputString(s, radix);\n        }\n    }\n\n    /**\n     * Parses the {@link CharSequence} argument as an unsigned {@code int} in\n     * the specified {@code radix}, beginning at the specified\n     * {@code beginIndex} and extending to {@code endIndex - 1}.\n     *\n     * \u003cp\u003eThe method does not take steps to guard against the\n     * {@code CharSequence} being mutated while parsing.\n     *\n     * @param      s   the {@code CharSequence} containing the unsigned\n     *                 {@code int} representation to be parsed\n     * @param      beginIndex   the beginning index, inclusive.\n     * @param      endIndex     the ending index, exclusive.\n     * @param      radix   the radix to be used while parsing {@code s}.\n     * @return     the unsigned {@code int} represented by the subsequence in\n     *             the specified radix.\n     * @throws     NullPointerException  if {@code s} is null.\n     * @throws     IndexOutOfBoundsException  if {@code beginIndex} is\n     *             negative, or if {@code beginIndex} is greater than\n     *             {@code endIndex} or if {@code endIndex} is greater than\n     *             {@code s.length()}.\n     * @throws     NumberFormatException  if the {@code CharSequence} does not\n     *             contain a parsable unsigned {@code int} in the specified\n     *             {@code radix}, or if {@code radix} is either smaller than\n     *             {@link java.lang.Character#MIN_RADIX} or larger than\n     *             {@link java.lang.Character#MAX_RADIX}.\n     * @since  9\n     */\n    public static int parseUnsignedInt(CharSequence s, int beginIndex, int endIndex, int radix)\n                throws NumberFormatException {\n        Objects.requireNonNull(s);\n\n        if (beginIndex \u003c 0 || beginIndex \u003e endIndex || endIndex \u003e s.length()) {\n            throw new IndexOutOfBoundsException();\n        }\n        int start \u003d beginIndex, len \u003d endIndex - beginIndex;\n\n        if (len \u003e 0) {\n            char firstChar \u003d s.charAt(start);\n            if (firstChar \u003d\u003d \u0027-\u0027) {\n                throw new\n                    NumberFormatException(String.format(\"Illegal leading minus sign \" +\n                                                       \"on unsigned string %s.\", s));\n            } else {\n                if (len \u003c\u003d 5 || // Integer.MAX_VALUE in Character.MAX_RADIX is 6 digits\n                        (radix \u003d\u003d 10 \u0026\u0026 len \u003c\u003d 9)) { // Integer.MAX_VALUE in base 10 is 10 digits\n                    return parseInt(s, start, start + len, radix);\n                } else {\n                    long ell \u003d Long.parseLong(s, start, start + len, radix);\n                    if ((ell \u0026 0xffff_ffff_0000_0000L) \u003d\u003d 0) {\n                        return (int) ell;\n                    } else {\n                        throw new\n                            NumberFormatException(String.format(\"String value %s exceeds \" +\n                                                                \"range of unsigned int.\", s));\n                    }\n                }\n            }\n        } else {\n            throw new NumberFormatException(\"\");\n        }\n    }\n\n    /**\n     * Parses the string argument as an unsigned decimal integer. The\n     * characters in the string must all be decimal digits, except\n     * that the first character may be an ASCII plus sign {@code\n     * \u0027+\u0027} ({@code \u0027\\u005Cu002B\u0027}). The resulting integer value\n     * is returned, exactly as if the argument and the radix 10 were\n     * given as arguments to the {@link\n     * #parseUnsignedInt(java.lang.String, int)} method.\n     *\n     * @param s   a {@code String} containing the unsigned {@code int}\n     *            representation to be parsed\n     * @return    the unsigned integer value represented by the argument in decimal.\n     * @throws    NumberFormatException  if the string does not contain a\n     *            parsable unsigned integer.\n     * @since 1.8\n     */\n    public static int parseUnsignedInt(String s) throws NumberFormatException {\n        return parseUnsignedInt(s, 10);\n    }\n\n    /**\n     * Returns an {@code Integer} object holding the value\n     * extracted from the specified {@code String} when parsed\n     * with the radix given by the second argument. The first argument\n     * is interpreted as representing a signed integer in the radix\n     * specified by the second argument, exactly as if the arguments\n     * were given to the {@link #parseInt(java.lang.String, int)}\n     * method. The result is an {@code Integer} object that\n     * represents the integer value specified by the string.\n     *\n     * \u003cp\u003eIn other words, this method returns an {@code Integer}\n     * object equal to the value of:\n     *\n     * \u003cblockquote\u003e\n     *  {@code new Integer(Integer.parseInt(s, radix))}\n     * \u003c/blockquote\u003e\n     *\n     * @param      s   the string to be parsed.\n     * @param      radix the radix to be used in interpreting {@code s}\n     * @return     an {@code Integer} object holding the value\n     *             represented by the string argument in the specified\n     *             radix.\n     * @throws    NumberFormatException if the {@code String}\n     *            does not contain a parsable {@code int}.\n     */\n    public static Integer valueOf(String s, int radix) throws NumberFormatException {\n        return Integer.valueOf(parseInt(s,radix));\n    }\n\n    /**\n     * Returns an {@code Integer} object holding the\n     * value of the specified {@code String}. The argument is\n     * interpreted as representing a signed decimal integer, exactly\n     * as if the argument were given to the {@link\n     * #parseInt(java.lang.String)} method. The result is an\n     * {@code Integer} object that represents the integer value\n     * specified by the string.\n     *\n     * \u003cp\u003eIn other words, this method returns an {@code Integer}\n     * object equal to the value of:\n     *\n     * \u003cblockquote\u003e\n     *  {@code new Integer(Integer.parseInt(s))}\n     * \u003c/blockquote\u003e\n     *\n     * @param      s   the string to be parsed.\n     * @return     an {@code Integer} object holding the value\n     *             represented by the string argument.\n     * @throws     NumberFormatException  if the string cannot be parsed\n     *             as an integer.\n     */\n    public static Integer valueOf(String s) throws NumberFormatException {\n        return Integer.valueOf(parseInt(s, 10));\n    }\n\n    /**\n     * Cache to support the object identity semantics of autoboxing for values between\n     * -128 and 127 (inclusive) as required by JLS.\n     *\n     * The cache is initialized on first usage.  The size of the cache\n     * may be controlled by the {@code -XX:AutoBoxCacheMax\u003d\u003csize\u003e} option.\n     * During VM initialization, java.lang.Integer.IntegerCache.high property\n     * may be set and saved in the private system properties in the\n     * jdk.internal.misc.VM class.\n     *\n     * WARNING: The cache is archived with CDS and reloaded from the shared\n     * archive at runtime. The archived cache (Integer[]) and Integer objects\n     * reside in the closed archive heap regions. Care should be taken when\n     * changing the implementation and the cache array should not be assigned\n     * with new Integer object(s) after initialization.\n     */\n\n    private static class IntegerCache {\n        static final int low \u003d -128;\n        static final int high;\n        static final Integer[] cache;\n        static Integer[] archivedCache;\n\n        static {\n            // high value may be configured by property\n            int h \u003d 127;\n            String integerCacheHighPropValue \u003d\n                VM.getSavedProperty(\"java.lang.Integer.IntegerCache.high\");\n            if (integerCacheHighPropValue !\u003d null) {\n                try {\n                    h \u003d Math.max(parseInt(integerCacheHighPropValue), 127);\n                    // Maximum array size is Integer.MAX_VALUE\n                    h \u003d Math.min(h, Integer.MAX_VALUE - (-low) -1);\n                } catch( NumberFormatException nfe) {\n                    // If the property cannot be parsed into an int, ignore it.\n                }\n            }\n            high \u003d h;\n\n            // Load IntegerCache.archivedCache from archive, if possible\n            CDS.initializeFromArchive(IntegerCache.class);\n            int size \u003d (high - low) + 1;\n\n            // Use the archived cache if it exists and is large enough\n            if (archivedCache \u003d\u003d null || size \u003e archivedCache.length) {\n                Integer[] c \u003d new Integer[size];\n                int j \u003d low;\n                for(int i \u003d 0; i \u003c c.length; i++) {\n                    c[i] \u003d new Integer(j++);\n                }\n                archivedCache \u003d c;\n            }\n            cache \u003d archivedCache;\n            // range [-128, 127] must be interned (JLS7 5.1.7)\n            assert IntegerCache.high \u003e\u003d 127;\n        }\n\n        private IntegerCache() {}\n    }\n\n    /**\n     * Returns an {@code Integer} instance representing the specified\n     * {@code int} value.  If a new {@code Integer} instance is not\n     * required, this method should generally be used in preference to\n     * the constructor {@link #Integer(int)}, as this method is likely\n     * to yield significantly better space and time performance by\n     * caching frequently requested values.\n     *\n     * This method will always cache values in the range -128 to 127,\n     * inclusive, and may cache other values outside of this range.\n     *\n     * @param  i an {@code int} value.\n     * @return an {@code Integer} instance representing {@code i}.\n     * @since  1.5\n     */\n    @IntrinsicCandidate\n    public static Integer valueOf(int i) {\n        if (i \u003e\u003d IntegerCache.low \u0026\u0026 i \u003c\u003d IntegerCache.high)\n            return IntegerCache.cache[i + (-IntegerCache.low)];\n        return new Integer(i);\n    }\n\n    /**\n     * The value of the {@code Integer}.\n     *\n     * @serial\n     */\n    private final int value;\n\n    /**\n     * Constructs a newly allocated {@code Integer} object that\n     * represents the specified {@code int} value.\n     *\n     * @param   value   the value to be represented by the\n     *                  {@code Integer} object.\n     *\n     * @deprecated\n     * It is rarely appropriate to use this constructor. The static factory\n     * {@link #valueOf(int)} is generally a better choice, as it is\n     * likely to yield significantly better space and time performance.\n     */\n    @Deprecated(since\u003d\"9\", forRemoval \u003d true)\n    public Integer(int value) {\n        this.value \u003d value;\n    }\n\n    /**\n     * Constructs a newly allocated {@code Integer} object that\n     * represents the {@code int} value indicated by the\n     * {@code String} parameter. The string is converted to an\n     * {@code int} value in exactly the manner used by the\n     * {@code parseInt} method for radix 10.\n     *\n     * @param   s   the {@code String} to be converted to an {@code Integer}.\n     * @throws      NumberFormatException if the {@code String} does not\n     *              contain a parsable integer.\n     *\n     * @deprecated\n     * It is rarely appropriate to use this constructor.\n     * Use {@link #parseInt(String)} to convert a string to a\n     * {@code int} primitive, or use {@link #valueOf(String)}\n     * to convert a string to an {@code Integer} object.\n     */\n    @Deprecated(since\u003d\"9\", forRemoval \u003d true)\n    public Integer(String s) throws NumberFormatException {\n        this.value \u003d parseInt(s, 10);\n    }\n\n    /**\n     * Returns the value of this {@code Integer} as a {@code byte}\n     * after a narrowing primitive conversion.\n     * @jls 5.1.3 Narrowing Primitive Conversion\n     */\n    public byte byteValue() {\n        return (byte)value;\n    }\n\n    /**\n     * Returns the value of this {@code Integer} as a {@code short}\n     * after a narrowing primitive conversion.\n     * @jls 5.1.3 Narrowing Primitive Conversion\n     */\n    public short shortValue() {\n        return (short)value;\n    }\n\n    /**\n     * Returns the value of this {@code Integer} as an\n     * {@code int}.\n     */\n    @IntrinsicCandidate\n    public int intValue() {\n        return value;\n    }\n\n    /**\n     * Returns the value of this {@code Integer} as a {@code long}\n     * after a widening primitive conversion.\n     * @jls 5.1.2 Widening Primitive Conversion\n     * @see Integer#toUnsignedLong(int)\n     */\n    public long longValue() {\n        return (long)value;\n    }\n\n    /**\n     * Returns the value of this {@code Integer} as a {@code float}\n     * after a widening primitive conversion.\n     * @jls 5.1.2 Widening Primitive Conversion\n     */\n    public float floatValue() {\n        return (float)value;\n    }\n\n    /**\n     * Returns the value of this {@code Integer} as a {@code double}\n     * after a widening primitive conversion.\n     * @jls 5.1.2 Widening Primitive Conversion\n     */\n    public double doubleValue() {\n        return (double)value;\n    }\n\n    /**\n     * Returns a {@code String} object representing this\n     * {@code Integer}\u0027s value. The value is converted to signed\n     * decimal representation and returned as a string, exactly as if\n     * the integer value were given as an argument to the {@link\n     * java.lang.Integer#toString(int)} method.\n     *\n     * @return  a string representation of the value of this object in\n     *          base\u0026nbsp;10.\n     */\n    public String toString() {\n        return toString(value);\n    }\n\n    /**\n     * Returns a hash code for this {@code Integer}.\n     *\n     * @return  a hash code value for this object, equal to the\n     *          primitive {@code int} value represented by this\n     *          {@code Integer} object.\n     */\n    @Override\n    public int hashCode() {\n        return Integer.hashCode(value);\n    }\n\n    /**\n     * Returns a hash code for an {@code int} value; compatible with\n     * {@code Integer.hashCode()}.\n     *\n     * @param value the value to hash\n     * @since 1.8\n     *\n     * @return a hash code value for an {@code int} value.\n     */\n    public static int hashCode(int value) {\n        return value;\n    }\n\n    /**\n     * Compares this object to the specified object.  The result is\n     * {@code true} if and only if the argument is not\n     * {@code null} and is an {@code Integer} object that\n     * contains the same {@code int} value as this object.\n     *\n     * @param   obj   the object to compare with.\n     * @return  {@code true} if the objects are the same;\n     *          {@code false} otherwise.\n     */\n    public boolean equals(Object obj) {\n        if (obj instanceof Integer) {\n            return value \u003d\u003d ((Integer)obj).intValue();\n        }\n        return false;\n    }\n\n    /**\n     * Determines the integer value of the system property with the\n     * specified name.\n     *\n     * \u003cp\u003eThe first argument is treated as the name of a system\n     * property.  System properties are accessible through the {@link\n     * java.lang.System#getProperty(java.lang.String)} method. The\n     * string value of this property is then interpreted as an integer\n     * value using the grammar supported by {@link Integer#decode decode} and\n     * an {@code Integer} object representing this value is returned.\n     *\n     * \u003cp\u003eIf there is no property with the specified name, if the\n     * specified name is empty or {@code null}, or if the property\n     * does not have the correct numeric format, then {@code null} is\n     * returned.\n     *\n     * \u003cp\u003eIn other words, this method returns an {@code Integer}\n     * object equal to the value of:\n     *\n     * \u003cblockquote\u003e\n     *  {@code getInteger(nm, null)}\n     * \u003c/blockquote\u003e\n     *\n     * @param   nm   property name.\n     * @return  the {@code Integer} value of the property.\n     * @throws  SecurityException for the same reasons as\n     *          {@link System#getProperty(String) System.getProperty}\n     * @see     java.lang.System#getProperty(java.lang.String)\n     * @see     java.lang.System#getProperty(java.lang.String, java.lang.String)\n     */\n    public static Integer getInteger(String nm) {\n        return getInteger(nm, null);\n    }\n\n    /**\n     * Determines the integer value of the system property with the\n     * specified name.\n     *\n     * \u003cp\u003eThe first argument is treated as the name of a system\n     * property.  System properties are accessible through the {@link\n     * java.lang.System#getProperty(java.lang.String)} method. The\n     * string value of this property is then interpreted as an integer\n     * value using the grammar supported by {@link Integer#decode decode} and\n     * an {@code Integer} object representing this value is returned.\n     *\n     * \u003cp\u003eThe second argument is the default value. An {@code Integer} object\n     * that represents the value of the second argument is returned if there\n     * is no property of the specified name, if the property does not have\n     * the correct numeric format, or if the specified name is empty or\n     * {@code null}.\n     *\n     * \u003cp\u003eIn other words, this method returns an {@code Integer} object\n     * equal to the value of:\n     *\n     * \u003cblockquote\u003e\n     *  {@code getInteger(nm, new Integer(val))}\n     * \u003c/blockquote\u003e\n     *\n     * but in practice it may be implemented in a manner such as:\n     *\n     * \u003cblockquote\u003e\u003cpre\u003e\n     * Integer result \u003d getInteger(nm, null);\n     * return (result \u003d\u003d null) ? new Integer(val) : result;\n     * \u003c/pre\u003e\u003c/blockquote\u003e\n     *\n     * to avoid the unnecessary allocation of an {@code Integer}\n     * object when the default value is not needed.\n     *\n     * @param   nm   property name.\n     * @param   val   default value.\n     * @return  the {@code Integer} value of the property.\n     * @throws  SecurityException for the same reasons as\n     *          {@link System#getProperty(String) System.getProperty}\n     * @see     java.lang.System#getProperty(java.lang.String)\n     * @see     java.lang.System#getProperty(java.lang.String, java.lang.String)\n     */\n    public static Integer getInteger(String nm, int val) {\n        Integer result \u003d getInteger(nm, null);\n        return (result \u003d\u003d null) ? Integer.valueOf(val) : result;\n    }\n\n    /**\n     * Returns the integer value of the system property with the\n     * specified name.  The first argument is treated as the name of a\n     * system property.  System properties are accessible through the\n     * {@link java.lang.System#getProperty(java.lang.String)} method.\n     * The string value of this property is then interpreted as an\n     * integer value, as per the {@link Integer#decode decode} method,\n     * and an {@code Integer} object representing this value is\n     * returned; in summary:\n     *\n     * \u003cul\u003e\u003cli\u003eIf the property value begins with the two ASCII characters\n     *         {@code 0x} or the ASCII character {@code #}, not\n     *      followed by a minus sign, then the rest of it is parsed as a\n     *      hexadecimal integer exactly as by the method\n     *      {@link #valueOf(java.lang.String, int)} with radix 16.\n     * \u003cli\u003eIf the property value begins with the ASCII character\n     *     {@code 0} followed by another character, it is parsed as an\n     *     octal integer exactly as by the method\n     *     {@link #valueOf(java.lang.String, int)} with radix 8.\n     * \u003cli\u003eOtherwise, the property value is parsed as a decimal integer\n     * exactly as by the method {@link #valueOf(java.lang.String, int)}\n     * with radix 10.\n     * \u003c/ul\u003e\n     *\n     * \u003cp\u003eThe second argument is the default value. The default value is\n     * returned if there is no property of the specified name, if the\n     * property does not have the correct numeric format, or if the\n     * specified name is empty or {@code null}.\n     *\n     * @param   nm   property name.\n     * @param   val   default value.\n     * @return  the {@code Integer} value of the property.\n     * @throws  SecurityException for the same reasons as\n     *          {@link System#getProperty(String) System.getProperty}\n     * @see     System#getProperty(java.lang.String)\n     * @see     System#getProperty(java.lang.String, java.lang.String)\n     */\n    public static Integer getInteger(String nm, Integer val) {\n        String v \u003d null;\n        try {\n            v \u003d System.getProperty(nm);\n        } catch (IllegalArgumentException | NullPointerException e) {\n        }\n        if (v !\u003d null) {\n            try {\n                return Integer.decode(v);\n            } catch (NumberFormatException e) {\n            }\n        }\n        return val;\n    }\n\n    /**\n     * Decodes a {@code String} into an {@code Integer}.\n     * Accepts decimal, hexadecimal, and octal numbers given\n     * by the following grammar:\n     *\n     * \u003cblockquote\u003e\n     * \u003cdl\u003e\n     * \u003cdt\u003e\u003ci\u003eDecodableString:\u003c/i\u003e\n     * \u003cdd\u003e\u003ci\u003eSign\u003csub\u003eopt\u003c/sub\u003e DecimalNumeral\u003c/i\u003e\n     * \u003cdd\u003e\u003ci\u003eSign\u003csub\u003eopt\u003c/sub\u003e\u003c/i\u003e {@code 0x} \u003ci\u003eHexDigits\u003c/i\u003e\n     * \u003cdd\u003e\u003ci\u003eSign\u003csub\u003eopt\u003c/sub\u003e\u003c/i\u003e {@code 0X} \u003ci\u003eHexDigits\u003c/i\u003e\n     * \u003cdd\u003e\u003ci\u003eSign\u003csub\u003eopt\u003c/sub\u003e\u003c/i\u003e {@code #} \u003ci\u003eHexDigits\u003c/i\u003e\n     * \u003cdd\u003e\u003ci\u003eSign\u003csub\u003eopt\u003c/sub\u003e\u003c/i\u003e {@code 0} \u003ci\u003eOctalDigits\u003c/i\u003e\n     *\n     * \u003cdt\u003e\u003ci\u003eSign:\u003c/i\u003e\n     * \u003cdd\u003e{@code -}\n     * \u003cdd\u003e{@code +}\n     * \u003c/dl\u003e\n     * \u003c/blockquote\u003e\n     *\n     * \u003ci\u003eDecimalNumeral\u003c/i\u003e, \u003ci\u003eHexDigits\u003c/i\u003e, and \u003ci\u003eOctalDigits\u003c/i\u003e\n     * are as defined in section {@jls 3.10.1} of\n     * \u003ccite\u003eThe Java Language Specification\u003c/cite\u003e,\n     * except that underscores are not accepted between digits.\n     *\n     * \u003cp\u003eThe sequence of characters following an optional\n     * sign and/or radix specifier (\"{@code 0x}\", \"{@code 0X}\",\n     * \"{@code #}\", or leading zero) is parsed as by the {@code\n     * Integer.parseInt} method with the indicated radix (10, 16, or\n     * 8).  This sequence of characters must represent a positive\n     * value or a {@link NumberFormatException} will be thrown.  The\n     * result is negated if first character of the specified {@code\n     * String} is the minus sign.  No whitespace characters are\n     * permitted in the {@code String}.\n     *\n     * @param     nm the {@code String} to decode.\n     * @return    an {@code Integer} object holding the {@code int}\n     *             value represented by {@code nm}\n     * @throws    NumberFormatException  if the {@code String} does not\n     *            contain a parsable integer.\n     * @see java.lang.Integer#parseInt(java.lang.String, int)\n     */\n    public static Integer decode(String nm) throws NumberFormatException {\n        int radix \u003d 10;\n        int index \u003d 0;\n        boolean negative \u003d false;\n        Integer result;\n\n        if (nm.isEmpty())\n            throw new NumberFormatException(\"Zero length string\");\n        char firstChar \u003d nm.charAt(0);\n        // Handle sign, if present\n        if (firstChar \u003d\u003d \u0027-\u0027) {\n            negative \u003d true;\n            index++;\n        } else if (firstChar \u003d\u003d \u0027+\u0027)\n            index++;\n\n        // Handle radix specifier, if present\n        if (nm.startsWith(\"0x\", index) || nm.startsWith(\"0X\", index)) {\n            index +\u003d 2;\n            radix \u003d 16;\n        }\n        else if (nm.startsWith(\"#\", index)) {\n            index ++;\n            radix \u003d 16;\n        }\n        else if (nm.startsWith(\"0\", index) \u0026\u0026 nm.length() \u003e 1 + index) {\n            index ++;\n            radix \u003d 8;\n        }\n\n        if (nm.startsWith(\"-\", index) || nm.startsWith(\"+\", index))\n            throw new NumberFormatException(\"Sign character in wrong position\");\n\n        try {\n            result \u003d Integer.valueOf(nm.substring(index), radix);\n            result \u003d negative ? Integer.valueOf(-result.intValue()) : result;\n        } catch (NumberFormatException e) {\n            // If number is Integer.MIN_VALUE, we\u0027ll end up here. The next line\n            // handles this case, and causes any genuine format error to be\n            // rethrown.\n            String constant \u003d negative ? (\"-\" + nm.substring(index))\n                                       : nm.substring(index);\n            result \u003d Integer.valueOf(constant, radix);\n        }\n        return result;\n    }\n\n    /**\n     * Compares two {@code Integer} objects numerically.\n     *\n     * @param   anotherInteger   the {@code Integer} to be compared.\n     * @return  the value {@code 0} if this {@code Integer} is\n     *          equal to the argument {@code Integer}; a value less than\n     *          {@code 0} if this {@code Integer} is numerically less\n     *          than the argument {@code Integer}; and a value greater\n     *          than {@code 0} if this {@code Integer} is numerically\n     *           greater than the argument {@code Integer} (signed\n     *           comparison).\n     * @since   1.2\n     */\n    public int compareTo(Integer anotherInteger) {\n        return compare(this.value, anotherInteger.value);\n    }\n\n    /**\n     * Compares two {@code int} values numerically.\n     * The value returned is identical to what would be returned by:\n     * \u003cpre\u003e\n     *    Integer.valueOf(x).compareTo(Integer.valueOf(y))\n     * \u003c/pre\u003e\n     *\n     * @param  x the first {@code int} to compare\n     * @param  y the second {@code int} to compare\n     * @return the value {@code 0} if {@code x \u003d\u003d y};\n     *         a value less than {@code 0} if {@code x \u003c y}; and\n     *         a value greater than {@code 0} if {@code x \u003e y}\n     * @since 1.7\n     */\n    public static int compare(int x, int y) {\n        return (x \u003c y) ? -1 : ((x \u003d\u003d y) ? 0 : 1);\n    }\n\n    /**\n     * Compares two {@code int} values numerically treating the values\n     * as unsigned.\n     *\n     * @param  x the first {@code int} to compare\n     * @param  y the second {@code int} to compare\n     * @return the value {@code 0} if {@code x \u003d\u003d y}; a value less\n     *         than {@code 0} if {@code x \u003c y} as unsigned values; and\n     *         a value greater than {@code 0} if {@code x \u003e y} as\n     *         unsigned values\n     * @since 1.8\n     */\n    public static int compareUnsigned(int x, int y) {\n        return compare(x + MIN_VALUE, y + MIN_VALUE);\n    }\n\n    /**\n     * Converts the argument to a {@code long} by an unsigned\n     * conversion.  In an unsigned conversion to a {@code long}, the\n     * high-order 32 bits of the {@code long} are zero and the\n     * low-order 32 bits are equal to the bits of the integer\n     * argument.\n     *\n     * Consequently, zero and positive {@code int} values are mapped\n     * to a numerically equal {@code long} value and negative {@code\n     * int} values are mapped to a {@code long} value equal to the\n     * input plus 2\u003csup\u003e32\u003c/sup\u003e.\n     *\n     * @param  x the value to convert to an unsigned {@code long}\n     * @return the argument converted to {@code long} by an unsigned\n     *         conversion\n     * @since 1.8\n     */\n    public static long toUnsignedLong(int x) {\n        return ((long) x) \u0026 0xffffffffL;\n    }\n\n    /**\n     * Returns the unsigned quotient of dividing the first argument by\n     * the second where each argument and the result is interpreted as\n     * an unsigned value.\n     *\n     * \u003cp\u003eNote that in two\u0027s complement arithmetic, the three other\n     * basic arithmetic operations of add, subtract, and multiply are\n     * bit-wise identical if the two operands are regarded as both\n     * being signed or both being unsigned.  Therefore separate {@code\n     * addUnsigned}, etc. methods are not provided.\n     *\n     * @param dividend the value to be divided\n     * @param divisor the value doing the dividing\n     * @return the unsigned quotient of the first argument divided by\n     * the second argument\n     * @see #remainderUnsigned\n     * @since 1.8\n     */\n    public static int divideUnsigned(int dividend, int divisor) {\n        // In lieu of tricky code, for now just use long arithmetic.\n        return (int)(toUnsignedLong(dividend) / toUnsignedLong(divisor));\n    }\n\n    /**\n     * Returns the unsigned remainder from dividing the first argument\n     * by the second where each argument and the result is interpreted\n     * as an unsigned value.\n     *\n     * @param dividend the value to be divided\n     * @param divisor the value doing the dividing\n     * @return the unsigned remainder of the first argument divided by\n     * the second argument\n     * @see #divideUnsigned\n     * @since 1.8\n     */\n    public static int remainderUnsigned(int dividend, int divisor) {\n        // In lieu of tricky code, for now just use long arithmetic.\n        return (int)(toUnsignedLong(dividend) % toUnsignedLong(divisor));\n    }\n\n\n    // Bit twiddling\n\n    /**\n     * The number of bits used to represent an {@code int} value in two\u0027s\n     * complement binary form.\n     *\n     * @since 1.5\n     */\n    @Native public static final int SIZE \u003d 32;\n\n    /**\n     * The number of bytes used to represent an {@code int} value in two\u0027s\n     * complement binary form.\n     *\n     * @since 1.8\n     */\n    public static final int BYTES \u003d SIZE / Byte.SIZE;\n\n    /**\n     * Returns an {@code int} value with at most a single one-bit, in the\n     * position of the highest-order (\"leftmost\") one-bit in the specified\n     * {@code int} value.  Returns zero if the specified value has no\n     * one-bits in its two\u0027s complement binary representation, that is, if it\n     * is equal to zero.\n     *\n     * @param i the value whose highest one bit is to be computed\n     * @return an {@code int} value with a single one-bit, in the position\n     *     of the highest-order one-bit in the specified value, or zero if\n     *     the specified value is itself equal to zero.\n     * @since 1.5\n     */\n    public static int highestOneBit(int i) {\n        return i \u0026 (MIN_VALUE \u003e\u003e\u003e numberOfLeadingZeros(i));\n    }\n\n    /**\n     * Returns an {@code int} value with at most a single one-bit, in the\n     * position of the lowest-order (\"rightmost\") one-bit in the specified\n     * {@code int} value.  Returns zero if the specified value has no\n     * one-bits in its two\u0027s complement binary representation, that is, if it\n     * is equal to zero.\n     *\n     * @param i the value whose lowest one bit is to be computed\n     * @return an {@code int} value with a single one-bit, in the position\n     *     of the lowest-order one-bit in the specified value, or zero if\n     *     the specified value is itself equal to zero.\n     * @since 1.5\n     */\n    public static int lowestOneBit(int i) {\n        // HD, Section 2-1\n        return i \u0026 -i;\n    }\n\n    /**\n     * Returns the number of zero bits preceding the highest-order\n     * (\"leftmost\") one-bit in the two\u0027s complement binary representation\n     * of the specified {@code int} value.  Returns 32 if the\n     * specified value has no one-bits in its two\u0027s complement representation,\n     * in other words if it is equal to zero.\n     *\n     * \u003cp\u003eNote that this method is closely related to the logarithm base 2.\n     * For all positive {@code int} values x:\n     * \u003cul\u003e\n     * \u003cli\u003efloor(log\u003csub\u003e2\u003c/sub\u003e(x)) \u003d {@code 31 - numberOfLeadingZeros(x)}\n     * \u003cli\u003eceil(log\u003csub\u003e2\u003c/sub\u003e(x)) \u003d {@code 32 - numberOfLeadingZeros(x - 1)}\n     * \u003c/ul\u003e\n     *\n     * @param i the value whose number of leading zeros is to be computed\n     * @return the number of zero bits preceding the highest-order\n     *     (\"leftmost\") one-bit in the two\u0027s complement binary representation\n     *     of the specified {@code int} value, or 32 if the value\n     *     is equal to zero.\n     * @since 1.5\n     */\n    @IntrinsicCandidate\n    public static int numberOfLeadingZeros(int i) {\n        // HD, Count leading 0\u0027s\n        if (i \u003c\u003d 0)\n            return i \u003d\u003d 0 ? 32 : 0;\n        int n \u003d 31;\n        if (i \u003e\u003d 1 \u003c\u003c 16) { n -\u003d 16; i \u003e\u003e\u003e\u003d 16; }\n        if (i \u003e\u003d 1 \u003c\u003c  8) { n -\u003d  8; i \u003e\u003e\u003e\u003d  8; }\n        if (i \u003e\u003d 1 \u003c\u003c  4) { n -\u003d  4; i \u003e\u003e\u003e\u003d  4; }\n        if (i \u003e\u003d 1 \u003c\u003c  2) { n -\u003d  2; i \u003e\u003e\u003e\u003d  2; }\n        return n - (i \u003e\u003e\u003e 1);\n    }\n\n    /**\n     * Returns the number of zero bits following the lowest-order (\"rightmost\")\n     * one-bit in the two\u0027s complement binary representation of the specified\n     * {@code int} value.  Returns 32 if the specified value has no\n     * one-bits in its two\u0027s complement representation, in other words if it is\n     * equal to zero.\n     *\n     * @param i the value whose number of trailing zeros is to be computed\n     * @return the number of zero bits following the lowest-order (\"rightmost\")\n     *     one-bit in the two\u0027s complement binary representation of the\n     *     specified {@code int} value, or 32 if the value is equal\n     *     to zero.\n     * @since 1.5\n     */\n    @IntrinsicCandidate\n    public static int numberOfTrailingZeros(int i) {\n        // HD, Count trailing 0\u0027s\n        i \u003d ~i \u0026 (i - 1);\n        if (i \u003c\u003d 0) return i \u0026 32;\n        int n \u003d 1;\n        if (i \u003e 1 \u003c\u003c 16) { n +\u003d 16; i \u003e\u003e\u003e\u003d 16; }\n        if (i \u003e 1 \u003c\u003c  8) { n +\u003d  8; i \u003e\u003e\u003e\u003d  8; }\n        if (i \u003e 1 \u003c\u003c  4) { n +\u003d  4; i \u003e\u003e\u003e\u003d  4; }\n        if (i \u003e 1 \u003c\u003c  2) { n +\u003d  2; i \u003e\u003e\u003e\u003d  2; }\n        return n + (i \u003e\u003e\u003e 1);\n    }\n\n    /**\n     * Returns the number of one-bits in the two\u0027s complement binary\n     * representation of the specified {@code int} value.  This function is\n     * sometimes referred to as the \u003ci\u003epopulation count\u003c/i\u003e.\n     *\n     * @param i the value whose bits are to be counted\n     * @return the number of one-bits in the two\u0027s complement binary\n     *     representation of the specified {@code int} value.\n     * @since 1.5\n     */\n    @IntrinsicCandidate\n    public static int bitCount(int i) {\n        // HD, Figure 5-2\n        i \u003d i - ((i \u003e\u003e\u003e 1) \u0026 0x55555555);\n        i \u003d (i \u0026 0x33333333) + ((i \u003e\u003e\u003e 2) \u0026 0x33333333);\n        i \u003d (i + (i \u003e\u003e\u003e 4)) \u0026 0x0f0f0f0f;\n        i \u003d i + (i \u003e\u003e\u003e 8);\n        i \u003d i + (i \u003e\u003e\u003e 16);\n        return i \u0026 0x3f;\n    }\n\n    /**\n     * Returns the value obtained by rotating the two\u0027s complement binary\n     * representation of the specified {@code int} value left by the\n     * specified number of bits.  (Bits shifted out of the left hand, or\n     * high-order, side reenter on the right, or low-order.)\n     *\n     * \u003cp\u003eNote that left rotation with a negative distance is equivalent to\n     * right rotation: {@code rotateLeft(val, -distance) \u003d\u003d rotateRight(val,\n     * distance)}.  Note also that rotation by any multiple of 32 is a\n     * no-op, so all but the last five bits of the rotation distance can be\n     * ignored, even if the distance is negative: {@code rotateLeft(val,\n     * distance) \u003d\u003d rotateLeft(val, distance \u0026 0x1F)}.\n     *\n     * @param i the value whose bits are to be rotated left\n     * @param distance the number of bit positions to rotate left\n     * @return the value obtained by rotating the two\u0027s complement binary\n     *     representation of the specified {@code int} value left by the\n     *     specified number of bits.\n     * @since 1.5\n     */\n    public static int rotateLeft(int i, int distance) {\n        return (i \u003c\u003c distance) | (i \u003e\u003e\u003e -distance);\n    }\n\n    /**\n     * Returns the value obtained by rotating the two\u0027s complement binary\n     * representation of the specified {@code int} value right by the\n     * specified number of bits.  (Bits shifted out of the right hand, or\n     * low-order, side reenter on the left, or high-order.)\n     *\n     * \u003cp\u003eNote that right rotation with a negative distance is equivalent to\n     * left rotation: {@code rotateRight(val, -distance) \u003d\u003d rotateLeft(val,\n     * distance)}.  Note also that rotation by any multiple of 32 is a\n     * no-op, so all but the last five bits of the rotation distance can be\n     * ignored, even if the distance is negative: {@code rotateRight(val,\n     * distance) \u003d\u003d rotateRight(val, distance \u0026 0x1F)}.\n     *\n     * @param i the value whose bits are to be rotated right\n     * @param distance the number of bit positions to rotate right\n     * @return the value obtained by rotating the two\u0027s complement binary\n     *     representation of the specified {@code int} value right by the\n     *     specified number of bits.\n     * @since 1.5\n     */\n    public static int rotateRight(int i, int distance) {\n        return (i \u003e\u003e\u003e distance) | (i \u003c\u003c -distance);\n    }\n\n    /**\n     * Returns the value obtained by reversing the order of the bits in the\n     * two\u0027s complement binary representation of the specified {@code int}\n     * value.\n     *\n     * @param i the value to be reversed\n     * @return the value obtained by reversing order of the bits in the\n     *     specified {@code int} value.\n     * @since 1.5\n     */\n    public static int reverse(int i) {\n        // HD, Figure 7-1\n        i \u003d (i \u0026 0x55555555) \u003c\u003c 1 | (i \u003e\u003e\u003e 1) \u0026 0x55555555;\n        i \u003d (i \u0026 0x33333333) \u003c\u003c 2 | (i \u003e\u003e\u003e 2) \u0026 0x33333333;\n        i \u003d (i \u0026 0x0f0f0f0f) \u003c\u003c 4 | (i \u003e\u003e\u003e 4) \u0026 0x0f0f0f0f;\n\n        return reverseBytes(i);\n    }\n\n    /**\n     * Returns the signum function of the specified {@code int} value.  (The\n     * return value is -1 if the specified value is negative; 0 if the\n     * specified value is zero; and 1 if the specified value is positive.)\n     *\n     * @param i the value whose signum is to be computed\n     * @return the signum function of the specified {@code int} value.\n     * @since 1.5\n     */\n    public static int signum(int i) {\n        // HD, Section 2-7\n        return (i \u003e\u003e 31) | (-i \u003e\u003e\u003e 31);\n    }\n\n    /**\n     * Returns the value obtained by reversing the order of the bytes in the\n     * two\u0027s complement representation of the specified {@code int} value.\n     *\n     * @param i the value whose bytes are to be reversed\n     * @return the value obtained by reversing the bytes in the specified\n     *     {@code int} value.\n     * @since 1.5\n     */\n    @IntrinsicCandidate\n    public static int reverseBytes(int i) {\n        return (i \u003c\u003c 24)            |\n               ((i \u0026 0xff00) \u003c\u003c 8)  |\n               ((i \u003e\u003e\u003e 8) \u0026 0xff00) |\n               (i \u003e\u003e\u003e 24);\n    }\n\n    /**\n     * Adds two integers together as per the + operator.\n     *\n     * @param a the first operand\n     * @param b the second operand\n     * @return the sum of {@code a} and {@code b}\n     * @see java.util.function.BinaryOperator\n     * @since 1.8\n     */\n    public static int sum(int a, int b) {\n        return a + b;\n    }\n\n    /**\n     * Returns the greater of two {@code int} values\n     * as if by calling {@link Math#max(int, int) Math.max}.\n     *\n     * @param a the first operand\n     * @param b the second operand\n     * @return the greater of {@code a} and {@code b}\n     * @see java.util.function.BinaryOperator\n     * @since 1.8\n     */\n    public static int max(int a, int b) {\n        return Math.max(a, b);\n    }\n\n    /**\n     * Returns the smaller of two {@code int} values\n     * as if by calling {@link Math#min(int, int) Math.min}.\n     *\n     * @param a the first operand\n     * @param b the second operand\n     * @return the smaller of {@code a} and {@code b}\n     * @see java.util.function.BinaryOperator\n     * @since 1.8\n     */\n    public static int min(int a, int b) {\n        return Math.min(a, b);\n    }\n\n    /**\n     * Returns an {@link Optional} containing the nominal descriptor for this\n     * instance, which is the instance itself.\n     *\n     * @return an {@link Optional} describing the {@linkplain Integer} instance\n     * @since 12\n     */\n    @Override\n    public Optional\u003cInteger\u003e describeConstable() {\n        return Optional.of(this);\n    }\n\n    /**\n     * Resolves this instance as a {@link ConstantDesc}, the result of which is\n     * the instance itself.\n     *\n     * @param lookup ignored\n     * @return the {@linkplain Integer} instance\n     * @since 12\n     */\n    @Override\n    public Integer resolveConstantDesc(MethodHandles.Lookup lookup) {\n        return this;\n    }\n\n    /** use serialVersionUID from JDK 1.0.2 for interoperability */\n    @java.io.Serial\n    @Native private static final long serialVersionUID \u003d 1360826667806852920L;\n}\n"
    }
  }
}
java.lang.IllegalArgumentException: Illegal character in opaque part at index 188: jar:file:///C:/Users/Vinicius/AppData/Local/Coursier/cache/arc/https/github.com/adoptium/temurin17-binaries/releases/download/jdk-17%2B35/OpenJDK17-jdk_x64_windows_hotspot_17_35.zip/jdk-17 35/lib/src.zip!/java.base/java/lang/Integer.java
	at java.base/java.net.URI.create(URI.java:906)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:178)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.$anonfun$toAbsolutePath$3(MtagsEnrichments.scala:175)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.withTryDecode$1(MtagsEnrichments.scala:153)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:175)
	at scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:756)
	at scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:753)
	at scala.meta.internal.metals.WorkspaceLspService.didOpen(WorkspaceLspService.scala:388)
	at scala.meta.metals.lsp.DelegatingScalaService.didOpen(DelegatingScalaService.scala:39)
	at jdk.internal.reflect.GeneratedMethodAccessor23.invoke(Unknown Source)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:568)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$recursiveFindRpcMethods$0(GenericEndpoint.java:65)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.notify(GenericEndpoint.java:160)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleNotification(RemoteEndpoint.java:231)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:198)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:185)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:97)
	at org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:114)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:539)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.base/java.lang.Thread.run(Thread.java:833)
Caused by: java.net.URISyntaxException: Illegal character in opaque part at index 188: jar:file:///C:/Users/Vinicius/AppData/Local/Coursier/cache/arc/https/github.com/adoptium/temurin17-binaries/releases/download/jdk-17%2B35/OpenJDK17-jdk_x64_windows_hotspot_17_35.zip/jdk-17 35/lib/src.zip!/java.base/java/lang/Integer.java
	at java.base/java.net.URI$Parser.fail(URI.java:2974)
	at java.base/java.net.URI$Parser.checkChars(URI.java:3145)
	at java.base/java.net.URI$Parser.parse(URI.java:3181)
	at java.base/java.net.URI.<init>(URI.java:623)
	at java.base/java.net.URI.create(URI.java:904)
	... 23 more

jul. 19, 2024 1:04:52 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleNotification
ADVERTÊNCIA: Notification threw an exception: {
  "jsonrpc": "2.0",
  "method": "textDocument/didClose",
  "params": {
    "textDocument": {
      "uri": "jar:file%3A///C%3A/Users/Vinicius/AppData/Local/Coursier/cache/arc/https/github.com/adoptium/temurin17-binaries/releases/download/jdk-17%25252B35/OpenJDK17-jdk_x64_windows_hotspot_17_35.zip/jdk-17%2B35/lib/src.zip%21/java.base/java/lang/Integer.java"
    }
  }
}
java.lang.IllegalArgumentException: Illegal character in opaque part at index 188: jar:file:///C:/Users/Vinicius/AppData/Local/Coursier/cache/arc/https/github.com/adoptium/temurin17-binaries/releases/download/jdk-17%2B35/OpenJDK17-jdk_x64_windows_hotspot_17_35.zip/jdk-17 35/lib/src.zip!/java.base/java/lang/Integer.java
	at java.base/java.net.URI.create(URI.java:906)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:178)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.$anonfun$toAbsolutePath$3(MtagsEnrichments.scala:175)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.withTryDecode$1(MtagsEnrichments.scala:153)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:175)
	at scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:756)
	at scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:753)
	at scala.meta.internal.metals.WorkspaceLspService.didClose(WorkspaceLspService.scala:407)
	at scala.meta.metals.lsp.DelegatingScalaService.didClose(DelegatingScalaService.scala:53)
	at jdk.internal.reflect.GeneratedMethodAccessor26.invoke(Unknown Source)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:568)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$recursiveFindRpcMethods$0(GenericEndpoint.java:65)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.notify(GenericEndpoint.java:160)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleNotification(RemoteEndpoint.java:231)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:198)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:185)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:97)
	at org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:114)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:539)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.base/java.lang.Thread.run(Thread.java:833)
Caused by: java.net.URISyntaxException: Illegal character in opaque part at index 188: jar:file:///C:/Users/Vinicius/AppData/Local/Coursier/cache/arc/https/github.com/adoptium/temurin17-binaries/releases/download/jdk-17%2B35/OpenJDK17-jdk_x64_windows_hotspot_17_35.zip/jdk-17 35/lib/src.zip!/java.base/java/lang/Integer.java
	at java.base/java.net.URI$Parser.fail(URI.java:2974)
	at java.base/java.net.URI$Parser.checkChars(URI.java:3145)
	at java.base/java.net.URI$Parser.parse(URI.java:3181)
	at java.base/java.net.URI.<init>(URI.java:623)
	at java.base/java.net.URI.create(URI.java:904)
	... 23 more

jul. 19, 2024 1:04:52 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleNotification
ADVERTÊNCIA: Notification threw an exception: {
  "jsonrpc": "2.0",
  "method": "textDocument/didOpen",
  "params": {
    "textDocument": {
      "uri": "jar:file%3A///C%3A/Users/Vinicius/AppData/Local/Coursier/cache/arc/https/github.com/adoptium/temurin17-binaries/releases/download/jdk-17%25252B35/OpenJDK17-jdk_x64_windows_hotspot_17_35.zip/jdk-17%2B35/lib/src.zip%21/java.base/java/lang/Integer.java",
      "languageId": "java",
      "version": 1,
      "text": "/*\n * Copyright (c) 1994, 2021, Oracle and/or its affiliates. All rights reserved.\n * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n *\n * This code is free software; you can redistribute it and/or modify it\n * under the terms of the GNU General Public License version 2 only, as\n * published by the Free Software Foundation.  Oracle designates this\n * particular file as subject to the \"Classpath\" exception as provided\n * by Oracle in the LICENSE file that accompanied this code.\n *\n * This code is distributed in the hope that it will be useful, but WITHOUT\n * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n * version 2 for more details (a copy is included in the LICENSE file that\n * accompanied this code).\n *\n * You should have received a copy of the GNU General Public License version\n * 2 along with this work; if not, write to the Free Software Foundation,\n * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n *\n * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n * or visit www.oracle.com if you need additional information or have any\n * questions.\n */\n\npackage java.lang;\n\nimport java.lang.annotation.Native;\nimport java.lang.invoke.MethodHandles;\nimport java.lang.constant.Constable;\nimport java.lang.constant.ConstantDesc;\nimport java.util.Objects;\nimport java.util.Optional;\n\nimport jdk.internal.misc.CDS;\nimport jdk.internal.misc.VM;\nimport jdk.internal.vm.annotation.IntrinsicCandidate;\n\nimport static java.lang.String.COMPACT_STRINGS;\nimport static java.lang.String.LATIN1;\nimport static java.lang.String.UTF16;\n\n/**\n * The {@code Integer} class wraps a value of the primitive type\n * {@code int} in an object. An object of type {@code Integer}\n * contains a single field whose type is {@code int}.\n *\n * \u003cp\u003eIn addition, this class provides several methods for converting\n * an {@code int} to a {@code String} and a {@code String} to an\n * {@code int}, as well as other constants and methods useful when\n * dealing with an {@code int}.\n *\n * \u003cp\u003eThis is a \u003ca href\u003d\"{@docRoot}/java.base/java/lang/doc-files/ValueBased.html\"\u003evalue-based\u003c/a\u003e\n * class; programmers should treat instances that are\n * {@linkplain #equals(Object) equal} as interchangeable and should not\n * use instances for synchronization, or unpredictable behavior may\n * occur. For example, in a future release, synchronization may fail.\n *\n * \u003cp\u003eImplementation note: The implementations of the \"bit twiddling\"\n * methods (such as {@link #highestOneBit(int) highestOneBit} and\n * {@link #numberOfTrailingZeros(int) numberOfTrailingZeros}) are\n * based on material from Henry S. Warren, Jr.\u0027s \u003ci\u003eHacker\u0027s\n * Delight\u003c/i\u003e, (Addison Wesley, 2002).\n *\n * @author  Lee Boynton\n * @author  Arthur van Hoff\n * @author  Josh Bloch\n * @author  Joseph D. Darcy\n * @since 1.0\n */\n@jdk.internal.ValueBased\npublic final class Integer extends Number\n        implements Comparable\u003cInteger\u003e, Constable, ConstantDesc {\n    /**\n     * A constant holding the minimum value an {@code int} can\n     * have, -2\u003csup\u003e31\u003c/sup\u003e.\n     */\n    @Native public static final int   MIN_VALUE \u003d 0x80000000;\n\n    /**\n     * A constant holding the maximum value an {@code int} can\n     * have, 2\u003csup\u003e31\u003c/sup\u003e-1.\n     */\n    @Native public static final int   MAX_VALUE \u003d 0x7fffffff;\n\n    /**\n     * The {@code Class} instance representing the primitive type\n     * {@code int}.\n     *\n     * @since   1.1\n     */\n    @SuppressWarnings(\"unchecked\")\n    public static final Class\u003cInteger\u003e  TYPE \u003d (Class\u003cInteger\u003e) Class.getPrimitiveClass(\"int\");\n\n    /**\n     * All possible chars for representing a number as a String\n     */\n    static final char[] digits \u003d {\n        \u00270\u0027 , \u00271\u0027 , \u00272\u0027 , \u00273\u0027 , \u00274\u0027 , \u00275\u0027 ,\n        \u00276\u0027 , \u00277\u0027 , \u00278\u0027 , \u00279\u0027 , \u0027a\u0027 , \u0027b\u0027 ,\n        \u0027c\u0027 , \u0027d\u0027 , \u0027e\u0027 , \u0027f\u0027 , \u0027g\u0027 , \u0027h\u0027 ,\n        \u0027i\u0027 , \u0027j\u0027 , \u0027k\u0027 , \u0027l\u0027 , \u0027m\u0027 , \u0027n\u0027 ,\n        \u0027o\u0027 , \u0027p\u0027 , \u0027q\u0027 , \u0027r\u0027 , \u0027s\u0027 , \u0027t\u0027 ,\n        \u0027u\u0027 , \u0027v\u0027 , \u0027w\u0027 , \u0027x\u0027 , \u0027y\u0027 , \u0027z\u0027\n    };\n\n    /**\n     * Returns a string representation of the first argument in the\n     * radix specified by the second argument.\n     *\n     * \u003cp\u003eIf the radix is smaller than {@code Character.MIN_RADIX}\n     * or larger than {@code Character.MAX_RADIX}, then the radix\n     * {@code 10} is used instead.\n     *\n     * \u003cp\u003eIf the first argument is negative, the first element of the\n     * result is the ASCII minus character {@code \u0027-\u0027}\n     * ({@code \u0027\\u005Cu002D\u0027}). If the first argument is not\n     * negative, no sign character appears in the result.\n     *\n     * \u003cp\u003eThe remaining characters of the result represent the magnitude\n     * of the first argument. If the magnitude is zero, it is\n     * represented by a single zero character {@code \u00270\u0027}\n     * ({@code \u0027\\u005Cu0030\u0027}); otherwise, the first character of\n     * the representation of the magnitude will not be the zero\n     * character.  The following ASCII characters are used as digits:\n     *\n     * \u003cblockquote\u003e\n     *   {@code 0123456789abcdefghijklmnopqrstuvwxyz}\n     * \u003c/blockquote\u003e\n     *\n     * These are {@code \u0027\\u005Cu0030\u0027} through\n     * {@code \u0027\\u005Cu0039\u0027} and {@code \u0027\\u005Cu0061\u0027} through\n     * {@code \u0027\\u005Cu007A\u0027}. If {@code radix} is\n     * \u003cvar\u003eN\u003c/var\u003e, then the first \u003cvar\u003eN\u003c/var\u003e of these characters\n     * are used as radix-\u003cvar\u003eN\u003c/var\u003e digits in the order shown. Thus,\n     * the digits for hexadecimal (radix 16) are\n     * {@code 0123456789abcdef}. If uppercase letters are\n     * desired, the {@link java.lang.String#toUpperCase()} method may\n     * be called on the result:\n     *\n     * \u003cblockquote\u003e\n     *  {@code Integer.toString(n, 16).toUpperCase()}\n     * \u003c/blockquote\u003e\n     *\n     * @param   i       an integer to be converted to a string.\n     * @param   radix   the radix to use in the string representation.\n     * @return  a string representation of the argument in the specified radix.\n     * @see     java.lang.Character#MAX_RADIX\n     * @see     java.lang.Character#MIN_RADIX\n     */\n    public static String toString(int i, int radix) {\n        if (radix \u003c Character.MIN_RADIX || radix \u003e Character.MAX_RADIX)\n            radix \u003d 10;\n\n        /* Use the faster version */\n        if (radix \u003d\u003d 10) {\n            return toString(i);\n        }\n\n        if (COMPACT_STRINGS) {\n            byte[] buf \u003d new byte[33];\n            boolean negative \u003d (i \u003c 0);\n            int charPos \u003d 32;\n\n            if (!negative) {\n                i \u003d -i;\n            }\n\n            while (i \u003c\u003d -radix) {\n                buf[charPos--] \u003d (byte)digits[-(i % radix)];\n                i \u003d i / radix;\n            }\n            buf[charPos] \u003d (byte)digits[-i];\n\n            if (negative) {\n                buf[--charPos] \u003d \u0027-\u0027;\n            }\n\n            return StringLatin1.newString(buf, charPos, (33 - charPos));\n        }\n        return toStringUTF16(i, radix);\n    }\n\n    private static String toStringUTF16(int i, int radix) {\n        byte[] buf \u003d new byte[33 * 2];\n        boolean negative \u003d (i \u003c 0);\n        int charPos \u003d 32;\n        if (!negative) {\n            i \u003d -i;\n        }\n        while (i \u003c\u003d -radix) {\n            StringUTF16.putChar(buf, charPos--, digits[-(i % radix)]);\n            i \u003d i / radix;\n        }\n        StringUTF16.putChar(buf, charPos, digits[-i]);\n\n        if (negative) {\n            StringUTF16.putChar(buf, --charPos, \u0027-\u0027);\n        }\n        return StringUTF16.newString(buf, charPos, (33 - charPos));\n    }\n\n    /**\n     * Returns a string representation of the first argument as an\n     * unsigned integer value in the radix specified by the second\n     * argument.\n     *\n     * \u003cp\u003eIf the radix is smaller than {@code Character.MIN_RADIX}\n     * or larger than {@code Character.MAX_RADIX}, then the radix\n     * {@code 10} is used instead.\n     *\n     * \u003cp\u003eNote that since the first argument is treated as an unsigned\n     * value, no leading sign character is printed.\n     *\n     * \u003cp\u003eIf the magnitude is zero, it is represented by a single zero\n     * character {@code \u00270\u0027} ({@code \u0027\\u005Cu0030\u0027}); otherwise,\n     * the first character of the representation of the magnitude will\n     * not be the zero character.\n     *\n     * \u003cp\u003eThe behavior of radixes and the characters used as digits\n     * are the same as {@link #toString(int, int) toString}.\n     *\n     * @param   i       an integer to be converted to an unsigned string.\n     * @param   radix   the radix to use in the string representation.\n     * @return  an unsigned string representation of the argument in the specified radix.\n     * @see     #toString(int, int)\n     * @since 1.8\n     */\n    public static String toUnsignedString(int i, int radix) {\n        return Long.toUnsignedString(toUnsignedLong(i), radix);\n    }\n\n    /**\n     * Returns a string representation of the integer argument as an\n     * unsigned integer in base\u0026nbsp;16.\n     *\n     * \u003cp\u003eThe unsigned integer value is the argument plus 2\u003csup\u003e32\u003c/sup\u003e\n     * if the argument is negative; otherwise, it is equal to the\n     * argument.  This value is converted to a string of ASCII digits\n     * in hexadecimal (base\u0026nbsp;16) with no extra leading\n     * {@code 0}s.\n     *\n     * \u003cp\u003eThe value of the argument can be recovered from the returned\n     * string {@code s} by calling {@link\n     * Integer#parseUnsignedInt(String, int)\n     * Integer.parseUnsignedInt(s, 16)}.\n     *\n     * \u003cp\u003eIf the unsigned magnitude is zero, it is represented by a\n     * single zero character {@code \u00270\u0027} ({@code \u0027\\u005Cu0030\u0027});\n     * otherwise, the first character of the representation of the\n     * unsigned magnitude will not be the zero character. The\n     * following characters are used as hexadecimal digits:\n     *\n     * \u003cblockquote\u003e\n     *  {@code 0123456789abcdef}\n     * \u003c/blockquote\u003e\n     *\n     * These are the characters {@code \u0027\\u005Cu0030\u0027} through\n     * {@code \u0027\\u005Cu0039\u0027} and {@code \u0027\\u005Cu0061\u0027} through\n     * {@code \u0027\\u005Cu0066\u0027}. If uppercase letters are\n     * desired, the {@link java.lang.String#toUpperCase()} method may\n     * be called on the result:\n     *\n     * \u003cblockquote\u003e\n     *  {@code Integer.toHexString(n).toUpperCase()}\n     * \u003c/blockquote\u003e\n     *\n     * @apiNote\n     * The {@link java.util.HexFormat} class provides formatting and parsing\n     * of byte arrays and primitives to return a string or adding to an {@link Appendable}.\n     * {@code HexFormat} formats and parses uppercase or lowercase hexadecimal characters,\n     * with leading zeros and for byte arrays includes for each byte\n     * a delimiter, prefix, and suffix.\n     *\n     * @param   i   an integer to be converted to a string.\n     * @return  the string representation of the unsigned integer value\n     *          represented by the argument in hexadecimal (base\u0026nbsp;16).\n     * @see java.util.HexFormat\n     * @see #parseUnsignedInt(String, int)\n     * @see #toUnsignedString(int, int)\n     * @since   1.0.2\n     */\n    public static String toHexString(int i) {\n        return toUnsignedString0(i, 4);\n    }\n\n    /**\n     * Returns a string representation of the integer argument as an\n     * unsigned integer in base\u0026nbsp;8.\n     *\n     * \u003cp\u003eThe unsigned integer value is the argument plus 2\u003csup\u003e32\u003c/sup\u003e\n     * if the argument is negative; otherwise, it is equal to the\n     * argument.  This value is converted to a string of ASCII digits\n     * in octal (base\u0026nbsp;8) with no extra leading {@code 0}s.\n     *\n     * \u003cp\u003eThe value of the argument can be recovered from the returned\n     * string {@code s} by calling {@link\n     * Integer#parseUnsignedInt(String, int)\n     * Integer.parseUnsignedInt(s, 8)}.\n     *\n     * \u003cp\u003eIf the unsigned magnitude is zero, it is represented by a\n     * single zero character {@code \u00270\u0027} ({@code \u0027\\u005Cu0030\u0027});\n     * otherwise, the first character of the representation of the\n     * unsigned magnitude will not be the zero character. The\n     * following characters are used as octal digits:\n     *\n     * \u003cblockquote\u003e\n     * {@code 01234567}\n     * \u003c/blockquote\u003e\n     *\n     * These are the characters {@code \u0027\\u005Cu0030\u0027} through\n     * {@code \u0027\\u005Cu0037\u0027}.\n     *\n     * @param   i   an integer to be converted to a string.\n     * @return  the string representation of the unsigned integer value\n     *          represented by the argument in octal (base\u0026nbsp;8).\n     * @see #parseUnsignedInt(String, int)\n     * @see #toUnsignedString(int, int)\n     * @since   1.0.2\n     */\n    public static String toOctalString(int i) {\n        return toUnsignedString0(i, 3);\n    }\n\n    /**\n     * Returns a string representation of the integer argument as an\n     * unsigned integer in base\u0026nbsp;2.\n     *\n     * \u003cp\u003eThe unsigned integer value is the argument plus 2\u003csup\u003e32\u003c/sup\u003e\n     * if the argument is negative; otherwise it is equal to the\n     * argument.  This value is converted to a string of ASCII digits\n     * in binary (base\u0026nbsp;2) with no extra leading {@code 0}s.\n     *\n     * \u003cp\u003eThe value of the argument can be recovered from the returned\n     * string {@code s} by calling {@link\n     * Integer#parseUnsignedInt(String, int)\n     * Integer.parseUnsignedInt(s, 2)}.\n     *\n     * \u003cp\u003eIf the unsigned magnitude is zero, it is represented by a\n     * single zero character {@code \u00270\u0027} ({@code \u0027\\u005Cu0030\u0027});\n     * otherwise, the first character of the representation of the\n     * unsigned magnitude will not be the zero character. The\n     * characters {@code \u00270\u0027} ({@code \u0027\\u005Cu0030\u0027}) and {@code\n     * \u00271\u0027} ({@code \u0027\\u005Cu0031\u0027}) are used as binary digits.\n     *\n     * @param   i   an integer to be converted to a string.\n     * @return  the string representation of the unsigned integer value\n     *          represented by the argument in binary (base\u0026nbsp;2).\n     * @see #parseUnsignedInt(String, int)\n     * @see #toUnsignedString(int, int)\n     * @since   1.0.2\n     */\n    public static String toBinaryString(int i) {\n        return toUnsignedString0(i, 1);\n    }\n\n    /**\n     * Convert the integer to an unsigned number.\n     */\n    private static String toUnsignedString0(int val, int shift) {\n        // assert shift \u003e 0 \u0026\u0026 shift \u003c\u003d5 : \"Illegal shift value\";\n        int mag \u003d Integer.SIZE - Integer.numberOfLeadingZeros(val);\n        int chars \u003d Math.max(((mag + (shift - 1)) / shift), 1);\n        if (COMPACT_STRINGS) {\n            byte[] buf \u003d new byte[chars];\n            formatUnsignedInt(val, shift, buf, chars);\n            return new String(buf, LATIN1);\n        } else {\n            byte[] buf \u003d new byte[chars * 2];\n            formatUnsignedIntUTF16(val, shift, buf, chars);\n            return new String(buf, UTF16);\n        }\n    }\n\n    /**\n     * Format an {@code int} (treated as unsigned) into a byte buffer (LATIN1 version). If\n     * {@code len} exceeds the formatted ASCII representation of {@code val},\n     * {@code buf} will be padded with leading zeroes.\n     *\n     * @param val the unsigned int to format\n     * @param shift the log2 of the base to format in (4 for hex, 3 for octal, 1 for binary)\n     * @param buf the byte buffer to write to\n     * @param len the number of characters to write\n     */\n    private static void formatUnsignedInt(int val, int shift, byte[] buf, int len) {\n        int charPos \u003d len;\n        int radix \u003d 1 \u003c\u003c shift;\n        int mask \u003d radix - 1;\n        do {\n            buf[--charPos] \u003d (byte)Integer.digits[val \u0026 mask];\n            val \u003e\u003e\u003e\u003d shift;\n        } while (charPos \u003e 0);\n    }\n\n    /**\n     * Format an {@code int} (treated as unsigned) into a byte buffer (UTF16 version). If\n     * {@code len} exceeds the formatted ASCII representation of {@code val},\n     * {@code buf} will be padded with leading zeroes.\n     *\n     * @param val the unsigned int to format\n     * @param shift the log2 of the base to format in (4 for hex, 3 for octal, 1 for binary)\n     * @param buf the byte buffer to write to\n     * @param len the number of characters to write\n     */\n    private static void formatUnsignedIntUTF16(int val, int shift, byte[] buf, int len) {\n        int charPos \u003d len;\n        int radix \u003d 1 \u003c\u003c shift;\n        int mask \u003d radix - 1;\n        do {\n            StringUTF16.putChar(buf, --charPos, Integer.digits[val \u0026 mask]);\n            val \u003e\u003e\u003e\u003d shift;\n        } while (charPos \u003e 0);\n    }\n\n    static final byte[] DigitTens \u003d {\n        \u00270\u0027, \u00270\u0027, \u00270\u0027, \u00270\u0027, \u00270\u0027, \u00270\u0027, \u00270\u0027, \u00270\u0027, \u00270\u0027, \u00270\u0027,\n        \u00271\u0027, \u00271\u0027, \u00271\u0027, \u00271\u0027, \u00271\u0027, \u00271\u0027, \u00271\u0027, \u00271\u0027, \u00271\u0027, \u00271\u0027,\n        \u00272\u0027, \u00272\u0027, \u00272\u0027, \u00272\u0027, \u00272\u0027, \u00272\u0027, \u00272\u0027, \u00272\u0027, \u00272\u0027, \u00272\u0027,\n        \u00273\u0027, \u00273\u0027, \u00273\u0027, \u00273\u0027, \u00273\u0027, \u00273\u0027, \u00273\u0027, \u00273\u0027, \u00273\u0027, \u00273\u0027,\n        \u00274\u0027, \u00274\u0027, \u00274\u0027, \u00274\u0027, \u00274\u0027, \u00274\u0027, \u00274\u0027, \u00274\u0027, \u00274\u0027, \u00274\u0027,\n        \u00275\u0027, \u00275\u0027, \u00275\u0027, \u00275\u0027, \u00275\u0027, \u00275\u0027, \u00275\u0027, \u00275\u0027, \u00275\u0027, \u00275\u0027,\n        \u00276\u0027, \u00276\u0027, \u00276\u0027, \u00276\u0027, \u00276\u0027, \u00276\u0027, \u00276\u0027, \u00276\u0027, \u00276\u0027, \u00276\u0027,\n        \u00277\u0027, \u00277\u0027, \u00277\u0027, \u00277\u0027, \u00277\u0027, \u00277\u0027, \u00277\u0027, \u00277\u0027, \u00277\u0027, \u00277\u0027,\n        \u00278\u0027, \u00278\u0027, \u00278\u0027, \u00278\u0027, \u00278\u0027, \u00278\u0027, \u00278\u0027, \u00278\u0027, \u00278\u0027, \u00278\u0027,\n        \u00279\u0027, \u00279\u0027, \u00279\u0027, \u00279\u0027, \u00279\u0027, \u00279\u0027, \u00279\u0027, \u00279\u0027, \u00279\u0027, \u00279\u0027,\n        } ;\n\n    static final byte[] DigitOnes \u003d {\n        \u00270\u0027, \u00271\u0027, \u00272\u0027, \u00273\u0027, \u00274\u0027, \u00275\u0027, \u00276\u0027, \u00277\u0027, \u00278\u0027, \u00279\u0027,\n        \u00270\u0027, \u00271\u0027, \u00272\u0027, \u00273\u0027, \u00274\u0027, \u00275\u0027, \u00276\u0027, \u00277\u0027, \u00278\u0027, \u00279\u0027,\n        \u00270\u0027, \u00271\u0027, \u00272\u0027, \u00273\u0027, \u00274\u0027, \u00275\u0027, \u00276\u0027, \u00277\u0027, \u00278\u0027, \u00279\u0027,\n        \u00270\u0027, \u00271\u0027, \u00272\u0027, \u00273\u0027, \u00274\u0027, \u00275\u0027, \u00276\u0027, \u00277\u0027, \u00278\u0027, \u00279\u0027,\n        \u00270\u0027, \u00271\u0027, \u00272\u0027, \u00273\u0027, \u00274\u0027, \u00275\u0027, \u00276\u0027, \u00277\u0027, \u00278\u0027, \u00279\u0027,\n        \u00270\u0027, \u00271\u0027, \u00272\u0027, \u00273\u0027, \u00274\u0027, \u00275\u0027, \u00276\u0027, \u00277\u0027, \u00278\u0027, \u00279\u0027,\n        \u00270\u0027, \u00271\u0027, \u00272\u0027, \u00273\u0027, \u00274\u0027, \u00275\u0027, \u00276\u0027, \u00277\u0027, \u00278\u0027, \u00279\u0027,\n        \u00270\u0027, \u00271\u0027, \u00272\u0027, \u00273\u0027, \u00274\u0027, \u00275\u0027, \u00276\u0027, \u00277\u0027, \u00278\u0027, \u00279\u0027,\n        \u00270\u0027, \u00271\u0027, \u00272\u0027, \u00273\u0027, \u00274\u0027, \u00275\u0027, \u00276\u0027, \u00277\u0027, \u00278\u0027, \u00279\u0027,\n        \u00270\u0027, \u00271\u0027, \u00272\u0027, \u00273\u0027, \u00274\u0027, \u00275\u0027, \u00276\u0027, \u00277\u0027, \u00278\u0027, \u00279\u0027,\n        } ;\n\n\n    /**\n     * Returns a {@code String} object representing the\n     * specified integer. The argument is converted to signed decimal\n     * representation and returned as a string, exactly as if the\n     * argument and radix 10 were given as arguments to the {@link\n     * #toString(int, int)} method.\n     *\n     * @param   i   an integer to be converted.\n     * @return  a string representation of the argument in base\u0026nbsp;10.\n     */\n    @IntrinsicCandidate\n    public static String toString(int i) {\n        int size \u003d stringSize(i);\n        if (COMPACT_STRINGS) {\n            byte[] buf \u003d new byte[size];\n            getChars(i, size, buf);\n            return new String(buf, LATIN1);\n        } else {\n            byte[] buf \u003d new byte[size * 2];\n            StringUTF16.getChars(i, size, buf);\n            return new String(buf, UTF16);\n        }\n    }\n\n    /**\n     * Returns a string representation of the argument as an unsigned\n     * decimal value.\n     *\n     * The argument is converted to unsigned decimal representation\n     * and returned as a string exactly as if the argument and radix\n     * 10 were given as arguments to the {@link #toUnsignedString(int,\n     * int)} method.\n     *\n     * @param   i  an integer to be converted to an unsigned string.\n     * @return  an unsigned string representation of the argument.\n     * @see     #toUnsignedString(int, int)\n     * @since 1.8\n     */\n    public static String toUnsignedString(int i) {\n        return Long.toString(toUnsignedLong(i));\n    }\n\n    /**\n     * Places characters representing the integer i into the\n     * character array buf. The characters are placed into\n     * the buffer backwards starting with the least significant\n     * digit at the specified index (exclusive), and working\n     * backwards from there.\n     *\n     * @implNote This method converts positive inputs into negative\n     * values, to cover the Integer.MIN_VALUE case. Converting otherwise\n     * (negative to positive) will expose -Integer.MIN_VALUE that overflows\n     * integer.\n     *\n     * @param i     value to convert\n     * @param index next index, after the least significant digit\n     * @param buf   target buffer, Latin1-encoded\n     * @return index of the most significant digit or minus sign, if present\n     */\n    static int getChars(int i, int index, byte[] buf) {\n        int q, r;\n        int charPos \u003d index;\n\n        boolean negative \u003d i \u003c 0;\n        if (!negative) {\n            i \u003d -i;\n        }\n\n        // Generate two digits per iteration\n        while (i \u003c\u003d -100) {\n            q \u003d i / 100;\n            r \u003d (q * 100) - i;\n            i \u003d q;\n            buf[--charPos] \u003d DigitOnes[r];\n            buf[--charPos] \u003d DigitTens[r];\n        }\n\n        // We know there are at most two digits left at this point.\n        q \u003d i / 10;\n        r \u003d (q * 10) - i;\n        buf[--charPos] \u003d (byte)(\u00270\u0027 + r);\n\n        // Whatever left is the remaining digit.\n        if (q \u003c 0) {\n            buf[--charPos] \u003d (byte)(\u00270\u0027 - q);\n        }\n\n        if (negative) {\n            buf[--charPos] \u003d (byte)\u0027-\u0027;\n        }\n        return charPos;\n    }\n\n    // Left here for compatibility reasons, see JDK-8143900.\n    static final int [] sizeTable \u003d { 9, 99, 999, 9999, 99999, 999999, 9999999,\n                                      99999999, 999999999, Integer.MAX_VALUE };\n\n    /**\n     * Returns the string representation size for a given int value.\n     *\n     * @param x int value\n     * @return string size\n     *\n     * @implNote There are other ways to compute this: e.g. binary search,\n     * but values are biased heavily towards zero, and therefore linear search\n     * wins. The iteration results are also routinely inlined in the generated\n     * code after loop unrolling.\n     */\n    static int stringSize(int x) {\n        int d \u003d 1;\n        if (x \u003e\u003d 0) {\n            d \u003d 0;\n            x \u003d -x;\n        }\n        int p \u003d -10;\n        for (int i \u003d 1; i \u003c 10; i++) {\n            if (x \u003e p)\n                return i + d;\n            p \u003d 10 * p;\n        }\n        return 10 + d;\n    }\n\n    /**\n     * Parses the string argument as a signed integer in the radix\n     * specified by the second argument. The characters in the string\n     * must all be digits of the specified radix (as determined by\n     * whether {@link java.lang.Character#digit(char, int)} returns a\n     * nonnegative value), except that the first character may be an\n     * ASCII minus sign {@code \u0027-\u0027} ({@code \u0027\\u005Cu002D\u0027}) to\n     * indicate a negative value or an ASCII plus sign {@code \u0027+\u0027}\n     * ({@code \u0027\\u005Cu002B\u0027}) to indicate a positive value. The\n     * resulting integer value is returned.\n     *\n     * \u003cp\u003eAn exception of type {@code NumberFormatException} is\n     * thrown if any of the following situations occurs:\n     * \u003cul\u003e\n     * \u003cli\u003eThe first argument is {@code null} or is a string of\n     * length zero.\n     *\n     * \u003cli\u003eThe radix is either smaller than\n     * {@link java.lang.Character#MIN_RADIX} or\n     * larger than {@link java.lang.Character#MAX_RADIX}.\n     *\n     * \u003cli\u003eAny character of the string is not a digit of the specified\n     * radix, except that the first character may be a minus sign\n     * {@code \u0027-\u0027} ({@code \u0027\\u005Cu002D\u0027}) or plus sign\n     * {@code \u0027+\u0027} ({@code \u0027\\u005Cu002B\u0027}) provided that the\n     * string is longer than length 1.\n     *\n     * \u003cli\u003eThe value represented by the string is not a value of type\n     * {@code int}.\n     * \u003c/ul\u003e\n     *\n     * \u003cp\u003eExamples:\n     * \u003cblockquote\u003e\u003cpre\u003e\n     * parseInt(\"0\", 10) returns 0\n     * parseInt(\"473\", 10) returns 473\n     * parseInt(\"+42\", 10) returns 42\n     * parseInt(\"-0\", 10) returns 0\n     * parseInt(\"-FF\", 16) returns -255\n     * parseInt(\"1100110\", 2) returns 102\n     * parseInt(\"2147483647\", 10) returns 2147483647\n     * parseInt(\"-2147483648\", 10) returns -2147483648\n     * parseInt(\"2147483648\", 10) throws a NumberFormatException\n     * parseInt(\"99\", 8) throws a NumberFormatException\n     * parseInt(\"Kona\", 10) throws a NumberFormatException\n     * parseInt(\"Kona\", 27) returns 411787\n     * \u003c/pre\u003e\u003c/blockquote\u003e\n     *\n     * @param      s   the {@code String} containing the integer\n     *                  representation to be parsed\n     * @param      radix   the radix to be used while parsing {@code s}.\n     * @return     the integer represented by the string argument in the\n     *             specified radix.\n     * @throws     NumberFormatException if the {@code String}\n     *             does not contain a parsable {@code int}.\n     */\n    public static int parseInt(String s, int radix)\n                throws NumberFormatException\n    {\n        /*\n         * WARNING: This method may be invoked early during VM initialization\n         * before IntegerCache is initialized. Care must be taken to not use\n         * the valueOf method.\n         */\n\n        if (s \u003d\u003d null) {\n            throw new NumberFormatException(\"Cannot parse null string\");\n        }\n\n        if (radix \u003c Character.MIN_RADIX) {\n            throw new NumberFormatException(\"radix \" + radix +\n                                            \" less than Character.MIN_RADIX\");\n        }\n\n        if (radix \u003e Character.MAX_RADIX) {\n            throw new NumberFormatException(\"radix \" + radix +\n                                            \" greater than Character.MAX_RADIX\");\n        }\n\n        boolean negative \u003d false;\n        int i \u003d 0, len \u003d s.length();\n        int limit \u003d -Integer.MAX_VALUE;\n\n        if (len \u003e 0) {\n            char firstChar \u003d s.charAt(0);\n            if (firstChar \u003c \u00270\u0027) { // Possible leading \"+\" or \"-\"\n                if (firstChar \u003d\u003d \u0027-\u0027) {\n                    negative \u003d true;\n                    limit \u003d Integer.MIN_VALUE;\n                } else if (firstChar !\u003d \u0027+\u0027) {\n                    throw NumberFormatException.forInputString(s, radix);\n                }\n\n                if (len \u003d\u003d 1) { // Cannot have lone \"+\" or \"-\"\n                    throw NumberFormatException.forInputString(s, radix);\n                }\n                i++;\n            }\n            int multmin \u003d limit / radix;\n            int result \u003d 0;\n            while (i \u003c len) {\n                // Accumulating negatively avoids surprises near MAX_VALUE\n                int digit \u003d Character.digit(s.charAt(i++), radix);\n                if (digit \u003c 0 || result \u003c multmin) {\n                    throw NumberFormatException.forInputString(s, radix);\n                }\n                result *\u003d radix;\n                if (result \u003c limit + digit) {\n                    throw NumberFormatException.forInputString(s, radix);\n                }\n                result -\u003d digit;\n            }\n            return negative ? result : -result;\n        } else {\n            throw NumberFormatException.forInputString(s, radix);\n        }\n    }\n\n    /**\n     * Parses the {@link CharSequence} argument as a signed {@code int} in the\n     * specified {@code radix}, beginning at the specified {@code beginIndex}\n     * and extending to {@code endIndex - 1}.\n     *\n     * \u003cp\u003eThe method does not take steps to guard against the\n     * {@code CharSequence} being mutated while parsing.\n     *\n     * @param      s   the {@code CharSequence} containing the {@code int}\n     *                  representation to be parsed\n     * @param      beginIndex   the beginning index, inclusive.\n     * @param      endIndex     the ending index, exclusive.\n     * @param      radix   the radix to be used while parsing {@code s}.\n     * @return     the signed {@code int} represented by the subsequence in\n     *             the specified radix.\n     * @throws     NullPointerException  if {@code s} is null.\n     * @throws     IndexOutOfBoundsException  if {@code beginIndex} is\n     *             negative, or if {@code beginIndex} is greater than\n     *             {@code endIndex} or if {@code endIndex} is greater than\n     *             {@code s.length()}.\n     * @throws     NumberFormatException  if the {@code CharSequence} does not\n     *             contain a parsable {@code int} in the specified\n     *             {@code radix}, or if {@code radix} is either smaller than\n     *             {@link java.lang.Character#MIN_RADIX} or larger than\n     *             {@link java.lang.Character#MAX_RADIX}.\n     * @since  9\n     */\n    public static int parseInt(CharSequence s, int beginIndex, int endIndex, int radix)\n                throws NumberFormatException {\n        Objects.requireNonNull(s);\n\n        if (beginIndex \u003c 0 || beginIndex \u003e endIndex || endIndex \u003e s.length()) {\n            throw new IndexOutOfBoundsException();\n        }\n        if (radix \u003c Character.MIN_RADIX) {\n            throw new NumberFormatException(\"radix \" + radix +\n                                            \" less than Character.MIN_RADIX\");\n        }\n        if (radix \u003e Character.MAX_RADIX) {\n            throw new NumberFormatException(\"radix \" + radix +\n                                            \" greater than Character.MAX_RADIX\");\n        }\n\n        boolean negative \u003d false;\n        int i \u003d beginIndex;\n        int limit \u003d -Integer.MAX_VALUE;\n\n        if (i \u003c endIndex) {\n            char firstChar \u003d s.charAt(i);\n            if (firstChar \u003c \u00270\u0027) { // Possible leading \"+\" or \"-\"\n                if (firstChar \u003d\u003d \u0027-\u0027) {\n                    negative \u003d true;\n                    limit \u003d Integer.MIN_VALUE;\n                } else if (firstChar !\u003d \u0027+\u0027) {\n                    throw NumberFormatException.forCharSequence(s, beginIndex,\n                            endIndex, i);\n                }\n                i++;\n                if (i \u003d\u003d endIndex) { // Cannot have lone \"+\" or \"-\"\n                    throw NumberFormatException.forCharSequence(s, beginIndex,\n                            endIndex, i);\n                }\n            }\n            int multmin \u003d limit / radix;\n            int result \u003d 0;\n            while (i \u003c endIndex) {\n                // Accumulating negatively avoids surprises near MAX_VALUE\n                int digit \u003d Character.digit(s.charAt(i), radix);\n                if (digit \u003c 0 || result \u003c multmin) {\n                    throw NumberFormatException.forCharSequence(s, beginIndex,\n                            endIndex, i);\n                }\n                result *\u003d radix;\n                if (result \u003c limit + digit) {\n                    throw NumberFormatException.forCharSequence(s, beginIndex,\n                            endIndex, i);\n                }\n                i++;\n                result -\u003d digit;\n            }\n            return negative ? result : -result;\n        } else {\n            throw NumberFormatException.forInputString(\"\", radix);\n        }\n    }\n\n    /**\n     * Parses the string argument as a signed decimal integer. The\n     * characters in the string must all be decimal digits, except\n     * that the first character may be an ASCII minus sign {@code \u0027-\u0027}\n     * ({@code \u0027\\u005Cu002D\u0027}) to indicate a negative value or an\n     * ASCII plus sign {@code \u0027+\u0027} ({@code \u0027\\u005Cu002B\u0027}) to\n     * indicate a positive value. The resulting integer value is\n     * returned, exactly as if the argument and the radix 10 were\n     * given as arguments to the {@link #parseInt(java.lang.String,\n     * int)} method.\n     *\n     * @param s    a {@code String} containing the {@code int}\n     *             representation to be parsed\n     * @return     the integer value represented by the argument in decimal.\n     * @throws     NumberFormatException  if the string does not contain a\n     *               parsable integer.\n     */\n    public static int parseInt(String s) throws NumberFormatException {\n        return parseInt(s,10);\n    }\n\n    /**\n     * Parses the string argument as an unsigned integer in the radix\n     * specified by the second argument.  An unsigned integer maps the\n     * values usually associated with negative numbers to positive\n     * numbers larger than {@code MAX_VALUE}.\n     *\n     * The characters in the string must all be digits of the\n     * specified radix (as determined by whether {@link\n     * java.lang.Character#digit(char, int)} returns a nonnegative\n     * value), except that the first character may be an ASCII plus\n     * sign {@code \u0027+\u0027} ({@code \u0027\\u005Cu002B\u0027}). The resulting\n     * integer value is returned.\n     *\n     * \u003cp\u003eAn exception of type {@code NumberFormatException} is\n     * thrown if any of the following situations occurs:\n     * \u003cul\u003e\n     * \u003cli\u003eThe first argument is {@code null} or is a string of\n     * length zero.\n     *\n     * \u003cli\u003eThe radix is either smaller than\n     * {@link java.lang.Character#MIN_RADIX} or\n     * larger than {@link java.lang.Character#MAX_RADIX}.\n     *\n     * \u003cli\u003eAny character of the string is not a digit of the specified\n     * radix, except that the first character may be a plus sign\n     * {@code \u0027+\u0027} ({@code \u0027\\u005Cu002B\u0027}) provided that the\n     * string is longer than length 1.\n     *\n     * \u003cli\u003eThe value represented by the string is larger than the\n     * largest unsigned {@code int}, 2\u003csup\u003e32\u003c/sup\u003e-1.\n     *\n     * \u003c/ul\u003e\n     *\n     *\n     * @param      s   the {@code String} containing the unsigned integer\n     *                  representation to be parsed\n     * @param      radix   the radix to be used while parsing {@code s}.\n     * @return     the integer represented by the string argument in the\n     *             specified radix.\n     * @throws     NumberFormatException if the {@code String}\n     *             does not contain a parsable {@code int}.\n     * @since 1.8\n     */\n    public static int parseUnsignedInt(String s, int radix)\n                throws NumberFormatException {\n        if (s \u003d\u003d null)  {\n            throw new NumberFormatException(\"Cannot parse null string\");\n        }\n\n        int len \u003d s.length();\n        if (len \u003e 0) {\n            char firstChar \u003d s.charAt(0);\n            if (firstChar \u003d\u003d \u0027-\u0027) {\n                throw new\n                    NumberFormatException(String.format(\"Illegal leading minus sign \" +\n                                                       \"on unsigned string %s.\", s));\n            } else {\n                if (len \u003c\u003d 5 || // Integer.MAX_VALUE in Character.MAX_RADIX is 6 digits\n                    (radix \u003d\u003d 10 \u0026\u0026 len \u003c\u003d 9) ) { // Integer.MAX_VALUE in base 10 is 10 digits\n                    return parseInt(s, radix);\n                } else {\n                    long ell \u003d Long.parseLong(s, radix);\n                    if ((ell \u0026 0xffff_ffff_0000_0000L) \u003d\u003d 0) {\n                        return (int) ell;\n                    } else {\n                        throw new\n                            NumberFormatException(String.format(\"String value %s exceeds \" +\n                                                                \"range of unsigned int.\", s));\n                    }\n                }\n            }\n        } else {\n            throw NumberFormatException.forInputString(s, radix);\n        }\n    }\n\n    /**\n     * Parses the {@link CharSequence} argument as an unsigned {@code int} in\n     * the specified {@code radix}, beginning at the specified\n     * {@code beginIndex} and extending to {@code endIndex - 1}.\n     *\n     * \u003cp\u003eThe method does not take steps to guard against the\n     * {@code CharSequence} being mutated while parsing.\n     *\n     * @param      s   the {@code CharSequence} containing the unsigned\n     *                 {@code int} representation to be parsed\n     * @param      beginIndex   the beginning index, inclusive.\n     * @param      endIndex     the ending index, exclusive.\n     * @param      radix   the radix to be used while parsing {@code s}.\n     * @return     the unsigned {@code int} represented by the subsequence in\n     *             the specified radix.\n     * @throws     NullPointerException  if {@code s} is null.\n     * @throws     IndexOutOfBoundsException  if {@code beginIndex} is\n     *             negative, or if {@code beginIndex} is greater than\n     *             {@code endIndex} or if {@code endIndex} is greater than\n     *             {@code s.length()}.\n     * @throws     NumberFormatException  if the {@code CharSequence} does not\n     *             contain a parsable unsigned {@code int} in the specified\n     *             {@code radix}, or if {@code radix} is either smaller than\n     *             {@link java.lang.Character#MIN_RADIX} or larger than\n     *             {@link java.lang.Character#MAX_RADIX}.\n     * @since  9\n     */\n    public static int parseUnsignedInt(CharSequence s, int beginIndex, int endIndex, int radix)\n                throws NumberFormatException {\n        Objects.requireNonNull(s);\n\n        if (beginIndex \u003c 0 || beginIndex \u003e endIndex || endIndex \u003e s.length()) {\n            throw new IndexOutOfBoundsException();\n        }\n        int start \u003d beginIndex, len \u003d endIndex - beginIndex;\n\n        if (len \u003e 0) {\n            char firstChar \u003d s.charAt(start);\n            if (firstChar \u003d\u003d \u0027-\u0027) {\n                throw new\n                    NumberFormatException(String.format(\"Illegal leading minus sign \" +\n                                                       \"on unsigned string %s.\", s));\n            } else {\n                if (len \u003c\u003d 5 || // Integer.MAX_VALUE in Character.MAX_RADIX is 6 digits\n                        (radix \u003d\u003d 10 \u0026\u0026 len \u003c\u003d 9)) { // Integer.MAX_VALUE in base 10 is 10 digits\n                    return parseInt(s, start, start + len, radix);\n                } else {\n                    long ell \u003d Long.parseLong(s, start, start + len, radix);\n                    if ((ell \u0026 0xffff_ffff_0000_0000L) \u003d\u003d 0) {\n                        return (int) ell;\n                    } else {\n                        throw new\n                            NumberFormatException(String.format(\"String value %s exceeds \" +\n                                                                \"range of unsigned int.\", s));\n                    }\n                }\n            }\n        } else {\n            throw new NumberFormatException(\"\");\n        }\n    }\n\n    /**\n     * Parses the string argument as an unsigned decimal integer. The\n     * characters in the string must all be decimal digits, except\n     * that the first character may be an ASCII plus sign {@code\n     * \u0027+\u0027} ({@code \u0027\\u005Cu002B\u0027}). The resulting integer value\n     * is returned, exactly as if the argument and the radix 10 were\n     * given as arguments to the {@link\n     * #parseUnsignedInt(java.lang.String, int)} method.\n     *\n     * @param s   a {@code String} containing the unsigned {@code int}\n     *            representation to be parsed\n     * @return    the unsigned integer value represented by the argument in decimal.\n     * @throws    NumberFormatException  if the string does not contain a\n     *            parsable unsigned integer.\n     * @since 1.8\n     */\n    public static int parseUnsignedInt(String s) throws NumberFormatException {\n        return parseUnsignedInt(s, 10);\n    }\n\n    /**\n     * Returns an {@code Integer} object holding the value\n     * extracted from the specified {@code String} when parsed\n     * with the radix given by the second argument. The first argument\n     * is interpreted as representing a signed integer in the radix\n     * specified by the second argument, exactly as if the arguments\n     * were given to the {@link #parseInt(java.lang.String, int)}\n     * method. The result is an {@code Integer} object that\n     * represents the integer value specified by the string.\n     *\n     * \u003cp\u003eIn other words, this method returns an {@code Integer}\n     * object equal to the value of:\n     *\n     * \u003cblockquote\u003e\n     *  {@code new Integer(Integer.parseInt(s, radix))}\n     * \u003c/blockquote\u003e\n     *\n     * @param      s   the string to be parsed.\n     * @param      radix the radix to be used in interpreting {@code s}\n     * @return     an {@code Integer} object holding the value\n     *             represented by the string argument in the specified\n     *             radix.\n     * @throws    NumberFormatException if the {@code String}\n     *            does not contain a parsable {@code int}.\n     */\n    public static Integer valueOf(String s, int radix) throws NumberFormatException {\n        return Integer.valueOf(parseInt(s,radix));\n    }\n\n    /**\n     * Returns an {@code Integer} object holding the\n     * value of the specified {@code String}. The argument is\n     * interpreted as representing a signed decimal integer, exactly\n     * as if the argument were given to the {@link\n     * #parseInt(java.lang.String)} method. The result is an\n     * {@code Integer} object that represents the integer value\n     * specified by the string.\n     *\n     * \u003cp\u003eIn other words, this method returns an {@code Integer}\n     * object equal to the value of:\n     *\n     * \u003cblockquote\u003e\n     *  {@code new Integer(Integer.parseInt(s))}\n     * \u003c/blockquote\u003e\n     *\n     * @param      s   the string to be parsed.\n     * @return     an {@code Integer} object holding the value\n     *             represented by the string argument.\n     * @throws     NumberFormatException  if the string cannot be parsed\n     *             as an integer.\n     */\n    public static Integer valueOf(String s) throws NumberFormatException {\n        return Integer.valueOf(parseInt(s, 10));\n    }\n\n    /**\n     * Cache to support the object identity semantics of autoboxing for values between\n     * -128 and 127 (inclusive) as required by JLS.\n     *\n     * The cache is initialized on first usage.  The size of the cache\n     * may be controlled by the {@code -XX:AutoBoxCacheMax\u003d\u003csize\u003e} option.\n     * During VM initialization, java.lang.Integer.IntegerCache.high property\n     * may be set and saved in the private system properties in the\n     * jdk.internal.misc.VM class.\n     *\n     * WARNING: The cache is archived with CDS and reloaded from the shared\n     * archive at runtime. The archived cache (Integer[]) and Integer objects\n     * reside in the closed archive heap regions. Care should be taken when\n     * changing the implementation and the cache array should not be assigned\n     * with new Integer object(s) after initialization.\n     */\n\n    private static class IntegerCache {\n        static final int low \u003d -128;\n        static final int high;\n        static final Integer[] cache;\n        static Integer[] archivedCache;\n\n        static {\n            // high value may be configured by property\n            int h \u003d 127;\n            String integerCacheHighPropValue \u003d\n                VM.getSavedProperty(\"java.lang.Integer.IntegerCache.high\");\n            if (integerCacheHighPropValue !\u003d null) {\n                try {\n                    h \u003d Math.max(parseInt(integerCacheHighPropValue), 127);\n                    // Maximum array size is Integer.MAX_VALUE\n                    h \u003d Math.min(h, Integer.MAX_VALUE - (-low) -1);\n                } catch( NumberFormatException nfe) {\n                    // If the property cannot be parsed into an int, ignore it.\n                }\n            }\n            high \u003d h;\n\n            // Load IntegerCache.archivedCache from archive, if possible\n            CDS.initializeFromArchive(IntegerCache.class);\n            int size \u003d (high - low) + 1;\n\n            // Use the archived cache if it exists and is large enough\n            if (archivedCache \u003d\u003d null || size \u003e archivedCache.length) {\n                Integer[] c \u003d new Integer[size];\n                int j \u003d low;\n                for(int i \u003d 0; i \u003c c.length; i++) {\n                    c[i] \u003d new Integer(j++);\n                }\n                archivedCache \u003d c;\n            }\n            cache \u003d archivedCache;\n            // range [-128, 127] must be interned (JLS7 5.1.7)\n            assert IntegerCache.high \u003e\u003d 127;\n        }\n\n        private IntegerCache() {}\n    }\n\n    /**\n     * Returns an {@code Integer} instance representing the specified\n     * {@code int} value.  If a new {@code Integer} instance is not\n     * required, this method should generally be used in preference to\n     * the constructor {@link #Integer(int)}, as this method is likely\n     * to yield significantly better space and time performance by\n     * caching frequently requested values.\n     *\n     * This method will always cache values in the range -128 to 127,\n     * inclusive, and may cache other values outside of this range.\n     *\n     * @param  i an {@code int} value.\n     * @return an {@code Integer} instance representing {@code i}.\n     * @since  1.5\n     */\n    @IntrinsicCandidate\n    public static Integer valueOf(int i) {\n        if (i \u003e\u003d IntegerCache.low \u0026\u0026 i \u003c\u003d IntegerCache.high)\n            return IntegerCache.cache[i + (-IntegerCache.low)];\n        return new Integer(i);\n    }\n\n    /**\n     * The value of the {@code Integer}.\n     *\n     * @serial\n     */\n    private final int value;\n\n    /**\n     * Constructs a newly allocated {@code Integer} object that\n     * represents the specified {@code int} value.\n     *\n     * @param   value   the value to be represented by the\n     *                  {@code Integer} object.\n     *\n     * @deprecated\n     * It is rarely appropriate to use this constructor. The static factory\n     * {@link #valueOf(int)} is generally a better choice, as it is\n     * likely to yield significantly better space and time performance.\n     */\n    @Deprecated(since\u003d\"9\", forRemoval \u003d true)\n    public Integer(int value) {\n        this.value \u003d value;\n    }\n\n    /**\n     * Constructs a newly allocated {@code Integer} object that\n     * represents the {@code int} value indicated by the\n     * {@code String} parameter. The string is converted to an\n     * {@code int} value in exactly the manner used by the\n     * {@code parseInt} method for radix 10.\n     *\n     * @param   s   the {@code String} to be converted to an {@code Integer}.\n     * @throws      NumberFormatException if the {@code String} does not\n     *              contain a parsable integer.\n     *\n     * @deprecated\n     * It is rarely appropriate to use this constructor.\n     * Use {@link #parseInt(String)} to convert a string to a\n     * {@code int} primitive, or use {@link #valueOf(String)}\n     * to convert a string to an {@code Integer} object.\n     */\n    @Deprecated(since\u003d\"9\", forRemoval \u003d true)\n    public Integer(String s) throws NumberFormatException {\n        this.value \u003d parseInt(s, 10);\n    }\n\n    /**\n     * Returns the value of this {@code Integer} as a {@code byte}\n     * after a narrowing primitive conversion.\n     * @jls 5.1.3 Narrowing Primitive Conversion\n     */\n    public byte byteValue() {\n        return (byte)value;\n    }\n\n    /**\n     * Returns the value of this {@code Integer} as a {@code short}\n     * after a narrowing primitive conversion.\n     * @jls 5.1.3 Narrowing Primitive Conversion\n     */\n    public short shortValue() {\n        return (short)value;\n    }\n\n    /**\n     * Returns the value of this {@code Integer} as an\n     * {@code int}.\n     */\n    @IntrinsicCandidate\n    public int intValue() {\n        return value;\n    }\n\n    /**\n     * Returns the value of this {@code Integer} as a {@code long}\n     * after a widening primitive conversion.\n     * @jls 5.1.2 Widening Primitive Conversion\n     * @see Integer#toUnsignedLong(int)\n     */\n    public long longValue() {\n        return (long)value;\n    }\n\n    /**\n     * Returns the value of this {@code Integer} as a {@code float}\n     * after a widening primitive conversion.\n     * @jls 5.1.2 Widening Primitive Conversion\n     */\n    public float floatValue() {\n        return (float)value;\n    }\n\n    /**\n     * Returns the value of this {@code Integer} as a {@code double}\n     * after a widening primitive conversion.\n     * @jls 5.1.2 Widening Primitive Conversion\n     */\n    public double doubleValue() {\n        return (double)value;\n    }\n\n    /**\n     * Returns a {@code String} object representing this\n     * {@code Integer}\u0027s value. The value is converted to signed\n     * decimal representation and returned as a string, exactly as if\n     * the integer value were given as an argument to the {@link\n     * java.lang.Integer#toString(int)} method.\n     *\n     * @return  a string representation of the value of this object in\n     *          base\u0026nbsp;10.\n     */\n    public String toString() {\n        return toString(value);\n    }\n\n    /**\n     * Returns a hash code for this {@code Integer}.\n     *\n     * @return  a hash code value for this object, equal to the\n     *          primitive {@code int} value represented by this\n     *          {@code Integer} object.\n     */\n    @Override\n    public int hashCode() {\n        return Integer.hashCode(value);\n    }\n\n    /**\n     * Returns a hash code for an {@code int} value; compatible with\n     * {@code Integer.hashCode()}.\n     *\n     * @param value the value to hash\n     * @since 1.8\n     *\n     * @return a hash code value for an {@code int} value.\n     */\n    public static int hashCode(int value) {\n        return value;\n    }\n\n    /**\n     * Compares this object to the specified object.  The result is\n     * {@code true} if and only if the argument is not\n     * {@code null} and is an {@code Integer} object that\n     * contains the same {@code int} value as this object.\n     *\n     * @param   obj   the object to compare with.\n     * @return  {@code true} if the objects are the same;\n     *          {@code false} otherwise.\n     */\n    public boolean equals(Object obj) {\n        if (obj instanceof Integer) {\n            return value \u003d\u003d ((Integer)obj).intValue();\n        }\n        return false;\n    }\n\n    /**\n     * Determines the integer value of the system property with the\n     * specified name.\n     *\n     * \u003cp\u003eThe first argument is treated as the name of a system\n     * property.  System properties are accessible through the {@link\n     * java.lang.System#getProperty(java.lang.String)} method. The\n     * string value of this property is then interpreted as an integer\n     * value using the grammar supported by {@link Integer#decode decode} and\n     * an {@code Integer} object representing this value is returned.\n     *\n     * \u003cp\u003eIf there is no property with the specified name, if the\n     * specified name is empty or {@code null}, or if the property\n     * does not have the correct numeric format, then {@code null} is\n     * returned.\n     *\n     * \u003cp\u003eIn other words, this method returns an {@code Integer}\n     * object equal to the value of:\n     *\n     * \u003cblockquote\u003e\n     *  {@code getInteger(nm, null)}\n     * \u003c/blockquote\u003e\n     *\n     * @param   nm   property name.\n     * @return  the {@code Integer} value of the property.\n     * @throws  SecurityException for the same reasons as\n     *          {@link System#getProperty(String) System.getProperty}\n     * @see     java.lang.System#getProperty(java.lang.String)\n     * @see     java.lang.System#getProperty(java.lang.String, java.lang.String)\n     */\n    public static Integer getInteger(String nm) {\n        return getInteger(nm, null);\n    }\n\n    /**\n     * Determines the integer value of the system property with the\n     * specified name.\n     *\n     * \u003cp\u003eThe first argument is treated as the name of a system\n     * property.  System properties are accessible through the {@link\n     * java.lang.System#getProperty(java.lang.String)} method. The\n     * string value of this property is then interpreted as an integer\n     * value using the grammar supported by {@link Integer#decode decode} and\n     * an {@code Integer} object representing this value is returned.\n     *\n     * \u003cp\u003eThe second argument is the default value. An {@code Integer} object\n     * that represents the value of the second argument is returned if there\n     * is no property of the specified name, if the property does not have\n     * the correct numeric format, or if the specified name is empty or\n     * {@code null}.\n     *\n     * \u003cp\u003eIn other words, this method returns an {@code Integer} object\n     * equal to the value of:\n     *\n     * \u003cblockquote\u003e\n     *  {@code getInteger(nm, new Integer(val))}\n     * \u003c/blockquote\u003e\n     *\n     * but in practice it may be implemented in a manner such as:\n     *\n     * \u003cblockquote\u003e\u003cpre\u003e\n     * Integer result \u003d getInteger(nm, null);\n     * return (result \u003d\u003d null) ? new Integer(val) : result;\n     * \u003c/pre\u003e\u003c/blockquote\u003e\n     *\n     * to avoid the unnecessary allocation of an {@code Integer}\n     * object when the default value is not needed.\n     *\n     * @param   nm   property name.\n     * @param   val   default value.\n     * @return  the {@code Integer} value of the property.\n     * @throws  SecurityException for the same reasons as\n     *          {@link System#getProperty(String) System.getProperty}\n     * @see     java.lang.System#getProperty(java.lang.String)\n     * @see     java.lang.System#getProperty(java.lang.String, java.lang.String)\n     */\n    public static Integer getInteger(String nm, int val) {\n        Integer result \u003d getInteger(nm, null);\n        return (result \u003d\u003d null) ? Integer.valueOf(val) : result;\n    }\n\n    /**\n     * Returns the integer value of the system property with the\n     * specified name.  The first argument is treated as the name of a\n     * system property.  System properties are accessible through the\n     * {@link java.lang.System#getProperty(java.lang.String)} method.\n     * The string value of this property is then interpreted as an\n     * integer value, as per the {@link Integer#decode decode} method,\n     * and an {@code Integer} object representing this value is\n     * returned; in summary:\n     *\n     * \u003cul\u003e\u003cli\u003eIf the property value begins with the two ASCII characters\n     *         {@code 0x} or the ASCII character {@code #}, not\n     *      followed by a minus sign, then the rest of it is parsed as a\n     *      hexadecimal integer exactly as by the method\n     *      {@link #valueOf(java.lang.String, int)} with radix 16.\n     * \u003cli\u003eIf the property value begins with the ASCII character\n     *     {@code 0} followed by another character, it is parsed as an\n     *     octal integer exactly as by the method\n     *     {@link #valueOf(java.lang.String, int)} with radix 8.\n     * \u003cli\u003eOtherwise, the property value is parsed as a decimal integer\n     * exactly as by the method {@link #valueOf(java.lang.String, int)}\n     * with radix 10.\n     * \u003c/ul\u003e\n     *\n     * \u003cp\u003eThe second argument is the default value. The default value is\n     * returned if there is no property of the specified name, if the\n     * property does not have the correct numeric format, or if the\n     * specified name is empty or {@code null}.\n     *\n     * @param   nm   property name.\n     * @param   val   default value.\n     * @return  the {@code Integer} value of the property.\n     * @throws  SecurityException for the same reasons as\n     *          {@link System#getProperty(String) System.getProperty}\n     * @see     System#getProperty(java.lang.String)\n     * @see     System#getProperty(java.lang.String, java.lang.String)\n     */\n    public static Integer getInteger(String nm, Integer val) {\n        String v \u003d null;\n        try {\n            v \u003d System.getProperty(nm);\n        } catch (IllegalArgumentException | NullPointerException e) {\n        }\n        if (v !\u003d null) {\n            try {\n                return Integer.decode(v);\n            } catch (NumberFormatException e) {\n            }\n        }\n        return val;\n    }\n\n    /**\n     * Decodes a {@code String} into an {@code Integer}.\n     * Accepts decimal, hexadecimal, and octal numbers given\n     * by the following grammar:\n     *\n     * \u003cblockquote\u003e\n     * \u003cdl\u003e\n     * \u003cdt\u003e\u003ci\u003eDecodableString:\u003c/i\u003e\n     * \u003cdd\u003e\u003ci\u003eSign\u003csub\u003eopt\u003c/sub\u003e DecimalNumeral\u003c/i\u003e\n     * \u003cdd\u003e\u003ci\u003eSign\u003csub\u003eopt\u003c/sub\u003e\u003c/i\u003e {@code 0x} \u003ci\u003eHexDigits\u003c/i\u003e\n     * \u003cdd\u003e\u003ci\u003eSign\u003csub\u003eopt\u003c/sub\u003e\u003c/i\u003e {@code 0X} \u003ci\u003eHexDigits\u003c/i\u003e\n     * \u003cdd\u003e\u003ci\u003eSign\u003csub\u003eopt\u003c/sub\u003e\u003c/i\u003e {@code #} \u003ci\u003eHexDigits\u003c/i\u003e\n     * \u003cdd\u003e\u003ci\u003eSign\u003csub\u003eopt\u003c/sub\u003e\u003c/i\u003e {@code 0} \u003ci\u003eOctalDigits\u003c/i\u003e\n     *\n     * \u003cdt\u003e\u003ci\u003eSign:\u003c/i\u003e\n     * \u003cdd\u003e{@code -}\n     * \u003cdd\u003e{@code +}\n     * \u003c/dl\u003e\n     * \u003c/blockquote\u003e\n     *\n     * \u003ci\u003eDecimalNumeral\u003c/i\u003e, \u003ci\u003eHexDigits\u003c/i\u003e, and \u003ci\u003eOctalDigits\u003c/i\u003e\n     * are as defined in section {@jls 3.10.1} of\n     * \u003ccite\u003eThe Java Language Specification\u003c/cite\u003e,\n     * except that underscores are not accepted between digits.\n     *\n     * \u003cp\u003eThe sequence of characters following an optional\n     * sign and/or radix specifier (\"{@code 0x}\", \"{@code 0X}\",\n     * \"{@code #}\", or leading zero) is parsed as by the {@code\n     * Integer.parseInt} method with the indicated radix (10, 16, or\n     * 8).  This sequence of characters must represent a positive\n     * value or a {@link NumberFormatException} will be thrown.  The\n     * result is negated if first character of the specified {@code\n     * String} is the minus sign.  No whitespace characters are\n     * permitted in the {@code String}.\n     *\n     * @param     nm the {@code String} to decode.\n     * @return    an {@code Integer} object holding the {@code int}\n     *             value represented by {@code nm}\n     * @throws    NumberFormatException  if the {@code String} does not\n     *            contain a parsable integer.\n     * @see java.lang.Integer#parseInt(java.lang.String, int)\n     */\n    public static Integer decode(String nm) throws NumberFormatException {\n        int radix \u003d 10;\n        int index \u003d 0;\n        boolean negative \u003d false;\n        Integer result;\n\n        if (nm.isEmpty())\n            throw new NumberFormatException(\"Zero length string\");\n        char firstChar \u003d nm.charAt(0);\n        // Handle sign, if present\n        if (firstChar \u003d\u003d \u0027-\u0027) {\n            negative \u003d true;\n            index++;\n        } else if (firstChar \u003d\u003d \u0027+\u0027)\n            index++;\n\n        // Handle radix specifier, if present\n        if (nm.startsWith(\"0x\", index) || nm.startsWith(\"0X\", index)) {\n            index +\u003d 2;\n            radix \u003d 16;\n        }\n        else if (nm.startsWith(\"#\", index)) {\n            index ++;\n            radix \u003d 16;\n        }\n        else if (nm.startsWith(\"0\", index) \u0026\u0026 nm.length() \u003e 1 + index) {\n            index ++;\n            radix \u003d 8;\n        }\n\n        if (nm.startsWith(\"-\", index) || nm.startsWith(\"+\", index))\n            throw new NumberFormatException(\"Sign character in wrong position\");\n\n        try {\n            result \u003d Integer.valueOf(nm.substring(index), radix);\n            result \u003d negative ? Integer.valueOf(-result.intValue()) : result;\n        } catch (NumberFormatException e) {\n            // If number is Integer.MIN_VALUE, we\u0027ll end up here. The next line\n            // handles this case, and causes any genuine format error to be\n            // rethrown.\n            String constant \u003d negative ? (\"-\" + nm.substring(index))\n                                       : nm.substring(index);\n            result \u003d Integer.valueOf(constant, radix);\n        }\n        return result;\n    }\n\n    /**\n     * Compares two {@code Integer} objects numerically.\n     *\n     * @param   anotherInteger   the {@code Integer} to be compared.\n     * @return  the value {@code 0} if this {@code Integer} is\n     *          equal to the argument {@code Integer}; a value less than\n     *          {@code 0} if this {@code Integer} is numerically less\n     *          than the argument {@code Integer}; and a value greater\n     *          than {@code 0} if this {@code Integer} is numerically\n     *           greater than the argument {@code Integer} (signed\n     *           comparison).\n     * @since   1.2\n     */\n    public int compareTo(Integer anotherInteger) {\n        return compare(this.value, anotherInteger.value);\n    }\n\n    /**\n     * Compares two {@code int} values numerically.\n     * The value returned is identical to what would be returned by:\n     * \u003cpre\u003e\n     *    Integer.valueOf(x).compareTo(Integer.valueOf(y))\n     * \u003c/pre\u003e\n     *\n     * @param  x the first {@code int} to compare\n     * @param  y the second {@code int} to compare\n     * @return the value {@code 0} if {@code x \u003d\u003d y};\n     *         a value less than {@code 0} if {@code x \u003c y}; and\n     *         a value greater than {@code 0} if {@code x \u003e y}\n     * @since 1.7\n     */\n    public static int compare(int x, int y) {\n        return (x \u003c y) ? -1 : ((x \u003d\u003d y) ? 0 : 1);\n    }\n\n    /**\n     * Compares two {@code int} values numerically treating the values\n     * as unsigned.\n     *\n     * @param  x the first {@code int} to compare\n     * @param  y the second {@code int} to compare\n     * @return the value {@code 0} if {@code x \u003d\u003d y}; a value less\n     *         than {@code 0} if {@code x \u003c y} as unsigned values; and\n     *         a value greater than {@code 0} if {@code x \u003e y} as\n     *         unsigned values\n     * @since 1.8\n     */\n    public static int compareUnsigned(int x, int y) {\n        return compare(x + MIN_VALUE, y + MIN_VALUE);\n    }\n\n    /**\n     * Converts the argument to a {@code long} by an unsigned\n     * conversion.  In an unsigned conversion to a {@code long}, the\n     * high-order 32 bits of the {@code long} are zero and the\n     * low-order 32 bits are equal to the bits of the integer\n     * argument.\n     *\n     * Consequently, zero and positive {@code int} values are mapped\n     * to a numerically equal {@code long} value and negative {@code\n     * int} values are mapped to a {@code long} value equal to the\n     * input plus 2\u003csup\u003e32\u003c/sup\u003e.\n     *\n     * @param  x the value to convert to an unsigned {@code long}\n     * @return the argument converted to {@code long} by an unsigned\n     *         conversion\n     * @since 1.8\n     */\n    public static long toUnsignedLong(int x) {\n        return ((long) x) \u0026 0xffffffffL;\n    }\n\n    /**\n     * Returns the unsigned quotient of dividing the first argument by\n     * the second where each argument and the result is interpreted as\n     * an unsigned value.\n     *\n     * \u003cp\u003eNote that in two\u0027s complement arithmetic, the three other\n     * basic arithmetic operations of add, subtract, and multiply are\n     * bit-wise identical if the two operands are regarded as both\n     * being signed or both being unsigned.  Therefore separate {@code\n     * addUnsigned}, etc. methods are not provided.\n     *\n     * @param dividend the value to be divided\n     * @param divisor the value doing the dividing\n     * @return the unsigned quotient of the first argument divided by\n     * the second argument\n     * @see #remainderUnsigned\n     * @since 1.8\n     */\n    public static int divideUnsigned(int dividend, int divisor) {\n        // In lieu of tricky code, for now just use long arithmetic.\n        return (int)(toUnsignedLong(dividend) / toUnsignedLong(divisor));\n    }\n\n    /**\n     * Returns the unsigned remainder from dividing the first argument\n     * by the second where each argument and the result is interpreted\n     * as an unsigned value.\n     *\n     * @param dividend the value to be divided\n     * @param divisor the value doing the dividing\n     * @return the unsigned remainder of the first argument divided by\n     * the second argument\n     * @see #divideUnsigned\n     * @since 1.8\n     */\n    public static int remainderUnsigned(int dividend, int divisor) {\n        // In lieu of tricky code, for now just use long arithmetic.\n        return (int)(toUnsignedLong(dividend) % toUnsignedLong(divisor));\n    }\n\n\n    // Bit twiddling\n\n    /**\n     * The number of bits used to represent an {@code int} value in two\u0027s\n     * complement binary form.\n     *\n     * @since 1.5\n     */\n    @Native public static final int SIZE \u003d 32;\n\n    /**\n     * The number of bytes used to represent an {@code int} value in two\u0027s\n     * complement binary form.\n     *\n     * @since 1.8\n     */\n    public static final int BYTES \u003d SIZE / Byte.SIZE;\n\n    /**\n     * Returns an {@code int} value with at most a single one-bit, in the\n     * position of the highest-order (\"leftmost\") one-bit in the specified\n     * {@code int} value.  Returns zero if the specified value has no\n     * one-bits in its two\u0027s complement binary representation, that is, if it\n     * is equal to zero.\n     *\n     * @param i the value whose highest one bit is to be computed\n     * @return an {@code int} value with a single one-bit, in the position\n     *     of the highest-order one-bit in the specified value, or zero if\n     *     the specified value is itself equal to zero.\n     * @since 1.5\n     */\n    public static int highestOneBit(int i) {\n        return i \u0026 (MIN_VALUE \u003e\u003e\u003e numberOfLeadingZeros(i));\n    }\n\n    /**\n     * Returns an {@code int} value with at most a single one-bit, in the\n     * position of the lowest-order (\"rightmost\") one-bit in the specified\n     * {@code int} value.  Returns zero if the specified value has no\n     * one-bits in its two\u0027s complement binary representation, that is, if it\n     * is equal to zero.\n     *\n     * @param i the value whose lowest one bit is to be computed\n     * @return an {@code int} value with a single one-bit, in the position\n     *     of the lowest-order one-bit in the specified value, or zero if\n     *     the specified value is itself equal to zero.\n     * @since 1.5\n     */\n    public static int lowestOneBit(int i) {\n        // HD, Section 2-1\n        return i \u0026 -i;\n    }\n\n    /**\n     * Returns the number of zero bits preceding the highest-order\n     * (\"leftmost\") one-bit in the two\u0027s complement binary representation\n     * of the specified {@code int} value.  Returns 32 if the\n     * specified value has no one-bits in its two\u0027s complement representation,\n     * in other words if it is equal to zero.\n     *\n     * \u003cp\u003eNote that this method is closely related to the logarithm base 2.\n     * For all positive {@code int} values x:\n     * \u003cul\u003e\n     * \u003cli\u003efloor(log\u003csub\u003e2\u003c/sub\u003e(x)) \u003d {@code 31 - numberOfLeadingZeros(x)}\n     * \u003cli\u003eceil(log\u003csub\u003e2\u003c/sub\u003e(x)) \u003d {@code 32 - numberOfLeadingZeros(x - 1)}\n     * \u003c/ul\u003e\n     *\n     * @param i the value whose number of leading zeros is to be computed\n     * @return the number of zero bits preceding the highest-order\n     *     (\"leftmost\") one-bit in the two\u0027s complement binary representation\n     *     of the specified {@code int} value, or 32 if the value\n     *     is equal to zero.\n     * @since 1.5\n     */\n    @IntrinsicCandidate\n    public static int numberOfLeadingZeros(int i) {\n        // HD, Count leading 0\u0027s\n        if (i \u003c\u003d 0)\n            return i \u003d\u003d 0 ? 32 : 0;\n        int n \u003d 31;\n        if (i \u003e\u003d 1 \u003c\u003c 16) { n -\u003d 16; i \u003e\u003e\u003e\u003d 16; }\n        if (i \u003e\u003d 1 \u003c\u003c  8) { n -\u003d  8; i \u003e\u003e\u003e\u003d  8; }\n        if (i \u003e\u003d 1 \u003c\u003c  4) { n -\u003d  4; i \u003e\u003e\u003e\u003d  4; }\n        if (i \u003e\u003d 1 \u003c\u003c  2) { n -\u003d  2; i \u003e\u003e\u003e\u003d  2; }\n        return n - (i \u003e\u003e\u003e 1);\n    }\n\n    /**\n     * Returns the number of zero bits following the lowest-order (\"rightmost\")\n     * one-bit in the two\u0027s complement binary representation of the specified\n     * {@code int} value.  Returns 32 if the specified value has no\n     * one-bits in its two\u0027s complement representation, in other words if it is\n     * equal to zero.\n     *\n     * @param i the value whose number of trailing zeros is to be computed\n     * @return the number of zero bits following the lowest-order (\"rightmost\")\n     *     one-bit in the two\u0027s complement binary representation of the\n     *     specified {@code int} value, or 32 if the value is equal\n     *     to zero.\n     * @since 1.5\n     */\n    @IntrinsicCandidate\n    public static int numberOfTrailingZeros(int i) {\n        // HD, Count trailing 0\u0027s\n        i \u003d ~i \u0026 (i - 1);\n        if (i \u003c\u003d 0) return i \u0026 32;\n        int n \u003d 1;\n        if (i \u003e 1 \u003c\u003c 16) { n +\u003d 16; i \u003e\u003e\u003e\u003d 16; }\n        if (i \u003e 1 \u003c\u003c  8) { n +\u003d  8; i \u003e\u003e\u003e\u003d  8; }\n        if (i \u003e 1 \u003c\u003c  4) { n +\u003d  4; i \u003e\u003e\u003e\u003d  4; }\n        if (i \u003e 1 \u003c\u003c  2) { n +\u003d  2; i \u003e\u003e\u003e\u003d  2; }\n        return n + (i \u003e\u003e\u003e 1);\n    }\n\n    /**\n     * Returns the number of one-bits in the two\u0027s complement binary\n     * representation of the specified {@code int} value.  This function is\n     * sometimes referred to as the \u003ci\u003epopulation count\u003c/i\u003e.\n     *\n     * @param i the value whose bits are to be counted\n     * @return the number of one-bits in the two\u0027s complement binary\n     *     representation of the specified {@code int} value.\n     * @since 1.5\n     */\n    @IntrinsicCandidate\n    public static int bitCount(int i) {\n        // HD, Figure 5-2\n        i \u003d i - ((i \u003e\u003e\u003e 1) \u0026 0x55555555);\n        i \u003d (i \u0026 0x33333333) + ((i \u003e\u003e\u003e 2) \u0026 0x33333333);\n        i \u003d (i + (i \u003e\u003e\u003e 4)) \u0026 0x0f0f0f0f;\n        i \u003d i + (i \u003e\u003e\u003e 8);\n        i \u003d i + (i \u003e\u003e\u003e 16);\n        return i \u0026 0x3f;\n    }\n\n    /**\n     * Returns the value obtained by rotating the two\u0027s complement binary\n     * representation of the specified {@code int} value left by the\n     * specified number of bits.  (Bits shifted out of the left hand, or\n     * high-order, side reenter on the right, or low-order.)\n     *\n     * \u003cp\u003eNote that left rotation with a negative distance is equivalent to\n     * right rotation: {@code rotateLeft(val, -distance) \u003d\u003d rotateRight(val,\n     * distance)}.  Note also that rotation by any multiple of 32 is a\n     * no-op, so all but the last five bits of the rotation distance can be\n     * ignored, even if the distance is negative: {@code rotateLeft(val,\n     * distance) \u003d\u003d rotateLeft(val, distance \u0026 0x1F)}.\n     *\n     * @param i the value whose bits are to be rotated left\n     * @param distance the number of bit positions to rotate left\n     * @return the value obtained by rotating the two\u0027s complement binary\n     *     representation of the specified {@code int} value left by the\n     *     specified number of bits.\n     * @since 1.5\n     */\n    public static int rotateLeft(int i, int distance) {\n        return (i \u003c\u003c distance) | (i \u003e\u003e\u003e -distance);\n    }\n\n    /**\n     * Returns the value obtained by rotating the two\u0027s complement binary\n     * representation of the specified {@code int} value right by the\n     * specified number of bits.  (Bits shifted out of the right hand, or\n     * low-order, side reenter on the left, or high-order.)\n     *\n     * \u003cp\u003eNote that right rotation with a negative distance is equivalent to\n     * left rotation: {@code rotateRight(val, -distance) \u003d\u003d rotateLeft(val,\n     * distance)}.  Note also that rotation by any multiple of 32 is a\n     * no-op, so all but the last five bits of the rotation distance can be\n     * ignored, even if the distance is negative: {@code rotateRight(val,\n     * distance) \u003d\u003d rotateRight(val, distance \u0026 0x1F)}.\n     *\n     * @param i the value whose bits are to be rotated right\n     * @param distance the number of bit positions to rotate right\n     * @return the value obtained by rotating the two\u0027s complement binary\n     *     representation of the specified {@code int} value right by the\n     *     specified number of bits.\n     * @since 1.5\n     */\n    public static int rotateRight(int i, int distance) {\n        return (i \u003e\u003e\u003e distance) | (i \u003c\u003c -distance);\n    }\n\n    /**\n     * Returns the value obtained by reversing the order of the bits in the\n     * two\u0027s complement binary representation of the specified {@code int}\n     * value.\n     *\n     * @param i the value to be reversed\n     * @return the value obtained by reversing order of the bits in the\n     *     specified {@code int} value.\n     * @since 1.5\n     */\n    public static int reverse(int i) {\n        // HD, Figure 7-1\n        i \u003d (i \u0026 0x55555555) \u003c\u003c 1 | (i \u003e\u003e\u003e 1) \u0026 0x55555555;\n        i \u003d (i \u0026 0x33333333) \u003c\u003c 2 | (i \u003e\u003e\u003e 2) \u0026 0x33333333;\n        i \u003d (i \u0026 0x0f0f0f0f) \u003c\u003c 4 | (i \u003e\u003e\u003e 4) \u0026 0x0f0f0f0f;\n\n        return reverseBytes(i);\n    }\n\n    /**\n     * Returns the signum function of the specified {@code int} value.  (The\n     * return value is -1 if the specified value is negative; 0 if the\n     * specified value is zero; and 1 if the specified value is positive.)\n     *\n     * @param i the value whose signum is to be computed\n     * @return the signum function of the specified {@code int} value.\n     * @since 1.5\n     */\n    public static int signum(int i) {\n        // HD, Section 2-7\n        return (i \u003e\u003e 31) | (-i \u003e\u003e\u003e 31);\n    }\n\n    /**\n     * Returns the value obtained by reversing the order of the bytes in the\n     * two\u0027s complement representation of the specified {@code int} value.\n     *\n     * @param i the value whose bytes are to be reversed\n     * @return the value obtained by reversing the bytes in the specified\n     *     {@code int} value.\n     * @since 1.5\n     */\n    @IntrinsicCandidate\n    public static int reverseBytes(int i) {\n        return (i \u003c\u003c 24)            |\n               ((i \u0026 0xff00) \u003c\u003c 8)  |\n               ((i \u003e\u003e\u003e 8) \u0026 0xff00) |\n               (i \u003e\u003e\u003e 24);\n    }\n\n    /**\n     * Adds two integers together as per the + operator.\n     *\n     * @param a the first operand\n     * @param b the second operand\n     * @return the sum of {@code a} and {@code b}\n     * @see java.util.function.BinaryOperator\n     * @since 1.8\n     */\n    public static int sum(int a, int b) {\n        return a + b;\n    }\n\n    /**\n     * Returns the greater of two {@code int} values\n     * as if by calling {@link Math#max(int, int) Math.max}.\n     *\n     * @param a the first operand\n     * @param b the second operand\n     * @return the greater of {@code a} and {@code b}\n     * @see java.util.function.BinaryOperator\n     * @since 1.8\n     */\n    public static int max(int a, int b) {\n        return Math.max(a, b);\n    }\n\n    /**\n     * Returns the smaller of two {@code int} values\n     * as if by calling {@link Math#min(int, int) Math.min}.\n     *\n     * @param a the first operand\n     * @param b the second operand\n     * @return the smaller of {@code a} and {@code b}\n     * @see java.util.function.BinaryOperator\n     * @since 1.8\n     */\n    public static int min(int a, int b) {\n        return Math.min(a, b);\n    }\n\n    /**\n     * Returns an {@link Optional} containing the nominal descriptor for this\n     * instance, which is the instance itself.\n     *\n     * @return an {@link Optional} describing the {@linkplain Integer} instance\n     * @since 12\n     */\n    @Override\n    public Optional\u003cInteger\u003e describeConstable() {\n        return Optional.of(this);\n    }\n\n    /**\n     * Resolves this instance as a {@link ConstantDesc}, the result of which is\n     * the instance itself.\n     *\n     * @param lookup ignored\n     * @return the {@linkplain Integer} instance\n     * @since 12\n     */\n    @Override\n    public Integer resolveConstantDesc(MethodHandles.Lookup lookup) {\n        return this;\n    }\n\n    /** use serialVersionUID from JDK 1.0.2 for interoperability */\n    @java.io.Serial\n    @Native private static final long serialVersionUID \u003d 1360826667806852920L;\n}\n"
    }
  }
}
java.lang.IllegalArgumentException: Illegal character in opaque part at index 188: jar:file:///C:/Users/Vinicius/AppData/Local/Coursier/cache/arc/https/github.com/adoptium/temurin17-binaries/releases/download/jdk-17%2B35/OpenJDK17-jdk_x64_windows_hotspot_17_35.zip/jdk-17 35/lib/src.zip!/java.base/java/lang/Integer.java
	at java.base/java.net.URI.create(URI.java:906)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:178)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.$anonfun$toAbsolutePath$3(MtagsEnrichments.scala:175)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.withTryDecode$1(MtagsEnrichments.scala:153)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:175)
	at scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:756)
	at scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:753)
	at scala.meta.internal.metals.WorkspaceLspService.didOpen(WorkspaceLspService.scala:388)
	at scala.meta.metals.lsp.DelegatingScalaService.didOpen(DelegatingScalaService.scala:39)
	at jdk.internal.reflect.GeneratedMethodAccessor23.invoke(Unknown Source)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:568)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$recursiveFindRpcMethods$0(GenericEndpoint.java:65)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.notify(GenericEndpoint.java:160)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleNotification(RemoteEndpoint.java:231)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:198)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:185)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:97)
	at org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:114)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:539)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.base/java.lang.Thread.run(Thread.java:833)
Caused by: java.net.URISyntaxException: Illegal character in opaque part at index 188: jar:file:///C:/Users/Vinicius/AppData/Local/Coursier/cache/arc/https/github.com/adoptium/temurin17-binaries/releases/download/jdk-17%2B35/OpenJDK17-jdk_x64_windows_hotspot_17_35.zip/jdk-17 35/lib/src.zip!/java.base/java/lang/Integer.java
	at java.base/java.net.URI$Parser.fail(URI.java:2974)
	at java.base/java.net.URI$Parser.checkChars(URI.java:3145)
	at java.base/java.net.URI$Parser.parse(URI.java:3181)
	at java.base/java.net.URI.<init>(URI.java:623)
	at java.base/java.net.URI.create(URI.java:904)
	... 23 more

jul. 19, 2024 1:04:52 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleNotification
ADVERTÊNCIA: Notification threw an exception: {
  "jsonrpc": "2.0",
  "method": "textDocument/didClose",
  "params": {
    "textDocument": {
      "uri": "jar:file%3A///C%3A/Users/Vinicius/AppData/Local/Coursier/cache/arc/https/github.com/adoptium/temurin17-binaries/releases/download/jdk-17%25252B35/OpenJDK17-jdk_x64_windows_hotspot_17_35.zip/jdk-17%2B35/lib/src.zip%21/java.base/java/lang/Integer.java"
    }
  }
}
java.lang.IllegalArgumentException: Illegal character in opaque part at index 188: jar:file:///C:/Users/Vinicius/AppData/Local/Coursier/cache/arc/https/github.com/adoptium/temurin17-binaries/releases/download/jdk-17%2B35/OpenJDK17-jdk_x64_windows_hotspot_17_35.zip/jdk-17 35/lib/src.zip!/java.base/java/lang/Integer.java
	at java.base/java.net.URI.create(URI.java:906)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:178)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.$anonfun$toAbsolutePath$3(MtagsEnrichments.scala:175)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.withTryDecode$1(MtagsEnrichments.scala:153)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:175)
	at scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:756)
	at scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:753)
	at scala.meta.internal.metals.WorkspaceLspService.didClose(WorkspaceLspService.scala:407)
	at scala.meta.metals.lsp.DelegatingScalaService.didClose(DelegatingScalaService.scala:53)
	at jdk.internal.reflect.GeneratedMethodAccessor26.invoke(Unknown Source)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:568)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$recursiveFindRpcMethods$0(GenericEndpoint.java:65)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.notify(GenericEndpoint.java:160)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleNotification(RemoteEndpoint.java:231)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:198)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:185)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:97)
	at org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:114)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:539)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.base/java.lang.Thread.run(Thread.java:833)
Caused by: java.net.URISyntaxException: Illegal character in opaque part at index 188: jar:file:///C:/Users/Vinicius/AppData/Local/Coursier/cache/arc/https/github.com/adoptium/temurin17-binaries/releases/download/jdk-17%2B35/OpenJDK17-jdk_x64_windows_hotspot_17_35.zip/jdk-17 35/lib/src.zip!/java.base/java/lang/Integer.java
	at java.base/java.net.URI$Parser.fail(URI.java:2974)
	at java.base/java.net.URI$Parser.checkChars(URI.java:3145)
	at java.base/java.net.URI$Parser.parse(URI.java:3181)
	at java.base/java.net.URI.<init>(URI.java:623)
	at java.base/java.net.URI.create(URI.java:904)
	... 23 more

jul. 19, 2024 1:04:53 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
ADVERTÊNCIA: Unmatched cancel notification for request id 5006
jul. 19, 2024 1:04:54 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
ADVERTÊNCIA: Unmatched cancel notification for request id 5010
2024.07.19 13:04:54 INFO  Can not organize imports if file has error
2024.07.19 13:04:54 INFO  compiling root (2 scala sources)
2024.07.19 13:04:54 INFO  time: compiled root in 0.21s
2024.07.19 13:05:23 INFO  compiling root (2 scala sources)
2024.07.19 13:05:23 INFO  time: compiled root in 0.24s
2024.07.19 13:05:27 INFO  compiling root (2 scala sources)
2024.07.19 13:05:27 INFO  time: compiled root in 0.2s
2024.07.19 13:05:27 INFO  compiling root (2 scala sources)
2024.07.19 13:05:28 INFO  time: compiled root in 0.25s
2024.07.19 13:06:14 INFO  compiling root (2 scala sources)
2024.07.19 13:06:14 INFO  time: compiled root in 0.23s
2024.07.19 13:06:20 INFO  Can not organize imports if file has error
2024.07.19 13:06:20 INFO  compiling root (2 scala sources)
2024.07.19 13:06:20 INFO  time: compiled root in 0.18s
jul. 19, 2024 1:06:23 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
ADVERTÊNCIA: Unmatched cancel notification for request id 5178
2024.07.19 13:06:23 WARN  Using indexes to guess the definition of S
2024.07.19 13:06:23 WARN  Using indexes to guess the definition of S
2024.07.19 13:06:24 WARN  Using indexes to guess the definition of S2
2024.07.19 13:06:24 INFO  Can not organize imports if file has error
2024.07.19 13:06:24 INFO  compiling root (2 scala sources)
2024.07.19 13:06:24 INFO  time: compiled root in 0.19s
2024.07.19 13:06:32 INFO  Can not organize imports if file has error
2024.07.19 13:06:32 INFO  compiling root (2 scala sources)
2024.07.19 13:06:32 INFO  time: compiled root in 0.24s
jul. 19, 2024 1:06:46 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
ADVERTÊNCIA: Unmatched cancel notification for request id 5232
jul. 19, 2024 1:06:50 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
ADVERTÊNCIA: Unmatched cancel notification for request id 5240
jul. 19, 2024 1:06:50 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
ADVERTÊNCIA: Unmatched cancel notification for request id 5248
jul. 19, 2024 1:06:52 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
ADVERTÊNCIA: Unmatched cancel notification for request id 5256
jul. 19, 2024 1:06:53 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
ADVERTÊNCIA: Unmatched cancel notification for request id 5264
jul. 19, 2024 1:06:57 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
ADVERTÊNCIA: Unmatched cancel notification for request id 5272
jul. 19, 2024 1:06:58 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
ADVERTÊNCIA: Unmatched cancel notification for request id 5280
jul. 19, 2024 1:07:00 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
ADVERTÊNCIA: Unmatched cancel notification for request id 5288
2024.07.19 13:07:05 WARN  Using indexes to guess the definition of A
2024.07.19 13:07:56 INFO  Can not organize imports if file has error
2024.07.19 13:07:56 INFO  compiling root (2 scala sources)
2024.07.19 13:07:56 INFO  time: compiled root in 0.2s
2024.07.19 13:07:58 INFO  Can not organize imports if file has error
2024.07.19 13:07:59 INFO  compiling root (2 scala sources)
2024.07.19 13:07:59 INFO  time: compiled root in 0.23s
jul. 19, 2024 1:08:05 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
ADVERTÊNCIA: Unmatched cancel notification for request id 5390
2024.07.19 13:08:37 INFO  Can not organize imports if file has error
2024.07.19 13:08:37 INFO  compiling root (2 scala sources)
2024.07.19 13:08:37 INFO  time: compiled root in 0.18s
2024.07.19 13:08:42 INFO  compiling root (2 scala sources)
2024.07.19 13:08:42 INFO  time: compiled root in 0.3s
2024.07.19 13:08:42 INFO  compiling root (2 scala sources)
2024.07.19 13:08:43 INFO  time: compiled root in 0.19s
jul. 19, 2024 1:10:55 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
ADVERTÊNCIA: Unmatched cancel notification for request id 5585
jul. 19, 2024 1:11:10 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
ADVERTÊNCIA: Unmatched cancel notification for request id 5593
jul. 19, 2024 1:11:15 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
ADVERTÊNCIA: Unmatched cancel notification for request id 5601
jul. 19, 2024 1:11:20 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
ADVERTÊNCIA: Unmatched cancel notification for request id 5610
jul. 19, 2024 1:11:23 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
ADVERTÊNCIA: Unmatched cancel notification for request id 5620
jul. 19, 2024 1:11:25 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
ADVERTÊNCIA: Unmatched cancel notification for request id 5629
jul. 19, 2024 1:11:31 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
ADVERTÊNCIA: Unmatched cancel notification for request id 5637
jul. 19, 2024 1:11:31 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
ADVERTÊNCIA: Unmatched cancel notification for request id 5645
jul. 19, 2024 1:11:49 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
ADVERTÊNCIA: Unmatched cancel notification for request id 5655
jul. 19, 2024 1:11:50 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
ADVERTÊNCIA: Unmatched cancel notification for request id 5664
jul. 19, 2024 1:11:51 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
ADVERTÊNCIA: Unmatched cancel notification for request id 5672
2024.07.19 13:12:26 INFO  compiling root (2 scala sources)
2024.07.19 13:12:26 INFO  time: compiled root in 0.21s
2024.07.19 13:12:35 INFO  Can not organize imports if file has error
2024.07.19 13:12:35 INFO  compiling root (2 scala sources)
2024.07.19 13:12:35 INFO  time: compiled root in 0.18s
2024.07.19 13:12:40 INFO  Can not organize imports if file has error
2024.07.19 13:12:41 INFO  compiling root (2 scala sources)
2024.07.19 13:12:41 INFO  time: compiled root in 0.17s
2024.07.19 13:12:42 INFO  Can not organize imports if file has error
2024.07.19 13:12:42 INFO  compiling root (2 scala sources)
2024.07.19 13:12:42 INFO  time: compiled root in 0.19s
2024.07.19 13:13:17 INFO  Can not organize imports if file has error
2024.07.19 13:13:17 INFO  compiling root (2 scala sources)
2024.07.19 13:13:17 INFO  time: compiled root in 0.22s
2024.07.19 13:13:28 WARN  Attempt to organize your imports failed. It looks like you have compilation issues causing your semanticdb to be stale. Ensure everything is compiling and try again.
2024.07.19 13:13:28 INFO  compiling root (2 scala sources)
2024.07.19 13:13:28 INFO  time: compiled root in 0.21s
2024.07.19 13:13:38 INFO  compiling root (2 scala sources)
2024.07.19 13:13:38 INFO  time: compiled root in 0.22s
2024.07.19 13:13:43 INFO  compiling root (2 scala sources)
2024.07.19 13:13:43 INFO  time: compiled root in 0.31s
2024.07.19 13:14:07 WARN  Attempt to organize your imports failed. It looks like you have compilation issues causing your semanticdb to be stale. Ensure everything is compiling and try again.
2024.07.19 13:14:07 INFO  compiling root (2 scala sources)
2024.07.19 13:14:07 INFO  time: compiled root in 0.18s
2024.07.19 13:14:49 INFO  compiling root (2 scala sources)
2024.07.19 13:14:49 INFO  time: compiled root in 0.26s
2024.07.19 13:14:58 INFO  compiling root (2 scala sources)
2024.07.19 13:14:58 INFO  time: compiled root in 0.2s
2024.07.19 13:15:06 INFO  compiling root (2 scala sources)
2024.07.19 13:15:06 INFO  time: compiled root in 0.22s
2024.07.19 13:15:09 INFO  compiling root (2 scala sources)
2024.07.19 13:15:09 INFO  time: compiled root in 0.22s
2024.07.19 13:15:20 INFO  Can not organize imports if file has error
2024.07.19 13:15:20 INFO  compiling root (2 scala sources)
2024.07.19 13:15:20 INFO  time: compiled root in 0.2s
2024.07.19 13:15:48 INFO  compiling root (2 scala sources)
2024.07.19 13:15:48 INFO  time: compiled root in 0.18s
2024.07.19 13:15:52 INFO  Can not organize imports if file has error
2024.07.19 13:15:52 INFO  compiling root (2 scala sources)
2024.07.19 13:15:52 INFO  time: compiled root in 0.25s
2024.07.19 13:15:56 INFO  Can not organize imports if file has error
2024.07.19 13:15:56 INFO  compiling root (2 scala sources)
2024.07.19 13:15:56 INFO  time: compiled root in 0.19s
2024.07.19 13:16:10 INFO  compiling root (2 scala sources)
2024.07.19 13:16:10 INFO  time: compiled root in 0.23s
jul. 19, 2024 1:16:10 PM scala.meta.internal.pc.CompilerAccess retryWithCleanCompiler
INFORMAÇÕES: compiler crashed due to an error in the Scala compiler, retrying with new compiler instance.
2024.07.19 13:16:16 INFO  Can not organize imports if file has error
2024.07.19 13:16:16 INFO  compiling root (2 scala sources)
2024.07.19 13:16:16 INFO  time: compiled root in 0.21s
jul. 19, 2024 1:16:17 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
ADVERTÊNCIA: Unmatched cancel notification for request id 6362
2024.07.19 13:17:23 INFO  compiling root (2 scala sources)
2024.07.19 13:17:23 INFO  time: compiled root in 0.17s
2024.07.19 13:17:24 WARN  Using indexes to guess the definition of Eval
2024.07.19 13:17:38 WARN  Using indexes to guess the definition of Eval
2024.07.19 13:18:49 INFO  Can not organize imports if file has error
2024.07.19 13:18:49 INFO  compiling root (2 scala sources)
2024.07.19 13:18:49 INFO  time: compiled root in 0.2s
jul. 19, 2024 1:18:51 PM scala.meta.internal.pc.CompilerAccess retryWithCleanCompiler
INFORMAÇÕES: compiler crashed due to an error in the Scala compiler, retrying with new compiler instance.
jul. 19, 2024 1:18:52 PM scala.meta.internal.pc.CompilerAccess handleError
GRAVE: A severe compiler error occurred, full details of the error can be found in the error report C:\Users\Vinicius\UnB\FLanguage\.metals\.reports\metals-full\2024-07-19\r_compiler-error_(root)_13-18-52-140.md
jul. 19, 2024 1:23:46 PM scala.meta.internal.pc.CompilerAccess retryWithCleanCompiler
INFORMAÇÕES: compiler crashed due to an error in the Scala compiler, retrying with new compiler instance.
jul. 19, 2024 1:23:46 PM scala.meta.internal.pc.CompilerAccess handleError
GRAVE: A severe compiler error occurred, full details of the error can be found in the error report C:\Users\Vinicius\UnB\FLanguage\.metals\.reports\metals-full\2024-07-19\r_compiler-error_(root)_13-23-46-452.md
jul. 19, 2024 1:23:49 PM scala.meta.internal.pc.CompilerAccess retryWithCleanCompiler
INFORMAÇÕES: compiler crashed due to an error in the Scala compiler, retrying with new compiler instance.
jul. 19, 2024 1:23:49 PM scala.meta.internal.pc.CompilerAccess handleError
GRAVE: A severe compiler error occurred, full details of the error can be found in the error report C:\Users\Vinicius\UnB\FLanguage\.metals\.reports\metals-full\2024-07-19\r_compiler-error_(root)_13-23-49-531.md
jul. 19, 2024 1:23:51 PM scala.meta.internal.pc.CompilerAccess retryWithCleanCompiler
INFORMAÇÕES: compiler crashed due to an error in the Scala compiler, retrying with new compiler instance.
jul. 19, 2024 1:23:51 PM scala.meta.internal.pc.CompilerAccess handleError
GRAVE: A severe compiler error occurred, full details of the error can be found in the error report C:\Users\Vinicius\UnB\FLanguage\.metals\.reports\metals-full\2024-07-19\r_compiler-error_(root)_13-23-51-415.md
jul. 19, 2024 1:23:57 PM scala.meta.internal.pc.CompilerAccess retryWithCleanCompiler
INFORMAÇÕES: compiler crashed due to an error in the Scala compiler, retrying with new compiler instance.
jul. 19, 2024 1:23:58 PM scala.meta.internal.pc.CompilerAccess handleError
GRAVE: A severe compiler error occurred, full details of the error can be found in the error report C:\Users\Vinicius\UnB\FLanguage\.metals\.reports\metals-full\2024-07-19\r_compiler-error_(root)_13-23-58-140.md
jul. 19, 2024 1:23:58 PM scala.meta.internal.pc.CompilerAccess retryWithCleanCompiler
INFORMAÇÕES: compiler crashed due to an error in the Scala compiler, retrying with new compiler instance.
jul. 19, 2024 1:23:58 PM scala.meta.internal.pc.CompilerAccess handleError
GRAVE: A severe compiler error occurred, full details of the error can be found in the error report C:\Users\Vinicius\UnB\FLanguage\.metals\.reports\metals-full\2024-07-19\r_compiler-error_(root)_13-23-58-833.md
jul. 19, 2024 1:23:59 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
ADVERTÊNCIA: Unmatched cancel notification for request id 6652
2024.07.19 13:24:23 INFO  compiling root (2 scala sources)
2024.07.19 13:24:23 INFO  time: compiled root in 0.26s
2024.07.19 13:24:32 INFO  compiling root (2 scala sources)
2024.07.19 13:24:32 INFO  time: compiled root in 0.27s
jul. 19, 2024 1:24:32 PM scala.meta.internal.pc.CompilerAccess retryWithCleanCompiler
INFORMAÇÕES: compiler crashed due to an error in the Scala compiler, retrying with new compiler instance.
jul. 19, 2024 1:24:43 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
ADVERTÊNCIA: Unmatched cancel notification for request id 6721
jul. 19, 2024 1:24:48 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
ADVERTÊNCIA: Unmatched cancel notification for request id 6741
jul. 19, 2024 1:24:49 PM scala.meta.internal.pc.CompilerAccess retryWithCleanCompiler
INFORMAÇÕES: compiler crashed due to an error in the Scala compiler, retrying with new compiler instance.
jul. 19, 2024 1:24:53 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
ADVERTÊNCIA: Unmatched cancel notification for request id 6763
jul. 19, 2024 1:24:54 PM scala.meta.internal.pc.CompilerAccess retryWithCleanCompiler
INFORMAÇÕES: compiler crashed due to an error in the Scala compiler, retrying with new compiler instance.
2024.07.19 13:24:54 INFO  compiling root (2 scala sources)
2024.07.19 13:24:54 INFO  time: compiled root in 0.32s
jul. 19, 2024 1:24:55 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
ADVERTÊNCIA: Unmatched cancel notification for request id 6788
jul. 19, 2024 1:24:56 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
ADVERTÊNCIA: Unmatched cancel notification for request id 6796
2024.07.19 13:24:56 INFO  compiling root (2 scala sources)
2024.07.19 13:24:56 INFO  time: compiled root in 0.22s
jul. 19, 2024 1:24:57 PM scala.meta.internal.pc.CompilerAccess retryWithCleanCompiler
INFORMAÇÕES: compiler crashed due to an error in the Scala compiler, retrying with new compiler instance.
jul. 19, 2024 1:24:57 PM scala.meta.internal.pc.CompilerAccess handleError
GRAVE: A severe compiler error occurred, full details of the error can be found in the error report C:\Users\Vinicius\UnB\FLanguage\.metals\.reports\metals-full\2024-07-19\r_compiler-error_(root)_13-24-57-398.md
jul. 19, 2024 1:25:04 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
ADVERTÊNCIA: Unmatched cancel notification for request id 6819
jul. 19, 2024 1:25:05 PM scala.meta.internal.pc.CompilerAccess retryWithCleanCompiler
INFORMAÇÕES: compiler crashed due to an error in the Scala compiler, retrying with new compiler instance.
jul. 19, 2024 1:25:05 PM scala.meta.internal.pc.CompilerAccess handleError
GRAVE: A severe compiler error occurred, full details of the error can be found in the error report C:\Users\Vinicius\UnB\FLanguage\.metals\.reports\metals-full\2024-07-19\r_compiler-error_(root)_13-25-05-477.md
2024.07.19 13:25:12 INFO  Can not organize imports if file has error
2024.07.19 13:25:12 INFO  compiling root (2 scala sources)
2024.07.19 13:25:12 INFO  time: compiled root in 0.22s
jul. 19, 2024 1:25:13 PM scala.meta.internal.pc.CompilerAccess retryWithCleanCompiler
INFORMAÇÕES: compiler crashed due to an error in the Scala compiler, retrying with new compiler instance.
jul. 19, 2024 1:25:13 PM scala.meta.internal.pc.CompilerAccess handleError
GRAVE: A severe compiler error occurred, full details of the error can be found in the error report C:\Users\Vinicius\UnB\FLanguage\.metals\.reports\metals-full\2024-07-19\r_compiler-error_(root)_13-25-13-590.md
2024.07.19 13:25:22 INFO  Can not organize imports if file has error
2024.07.19 13:25:23 INFO  compiling root (2 scala sources)
2024.07.19 13:25:23 INFO  time: compiled root in 0.2s
2024.07.19 13:25:30 INFO  Can not organize imports if file has error
2024.07.19 13:25:30 INFO  compiling root (2 scala sources)
2024.07.19 13:25:30 INFO  time: compiled root in 0.21s
jul. 19, 2024 1:25:31 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
ADVERTÊNCIA: Unmatched cancel notification for request id 6907
2024.07.19 13:25:32 INFO  Can not organize imports if file has error
2024.07.19 13:25:32 INFO  compiling root (2 scala sources)
2024.07.19 13:25:32 INFO  time: compiled root in 0.21s
2024.07.19 13:25:35 INFO  Can not organize imports if file has error
2024.07.19 13:25:35 INFO  compiling root (2 scala sources)
2024.07.19 13:25:35 INFO  time: compiled root in 0.19s
2024.07.19 13:25:36 INFO  Can not organize imports if file has error
2024.07.19 13:25:36 INFO  compiling root (2 scala sources)
2024.07.19 13:25:36 INFO  time: compiled root in 0.19s
2024.07.19 13:25:45 INFO  Can not organize imports if file has error
2024.07.19 13:25:46 INFO  compiling root (2 scala sources)
2024.07.19 13:25:46 INFO  time: compiled root in 0.21s
2024.07.19 13:25:47 INFO  Can not organize imports if file has error
2024.07.19 13:25:47 INFO  compiling root (2 scala sources)
2024.07.19 13:25:47 INFO  time: compiled root in 0.19s
2024.07.19 13:26:07 INFO  Can not organize imports if file has error
2024.07.19 13:26:07 INFO  compiling root (2 scala sources)
2024.07.19 13:26:07 INFO  time: compiled root in 0.11s
2024.07.19 13:26:09 INFO  Can not organize imports if file has error
2024.07.19 13:26:09 INFO  compiling root (2 scala sources)
2024.07.19 13:26:09 INFO  time: compiled root in 0.21s
2024.07.19 13:26:21 INFO  Can not organize imports if file has error
2024.07.19 13:26:21 INFO  compiling root (2 scala sources)
2024.07.19 13:26:21 INFO  time: compiled root in 0.19s
jul. 19, 2024 1:27:38 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
ADVERTÊNCIA: Unmatched cancel notification for request id 7056
jul. 19, 2024 1:27:38 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
ADVERTÊNCIA: Unmatched cancel notification for request id 7064
jul. 19, 2024 1:27:39 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
ADVERTÊNCIA: Unmatched cancel notification for request id 7068
jul. 19, 2024 1:27:39 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
ADVERTÊNCIA: Unmatched cancel notification for request id 7076
jul. 19, 2024 1:28:08 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
ADVERTÊNCIA: Unmatched cancel notification for request id 7084
2024.07.19 13:28:15 INFO  Can not organize imports if file has error
2024.07.19 13:28:15 INFO  compiling root (2 scala sources)
2024.07.19 13:28:15 INFO  time: compiled root in 0.18s
jul. 19, 2024 1:28:18 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleNotification
ADVERTÊNCIA: Notification threw an exception: {
  "jsonrpc": "2.0",
  "method": "textDocument/didOpen",
  "params": {
    "textDocument": {
      "uri": "jar:file%3A///C%3A/Users/Vinicius/AppData/Local/Coursier/cache/arc/https/github.com/adoptium/temurin17-binaries/releases/download/jdk-17%25252B35/OpenJDK17-jdk_x64_windows_hotspot_17_35.zip/jdk-17%2B35/lib/src.zip%21/java.base/java/lang/Integer.java",
      "languageId": "java",
      "version": 1,
      "text": "/*\n * Copyright (c) 1994, 2021, Oracle and/or its affiliates. All rights reserved.\n * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n *\n * This code is free software; you can redistribute it and/or modify it\n * under the terms of the GNU General Public License version 2 only, as\n * published by the Free Software Foundation.  Oracle designates this\n * particular file as subject to the \"Classpath\" exception as provided\n * by Oracle in the LICENSE file that accompanied this code.\n *\n * This code is distributed in the hope that it will be useful, but WITHOUT\n * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n * version 2 for more details (a copy is included in the LICENSE file that\n * accompanied this code).\n *\n * You should have received a copy of the GNU General Public License version\n * 2 along with this work; if not, write to the Free Software Foundation,\n * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n *\n * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n * or visit www.oracle.com if you need additional information or have any\n * questions.\n */\n\npackage java.lang;\n\nimport java.lang.annotation.Native;\nimport java.lang.invoke.MethodHandles;\nimport java.lang.constant.Constable;\nimport java.lang.constant.ConstantDesc;\nimport java.util.Objects;\nimport java.util.Optional;\n\nimport jdk.internal.misc.CDS;\nimport jdk.internal.misc.VM;\nimport jdk.internal.vm.annotation.IntrinsicCandidate;\n\nimport static java.lang.String.COMPACT_STRINGS;\nimport static java.lang.String.LATIN1;\nimport static java.lang.String.UTF16;\n\n/**\n * The {@code Integer} class wraps a value of the primitive type\n * {@code int} in an object. An object of type {@code Integer}\n * contains a single field whose type is {@code int}.\n *\n * \u003cp\u003eIn addition, this class provides several methods for converting\n * an {@code int} to a {@code String} and a {@code String} to an\n * {@code int}, as well as other constants and methods useful when\n * dealing with an {@code int}.\n *\n * \u003cp\u003eThis is a \u003ca href\u003d\"{@docRoot}/java.base/java/lang/doc-files/ValueBased.html\"\u003evalue-based\u003c/a\u003e\n * class; programmers should treat instances that are\n * {@linkplain #equals(Object) equal} as interchangeable and should not\n * use instances for synchronization, or unpredictable behavior may\n * occur. For example, in a future release, synchronization may fail.\n *\n * \u003cp\u003eImplementation note: The implementations of the \"bit twiddling\"\n * methods (such as {@link #highestOneBit(int) highestOneBit} and\n * {@link #numberOfTrailingZeros(int) numberOfTrailingZeros}) are\n * based on material from Henry S. Warren, Jr.\u0027s \u003ci\u003eHacker\u0027s\n * Delight\u003c/i\u003e, (Addison Wesley, 2002).\n *\n * @author  Lee Boynton\n * @author  Arthur van Hoff\n * @author  Josh Bloch\n * @author  Joseph D. Darcy\n * @since 1.0\n */\n@jdk.internal.ValueBased\npublic final class Integer extends Number\n        implements Comparable\u003cInteger\u003e, Constable, ConstantDesc {\n    /**\n     * A constant holding the minimum value an {@code int} can\n     * have, -2\u003csup\u003e31\u003c/sup\u003e.\n     */\n    @Native public static final int   MIN_VALUE \u003d 0x80000000;\n\n    /**\n     * A constant holding the maximum value an {@code int} can\n     * have, 2\u003csup\u003e31\u003c/sup\u003e-1.\n     */\n    @Native public static final int   MAX_VALUE \u003d 0x7fffffff;\n\n    /**\n     * The {@code Class} instance representing the primitive type\n     * {@code int}.\n     *\n     * @since   1.1\n     */\n    @SuppressWarnings(\"unchecked\")\n    public static final Class\u003cInteger\u003e  TYPE \u003d (Class\u003cInteger\u003e) Class.getPrimitiveClass(\"int\");\n\n    /**\n     * All possible chars for representing a number as a String\n     */\n    static final char[] digits \u003d {\n        \u00270\u0027 , \u00271\u0027 , \u00272\u0027 , \u00273\u0027 , \u00274\u0027 , \u00275\u0027 ,\n        \u00276\u0027 , \u00277\u0027 , \u00278\u0027 , \u00279\u0027 , \u0027a\u0027 , \u0027b\u0027 ,\n        \u0027c\u0027 , \u0027d\u0027 , \u0027e\u0027 , \u0027f\u0027 , \u0027g\u0027 , \u0027h\u0027 ,\n        \u0027i\u0027 , \u0027j\u0027 , \u0027k\u0027 , \u0027l\u0027 , \u0027m\u0027 , \u0027n\u0027 ,\n        \u0027o\u0027 , \u0027p\u0027 , \u0027q\u0027 , \u0027r\u0027 , \u0027s\u0027 , \u0027t\u0027 ,\n        \u0027u\u0027 , \u0027v\u0027 , \u0027w\u0027 , \u0027x\u0027 , \u0027y\u0027 , \u0027z\u0027\n    };\n\n    /**\n     * Returns a string representation of the first argument in the\n     * radix specified by the second argument.\n     *\n     * \u003cp\u003eIf the radix is smaller than {@code Character.MIN_RADIX}\n     * or larger than {@code Character.MAX_RADIX}, then the radix\n     * {@code 10} is used instead.\n     *\n     * \u003cp\u003eIf the first argument is negative, the first element of the\n     * result is the ASCII minus character {@code \u0027-\u0027}\n     * ({@code \u0027\\u005Cu002D\u0027}). If the first argument is not\n     * negative, no sign character appears in the result.\n     *\n     * \u003cp\u003eThe remaining characters of the result represent the magnitude\n     * of the first argument. If the magnitude is zero, it is\n     * represented by a single zero character {@code \u00270\u0027}\n     * ({@code \u0027\\u005Cu0030\u0027}); otherwise, the first character of\n     * the representation of the magnitude will not be the zero\n     * character.  The following ASCII characters are used as digits:\n     *\n     * \u003cblockquote\u003e\n     *   {@code 0123456789abcdefghijklmnopqrstuvwxyz}\n     * \u003c/blockquote\u003e\n     *\n     * These are {@code \u0027\\u005Cu0030\u0027} through\n     * {@code \u0027\\u005Cu0039\u0027} and {@code \u0027\\u005Cu0061\u0027} through\n     * {@code \u0027\\u005Cu007A\u0027}. If {@code radix} is\n     * \u003cvar\u003eN\u003c/var\u003e, then the first \u003cvar\u003eN\u003c/var\u003e of these characters\n     * are used as radix-\u003cvar\u003eN\u003c/var\u003e digits in the order shown. Thus,\n     * the digits for hexadecimal (radix 16) are\n     * {@code 0123456789abcdef}. If uppercase letters are\n     * desired, the {@link java.lang.String#toUpperCase()} method may\n     * be called on the result:\n     *\n     * \u003cblockquote\u003e\n     *  {@code Integer.toString(n, 16).toUpperCase()}\n     * \u003c/blockquote\u003e\n     *\n     * @param   i       an integer to be converted to a string.\n     * @param   radix   the radix to use in the string representation.\n     * @return  a string representation of the argument in the specified radix.\n     * @see     java.lang.Character#MAX_RADIX\n     * @see     java.lang.Character#MIN_RADIX\n     */\n    public static String toString(int i, int radix) {\n        if (radix \u003c Character.MIN_RADIX || radix \u003e Character.MAX_RADIX)\n            radix \u003d 10;\n\n        /* Use the faster version */\n        if (radix \u003d\u003d 10) {\n            return toString(i);\n        }\n\n        if (COMPACT_STRINGS) {\n            byte[] buf \u003d new byte[33];\n            boolean negative \u003d (i \u003c 0);\n            int charPos \u003d 32;\n\n            if (!negative) {\n                i \u003d -i;\n            }\n\n            while (i \u003c\u003d -radix) {\n                buf[charPos--] \u003d (byte)digits[-(i % radix)];\n                i \u003d i / radix;\n            }\n            buf[charPos] \u003d (byte)digits[-i];\n\n            if (negative) {\n                buf[--charPos] \u003d \u0027-\u0027;\n            }\n\n            return StringLatin1.newString(buf, charPos, (33 - charPos));\n        }\n        return toStringUTF16(i, radix);\n    }\n\n    private static String toStringUTF16(int i, int radix) {\n        byte[] buf \u003d new byte[33 * 2];\n        boolean negative \u003d (i \u003c 0);\n        int charPos \u003d 32;\n        if (!negative) {\n            i \u003d -i;\n        }\n        while (i \u003c\u003d -radix) {\n            StringUTF16.putChar(buf, charPos--, digits[-(i % radix)]);\n            i \u003d i / radix;\n        }\n        StringUTF16.putChar(buf, charPos, digits[-i]);\n\n        if (negative) {\n            StringUTF16.putChar(buf, --charPos, \u0027-\u0027);\n        }\n        return StringUTF16.newString(buf, charPos, (33 - charPos));\n    }\n\n    /**\n     * Returns a string representation of the first argument as an\n     * unsigned integer value in the radix specified by the second\n     * argument.\n     *\n     * \u003cp\u003eIf the radix is smaller than {@code Character.MIN_RADIX}\n     * or larger than {@code Character.MAX_RADIX}, then the radix\n     * {@code 10} is used instead.\n     *\n     * \u003cp\u003eNote that since the first argument is treated as an unsigned\n     * value, no leading sign character is printed.\n     *\n     * \u003cp\u003eIf the magnitude is zero, it is represented by a single zero\n     * character {@code \u00270\u0027} ({@code \u0027\\u005Cu0030\u0027}); otherwise,\n     * the first character of the representation of the magnitude will\n     * not be the zero character.\n     *\n     * \u003cp\u003eThe behavior of radixes and the characters used as digits\n     * are the same as {@link #toString(int, int) toString}.\n     *\n     * @param   i       an integer to be converted to an unsigned string.\n     * @param   radix   the radix to use in the string representation.\n     * @return  an unsigned string representation of the argument in the specified radix.\n     * @see     #toString(int, int)\n     * @since 1.8\n     */\n    public static String toUnsignedString(int i, int radix) {\n        return Long.toUnsignedString(toUnsignedLong(i), radix);\n    }\n\n    /**\n     * Returns a string representation of the integer argument as an\n     * unsigned integer in base\u0026nbsp;16.\n     *\n     * \u003cp\u003eThe unsigned integer value is the argument plus 2\u003csup\u003e32\u003c/sup\u003e\n     * if the argument is negative; otherwise, it is equal to the\n     * argument.  This value is converted to a string of ASCII digits\n     * in hexadecimal (base\u0026nbsp;16) with no extra leading\n     * {@code 0}s.\n     *\n     * \u003cp\u003eThe value of the argument can be recovered from the returned\n     * string {@code s} by calling {@link\n     * Integer#parseUnsignedInt(String, int)\n     * Integer.parseUnsignedInt(s, 16)}.\n     *\n     * \u003cp\u003eIf the unsigned magnitude is zero, it is represented by a\n     * single zero character {@code \u00270\u0027} ({@code \u0027\\u005Cu0030\u0027});\n     * otherwise, the first character of the representation of the\n     * unsigned magnitude will not be the zero character. The\n     * following characters are used as hexadecimal digits:\n     *\n     * \u003cblockquote\u003e\n     *  {@code 0123456789abcdef}\n     * \u003c/blockquote\u003e\n     *\n     * These are the characters {@code \u0027\\u005Cu0030\u0027} through\n     * {@code \u0027\\u005Cu0039\u0027} and {@code \u0027\\u005Cu0061\u0027} through\n     * {@code \u0027\\u005Cu0066\u0027}. If uppercase letters are\n     * desired, the {@link java.lang.String#toUpperCase()} method may\n     * be called on the result:\n     *\n     * \u003cblockquote\u003e\n     *  {@code Integer.toHexString(n).toUpperCase()}\n     * \u003c/blockquote\u003e\n     *\n     * @apiNote\n     * The {@link java.util.HexFormat} class provides formatting and parsing\n     * of byte arrays and primitives to return a string or adding to an {@link Appendable}.\n     * {@code HexFormat} formats and parses uppercase or lowercase hexadecimal characters,\n     * with leading zeros and for byte arrays includes for each byte\n     * a delimiter, prefix, and suffix.\n     *\n     * @param   i   an integer to be converted to a string.\n     * @return  the string representation of the unsigned integer value\n     *          represented by the argument in hexadecimal (base\u0026nbsp;16).\n     * @see java.util.HexFormat\n     * @see #parseUnsignedInt(String, int)\n     * @see #toUnsignedString(int, int)\n     * @since   1.0.2\n     */\n    public static String toHexString(int i) {\n        return toUnsignedString0(i, 4);\n    }\n\n    /**\n     * Returns a string representation of the integer argument as an\n     * unsigned integer in base\u0026nbsp;8.\n     *\n     * \u003cp\u003eThe unsigned integer value is the argument plus 2\u003csup\u003e32\u003c/sup\u003e\n     * if the argument is negative; otherwise, it is equal to the\n     * argument.  This value is converted to a string of ASCII digits\n     * in octal (base\u0026nbsp;8) with no extra leading {@code 0}s.\n     *\n     * \u003cp\u003eThe value of the argument can be recovered from the returned\n     * string {@code s} by calling {@link\n     * Integer#parseUnsignedInt(String, int)\n     * Integer.parseUnsignedInt(s, 8)}.\n     *\n     * \u003cp\u003eIf the unsigned magnitude is zero, it is represented by a\n     * single zero character {@code \u00270\u0027} ({@code \u0027\\u005Cu0030\u0027});\n     * otherwise, the first character of the representation of the\n     * unsigned magnitude will not be the zero character. The\n     * following characters are used as octal digits:\n     *\n     * \u003cblockquote\u003e\n     * {@code 01234567}\n     * \u003c/blockquote\u003e\n     *\n     * These are the characters {@code \u0027\\u005Cu0030\u0027} through\n     * {@code \u0027\\u005Cu0037\u0027}.\n     *\n     * @param   i   an integer to be converted to a string.\n     * @return  the string representation of the unsigned integer value\n     *          represented by the argument in octal (base\u0026nbsp;8).\n     * @see #parseUnsignedInt(String, int)\n     * @see #toUnsignedString(int, int)\n     * @since   1.0.2\n     */\n    public static String toOctalString(int i) {\n        return toUnsignedString0(i, 3);\n    }\n\n    /**\n     * Returns a string representation of the integer argument as an\n     * unsigned integer in base\u0026nbsp;2.\n     *\n     * \u003cp\u003eThe unsigned integer value is the argument plus 2\u003csup\u003e32\u003c/sup\u003e\n     * if the argument is negative; otherwise it is equal to the\n     * argument.  This value is converted to a string of ASCII digits\n     * in binary (base\u0026nbsp;2) with no extra leading {@code 0}s.\n     *\n     * \u003cp\u003eThe value of the argument can be recovered from the returned\n     * string {@code s} by calling {@link\n     * Integer#parseUnsignedInt(String, int)\n     * Integer.parseUnsignedInt(s, 2)}.\n     *\n     * \u003cp\u003eIf the unsigned magnitude is zero, it is represented by a\n     * single zero character {@code \u00270\u0027} ({@code \u0027\\u005Cu0030\u0027});\n     * otherwise, the first character of the representation of the\n     * unsigned magnitude will not be the zero character. The\n     * characters {@code \u00270\u0027} ({@code \u0027\\u005Cu0030\u0027}) and {@code\n     * \u00271\u0027} ({@code \u0027\\u005Cu0031\u0027}) are used as binary digits.\n     *\n     * @param   i   an integer to be converted to a string.\n     * @return  the string representation of the unsigned integer value\n     *          represented by the argument in binary (base\u0026nbsp;2).\n     * @see #parseUnsignedInt(String, int)\n     * @see #toUnsignedString(int, int)\n     * @since   1.0.2\n     */\n    public static String toBinaryString(int i) {\n        return toUnsignedString0(i, 1);\n    }\n\n    /**\n     * Convert the integer to an unsigned number.\n     */\n    private static String toUnsignedString0(int val, int shift) {\n        // assert shift \u003e 0 \u0026\u0026 shift \u003c\u003d5 : \"Illegal shift value\";\n        int mag \u003d Integer.SIZE - Integer.numberOfLeadingZeros(val);\n        int chars \u003d Math.max(((mag + (shift - 1)) / shift), 1);\n        if (COMPACT_STRINGS) {\n            byte[] buf \u003d new byte[chars];\n            formatUnsignedInt(val, shift, buf, chars);\n            return new String(buf, LATIN1);\n        } else {\n            byte[] buf \u003d new byte[chars * 2];\n            formatUnsignedIntUTF16(val, shift, buf, chars);\n            return new String(buf, UTF16);\n        }\n    }\n\n    /**\n     * Format an {@code int} (treated as unsigned) into a byte buffer (LATIN1 version). If\n     * {@code len} exceeds the formatted ASCII representation of {@code val},\n     * {@code buf} will be padded with leading zeroes.\n     *\n     * @param val the unsigned int to format\n     * @param shift the log2 of the base to format in (4 for hex, 3 for octal, 1 for binary)\n     * @param buf the byte buffer to write to\n     * @param len the number of characters to write\n     */\n    private static void formatUnsignedInt(int val, int shift, byte[] buf, int len) {\n        int charPos \u003d len;\n        int radix \u003d 1 \u003c\u003c shift;\n        int mask \u003d radix - 1;\n        do {\n            buf[--charPos] \u003d (byte)Integer.digits[val \u0026 mask];\n            val \u003e\u003e\u003e\u003d shift;\n        } while (charPos \u003e 0);\n    }\n\n    /**\n     * Format an {@code int} (treated as unsigned) into a byte buffer (UTF16 version). If\n     * {@code len} exceeds the formatted ASCII representation of {@code val},\n     * {@code buf} will be padded with leading zeroes.\n     *\n     * @param val the unsigned int to format\n     * @param shift the log2 of the base to format in (4 for hex, 3 for octal, 1 for binary)\n     * @param buf the byte buffer to write to\n     * @param len the number of characters to write\n     */\n    private static void formatUnsignedIntUTF16(int val, int shift, byte[] buf, int len) {\n        int charPos \u003d len;\n        int radix \u003d 1 \u003c\u003c shift;\n        int mask \u003d radix - 1;\n        do {\n            StringUTF16.putChar(buf, --charPos, Integer.digits[val \u0026 mask]);\n            val \u003e\u003e\u003e\u003d shift;\n        } while (charPos \u003e 0);\n    }\n\n    static final byte[] DigitTens \u003d {\n        \u00270\u0027, \u00270\u0027, \u00270\u0027, \u00270\u0027, \u00270\u0027, \u00270\u0027, \u00270\u0027, \u00270\u0027, \u00270\u0027, \u00270\u0027,\n        \u00271\u0027, \u00271\u0027, \u00271\u0027, \u00271\u0027, \u00271\u0027, \u00271\u0027, \u00271\u0027, \u00271\u0027, \u00271\u0027, \u00271\u0027,\n        \u00272\u0027, \u00272\u0027, \u00272\u0027, \u00272\u0027, \u00272\u0027, \u00272\u0027, \u00272\u0027, \u00272\u0027, \u00272\u0027, \u00272\u0027,\n        \u00273\u0027, \u00273\u0027, \u00273\u0027, \u00273\u0027, \u00273\u0027, \u00273\u0027, \u00273\u0027, \u00273\u0027, \u00273\u0027, \u00273\u0027,\n        \u00274\u0027, \u00274\u0027, \u00274\u0027, \u00274\u0027, \u00274\u0027, \u00274\u0027, \u00274\u0027, \u00274\u0027, \u00274\u0027, \u00274\u0027,\n        \u00275\u0027, \u00275\u0027, \u00275\u0027, \u00275\u0027, \u00275\u0027, \u00275\u0027, \u00275\u0027, \u00275\u0027, \u00275\u0027, \u00275\u0027,\n        \u00276\u0027, \u00276\u0027, \u00276\u0027, \u00276\u0027, \u00276\u0027, \u00276\u0027, \u00276\u0027, \u00276\u0027, \u00276\u0027, \u00276\u0027,\n        \u00277\u0027, \u00277\u0027, \u00277\u0027, \u00277\u0027, \u00277\u0027, \u00277\u0027, \u00277\u0027, \u00277\u0027, \u00277\u0027, \u00277\u0027,\n        \u00278\u0027, \u00278\u0027, \u00278\u0027, \u00278\u0027, \u00278\u0027, \u00278\u0027, \u00278\u0027, \u00278\u0027, \u00278\u0027, \u00278\u0027,\n        \u00279\u0027, \u00279\u0027, \u00279\u0027, \u00279\u0027, \u00279\u0027, \u00279\u0027, \u00279\u0027, \u00279\u0027, \u00279\u0027, \u00279\u0027,\n        } ;\n\n    static final byte[] DigitOnes \u003d {\n        \u00270\u0027, \u00271\u0027, \u00272\u0027, \u00273\u0027, \u00274\u0027, \u00275\u0027, \u00276\u0027, \u00277\u0027, \u00278\u0027, \u00279\u0027,\n        \u00270\u0027, \u00271\u0027, \u00272\u0027, \u00273\u0027, \u00274\u0027, \u00275\u0027, \u00276\u0027, \u00277\u0027, \u00278\u0027, \u00279\u0027,\n        \u00270\u0027, \u00271\u0027, \u00272\u0027, \u00273\u0027, \u00274\u0027, \u00275\u0027, \u00276\u0027, \u00277\u0027, \u00278\u0027, \u00279\u0027,\n        \u00270\u0027, \u00271\u0027, \u00272\u0027, \u00273\u0027, \u00274\u0027, \u00275\u0027, \u00276\u0027, \u00277\u0027, \u00278\u0027, \u00279\u0027,\n        \u00270\u0027, \u00271\u0027, \u00272\u0027, \u00273\u0027, \u00274\u0027, \u00275\u0027, \u00276\u0027, \u00277\u0027, \u00278\u0027, \u00279\u0027,\n        \u00270\u0027, \u00271\u0027, \u00272\u0027, \u00273\u0027, \u00274\u0027, \u00275\u0027, \u00276\u0027, \u00277\u0027, \u00278\u0027, \u00279\u0027,\n        \u00270\u0027, \u00271\u0027, \u00272\u0027, \u00273\u0027, \u00274\u0027, \u00275\u0027, \u00276\u0027, \u00277\u0027, \u00278\u0027, \u00279\u0027,\n        \u00270\u0027, \u00271\u0027, \u00272\u0027, \u00273\u0027, \u00274\u0027, \u00275\u0027, \u00276\u0027, \u00277\u0027, \u00278\u0027, \u00279\u0027,\n        \u00270\u0027, \u00271\u0027, \u00272\u0027, \u00273\u0027, \u00274\u0027, \u00275\u0027, \u00276\u0027, \u00277\u0027, \u00278\u0027, \u00279\u0027,\n        \u00270\u0027, \u00271\u0027, \u00272\u0027, \u00273\u0027, \u00274\u0027, \u00275\u0027, \u00276\u0027, \u00277\u0027, \u00278\u0027, \u00279\u0027,\n        } ;\n\n\n    /**\n     * Returns a {@code String} object representing the\n     * specified integer. The argument is converted to signed decimal\n     * representation and returned as a string, exactly as if the\n     * argument and radix 10 were given as arguments to the {@link\n     * #toString(int, int)} method.\n     *\n     * @param   i   an integer to be converted.\n     * @return  a string representation of the argument in base\u0026nbsp;10.\n     */\n    @IntrinsicCandidate\n    public static String toString(int i) {\n        int size \u003d stringSize(i);\n        if (COMPACT_STRINGS) {\n            byte[] buf \u003d new byte[size];\n            getChars(i, size, buf);\n            return new String(buf, LATIN1);\n        } else {\n            byte[] buf \u003d new byte[size * 2];\n            StringUTF16.getChars(i, size, buf);\n            return new String(buf, UTF16);\n        }\n    }\n\n    /**\n     * Returns a string representation of the argument as an unsigned\n     * decimal value.\n     *\n     * The argument is converted to unsigned decimal representation\n     * and returned as a string exactly as if the argument and radix\n     * 10 were given as arguments to the {@link #toUnsignedString(int,\n     * int)} method.\n     *\n     * @param   i  an integer to be converted to an unsigned string.\n     * @return  an unsigned string representation of the argument.\n     * @see     #toUnsignedString(int, int)\n     * @since 1.8\n     */\n    public static String toUnsignedString(int i) {\n        return Long.toString(toUnsignedLong(i));\n    }\n\n    /**\n     * Places characters representing the integer i into the\n     * character array buf. The characters are placed into\n     * the buffer backwards starting with the least significant\n     * digit at the specified index (exclusive), and working\n     * backwards from there.\n     *\n     * @implNote This method converts positive inputs into negative\n     * values, to cover the Integer.MIN_VALUE case. Converting otherwise\n     * (negative to positive) will expose -Integer.MIN_VALUE that overflows\n     * integer.\n     *\n     * @param i     value to convert\n     * @param index next index, after the least significant digit\n     * @param buf   target buffer, Latin1-encoded\n     * @return index of the most significant digit or minus sign, if present\n     */\n    static int getChars(int i, int index, byte[] buf) {\n        int q, r;\n        int charPos \u003d index;\n\n        boolean negative \u003d i \u003c 0;\n        if (!negative) {\n            i \u003d -i;\n        }\n\n        // Generate two digits per iteration\n        while (i \u003c\u003d -100) {\n            q \u003d i / 100;\n            r \u003d (q * 100) - i;\n            i \u003d q;\n            buf[--charPos] \u003d DigitOnes[r];\n            buf[--charPos] \u003d DigitTens[r];\n        }\n\n        // We know there are at most two digits left at this point.\n        q \u003d i / 10;\n        r \u003d (q * 10) - i;\n        buf[--charPos] \u003d (byte)(\u00270\u0027 + r);\n\n        // Whatever left is the remaining digit.\n        if (q \u003c 0) {\n            buf[--charPos] \u003d (byte)(\u00270\u0027 - q);\n        }\n\n        if (negative) {\n            buf[--charPos] \u003d (byte)\u0027-\u0027;\n        }\n        return charPos;\n    }\n\n    // Left here for compatibility reasons, see JDK-8143900.\n    static final int [] sizeTable \u003d { 9, 99, 999, 9999, 99999, 999999, 9999999,\n                                      99999999, 999999999, Integer.MAX_VALUE };\n\n    /**\n     * Returns the string representation size for a given int value.\n     *\n     * @param x int value\n     * @return string size\n     *\n     * @implNote There are other ways to compute this: e.g. binary search,\n     * but values are biased heavily towards zero, and therefore linear search\n     * wins. The iteration results are also routinely inlined in the generated\n     * code after loop unrolling.\n     */\n    static int stringSize(int x) {\n        int d \u003d 1;\n        if (x \u003e\u003d 0) {\n            d \u003d 0;\n            x \u003d -x;\n        }\n        int p \u003d -10;\n        for (int i \u003d 1; i \u003c 10; i++) {\n            if (x \u003e p)\n                return i + d;\n            p \u003d 10 * p;\n        }\n        return 10 + d;\n    }\n\n    /**\n     * Parses the string argument as a signed integer in the radix\n     * specified by the second argument. The characters in the string\n     * must all be digits of the specified radix (as determined by\n     * whether {@link java.lang.Character#digit(char, int)} returns a\n     * nonnegative value), except that the first character may be an\n     * ASCII minus sign {@code \u0027-\u0027} ({@code \u0027\\u005Cu002D\u0027}) to\n     * indicate a negative value or an ASCII plus sign {@code \u0027+\u0027}\n     * ({@code \u0027\\u005Cu002B\u0027}) to indicate a positive value. The\n     * resulting integer value is returned.\n     *\n     * \u003cp\u003eAn exception of type {@code NumberFormatException} is\n     * thrown if any of the following situations occurs:\n     * \u003cul\u003e\n     * \u003cli\u003eThe first argument is {@code null} or is a string of\n     * length zero.\n     *\n     * \u003cli\u003eThe radix is either smaller than\n     * {@link java.lang.Character#MIN_RADIX} or\n     * larger than {@link java.lang.Character#MAX_RADIX}.\n     *\n     * \u003cli\u003eAny character of the string is not a digit of the specified\n     * radix, except that the first character may be a minus sign\n     * {@code \u0027-\u0027} ({@code \u0027\\u005Cu002D\u0027}) or plus sign\n     * {@code \u0027+\u0027} ({@code \u0027\\u005Cu002B\u0027}) provided that the\n     * string is longer than length 1.\n     *\n     * \u003cli\u003eThe value represented by the string is not a value of type\n     * {@code int}.\n     * \u003c/ul\u003e\n     *\n     * \u003cp\u003eExamples:\n     * \u003cblockquote\u003e\u003cpre\u003e\n     * parseInt(\"0\", 10) returns 0\n     * parseInt(\"473\", 10) returns 473\n     * parseInt(\"+42\", 10) returns 42\n     * parseInt(\"-0\", 10) returns 0\n     * parseInt(\"-FF\", 16) returns -255\n     * parseInt(\"1100110\", 2) returns 102\n     * parseInt(\"2147483647\", 10) returns 2147483647\n     * parseInt(\"-2147483648\", 10) returns -2147483648\n     * parseInt(\"2147483648\", 10) throws a NumberFormatException\n     * parseInt(\"99\", 8) throws a NumberFormatException\n     * parseInt(\"Kona\", 10) throws a NumberFormatException\n     * parseInt(\"Kona\", 27) returns 411787\n     * \u003c/pre\u003e\u003c/blockquote\u003e\n     *\n     * @param      s   the {@code String} containing the integer\n     *                  representation to be parsed\n     * @param      radix   the radix to be used while parsing {@code s}.\n     * @return     the integer represented by the string argument in the\n     *             specified radix.\n     * @throws     NumberFormatException if the {@code String}\n     *             does not contain a parsable {@code int}.\n     */\n    public static int parseInt(String s, int radix)\n                throws NumberFormatException\n    {\n        /*\n         * WARNING: This method may be invoked early during VM initialization\n         * before IntegerCache is initialized. Care must be taken to not use\n         * the valueOf method.\n         */\n\n        if (s \u003d\u003d null) {\n            throw new NumberFormatException(\"Cannot parse null string\");\n        }\n\n        if (radix \u003c Character.MIN_RADIX) {\n            throw new NumberFormatException(\"radix \" + radix +\n                                            \" less than Character.MIN_RADIX\");\n        }\n\n        if (radix \u003e Character.MAX_RADIX) {\n            throw new NumberFormatException(\"radix \" + radix +\n                                            \" greater than Character.MAX_RADIX\");\n        }\n\n        boolean negative \u003d false;\n        int i \u003d 0, len \u003d s.length();\n        int limit \u003d -Integer.MAX_VALUE;\n\n        if (len \u003e 0) {\n            char firstChar \u003d s.charAt(0);\n            if (firstChar \u003c \u00270\u0027) { // Possible leading \"+\" or \"-\"\n                if (firstChar \u003d\u003d \u0027-\u0027) {\n                    negative \u003d true;\n                    limit \u003d Integer.MIN_VALUE;\n                } else if (firstChar !\u003d \u0027+\u0027) {\n                    throw NumberFormatException.forInputString(s, radix);\n                }\n\n                if (len \u003d\u003d 1) { // Cannot have lone \"+\" or \"-\"\n                    throw NumberFormatException.forInputString(s, radix);\n                }\n                i++;\n            }\n            int multmin \u003d limit / radix;\n            int result \u003d 0;\n            while (i \u003c len) {\n                // Accumulating negatively avoids surprises near MAX_VALUE\n                int digit \u003d Character.digit(s.charAt(i++), radix);\n                if (digit \u003c 0 || result \u003c multmin) {\n                    throw NumberFormatException.forInputString(s, radix);\n                }\n                result *\u003d radix;\n                if (result \u003c limit + digit) {\n                    throw NumberFormatException.forInputString(s, radix);\n                }\n                result -\u003d digit;\n            }\n            return negative ? result : -result;\n        } else {\n            throw NumberFormatException.forInputString(s, radix);\n        }\n    }\n\n    /**\n     * Parses the {@link CharSequence} argument as a signed {@code int} in the\n     * specified {@code radix}, beginning at the specified {@code beginIndex}\n     * and extending to {@code endIndex - 1}.\n     *\n     * \u003cp\u003eThe method does not take steps to guard against the\n     * {@code CharSequence} being mutated while parsing.\n     *\n     * @param      s   the {@code CharSequence} containing the {@code int}\n     *                  representation to be parsed\n     * @param      beginIndex   the beginning index, inclusive.\n     * @param      endIndex     the ending index, exclusive.\n     * @param      radix   the radix to be used while parsing {@code s}.\n     * @return     the signed {@code int} represented by the subsequence in\n     *             the specified radix.\n     * @throws     NullPointerException  if {@code s} is null.\n     * @throws     IndexOutOfBoundsException  if {@code beginIndex} is\n     *             negative, or if {@code beginIndex} is greater than\n     *             {@code endIndex} or if {@code endIndex} is greater than\n     *             {@code s.length()}.\n     * @throws     NumberFormatException  if the {@code CharSequence} does not\n     *             contain a parsable {@code int} in the specified\n     *             {@code radix}, or if {@code radix} is either smaller than\n     *             {@link java.lang.Character#MIN_RADIX} or larger than\n     *             {@link java.lang.Character#MAX_RADIX}.\n     * @since  9\n     */\n    public static int parseInt(CharSequence s, int beginIndex, int endIndex, int radix)\n                throws NumberFormatException {\n        Objects.requireNonNull(s);\n\n        if (beginIndex \u003c 0 || beginIndex \u003e endIndex || endIndex \u003e s.length()) {\n            throw new IndexOutOfBoundsException();\n        }\n        if (radix \u003c Character.MIN_RADIX) {\n            throw new NumberFormatException(\"radix \" + radix +\n                                            \" less than Character.MIN_RADIX\");\n        }\n        if (radix \u003e Character.MAX_RADIX) {\n            throw new NumberFormatException(\"radix \" + radix +\n                                            \" greater than Character.MAX_RADIX\");\n        }\n\n        boolean negative \u003d false;\n        int i \u003d beginIndex;\n        int limit \u003d -Integer.MAX_VALUE;\n\n        if (i \u003c endIndex) {\n            char firstChar \u003d s.charAt(i);\n            if (firstChar \u003c \u00270\u0027) { // Possible leading \"+\" or \"-\"\n                if (firstChar \u003d\u003d \u0027-\u0027) {\n                    negative \u003d true;\n                    limit \u003d Integer.MIN_VALUE;\n                } else if (firstChar !\u003d \u0027+\u0027) {\n                    throw NumberFormatException.forCharSequence(s, beginIndex,\n                            endIndex, i);\n                }\n                i++;\n                if (i \u003d\u003d endIndex) { // Cannot have lone \"+\" or \"-\"\n                    throw NumberFormatException.forCharSequence(s, beginIndex,\n                            endIndex, i);\n                }\n            }\n            int multmin \u003d limit / radix;\n            int result \u003d 0;\n            while (i \u003c endIndex) {\n                // Accumulating negatively avoids surprises near MAX_VALUE\n                int digit \u003d Character.digit(s.charAt(i), radix);\n                if (digit \u003c 0 || result \u003c multmin) {\n                    throw NumberFormatException.forCharSequence(s, beginIndex,\n                            endIndex, i);\n                }\n                result *\u003d radix;\n                if (result \u003c limit + digit) {\n                    throw NumberFormatException.forCharSequence(s, beginIndex,\n                            endIndex, i);\n                }\n                i++;\n                result -\u003d digit;\n            }\n            return negative ? result : -result;\n        } else {\n            throw NumberFormatException.forInputString(\"\", radix);\n        }\n    }\n\n    /**\n     * Parses the string argument as a signed decimal integer. The\n     * characters in the string must all be decimal digits, except\n     * that the first character may be an ASCII minus sign {@code \u0027-\u0027}\n     * ({@code \u0027\\u005Cu002D\u0027}) to indicate a negative value or an\n     * ASCII plus sign {@code \u0027+\u0027} ({@code \u0027\\u005Cu002B\u0027}) to\n     * indicate a positive value. The resulting integer value is\n     * returned, exactly as if the argument and the radix 10 were\n     * given as arguments to the {@link #parseInt(java.lang.String,\n     * int)} method.\n     *\n     * @param s    a {@code String} containing the {@code int}\n     *             representation to be parsed\n     * @return     the integer value represented by the argument in decimal.\n     * @throws     NumberFormatException  if the string does not contain a\n     *               parsable integer.\n     */\n    public static int parseInt(String s) throws NumberFormatException {\n        return parseInt(s,10);\n    }\n\n    /**\n     * Parses the string argument as an unsigned integer in the radix\n     * specified by the second argument.  An unsigned integer maps the\n     * values usually associated with negative numbers to positive\n     * numbers larger than {@code MAX_VALUE}.\n     *\n     * The characters in the string must all be digits of the\n     * specified radix (as determined by whether {@link\n     * java.lang.Character#digit(char, int)} returns a nonnegative\n     * value), except that the first character may be an ASCII plus\n     * sign {@code \u0027+\u0027} ({@code \u0027\\u005Cu002B\u0027}). The resulting\n     * integer value is returned.\n     *\n     * \u003cp\u003eAn exception of type {@code NumberFormatException} is\n     * thrown if any of the following situations occurs:\n     * \u003cul\u003e\n     * \u003cli\u003eThe first argument is {@code null} or is a string of\n     * length zero.\n     *\n     * \u003cli\u003eThe radix is either smaller than\n     * {@link java.lang.Character#MIN_RADIX} or\n     * larger than {@link java.lang.Character#MAX_RADIX}.\n     *\n     * \u003cli\u003eAny character of the string is not a digit of the specified\n     * radix, except that the first character may be a plus sign\n     * {@code \u0027+\u0027} ({@code \u0027\\u005Cu002B\u0027}) provided that the\n     * string is longer than length 1.\n     *\n     * \u003cli\u003eThe value represented by the string is larger than the\n     * largest unsigned {@code int}, 2\u003csup\u003e32\u003c/sup\u003e-1.\n     *\n     * \u003c/ul\u003e\n     *\n     *\n     * @param      s   the {@code String} containing the unsigned integer\n     *                  representation to be parsed\n     * @param      radix   the radix to be used while parsing {@code s}.\n     * @return     the integer represented by the string argument in the\n     *             specified radix.\n     * @throws     NumberFormatException if the {@code String}\n     *             does not contain a parsable {@code int}.\n     * @since 1.8\n     */\n    public static int parseUnsignedInt(String s, int radix)\n                throws NumberFormatException {\n        if (s \u003d\u003d null)  {\n            throw new NumberFormatException(\"Cannot parse null string\");\n        }\n\n        int len \u003d s.length();\n        if (len \u003e 0) {\n            char firstChar \u003d s.charAt(0);\n            if (firstChar \u003d\u003d \u0027-\u0027) {\n                throw new\n                    NumberFormatException(String.format(\"Illegal leading minus sign \" +\n                                                       \"on unsigned string %s.\", s));\n            } else {\n                if (len \u003c\u003d 5 || // Integer.MAX_VALUE in Character.MAX_RADIX is 6 digits\n                    (radix \u003d\u003d 10 \u0026\u0026 len \u003c\u003d 9) ) { // Integer.MAX_VALUE in base 10 is 10 digits\n                    return parseInt(s, radix);\n                } else {\n                    long ell \u003d Long.parseLong(s, radix);\n                    if ((ell \u0026 0xffff_ffff_0000_0000L) \u003d\u003d 0) {\n                        return (int) ell;\n                    } else {\n                        throw new\n                            NumberFormatException(String.format(\"String value %s exceeds \" +\n                                                                \"range of unsigned int.\", s));\n                    }\n                }\n            }\n        } else {\n            throw NumberFormatException.forInputString(s, radix);\n        }\n    }\n\n    /**\n     * Parses the {@link CharSequence} argument as an unsigned {@code int} in\n     * the specified {@code radix}, beginning at the specified\n     * {@code beginIndex} and extending to {@code endIndex - 1}.\n     *\n     * \u003cp\u003eThe method does not take steps to guard against the\n     * {@code CharSequence} being mutated while parsing.\n     *\n     * @param      s   the {@code CharSequence} containing the unsigned\n     *                 {@code int} representation to be parsed\n     * @param      beginIndex   the beginning index, inclusive.\n     * @param      endIndex     the ending index, exclusive.\n     * @param      radix   the radix to be used while parsing {@code s}.\n     * @return     the unsigned {@code int} represented by the subsequence in\n     *             the specified radix.\n     * @throws     NullPointerException  if {@code s} is null.\n     * @throws     IndexOutOfBoundsException  if {@code beginIndex} is\n     *             negative, or if {@code beginIndex} is greater than\n     *             {@code endIndex} or if {@code endIndex} is greater than\n     *             {@code s.length()}.\n     * @throws     NumberFormatException  if the {@code CharSequence} does not\n     *             contain a parsable unsigned {@code int} in the specified\n     *             {@code radix}, or if {@code radix} is either smaller than\n     *             {@link java.lang.Character#MIN_RADIX} or larger than\n     *             {@link java.lang.Character#MAX_RADIX}.\n     * @since  9\n     */\n    public static int parseUnsignedInt(CharSequence s, int beginIndex, int endIndex, int radix)\n                throws NumberFormatException {\n        Objects.requireNonNull(s);\n\n        if (beginIndex \u003c 0 || beginIndex \u003e endIndex || endIndex \u003e s.length()) {\n            throw new IndexOutOfBoundsException();\n        }\n        int start \u003d beginIndex, len \u003d endIndex - beginIndex;\n\n        if (len \u003e 0) {\n            char firstChar \u003d s.charAt(start);\n            if (firstChar \u003d\u003d \u0027-\u0027) {\n                throw new\n                    NumberFormatException(String.format(\"Illegal leading minus sign \" +\n                                                       \"on unsigned string %s.\", s));\n            } else {\n                if (len \u003c\u003d 5 || // Integer.MAX_VALUE in Character.MAX_RADIX is 6 digits\n                        (radix \u003d\u003d 10 \u0026\u0026 len \u003c\u003d 9)) { // Integer.MAX_VALUE in base 10 is 10 digits\n                    return parseInt(s, start, start + len, radix);\n                } else {\n                    long ell \u003d Long.parseLong(s, start, start + len, radix);\n                    if ((ell \u0026 0xffff_ffff_0000_0000L) \u003d\u003d 0) {\n                        return (int) ell;\n                    } else {\n                        throw new\n                            NumberFormatException(String.format(\"String value %s exceeds \" +\n                                                                \"range of unsigned int.\", s));\n                    }\n                }\n            }\n        } else {\n            throw new NumberFormatException(\"\");\n        }\n    }\n\n    /**\n     * Parses the string argument as an unsigned decimal integer. The\n     * characters in the string must all be decimal digits, except\n     * that the first character may be an ASCII plus sign {@code\n     * \u0027+\u0027} ({@code \u0027\\u005Cu002B\u0027}). The resulting integer value\n     * is returned, exactly as if the argument and the radix 10 were\n     * given as arguments to the {@link\n     * #parseUnsignedInt(java.lang.String, int)} method.\n     *\n     * @param s   a {@code String} containing the unsigned {@code int}\n     *            representation to be parsed\n     * @return    the unsigned integer value represented by the argument in decimal.\n     * @throws    NumberFormatException  if the string does not contain a\n     *            parsable unsigned integer.\n     * @since 1.8\n     */\n    public static int parseUnsignedInt(String s) throws NumberFormatException {\n        return parseUnsignedInt(s, 10);\n    }\n\n    /**\n     * Returns an {@code Integer} object holding the value\n     * extracted from the specified {@code String} when parsed\n     * with the radix given by the second argument. The first argument\n     * is interpreted as representing a signed integer in the radix\n     * specified by the second argument, exactly as if the arguments\n     * were given to the {@link #parseInt(java.lang.String, int)}\n     * method. The result is an {@code Integer} object that\n     * represents the integer value specified by the string.\n     *\n     * \u003cp\u003eIn other words, this method returns an {@code Integer}\n     * object equal to the value of:\n     *\n     * \u003cblockquote\u003e\n     *  {@code new Integer(Integer.parseInt(s, radix))}\n     * \u003c/blockquote\u003e\n     *\n     * @param      s   the string to be parsed.\n     * @param      radix the radix to be used in interpreting {@code s}\n     * @return     an {@code Integer} object holding the value\n     *             represented by the string argument in the specified\n     *             radix.\n     * @throws    NumberFormatException if the {@code String}\n     *            does not contain a parsable {@code int}.\n     */\n    public static Integer valueOf(String s, int radix) throws NumberFormatException {\n        return Integer.valueOf(parseInt(s,radix));\n    }\n\n    /**\n     * Returns an {@code Integer} object holding the\n     * value of the specified {@code String}. The argument is\n     * interpreted as representing a signed decimal integer, exactly\n     * as if the argument were given to the {@link\n     * #parseInt(java.lang.String)} method. The result is an\n     * {@code Integer} object that represents the integer value\n     * specified by the string.\n     *\n     * \u003cp\u003eIn other words, this method returns an {@code Integer}\n     * object equal to the value of:\n     *\n     * \u003cblockquote\u003e\n     *  {@code new Integer(Integer.parseInt(s))}\n     * \u003c/blockquote\u003e\n     *\n     * @param      s   the string to be parsed.\n     * @return     an {@code Integer} object holding the value\n     *             represented by the string argument.\n     * @throws     NumberFormatException  if the string cannot be parsed\n     *             as an integer.\n     */\n    public static Integer valueOf(String s) throws NumberFormatException {\n        return Integer.valueOf(parseInt(s, 10));\n    }\n\n    /**\n     * Cache to support the object identity semantics of autoboxing for values between\n     * -128 and 127 (inclusive) as required by JLS.\n     *\n     * The cache is initialized on first usage.  The size of the cache\n     * may be controlled by the {@code -XX:AutoBoxCacheMax\u003d\u003csize\u003e} option.\n     * During VM initialization, java.lang.Integer.IntegerCache.high property\n     * may be set and saved in the private system properties in the\n     * jdk.internal.misc.VM class.\n     *\n     * WARNING: The cache is archived with CDS and reloaded from the shared\n     * archive at runtime. The archived cache (Integer[]) and Integer objects\n     * reside in the closed archive heap regions. Care should be taken when\n     * changing the implementation and the cache array should not be assigned\n     * with new Integer object(s) after initialization.\n     */\n\n    private static class IntegerCache {\n        static final int low \u003d -128;\n        static final int high;\n        static final Integer[] cache;\n        static Integer[] archivedCache;\n\n        static {\n            // high value may be configured by property\n            int h \u003d 127;\n            String integerCacheHighPropValue \u003d\n                VM.getSavedProperty(\"java.lang.Integer.IntegerCache.high\");\n            if (integerCacheHighPropValue !\u003d null) {\n                try {\n                    h \u003d Math.max(parseInt(integerCacheHighPropValue), 127);\n                    // Maximum array size is Integer.MAX_VALUE\n                    h \u003d Math.min(h, Integer.MAX_VALUE - (-low) -1);\n                } catch( NumberFormatException nfe) {\n                    // If the property cannot be parsed into an int, ignore it.\n                }\n            }\n            high \u003d h;\n\n            // Load IntegerCache.archivedCache from archive, if possible\n            CDS.initializeFromArchive(IntegerCache.class);\n            int size \u003d (high - low) + 1;\n\n            // Use the archived cache if it exists and is large enough\n            if (archivedCache \u003d\u003d null || size \u003e archivedCache.length) {\n                Integer[] c \u003d new Integer[size];\n                int j \u003d low;\n                for(int i \u003d 0; i \u003c c.length; i++) {\n                    c[i] \u003d new Integer(j++);\n                }\n                archivedCache \u003d c;\n            }\n            cache \u003d archivedCache;\n            // range [-128, 127] must be interned (JLS7 5.1.7)\n            assert IntegerCache.high \u003e\u003d 127;\n        }\n\n        private IntegerCache() {}\n    }\n\n    /**\n     * Returns an {@code Integer} instance representing the specified\n     * {@code int} value.  If a new {@code Integer} instance is not\n     * required, this method should generally be used in preference to\n     * the constructor {@link #Integer(int)}, as this method is likely\n     * to yield significantly better space and time performance by\n     * caching frequently requested values.\n     *\n     * This method will always cache values in the range -128 to 127,\n     * inclusive, and may cache other values outside of this range.\n     *\n     * @param  i an {@code int} value.\n     * @return an {@code Integer} instance representing {@code i}.\n     * @since  1.5\n     */\n    @IntrinsicCandidate\n    public static Integer valueOf(int i) {\n        if (i \u003e\u003d IntegerCache.low \u0026\u0026 i \u003c\u003d IntegerCache.high)\n            return IntegerCache.cache[i + (-IntegerCache.low)];\n        return new Integer(i);\n    }\n\n    /**\n     * The value of the {@code Integer}.\n     *\n     * @serial\n     */\n    private final int value;\n\n    /**\n     * Constructs a newly allocated {@code Integer} object that\n     * represents the specified {@code int} value.\n     *\n     * @param   value   the value to be represented by the\n     *                  {@code Integer} object.\n     *\n     * @deprecated\n     * It is rarely appropriate to use this constructor. The static factory\n     * {@link #valueOf(int)} is generally a better choice, as it is\n     * likely to yield significantly better space and time performance.\n     */\n    @Deprecated(since\u003d\"9\", forRemoval \u003d true)\n    public Integer(int value) {\n        this.value \u003d value;\n    }\n\n    /**\n     * Constructs a newly allocated {@code Integer} object that\n     * represents the {@code int} value indicated by the\n     * {@code String} parameter. The string is converted to an\n     * {@code int} value in exactly the manner used by the\n     * {@code parseInt} method for radix 10.\n     *\n     * @param   s   the {@code String} to be converted to an {@code Integer}.\n     * @throws      NumberFormatException if the {@code String} does not\n     *              contain a parsable integer.\n     *\n     * @deprecated\n     * It is rarely appropriate to use this constructor.\n     * Use {@link #parseInt(String)} to convert a string to a\n     * {@code int} primitive, or use {@link #valueOf(String)}\n     * to convert a string to an {@code Integer} object.\n     */\n    @Deprecated(since\u003d\"9\", forRemoval \u003d true)\n    public Integer(String s) throws NumberFormatException {\n        this.value \u003d parseInt(s, 10);\n    }\n\n    /**\n     * Returns the value of this {@code Integer} as a {@code byte}\n     * after a narrowing primitive conversion.\n     * @jls 5.1.3 Narrowing Primitive Conversion\n     */\n    public byte byteValue() {\n        return (byte)value;\n    }\n\n    /**\n     * Returns the value of this {@code Integer} as a {@code short}\n     * after a narrowing primitive conversion.\n     * @jls 5.1.3 Narrowing Primitive Conversion\n     */\n    public short shortValue() {\n        return (short)value;\n    }\n\n    /**\n     * Returns the value of this {@code Integer} as an\n     * {@code int}.\n     */\n    @IntrinsicCandidate\n    public int intValue() {\n        return value;\n    }\n\n    /**\n     * Returns the value of this {@code Integer} as a {@code long}\n     * after a widening primitive conversion.\n     * @jls 5.1.2 Widening Primitive Conversion\n     * @see Integer#toUnsignedLong(int)\n     */\n    public long longValue() {\n        return (long)value;\n    }\n\n    /**\n     * Returns the value of this {@code Integer} as a {@code float}\n     * after a widening primitive conversion.\n     * @jls 5.1.2 Widening Primitive Conversion\n     */\n    public float floatValue() {\n        return (float)value;\n    }\n\n    /**\n     * Returns the value of this {@code Integer} as a {@code double}\n     * after a widening primitive conversion.\n     * @jls 5.1.2 Widening Primitive Conversion\n     */\n    public double doubleValue() {\n        return (double)value;\n    }\n\n    /**\n     * Returns a {@code String} object representing this\n     * {@code Integer}\u0027s value. The value is converted to signed\n     * decimal representation and returned as a string, exactly as if\n     * the integer value were given as an argument to the {@link\n     * java.lang.Integer#toString(int)} method.\n     *\n     * @return  a string representation of the value of this object in\n     *          base\u0026nbsp;10.\n     */\n    public String toString() {\n        return toString(value);\n    }\n\n    /**\n     * Returns a hash code for this {@code Integer}.\n     *\n     * @return  a hash code value for this object, equal to the\n     *          primitive {@code int} value represented by this\n     *          {@code Integer} object.\n     */\n    @Override\n    public int hashCode() {\n        return Integer.hashCode(value);\n    }\n\n    /**\n     * Returns a hash code for an {@code int} value; compatible with\n     * {@code Integer.hashCode()}.\n     *\n     * @param value the value to hash\n     * @since 1.8\n     *\n     * @return a hash code value for an {@code int} value.\n     */\n    public static int hashCode(int value) {\n        return value;\n    }\n\n    /**\n     * Compares this object to the specified object.  The result is\n     * {@code true} if and only if the argument is not\n     * {@code null} and is an {@code Integer} object that\n     * contains the same {@code int} value as this object.\n     *\n     * @param   obj   the object to compare with.\n     * @return  {@code true} if the objects are the same;\n     *          {@code false} otherwise.\n     */\n    public boolean equals(Object obj) {\n        if (obj instanceof Integer) {\n            return value \u003d\u003d ((Integer)obj).intValue();\n        }\n        return false;\n    }\n\n    /**\n     * Determines the integer value of the system property with the\n     * specified name.\n     *\n     * \u003cp\u003eThe first argument is treated as the name of a system\n     * property.  System properties are accessible through the {@link\n     * java.lang.System#getProperty(java.lang.String)} method. The\n     * string value of this property is then interpreted as an integer\n     * value using the grammar supported by {@link Integer#decode decode} and\n     * an {@code Integer} object representing this value is returned.\n     *\n     * \u003cp\u003eIf there is no property with the specified name, if the\n     * specified name is empty or {@code null}, or if the property\n     * does not have the correct numeric format, then {@code null} is\n     * returned.\n     *\n     * \u003cp\u003eIn other words, this method returns an {@code Integer}\n     * object equal to the value of:\n     *\n     * \u003cblockquote\u003e\n     *  {@code getInteger(nm, null)}\n     * \u003c/blockquote\u003e\n     *\n     * @param   nm   property name.\n     * @return  the {@code Integer} value of the property.\n     * @throws  SecurityException for the same reasons as\n     *          {@link System#getProperty(String) System.getProperty}\n     * @see     java.lang.System#getProperty(java.lang.String)\n     * @see     java.lang.System#getProperty(java.lang.String, java.lang.String)\n     */\n    public static Integer getInteger(String nm) {\n        return getInteger(nm, null);\n    }\n\n    /**\n     * Determines the integer value of the system property with the\n     * specified name.\n     *\n     * \u003cp\u003eThe first argument is treated as the name of a system\n     * property.  System properties are accessible through the {@link\n     * java.lang.System#getProperty(java.lang.String)} method. The\n     * string value of this property is then interpreted as an integer\n     * value using the grammar supported by {@link Integer#decode decode} and\n     * an {@code Integer} object representing this value is returned.\n     *\n     * \u003cp\u003eThe second argument is the default value. An {@code Integer} object\n     * that represents the value of the second argument is returned if there\n     * is no property of the specified name, if the property does not have\n     * the correct numeric format, or if the specified name is empty or\n     * {@code null}.\n     *\n     * \u003cp\u003eIn other words, this method returns an {@code Integer} object\n     * equal to the value of:\n     *\n     * \u003cblockquote\u003e\n     *  {@code getInteger(nm, new Integer(val))}\n     * \u003c/blockquote\u003e\n     *\n     * but in practice it may be implemented in a manner such as:\n     *\n     * \u003cblockquote\u003e\u003cpre\u003e\n     * Integer result \u003d getInteger(nm, null);\n     * return (result \u003d\u003d null) ? new Integer(val) : result;\n     * \u003c/pre\u003e\u003c/blockquote\u003e\n     *\n     * to avoid the unnecessary allocation of an {@code Integer}\n     * object when the default value is not needed.\n     *\n     * @param   nm   property name.\n     * @param   val   default value.\n     * @return  the {@code Integer} value of the property.\n     * @throws  SecurityException for the same reasons as\n     *          {@link System#getProperty(String) System.getProperty}\n     * @see     java.lang.System#getProperty(java.lang.String)\n     * @see     java.lang.System#getProperty(java.lang.String, java.lang.String)\n     */\n    public static Integer getInteger(String nm, int val) {\n        Integer result \u003d getInteger(nm, null);\n        return (result \u003d\u003d null) ? Integer.valueOf(val) : result;\n    }\n\n    /**\n     * Returns the integer value of the system property with the\n     * specified name.  The first argument is treated as the name of a\n     * system property.  System properties are accessible through the\n     * {@link java.lang.System#getProperty(java.lang.String)} method.\n     * The string value of this property is then interpreted as an\n     * integer value, as per the {@link Integer#decode decode} method,\n     * and an {@code Integer} object representing this value is\n     * returned; in summary:\n     *\n     * \u003cul\u003e\u003cli\u003eIf the property value begins with the two ASCII characters\n     *         {@code 0x} or the ASCII character {@code #}, not\n     *      followed by a minus sign, then the rest of it is parsed as a\n     *      hexadecimal integer exactly as by the method\n     *      {@link #valueOf(java.lang.String, int)} with radix 16.\n     * \u003cli\u003eIf the property value begins with the ASCII character\n     *     {@code 0} followed by another character, it is parsed as an\n     *     octal integer exactly as by the method\n     *     {@link #valueOf(java.lang.String, int)} with radix 8.\n     * \u003cli\u003eOtherwise, the property value is parsed as a decimal integer\n     * exactly as by the method {@link #valueOf(java.lang.String, int)}\n     * with radix 10.\n     * \u003c/ul\u003e\n     *\n     * \u003cp\u003eThe second argument is the default value. The default value is\n     * returned if there is no property of the specified name, if the\n     * property does not have the correct numeric format, or if the\n     * specified name is empty or {@code null}.\n     *\n     * @param   nm   property name.\n     * @param   val   default value.\n     * @return  the {@code Integer} value of the property.\n     * @throws  SecurityException for the same reasons as\n     *          {@link System#getProperty(String) System.getProperty}\n     * @see     System#getProperty(java.lang.String)\n     * @see     System#getProperty(java.lang.String, java.lang.String)\n     */\n    public static Integer getInteger(String nm, Integer val) {\n        String v \u003d null;\n        try {\n            v \u003d System.getProperty(nm);\n        } catch (IllegalArgumentException | NullPointerException e) {\n        }\n        if (v !\u003d null) {\n            try {\n                return Integer.decode(v);\n            } catch (NumberFormatException e) {\n            }\n        }\n        return val;\n    }\n\n    /**\n     * Decodes a {@code String} into an {@code Integer}.\n     * Accepts decimal, hexadecimal, and octal numbers given\n     * by the following grammar:\n     *\n     * \u003cblockquote\u003e\n     * \u003cdl\u003e\n     * \u003cdt\u003e\u003ci\u003eDecodableString:\u003c/i\u003e\n     * \u003cdd\u003e\u003ci\u003eSign\u003csub\u003eopt\u003c/sub\u003e DecimalNumeral\u003c/i\u003e\n     * \u003cdd\u003e\u003ci\u003eSign\u003csub\u003eopt\u003c/sub\u003e\u003c/i\u003e {@code 0x} \u003ci\u003eHexDigits\u003c/i\u003e\n     * \u003cdd\u003e\u003ci\u003eSign\u003csub\u003eopt\u003c/sub\u003e\u003c/i\u003e {@code 0X} \u003ci\u003eHexDigits\u003c/i\u003e\n     * \u003cdd\u003e\u003ci\u003eSign\u003csub\u003eopt\u003c/sub\u003e\u003c/i\u003e {@code #} \u003ci\u003eHexDigits\u003c/i\u003e\n     * \u003cdd\u003e\u003ci\u003eSign\u003csub\u003eopt\u003c/sub\u003e\u003c/i\u003e {@code 0} \u003ci\u003eOctalDigits\u003c/i\u003e\n     *\n     * \u003cdt\u003e\u003ci\u003eSign:\u003c/i\u003e\n     * \u003cdd\u003e{@code -}\n     * \u003cdd\u003e{@code +}\n     * \u003c/dl\u003e\n     * \u003c/blockquote\u003e\n     *\n     * \u003ci\u003eDecimalNumeral\u003c/i\u003e, \u003ci\u003eHexDigits\u003c/i\u003e, and \u003ci\u003eOctalDigits\u003c/i\u003e\n     * are as defined in section {@jls 3.10.1} of\n     * \u003ccite\u003eThe Java Language Specification\u003c/cite\u003e,\n     * except that underscores are not accepted between digits.\n     *\n     * \u003cp\u003eThe sequence of characters following an optional\n     * sign and/or radix specifier (\"{@code 0x}\", \"{@code 0X}\",\n     * \"{@code #}\", or leading zero) is parsed as by the {@code\n     * Integer.parseInt} method with the indicated radix (10, 16, or\n     * 8).  This sequence of characters must represent a positive\n     * value or a {@link NumberFormatException} will be thrown.  The\n     * result is negated if first character of the specified {@code\n     * String} is the minus sign.  No whitespace characters are\n     * permitted in the {@code String}.\n     *\n     * @param     nm the {@code String} to decode.\n     * @return    an {@code Integer} object holding the {@code int}\n     *             value represented by {@code nm}\n     * @throws    NumberFormatException  if the {@code String} does not\n     *            contain a parsable integer.\n     * @see java.lang.Integer#parseInt(java.lang.String, int)\n     */\n    public static Integer decode(String nm) throws NumberFormatException {\n        int radix \u003d 10;\n        int index \u003d 0;\n        boolean negative \u003d false;\n        Integer result;\n\n        if (nm.isEmpty())\n            throw new NumberFormatException(\"Zero length string\");\n        char firstChar \u003d nm.charAt(0);\n        // Handle sign, if present\n        if (firstChar \u003d\u003d \u0027-\u0027) {\n            negative \u003d true;\n            index++;\n        } else if (firstChar \u003d\u003d \u0027+\u0027)\n            index++;\n\n        // Handle radix specifier, if present\n        if (nm.startsWith(\"0x\", index) || nm.startsWith(\"0X\", index)) {\n            index +\u003d 2;\n            radix \u003d 16;\n        }\n        else if (nm.startsWith(\"#\", index)) {\n            index ++;\n            radix \u003d 16;\n        }\n        else if (nm.startsWith(\"0\", index) \u0026\u0026 nm.length() \u003e 1 + index) {\n            index ++;\n            radix \u003d 8;\n        }\n\n        if (nm.startsWith(\"-\", index) || nm.startsWith(\"+\", index))\n            throw new NumberFormatException(\"Sign character in wrong position\");\n\n        try {\n            result \u003d Integer.valueOf(nm.substring(index), radix);\n            result \u003d negative ? Integer.valueOf(-result.intValue()) : result;\n        } catch (NumberFormatException e) {\n            // If number is Integer.MIN_VALUE, we\u0027ll end up here. The next line\n            // handles this case, and causes any genuine format error to be\n            // rethrown.\n            String constant \u003d negative ? (\"-\" + nm.substring(index))\n                                       : nm.substring(index);\n            result \u003d Integer.valueOf(constant, radix);\n        }\n        return result;\n    }\n\n    /**\n     * Compares two {@code Integer} objects numerically.\n     *\n     * @param   anotherInteger   the {@code Integer} to be compared.\n     * @return  the value {@code 0} if this {@code Integer} is\n     *          equal to the argument {@code Integer}; a value less than\n     *          {@code 0} if this {@code Integer} is numerically less\n     *          than the argument {@code Integer}; and a value greater\n     *          than {@code 0} if this {@code Integer} is numerically\n     *           greater than the argument {@code Integer} (signed\n     *           comparison).\n     * @since   1.2\n     */\n    public int compareTo(Integer anotherInteger) {\n        return compare(this.value, anotherInteger.value);\n    }\n\n    /**\n     * Compares two {@code int} values numerically.\n     * The value returned is identical to what would be returned by:\n     * \u003cpre\u003e\n     *    Integer.valueOf(x).compareTo(Integer.valueOf(y))\n     * \u003c/pre\u003e\n     *\n     * @param  x the first {@code int} to compare\n     * @param  y the second {@code int} to compare\n     * @return the value {@code 0} if {@code x \u003d\u003d y};\n     *         a value less than {@code 0} if {@code x \u003c y}; and\n     *         a value greater than {@code 0} if {@code x \u003e y}\n     * @since 1.7\n     */\n    public static int compare(int x, int y) {\n        return (x \u003c y) ? -1 : ((x \u003d\u003d y) ? 0 : 1);\n    }\n\n    /**\n     * Compares two {@code int} values numerically treating the values\n     * as unsigned.\n     *\n     * @param  x the first {@code int} to compare\n     * @param  y the second {@code int} to compare\n     * @return the value {@code 0} if {@code x \u003d\u003d y}; a value less\n     *         than {@code 0} if {@code x \u003c y} as unsigned values; and\n     *         a value greater than {@code 0} if {@code x \u003e y} as\n     *         unsigned values\n     * @since 1.8\n     */\n    public static int compareUnsigned(int x, int y) {\n        return compare(x + MIN_VALUE, y + MIN_VALUE);\n    }\n\n    /**\n     * Converts the argument to a {@code long} by an unsigned\n     * conversion.  In an unsigned conversion to a {@code long}, the\n     * high-order 32 bits of the {@code long} are zero and the\n     * low-order 32 bits are equal to the bits of the integer\n     * argument.\n     *\n     * Consequently, zero and positive {@code int} values are mapped\n     * to a numerically equal {@code long} value and negative {@code\n     * int} values are mapped to a {@code long} value equal to the\n     * input plus 2\u003csup\u003e32\u003c/sup\u003e.\n     *\n     * @param  x the value to convert to an unsigned {@code long}\n     * @return the argument converted to {@code long} by an unsigned\n     *         conversion\n     * @since 1.8\n     */\n    public static long toUnsignedLong(int x) {\n        return ((long) x) \u0026 0xffffffffL;\n    }\n\n    /**\n     * Returns the unsigned quotient of dividing the first argument by\n     * the second where each argument and the result is interpreted as\n     * an unsigned value.\n     *\n     * \u003cp\u003eNote that in two\u0027s complement arithmetic, the three other\n     * basic arithmetic operations of add, subtract, and multiply are\n     * bit-wise identical if the two operands are regarded as both\n     * being signed or both being unsigned.  Therefore separate {@code\n     * addUnsigned}, etc. methods are not provided.\n     *\n     * @param dividend the value to be divided\n     * @param divisor the value doing the dividing\n     * @return the unsigned quotient of the first argument divided by\n     * the second argument\n     * @see #remainderUnsigned\n     * @since 1.8\n     */\n    public static int divideUnsigned(int dividend, int divisor) {\n        // In lieu of tricky code, for now just use long arithmetic.\n        return (int)(toUnsignedLong(dividend) / toUnsignedLong(divisor));\n    }\n\n    /**\n     * Returns the unsigned remainder from dividing the first argument\n     * by the second where each argument and the result is interpreted\n     * as an unsigned value.\n     *\n     * @param dividend the value to be divided\n     * @param divisor the value doing the dividing\n     * @return the unsigned remainder of the first argument divided by\n     * the second argument\n     * @see #divideUnsigned\n     * @since 1.8\n     */\n    public static int remainderUnsigned(int dividend, int divisor) {\n        // In lieu of tricky code, for now just use long arithmetic.\n        return (int)(toUnsignedLong(dividend) % toUnsignedLong(divisor));\n    }\n\n\n    // Bit twiddling\n\n    /**\n     * The number of bits used to represent an {@code int} value in two\u0027s\n     * complement binary form.\n     *\n     * @since 1.5\n     */\n    @Native public static final int SIZE \u003d 32;\n\n    /**\n     * The number of bytes used to represent an {@code int} value in two\u0027s\n     * complement binary form.\n     *\n     * @since 1.8\n     */\n    public static final int BYTES \u003d SIZE / Byte.SIZE;\n\n    /**\n     * Returns an {@code int} value with at most a single one-bit, in the\n     * position of the highest-order (\"leftmost\") one-bit in the specified\n     * {@code int} value.  Returns zero if the specified value has no\n     * one-bits in its two\u0027s complement binary representation, that is, if it\n     * is equal to zero.\n     *\n     * @param i the value whose highest one bit is to be computed\n     * @return an {@code int} value with a single one-bit, in the position\n     *     of the highest-order one-bit in the specified value, or zero if\n     *     the specified value is itself equal to zero.\n     * @since 1.5\n     */\n    public static int highestOneBit(int i) {\n        return i \u0026 (MIN_VALUE \u003e\u003e\u003e numberOfLeadingZeros(i));\n    }\n\n    /**\n     * Returns an {@code int} value with at most a single one-bit, in the\n     * position of the lowest-order (\"rightmost\") one-bit in the specified\n     * {@code int} value.  Returns zero if the specified value has no\n     * one-bits in its two\u0027s complement binary representation, that is, if it\n     * is equal to zero.\n     *\n     * @param i the value whose lowest one bit is to be computed\n     * @return an {@code int} value with a single one-bit, in the position\n     *     of the lowest-order one-bit in the specified value, or zero if\n     *     the specified value is itself equal to zero.\n     * @since 1.5\n     */\n    public static int lowestOneBit(int i) {\n        // HD, Section 2-1\n        return i \u0026 -i;\n    }\n\n    /**\n     * Returns the number of zero bits preceding the highest-order\n     * (\"leftmost\") one-bit in the two\u0027s complement binary representation\n     * of the specified {@code int} value.  Returns 32 if the\n     * specified value has no one-bits in its two\u0027s complement representation,\n     * in other words if it is equal to zero.\n     *\n     * \u003cp\u003eNote that this method is closely related to the logarithm base 2.\n     * For all positive {@code int} values x:\n     * \u003cul\u003e\n     * \u003cli\u003efloor(log\u003csub\u003e2\u003c/sub\u003e(x)) \u003d {@code 31 - numberOfLeadingZeros(x)}\n     * \u003cli\u003eceil(log\u003csub\u003e2\u003c/sub\u003e(x)) \u003d {@code 32 - numberOfLeadingZeros(x - 1)}\n     * \u003c/ul\u003e\n     *\n     * @param i the value whose number of leading zeros is to be computed\n     * @return the number of zero bits preceding the highest-order\n     *     (\"leftmost\") one-bit in the two\u0027s complement binary representation\n     *     of the specified {@code int} value, or 32 if the value\n     *     is equal to zero.\n     * @since 1.5\n     */\n    @IntrinsicCandidate\n    public static int numberOfLeadingZeros(int i) {\n        // HD, Count leading 0\u0027s\n        if (i \u003c\u003d 0)\n            return i \u003d\u003d 0 ? 32 : 0;\n        int n \u003d 31;\n        if (i \u003e\u003d 1 \u003c\u003c 16) { n -\u003d 16; i \u003e\u003e\u003e\u003d 16; }\n        if (i \u003e\u003d 1 \u003c\u003c  8) { n -\u003d  8; i \u003e\u003e\u003e\u003d  8; }\n        if (i \u003e\u003d 1 \u003c\u003c  4) { n -\u003d  4; i \u003e\u003e\u003e\u003d  4; }\n        if (i \u003e\u003d 1 \u003c\u003c  2) { n -\u003d  2; i \u003e\u003e\u003e\u003d  2; }\n        return n - (i \u003e\u003e\u003e 1);\n    }\n\n    /**\n     * Returns the number of zero bits following the lowest-order (\"rightmost\")\n     * one-bit in the two\u0027s complement binary representation of the specified\n     * {@code int} value.  Returns 32 if the specified value has no\n     * one-bits in its two\u0027s complement representation, in other words if it is\n     * equal to zero.\n     *\n     * @param i the value whose number of trailing zeros is to be computed\n     * @return the number of zero bits following the lowest-order (\"rightmost\")\n     *     one-bit in the two\u0027s complement binary representation of the\n     *     specified {@code int} value, or 32 if the value is equal\n     *     to zero.\n     * @since 1.5\n     */\n    @IntrinsicCandidate\n    public static int numberOfTrailingZeros(int i) {\n        // HD, Count trailing 0\u0027s\n        i \u003d ~i \u0026 (i - 1);\n        if (i \u003c\u003d 0) return i \u0026 32;\n        int n \u003d 1;\n        if (i \u003e 1 \u003c\u003c 16) { n +\u003d 16; i \u003e\u003e\u003e\u003d 16; }\n        if (i \u003e 1 \u003c\u003c  8) { n +\u003d  8; i \u003e\u003e\u003e\u003d  8; }\n        if (i \u003e 1 \u003c\u003c  4) { n +\u003d  4; i \u003e\u003e\u003e\u003d  4; }\n        if (i \u003e 1 \u003c\u003c  2) { n +\u003d  2; i \u003e\u003e\u003e\u003d  2; }\n        return n + (i \u003e\u003e\u003e 1);\n    }\n\n    /**\n     * Returns the number of one-bits in the two\u0027s complement binary\n     * representation of the specified {@code int} value.  This function is\n     * sometimes referred to as the \u003ci\u003epopulation count\u003c/i\u003e.\n     *\n     * @param i the value whose bits are to be counted\n     * @return the number of one-bits in the two\u0027s complement binary\n     *     representation of the specified {@code int} value.\n     * @since 1.5\n     */\n    @IntrinsicCandidate\n    public static int bitCount(int i) {\n        // HD, Figure 5-2\n        i \u003d i - ((i \u003e\u003e\u003e 1) \u0026 0x55555555);\n        i \u003d (i \u0026 0x33333333) + ((i \u003e\u003e\u003e 2) \u0026 0x33333333);\n        i \u003d (i + (i \u003e\u003e\u003e 4)) \u0026 0x0f0f0f0f;\n        i \u003d i + (i \u003e\u003e\u003e 8);\n        i \u003d i + (i \u003e\u003e\u003e 16);\n        return i \u0026 0x3f;\n    }\n\n    /**\n     * Returns the value obtained by rotating the two\u0027s complement binary\n     * representation of the specified {@code int} value left by the\n     * specified number of bits.  (Bits shifted out of the left hand, or\n     * high-order, side reenter on the right, or low-order.)\n     *\n     * \u003cp\u003eNote that left rotation with a negative distance is equivalent to\n     * right rotation: {@code rotateLeft(val, -distance) \u003d\u003d rotateRight(val,\n     * distance)}.  Note also that rotation by any multiple of 32 is a\n     * no-op, so all but the last five bits of the rotation distance can be\n     * ignored, even if the distance is negative: {@code rotateLeft(val,\n     * distance) \u003d\u003d rotateLeft(val, distance \u0026 0x1F)}.\n     *\n     * @param i the value whose bits are to be rotated left\n     * @param distance the number of bit positions to rotate left\n     * @return the value obtained by rotating the two\u0027s complement binary\n     *     representation of the specified {@code int} value left by the\n     *     specified number of bits.\n     * @since 1.5\n     */\n    public static int rotateLeft(int i, int distance) {\n        return (i \u003c\u003c distance) | (i \u003e\u003e\u003e -distance);\n    }\n\n    /**\n     * Returns the value obtained by rotating the two\u0027s complement binary\n     * representation of the specified {@code int} value right by the\n     * specified number of bits.  (Bits shifted out of the right hand, or\n     * low-order, side reenter on the left, or high-order.)\n     *\n     * \u003cp\u003eNote that right rotation with a negative distance is equivalent to\n     * left rotation: {@code rotateRight(val, -distance) \u003d\u003d rotateLeft(val,\n     * distance)}.  Note also that rotation by any multiple of 32 is a\n     * no-op, so all but the last five bits of the rotation distance can be\n     * ignored, even if the distance is negative: {@code rotateRight(val,\n     * distance) \u003d\u003d rotateRight(val, distance \u0026 0x1F)}.\n     *\n     * @param i the value whose bits are to be rotated right\n     * @param distance the number of bit positions to rotate right\n     * @return the value obtained by rotating the two\u0027s complement binary\n     *     representation of the specified {@code int} value right by the\n     *     specified number of bits.\n     * @since 1.5\n     */\n    public static int rotateRight(int i, int distance) {\n        return (i \u003e\u003e\u003e distance) | (i \u003c\u003c -distance);\n    }\n\n    /**\n     * Returns the value obtained by reversing the order of the bits in the\n     * two\u0027s complement binary representation of the specified {@code int}\n     * value.\n     *\n     * @param i the value to be reversed\n     * @return the value obtained by reversing order of the bits in the\n     *     specified {@code int} value.\n     * @since 1.5\n     */\n    public static int reverse(int i) {\n        // HD, Figure 7-1\n        i \u003d (i \u0026 0x55555555) \u003c\u003c 1 | (i \u003e\u003e\u003e 1) \u0026 0x55555555;\n        i \u003d (i \u0026 0x33333333) \u003c\u003c 2 | (i \u003e\u003e\u003e 2) \u0026 0x33333333;\n        i \u003d (i \u0026 0x0f0f0f0f) \u003c\u003c 4 | (i \u003e\u003e\u003e 4) \u0026 0x0f0f0f0f;\n\n        return reverseBytes(i);\n    }\n\n    /**\n     * Returns the signum function of the specified {@code int} value.  (The\n     * return value is -1 if the specified value is negative; 0 if the\n     * specified value is zero; and 1 if the specified value is positive.)\n     *\n     * @param i the value whose signum is to be computed\n     * @return the signum function of the specified {@code int} value.\n     * @since 1.5\n     */\n    public static int signum(int i) {\n        // HD, Section 2-7\n        return (i \u003e\u003e 31) | (-i \u003e\u003e\u003e 31);\n    }\n\n    /**\n     * Returns the value obtained by reversing the order of the bytes in the\n     * two\u0027s complement representation of the specified {@code int} value.\n     *\n     * @param i the value whose bytes are to be reversed\n     * @return the value obtained by reversing the bytes in the specified\n     *     {@code int} value.\n     * @since 1.5\n     */\n    @IntrinsicCandidate\n    public static int reverseBytes(int i) {\n        return (i \u003c\u003c 24)            |\n               ((i \u0026 0xff00) \u003c\u003c 8)  |\n               ((i \u003e\u003e\u003e 8) \u0026 0xff00) |\n               (i \u003e\u003e\u003e 24);\n    }\n\n    /**\n     * Adds two integers together as per the + operator.\n     *\n     * @param a the first operand\n     * @param b the second operand\n     * @return the sum of {@code a} and {@code b}\n     * @see java.util.function.BinaryOperator\n     * @since 1.8\n     */\n    public static int sum(int a, int b) {\n        return a + b;\n    }\n\n    /**\n     * Returns the greater of two {@code int} values\n     * as if by calling {@link Math#max(int, int) Math.max}.\n     *\n     * @param a the first operand\n     * @param b the second operand\n     * @return the greater of {@code a} and {@code b}\n     * @see java.util.function.BinaryOperator\n     * @since 1.8\n     */\n    public static int max(int a, int b) {\n        return Math.max(a, b);\n    }\n\n    /**\n     * Returns the smaller of two {@code int} values\n     * as if by calling {@link Math#min(int, int) Math.min}.\n     *\n     * @param a the first operand\n     * @param b the second operand\n     * @return the smaller of {@code a} and {@code b}\n     * @see java.util.function.BinaryOperator\n     * @since 1.8\n     */\n    public static int min(int a, int b) {\n        return Math.min(a, b);\n    }\n\n    /**\n     * Returns an {@link Optional} containing the nominal descriptor for this\n     * instance, which is the instance itself.\n     *\n     * @return an {@link Optional} describing the {@linkplain Integer} instance\n     * @since 12\n     */\n    @Override\n    public Optional\u003cInteger\u003e describeConstable() {\n        return Optional.of(this);\n    }\n\n    /**\n     * Resolves this instance as a {@link ConstantDesc}, the result of which is\n     * the instance itself.\n     *\n     * @param lookup ignored\n     * @return the {@linkplain Integer} instance\n     * @since 12\n     */\n    @Override\n    public Integer resolveConstantDesc(MethodHandles.Lookup lookup) {\n        return this;\n    }\n\n    /** use serialVersionUID from JDK 1.0.2 for interoperability */\n    @java.io.Serial\n    @Native private static final long serialVersionUID \u003d 1360826667806852920L;\n}\n"
    }
  }
}
java.lang.IllegalArgumentException: Illegal character in opaque part at index 188: jar:file:///C:/Users/Vinicius/AppData/Local/Coursier/cache/arc/https/github.com/adoptium/temurin17-binaries/releases/download/jdk-17%2B35/OpenJDK17-jdk_x64_windows_hotspot_17_35.zip/jdk-17 35/lib/src.zip!/java.base/java/lang/Integer.java
	at java.base/java.net.URI.create(URI.java:906)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:178)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.$anonfun$toAbsolutePath$3(MtagsEnrichments.scala:175)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.withTryDecode$1(MtagsEnrichments.scala:153)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:175)
	at scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:756)
	at scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:753)
	at scala.meta.internal.metals.WorkspaceLspService.didOpen(WorkspaceLspService.scala:388)
	at scala.meta.metals.lsp.DelegatingScalaService.didOpen(DelegatingScalaService.scala:39)
	at jdk.internal.reflect.GeneratedMethodAccessor23.invoke(Unknown Source)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:568)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$recursiveFindRpcMethods$0(GenericEndpoint.java:65)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.notify(GenericEndpoint.java:160)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleNotification(RemoteEndpoint.java:231)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:198)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:185)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:97)
	at org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:114)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:539)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.base/java.lang.Thread.run(Thread.java:833)
Caused by: java.net.URISyntaxException: Illegal character in opaque part at index 188: jar:file:///C:/Users/Vinicius/AppData/Local/Coursier/cache/arc/https/github.com/adoptium/temurin17-binaries/releases/download/jdk-17%2B35/OpenJDK17-jdk_x64_windows_hotspot_17_35.zip/jdk-17 35/lib/src.zip!/java.base/java/lang/Integer.java
	at java.base/java.net.URI$Parser.fail(URI.java:2974)
	at java.base/java.net.URI$Parser.checkChars(URI.java:3145)
	at java.base/java.net.URI$Parser.parse(URI.java:3181)
	at java.base/java.net.URI.<init>(URI.java:623)
	at java.base/java.net.URI.create(URI.java:904)
	... 23 more

jul. 19, 2024 1:28:18 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleNotification
ADVERTÊNCIA: Notification threw an exception: {
  "jsonrpc": "2.0",
  "method": "textDocument/didClose",
  "params": {
    "textDocument": {
      "uri": "jar:file%3A///C%3A/Users/Vinicius/AppData/Local/Coursier/cache/arc/https/github.com/adoptium/temurin17-binaries/releases/download/jdk-17%25252B35/OpenJDK17-jdk_x64_windows_hotspot_17_35.zip/jdk-17%2B35/lib/src.zip%21/java.base/java/lang/Integer.java"
    }
  }
}
java.lang.IllegalArgumentException: Illegal character in opaque part at index 188: jar:file:///C:/Users/Vinicius/AppData/Local/Coursier/cache/arc/https/github.com/adoptium/temurin17-binaries/releases/download/jdk-17%2B35/OpenJDK17-jdk_x64_windows_hotspot_17_35.zip/jdk-17 35/lib/src.zip!/java.base/java/lang/Integer.java
	at java.base/java.net.URI.create(URI.java:906)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:178)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.$anonfun$toAbsolutePath$3(MtagsEnrichments.scala:175)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.withTryDecode$1(MtagsEnrichments.scala:153)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:175)
	at scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:756)
	at scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:753)
	at scala.meta.internal.metals.WorkspaceLspService.didClose(WorkspaceLspService.scala:407)
	at scala.meta.metals.lsp.DelegatingScalaService.didClose(DelegatingScalaService.scala:53)
	at jdk.internal.reflect.GeneratedMethodAccessor26.invoke(Unknown Source)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:568)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$recursiveFindRpcMethods$0(GenericEndpoint.java:65)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.notify(GenericEndpoint.java:160)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleNotification(RemoteEndpoint.java:231)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:198)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:185)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:97)
	at org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:114)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:539)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.base/java.lang.Thread.run(Thread.java:833)
Caused by: java.net.URISyntaxException: Illegal character in opaque part at index 188: jar:file:///C:/Users/Vinicius/AppData/Local/Coursier/cache/arc/https/github.com/adoptium/temurin17-binaries/releases/download/jdk-17%2B35/OpenJDK17-jdk_x64_windows_hotspot_17_35.zip/jdk-17 35/lib/src.zip!/java.base/java/lang/Integer.java
	at java.base/java.net.URI$Parser.fail(URI.java:2974)
	at java.base/java.net.URI$Parser.checkChars(URI.java:3145)
	at java.base/java.net.URI$Parser.parse(URI.java:3181)
	at java.base/java.net.URI.<init>(URI.java:623)
	at java.base/java.net.URI.create(URI.java:904)
	... 23 more

2024.07.19 13:28:18 INFO  Can not organize imports if file has error
2024.07.19 13:28:18 INFO  compiling root (2 scala sources)
2024.07.19 13:28:18 INFO  time: compiled root in 0.2s
jul. 19, 2024 1:28:30 PM scala.meta.internal.pc.CompilerAccess retryWithCleanCompiler
INFORMAÇÕES: compiler crashed due to an error in the Scala compiler, retrying with new compiler instance.
jul. 19, 2024 1:28:30 PM scala.meta.internal.pc.CompilerAccess handleError
GRAVE: A severe compiler error occurred, full details of the error can be found in the error report C:\Users\Vinicius\UnB\FLanguage\.metals\.reports\metals-full\2024-07-19\r_compiler-error_(root)_13-28-30-858.md
jul. 19, 2024 1:28:32 PM scala.meta.internal.pc.CompilerAccess retryWithCleanCompiler
INFORMAÇÕES: compiler crashed due to an error in the Scala compiler, retrying with new compiler instance.
jul. 19, 2024 1:28:32 PM scala.meta.internal.pc.CompilerAccess handleError
GRAVE: A severe compiler error occurred, full details of the error can be found in the error report C:\Users\Vinicius\UnB\FLanguage\.metals\.reports\metals-full\2024-07-19\r_compiler-error_(root)_13-28-32-707.md
jul. 19, 2024 1:28:35 PM scala.meta.internal.pc.CompilerAccess retryWithCleanCompiler
INFORMAÇÕES: compiler crashed due to an error in the Scala compiler, retrying with new compiler instance.
jul. 19, 2024 1:28:35 PM scala.meta.internal.pc.CompilerAccess handleError
GRAVE: A severe compiler error occurred, full details of the error can be found in the error report C:\Users\Vinicius\UnB\FLanguage\.metals\.reports\metals-full\2024-07-19\r_compiler-error_(root)_13-28-35-345.md
jul. 19, 2024 1:28:35 PM scala.meta.internal.pc.CompilerAccess retryWithCleanCompiler
INFORMAÇÕES: compiler crashed due to an error in the Scala compiler, retrying with new compiler instance.
jul. 19, 2024 1:28:35 PM scala.meta.internal.pc.CompilerAccess handleError
GRAVE: A severe compiler error occurred, full details of the error can be found in the error report C:\Users\Vinicius\UnB\FLanguage\.metals\.reports\metals-full\2024-07-19\r_compiler-error_(root)_13-28-35-946.md
jul. 19, 2024 1:29:12 PM scala.meta.internal.pc.CompilerAccess retryWithCleanCompiler
INFORMAÇÕES: compiler crashed due to an error in the Scala compiler, retrying with new compiler instance.
jul. 19, 2024 1:29:12 PM scala.meta.internal.pc.CompilerAccess handleError
GRAVE: A severe compiler error occurred, full details of the error can be found in the error report C:\Users\Vinicius\UnB\FLanguage\.metals\.reports\metals-full\2024-07-19\r_compiler-error_(root)_13-29-12-683.md
jul. 19, 2024 1:29:13 PM scala.meta.internal.pc.CompilerAccess retryWithCleanCompiler
INFORMAÇÕES: compiler crashed due to an error in the Scala compiler, retrying with new compiler instance.
jul. 19, 2024 1:29:13 PM scala.meta.internal.pc.CompilerAccess handleError
GRAVE: A severe compiler error occurred, full details of the error can be found in the error report C:\Users\Vinicius\UnB\FLanguage\.metals\.reports\metals-full\2024-07-19\r_compiler-error_(root)_13-29-13-858.md
jul. 19, 2024 1:29:14 PM scala.meta.internal.pc.CompilerAccess retryWithCleanCompiler
INFORMAÇÕES: compiler crashed due to an error in the Scala compiler, retrying with new compiler instance.
2024.07.19 13:29:14 INFO  Can not organize imports if file has error
2024.07.19 13:29:14 INFO  compiling root (2 scala sources)
jul. 19, 2024 1:29:15 PM scala.meta.internal.pc.CompilerAccess handleError
GRAVE: A severe compiler error occurred, full details of the error can be found in the error report C:\Users\Vinicius\UnB\FLanguage\.metals\.reports\metals-full\2024-07-19\r_compiler-error_(root)_13-29-15-192.md
2024.07.19 13:29:14 INFO  time: compiled root in 0.23s
2024.07.19 13:29:14 INFO  Can not organize imports if file has error
2024.07.19 13:29:14 INFO  compiling root (2 scala sources)
2024.07.19 13:29:14 INFO  time: compiled root in 0.15s
2024.07.19 13:29:19 WARN  Using indexes to guess the definition of S2
2024.07.19 13:30:00 INFO  compiling root (2 scala sources)
2024.07.19 13:30:00 INFO  time: compiled root in 0.21s
2024.07.19 13:30:00 INFO  compiling root (2 scala sources)
2024.07.19 13:30:01 INFO  time: compiled root in 0.25s
jul. 19, 2024 1:30:11 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
ADVERTÊNCIA: Unmatched cancel notification for request id 7379
2024.07.19 13:30:23 INFO  compiling root (2 scala sources)
2024.07.19 13:30:23 INFO  time: compiled root in 0.21s
2024.07.19 13:30:27 INFO  compiling root (2 scala sources)
2024.07.19 13:30:27 INFO  time: compiled root in 0.2s
2024.07.19 13:30:41 INFO  compiling root (2 scala sources)
2024.07.19 13:30:41 INFO  time: compiled root in 0.14s
2024.07.19 13:30:45 INFO  Can not organize imports if file has error
2024.07.19 13:30:45 INFO  compiling root (2 scala sources)
2024.07.19 13:30:45 INFO  time: compiled root in 0.18s
2024.07.19 13:31:52 INFO  compiling root (2 scala sources)
2024.07.19 13:31:52 INFO  time: compiled root in 0.19s
jul. 19, 2024 1:31:53 PM scala.meta.internal.pc.CompilerAccess retryWithCleanCompiler
INFORMAÇÕES: compiler crashed due to an error in the Scala compiler, retrying with new compiler instance.
jul. 19, 2024 1:31:53 PM scala.meta.internal.pc.CompilerAccess handleError
GRAVE: A severe compiler error occurred, full details of the error can be found in the error report C:\Users\Vinicius\UnB\FLanguage\.metals\.reports\metals-full\2024-07-19\r_compiler-error_(root)_13-31-53-751.md
jul. 19, 2024 1:31:55 PM scala.meta.internal.pc.CompilerAccess retryWithCleanCompiler
INFORMAÇÕES: compiler crashed due to an error in the Scala compiler, retrying with new compiler instance.
jul. 19, 2024 1:31:56 PM scala.meta.internal.pc.CompilerAccess handleError
GRAVE: A severe compiler error occurred, full details of the error can be found in the error report C:\Users\Vinicius\UnB\FLanguage\.metals\.reports\metals-full\2024-07-19\r_compiler-error_(root)_13-31-56-254.md
2024.07.19 13:31:59 INFO  Can not organize imports if file has error
2024.07.19 13:32:00 INFO  compiling root (2 scala sources)
2024.07.19 13:32:00 INFO  time: compiled root in 0.19s
2024.07.19 13:32:02 INFO  Can not organize imports if file has error
2024.07.19 13:32:02 INFO  compiling root (2 scala sources)
2024.07.19 13:32:02 INFO  time: compiled root in 0.21s
jul. 19, 2024 1:32:05 PM scala.meta.internal.pc.CompilerAccess retryWithCleanCompiler
INFORMAÇÕES: compiler crashed due to an error in the Scala compiler, retrying with new compiler instance.
jul. 19, 2024 1:32:05 PM scala.meta.internal.pc.CompilerAccess handleError
GRAVE: A severe compiler error occurred, full details of the error can be found in the error report C:\Users\Vinicius\UnB\FLanguage\.metals\.reports\metals-full\2024-07-19\r_compiler-error_(root)_13-32-05-766.md
jul. 19, 2024 1:32:06 PM scala.meta.internal.pc.CompilerAccess retryWithCleanCompiler
INFORMAÇÕES: compiler crashed due to an error in the Scala compiler, retrying with new compiler instance.
jul. 19, 2024 1:32:06 PM scala.meta.internal.pc.CompilerAccess handleError
GRAVE: A severe compiler error occurred, full details of the error can be found in the error report C:\Users\Vinicius\UnB\FLanguage\.metals\.reports\metals-full\2024-07-19\r_compiler-error_(root)_13-32-06-490.md
2024.07.19 13:32:37 INFO  Can not organize imports if file has error
2024.07.19 13:32:37 INFO  compiling root (2 scala sources)
2024.07.19 13:32:37 INFO  time: compiled root in 0.19s
jul. 19, 2024 1:32:38 PM scala.meta.internal.pc.CompilerAccess retryWithCleanCompiler
INFORMAÇÕES: compiler crashed due to an error in the Scala compiler, retrying with new compiler instance.
2024.07.19 13:32:39 INFO  Can not organize imports if file has error
2024.07.19 13:32:39 INFO  compiling root (2 scala sources)
jul. 19, 2024 1:32:39 PM scala.meta.internal.pc.CompilerAccess retryWithCleanCompiler
INFORMAÇÕES: compiler crashed due to an error in the Scala compiler, retrying with new compiler instance.
2024.07.19 13:32:39 INFO  time: compiled root in 0.29s
jul. 19, 2024 1:32:39 PM scala.meta.internal.pc.CompilerAccess handleError
GRAVE: A severe compiler error occurred, full details of the error can be found in the error report C:\Users\Vinicius\UnB\FLanguage\.metals\.reports\metals-full\2024-07-19\r_compiler-error_(root)_13-32-39-873.md
jul. 19, 2024 1:33:07 PM scala.meta.internal.pc.CompilerAccess retryWithCleanCompiler
INFORMAÇÕES: compiler crashed due to an error in the Scala compiler, retrying with new compiler instance.
jul. 19, 2024 1:33:07 PM scala.meta.internal.pc.CompilerAccess handleError
GRAVE: A severe compiler error occurred, full details of the error can be found in the error report C:\Users\Vinicius\UnB\FLanguage\.metals\.reports\metals-full\2024-07-19\r_compiler-error_(root)_13-33-07-831.md
jul. 19, 2024 1:33:08 PM scala.meta.internal.pc.CompilerAccess retryWithCleanCompiler
INFORMAÇÕES: compiler crashed due to an error in the Scala compiler, retrying with new compiler instance.
jul. 19, 2024 1:33:08 PM scala.meta.internal.pc.CompilerAccess handleError
GRAVE: A severe compiler error occurred, full details of the error can be found in the error report C:\Users\Vinicius\UnB\FLanguage\.metals\.reports\metals-full\2024-07-19\r_compiler-error_(root)_13-33-08-980.md
jul. 19, 2024 1:33:09 PM scala.meta.internal.pc.CompilerAccess retryWithCleanCompiler
INFORMAÇÕES: compiler crashed due to an error in the Scala compiler, retrying with new compiler instance.
jul. 19, 2024 1:33:11 PM scala.meta.internal.pc.CompilerAccess retryWithCleanCompiler
INFORMAÇÕES: compiler crashed due to an error in the Scala compiler, retrying with new compiler instance.
2024.07.19 13:33:11 INFO  Can not organize imports if file has error
jul. 19, 2024 1:33:11 PM scala.meta.internal.pc.CompilerAccess handleError
GRAVE: A severe compiler error occurred, full details of the error can be found in the error report C:\Users\Vinicius\UnB\FLanguage\.metals\.reports\metals-full\2024-07-19\r_compiler-error_(root)_13-33-11-277.md
2024.07.19 13:33:11 INFO  compiling root (2 scala sources)
2024.07.19 13:33:11 INFO  time: compiled root in 0.28s
2024.07.19 13:33:14 INFO  compiling root (2 scala sources)
2024.07.19 13:33:14 INFO  Deduplicating compilation of root from bsp client 'Metals 1.3.3' (since 1h 10m 37.089s)
2024.07.19 13:33:14 INFO  compiling root (2 scala sources)
2024.07.19 13:33:14 INFO  time: compiled root in 23ms
2024.07.19 13:33:15 WARN  Attempt to organize your imports failed. It looks like you have compilation issues causing your semanticdb to be stale. Ensure everything is compiling and try again.
2024.07.19 13:33:15 INFO  Can not organize imports if file has error
2024.07.19 13:33:14 INFO  compiling root (2 scala sources)
2024.07.19 13:33:14 INFO  time: compiled root in 0.24s
2024.07.19 13:33:14 INFO  compiling root (2 scala sources)
2024.07.19 13:33:14 INFO  time: compiled root in 0.19s
2024.07.19 13:33:16 INFO  Can not organize imports if file has error
2024.07.19 13:33:16 INFO  compiling root (2 scala sources)
2024.07.19 13:33:16 INFO  time: compiled root in 0.18s
2024.07.19 13:33:20 INFO  compiling root (2 scala sources)
2024.07.19 13:33:20 INFO  time: compiled root in 0.18s
2024.07.19 13:33:43 INFO  compiling root (2 scala sources)
2024.07.19 13:33:43 INFO  time: compiled root in 0.16s
2024.07.19 13:33:44 INFO  Can not organize imports if file has error
2024.07.19 13:33:44 INFO  compiling root (2 scala sources)
2024.07.19 13:33:44 INFO  time: compiled root in 0.18s
2024.07.19 13:33:56 INFO  Can not organize imports if file has error
2024.07.19 13:33:56 INFO  compiling root (2 scala sources)
2024.07.19 13:33:56 INFO  time: compiled root in 0.19s
jul. 19, 2024 1:33:57 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleNotification
ADVERTÊNCIA: Notification threw an exception: {
  "jsonrpc": "2.0",
  "method": "textDocument/didOpen",
  "params": {
    "textDocument": {
      "uri": "jar:file%3A///C%3A/Users/Vinicius/AppData/Local/Coursier/cache/arc/https/github.com/adoptium/temurin17-binaries/releases/download/jdk-17%25252B35/OpenJDK17-jdk_x64_windows_hotspot_17_35.zip/jdk-17%2B35/lib/src.zip%21/java.base/java/lang/Integer.java",
      "languageId": "java",
      "version": 1,
      "text": "/*\n * Copyright (c) 1994, 2021, Oracle and/or its affiliates. All rights reserved.\n * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n *\n * This code is free software; you can redistribute it and/or modify it\n * under the terms of the GNU General Public License version 2 only, as\n * published by the Free Software Foundation.  Oracle designates this\n * particular file as subject to the \"Classpath\" exception as provided\n * by Oracle in the LICENSE file that accompanied this code.\n *\n * This code is distributed in the hope that it will be useful, but WITHOUT\n * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n * version 2 for more details (a copy is included in the LICENSE file that\n * accompanied this code).\n *\n * You should have received a copy of the GNU General Public License version\n * 2 along with this work; if not, write to the Free Software Foundation,\n * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n *\n * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n * or visit www.oracle.com if you need additional information or have any\n * questions.\n */\n\npackage java.lang;\n\nimport java.lang.annotation.Native;\nimport java.lang.invoke.MethodHandles;\nimport java.lang.constant.Constable;\nimport java.lang.constant.ConstantDesc;\nimport java.util.Objects;\nimport java.util.Optional;\n\nimport jdk.internal.misc.CDS;\nimport jdk.internal.misc.VM;\nimport jdk.internal.vm.annotation.IntrinsicCandidate;\n\nimport static java.lang.String.COMPACT_STRINGS;\nimport static java.lang.String.LATIN1;\nimport static java.lang.String.UTF16;\n\n/**\n * The {@code Integer} class wraps a value of the primitive type\n * {@code int} in an object. An object of type {@code Integer}\n * contains a single field whose type is {@code int}.\n *\n * \u003cp\u003eIn addition, this class provides several methods for converting\n * an {@code int} to a {@code String} and a {@code String} to an\n * {@code int}, as well as other constants and methods useful when\n * dealing with an {@code int}.\n *\n * \u003cp\u003eThis is a \u003ca href\u003d\"{@docRoot}/java.base/java/lang/doc-files/ValueBased.html\"\u003evalue-based\u003c/a\u003e\n * class; programmers should treat instances that are\n * {@linkplain #equals(Object) equal} as interchangeable and should not\n * use instances for synchronization, or unpredictable behavior may\n * occur. For example, in a future release, synchronization may fail.\n *\n * \u003cp\u003eImplementation note: The implementations of the \"bit twiddling\"\n * methods (such as {@link #highestOneBit(int) highestOneBit} and\n * {@link #numberOfTrailingZeros(int) numberOfTrailingZeros}) are\n * based on material from Henry S. Warren, Jr.\u0027s \u003ci\u003eHacker\u0027s\n * Delight\u003c/i\u003e, (Addison Wesley, 2002).\n *\n * @author  Lee Boynton\n * @author  Arthur van Hoff\n * @author  Josh Bloch\n * @author  Joseph D. Darcy\n * @since 1.0\n */\n@jdk.internal.ValueBased\npublic final class Integer extends Number\n        implements Comparable\u003cInteger\u003e, Constable, ConstantDesc {\n    /**\n     * A constant holding the minimum value an {@code int} can\n     * have, -2\u003csup\u003e31\u003c/sup\u003e.\n     */\n    @Native public static final int   MIN_VALUE \u003d 0x80000000;\n\n    /**\n     * A constant holding the maximum value an {@code int} can\n     * have, 2\u003csup\u003e31\u003c/sup\u003e-1.\n     */\n    @Native public static final int   MAX_VALUE \u003d 0x7fffffff;\n\n    /**\n     * The {@code Class} instance representing the primitive type\n     * {@code int}.\n     *\n     * @since   1.1\n     */\n    @SuppressWarnings(\"unchecked\")\n    public static final Class\u003cInteger\u003e  TYPE \u003d (Class\u003cInteger\u003e) Class.getPrimitiveClass(\"int\");\n\n    /**\n     * All possible chars for representing a number as a String\n     */\n    static final char[] digits \u003d {\n        \u00270\u0027 , \u00271\u0027 , \u00272\u0027 , \u00273\u0027 , \u00274\u0027 , \u00275\u0027 ,\n        \u00276\u0027 , \u00277\u0027 , \u00278\u0027 , \u00279\u0027 , \u0027a\u0027 , \u0027b\u0027 ,\n        \u0027c\u0027 , \u0027d\u0027 , \u0027e\u0027 , \u0027f\u0027 , \u0027g\u0027 , \u0027h\u0027 ,\n        \u0027i\u0027 , \u0027j\u0027 , \u0027k\u0027 , \u0027l\u0027 , \u0027m\u0027 , \u0027n\u0027 ,\n        \u0027o\u0027 , \u0027p\u0027 , \u0027q\u0027 , \u0027r\u0027 , \u0027s\u0027 , \u0027t\u0027 ,\n        \u0027u\u0027 , \u0027v\u0027 , \u0027w\u0027 , \u0027x\u0027 , \u0027y\u0027 , \u0027z\u0027\n    };\n\n    /**\n     * Returns a string representation of the first argument in the\n     * radix specified by the second argument.\n     *\n     * \u003cp\u003eIf the radix is smaller than {@code Character.MIN_RADIX}\n     * or larger than {@code Character.MAX_RADIX}, then the radix\n     * {@code 10} is used instead.\n     *\n     * \u003cp\u003eIf the first argument is negative, the first element of the\n     * result is the ASCII minus character {@code \u0027-\u0027}\n     * ({@code \u0027\\u005Cu002D\u0027}). If the first argument is not\n     * negative, no sign character appears in the result.\n     *\n     * \u003cp\u003eThe remaining characters of the result represent the magnitude\n     * of the first argument. If the magnitude is zero, it is\n     * represented by a single zero character {@code \u00270\u0027}\n     * ({@code \u0027\\u005Cu0030\u0027}); otherwise, the first character of\n     * the representation of the magnitude will not be the zero\n     * character.  The following ASCII characters are used as digits:\n     *\n     * \u003cblockquote\u003e\n     *   {@code 0123456789abcdefghijklmnopqrstuvwxyz}\n     * \u003c/blockquote\u003e\n     *\n     * These are {@code \u0027\\u005Cu0030\u0027} through\n     * {@code \u0027\\u005Cu0039\u0027} and {@code \u0027\\u005Cu0061\u0027} through\n     * {@code \u0027\\u005Cu007A\u0027}. If {@code radix} is\n     * \u003cvar\u003eN\u003c/var\u003e, then the first \u003cvar\u003eN\u003c/var\u003e of these characters\n     * are used as radix-\u003cvar\u003eN\u003c/var\u003e digits in the order shown. Thus,\n     * the digits for hexadecimal (radix 16) are\n     * {@code 0123456789abcdef}. If uppercase letters are\n     * desired, the {@link java.lang.String#toUpperCase()} method may\n     * be called on the result:\n     *\n     * \u003cblockquote\u003e\n     *  {@code Integer.toString(n, 16).toUpperCase()}\n     * \u003c/blockquote\u003e\n     *\n     * @param   i       an integer to be converted to a string.\n     * @param   radix   the radix to use in the string representation.\n     * @return  a string representation of the argument in the specified radix.\n     * @see     java.lang.Character#MAX_RADIX\n     * @see     java.lang.Character#MIN_RADIX\n     */\n    public static String toString(int i, int radix) {\n        if (radix \u003c Character.MIN_RADIX || radix \u003e Character.MAX_RADIX)\n            radix \u003d 10;\n\n        /* Use the faster version */\n        if (radix \u003d\u003d 10) {\n            return toString(i);\n        }\n\n        if (COMPACT_STRINGS) {\n            byte[] buf \u003d new byte[33];\n            boolean negative \u003d (i \u003c 0);\n            int charPos \u003d 32;\n\n            if (!negative) {\n                i \u003d -i;\n            }\n\n            while (i \u003c\u003d -radix) {\n                buf[charPos--] \u003d (byte)digits[-(i % radix)];\n                i \u003d i / radix;\n            }\n            buf[charPos] \u003d (byte)digits[-i];\n\n            if (negative) {\n                buf[--charPos] \u003d \u0027-\u0027;\n            }\n\n            return StringLatin1.newString(buf, charPos, (33 - charPos));\n        }\n        return toStringUTF16(i, radix);\n    }\n\n    private static String toStringUTF16(int i, int radix) {\n        byte[] buf \u003d new byte[33 * 2];\n        boolean negative \u003d (i \u003c 0);\n        int charPos \u003d 32;\n        if (!negative) {\n            i \u003d -i;\n        }\n        while (i \u003c\u003d -radix) {\n            StringUTF16.putChar(buf, charPos--, digits[-(i % radix)]);\n            i \u003d i / radix;\n        }\n        StringUTF16.putChar(buf, charPos, digits[-i]);\n\n        if (negative) {\n            StringUTF16.putChar(buf, --charPos, \u0027-\u0027);\n        }\n        return StringUTF16.newString(buf, charPos, (33 - charPos));\n    }\n\n    /**\n     * Returns a string representation of the first argument as an\n     * unsigned integer value in the radix specified by the second\n     * argument.\n     *\n     * \u003cp\u003eIf the radix is smaller than {@code Character.MIN_RADIX}\n     * or larger than {@code Character.MAX_RADIX}, then the radix\n     * {@code 10} is used instead.\n     *\n     * \u003cp\u003eNote that since the first argument is treated as an unsigned\n     * value, no leading sign character is printed.\n     *\n     * \u003cp\u003eIf the magnitude is zero, it is represented by a single zero\n     * character {@code \u00270\u0027} ({@code \u0027\\u005Cu0030\u0027}); otherwise,\n     * the first character of the representation of the magnitude will\n     * not be the zero character.\n     *\n     * \u003cp\u003eThe behavior of radixes and the characters used as digits\n     * are the same as {@link #toString(int, int) toString}.\n     *\n     * @param   i       an integer to be converted to an unsigned string.\n     * @param   radix   the radix to use in the string representation.\n     * @return  an unsigned string representation of the argument in the specified radix.\n     * @see     #toString(int, int)\n     * @since 1.8\n     */\n    public static String toUnsignedString(int i, int radix) {\n        return Long.toUnsignedString(toUnsignedLong(i), radix);\n    }\n\n    /**\n     * Returns a string representation of the integer argument as an\n     * unsigned integer in base\u0026nbsp;16.\n     *\n     * \u003cp\u003eThe unsigned integer value is the argument plus 2\u003csup\u003e32\u003c/sup\u003e\n     * if the argument is negative; otherwise, it is equal to the\n     * argument.  This value is converted to a string of ASCII digits\n     * in hexadecimal (base\u0026nbsp;16) with no extra leading\n     * {@code 0}s.\n     *\n     * \u003cp\u003eThe value of the argument can be recovered from the returned\n     * string {@code s} by calling {@link\n     * Integer#parseUnsignedInt(String, int)\n     * Integer.parseUnsignedInt(s, 16)}.\n     *\n     * \u003cp\u003eIf the unsigned magnitude is zero, it is represented by a\n     * single zero character {@code \u00270\u0027} ({@code \u0027\\u005Cu0030\u0027});\n     * otherwise, the first character of the representation of the\n     * unsigned magnitude will not be the zero character. The\n     * following characters are used as hexadecimal digits:\n     *\n     * \u003cblockquote\u003e\n     *  {@code 0123456789abcdef}\n     * \u003c/blockquote\u003e\n     *\n     * These are the characters {@code \u0027\\u005Cu0030\u0027} through\n     * {@code \u0027\\u005Cu0039\u0027} and {@code \u0027\\u005Cu0061\u0027} through\n     * {@code \u0027\\u005Cu0066\u0027}. If uppercase letters are\n     * desired, the {@link java.lang.String#toUpperCase()} method may\n     * be called on the result:\n     *\n     * \u003cblockquote\u003e\n     *  {@code Integer.toHexString(n).toUpperCase()}\n     * \u003c/blockquote\u003e\n     *\n     * @apiNote\n     * The {@link java.util.HexFormat} class provides formatting and parsing\n     * of byte arrays and primitives to return a string or adding to an {@link Appendable}.\n     * {@code HexFormat} formats and parses uppercase or lowercase hexadecimal characters,\n     * with leading zeros and for byte arrays includes for each byte\n     * a delimiter, prefix, and suffix.\n     *\n     * @param   i   an integer to be converted to a string.\n     * @return  the string representation of the unsigned integer value\n     *          represented by the argument in hexadecimal (base\u0026nbsp;16).\n     * @see java.util.HexFormat\n     * @see #parseUnsignedInt(String, int)\n     * @see #toUnsignedString(int, int)\n     * @since   1.0.2\n     */\n    public static String toHexString(int i) {\n        return toUnsignedString0(i, 4);\n    }\n\n    /**\n     * Returns a string representation of the integer argument as an\n     * unsigned integer in base\u0026nbsp;8.\n     *\n     * \u003cp\u003eThe unsigned integer value is the argument plus 2\u003csup\u003e32\u003c/sup\u003e\n     * if the argument is negative; otherwise, it is equal to the\n     * argument.  This value is converted to a string of ASCII digits\n     * in octal (base\u0026nbsp;8) with no extra leading {@code 0}s.\n     *\n     * \u003cp\u003eThe value of the argument can be recovered from the returned\n     * string {@code s} by calling {@link\n     * Integer#parseUnsignedInt(String, int)\n     * Integer.parseUnsignedInt(s, 8)}.\n     *\n     * \u003cp\u003eIf the unsigned magnitude is zero, it is represented by a\n     * single zero character {@code \u00270\u0027} ({@code \u0027\\u005Cu0030\u0027});\n     * otherwise, the first character of the representation of the\n     * unsigned magnitude will not be the zero character. The\n     * following characters are used as octal digits:\n     *\n     * \u003cblockquote\u003e\n     * {@code 01234567}\n     * \u003c/blockquote\u003e\n     *\n     * These are the characters {@code \u0027\\u005Cu0030\u0027} through\n     * {@code \u0027\\u005Cu0037\u0027}.\n     *\n     * @param   i   an integer to be converted to a string.\n     * @return  the string representation of the unsigned integer value\n     *          represented by the argument in octal (base\u0026nbsp;8).\n     * @see #parseUnsignedInt(String, int)\n     * @see #toUnsignedString(int, int)\n     * @since   1.0.2\n     */\n    public static String toOctalString(int i) {\n        return toUnsignedString0(i, 3);\n    }\n\n    /**\n     * Returns a string representation of the integer argument as an\n     * unsigned integer in base\u0026nbsp;2.\n     *\n     * \u003cp\u003eThe unsigned integer value is the argument plus 2\u003csup\u003e32\u003c/sup\u003e\n     * if the argument is negative; otherwise it is equal to the\n     * argument.  This value is converted to a string of ASCII digits\n     * in binary (base\u0026nbsp;2) with no extra leading {@code 0}s.\n     *\n     * \u003cp\u003eThe value of the argument can be recovered from the returned\n     * string {@code s} by calling {@link\n     * Integer#parseUnsignedInt(String, int)\n     * Integer.parseUnsignedInt(s, 2)}.\n     *\n     * \u003cp\u003eIf the unsigned magnitude is zero, it is represented by a\n     * single zero character {@code \u00270\u0027} ({@code \u0027\\u005Cu0030\u0027});\n     * otherwise, the first character of the representation of the\n     * unsigned magnitude will not be the zero character. The\n     * characters {@code \u00270\u0027} ({@code \u0027\\u005Cu0030\u0027}) and {@code\n     * \u00271\u0027} ({@code \u0027\\u005Cu0031\u0027}) are used as binary digits.\n     *\n     * @param   i   an integer to be converted to a string.\n     * @return  the string representation of the unsigned integer value\n     *          represented by the argument in binary (base\u0026nbsp;2).\n     * @see #parseUnsignedInt(String, int)\n     * @see #toUnsignedString(int, int)\n     * @since   1.0.2\n     */\n    public static String toBinaryString(int i) {\n        return toUnsignedString0(i, 1);\n    }\n\n    /**\n     * Convert the integer to an unsigned number.\n     */\n    private static String toUnsignedString0(int val, int shift) {\n        // assert shift \u003e 0 \u0026\u0026 shift \u003c\u003d5 : \"Illegal shift value\";\n        int mag \u003d Integer.SIZE - Integer.numberOfLeadingZeros(val);\n        int chars \u003d Math.max(((mag + (shift - 1)) / shift), 1);\n        if (COMPACT_STRINGS) {\n            byte[] buf \u003d new byte[chars];\n            formatUnsignedInt(val, shift, buf, chars);\n            return new String(buf, LATIN1);\n        } else {\n            byte[] buf \u003d new byte[chars * 2];\n            formatUnsignedIntUTF16(val, shift, buf, chars);\n            return new String(buf, UTF16);\n        }\n    }\n\n    /**\n     * Format an {@code int} (treated as unsigned) into a byte buffer (LATIN1 version). If\n     * {@code len} exceeds the formatted ASCII representation of {@code val},\n     * {@code buf} will be padded with leading zeroes.\n     *\n     * @param val the unsigned int to format\n     * @param shift the log2 of the base to format in (4 for hex, 3 for octal, 1 for binary)\n     * @param buf the byte buffer to write to\n     * @param len the number of characters to write\n     */\n    private static void formatUnsignedInt(int val, int shift, byte[] buf, int len) {\n        int charPos \u003d len;\n        int radix \u003d 1 \u003c\u003c shift;\n        int mask \u003d radix - 1;\n        do {\n            buf[--charPos] \u003d (byte)Integer.digits[val \u0026 mask];\n            val \u003e\u003e\u003e\u003d shift;\n        } while (charPos \u003e 0);\n    }\n\n    /**\n     * Format an {@code int} (treated as unsigned) into a byte buffer (UTF16 version). If\n     * {@code len} exceeds the formatted ASCII representation of {@code val},\n     * {@code buf} will be padded with leading zeroes.\n     *\n     * @param val the unsigned int to format\n     * @param shift the log2 of the base to format in (4 for hex, 3 for octal, 1 for binary)\n     * @param buf the byte buffer to write to\n     * @param len the number of characters to write\n     */\n    private static void formatUnsignedIntUTF16(int val, int shift, byte[] buf, int len) {\n        int charPos \u003d len;\n        int radix \u003d 1 \u003c\u003c shift;\n        int mask \u003d radix - 1;\n        do {\n            StringUTF16.putChar(buf, --charPos, Integer.digits[val \u0026 mask]);\n            val \u003e\u003e\u003e\u003d shift;\n        } while (charPos \u003e 0);\n    }\n\n    static final byte[] DigitTens \u003d {\n        \u00270\u0027, \u00270\u0027, \u00270\u0027, \u00270\u0027, \u00270\u0027, \u00270\u0027, \u00270\u0027, \u00270\u0027, \u00270\u0027, \u00270\u0027,\n        \u00271\u0027, \u00271\u0027, \u00271\u0027, \u00271\u0027, \u00271\u0027, \u00271\u0027, \u00271\u0027, \u00271\u0027, \u00271\u0027, \u00271\u0027,\n        \u00272\u0027, \u00272\u0027, \u00272\u0027, \u00272\u0027, \u00272\u0027, \u00272\u0027, \u00272\u0027, \u00272\u0027, \u00272\u0027, \u00272\u0027,\n        \u00273\u0027, \u00273\u0027, \u00273\u0027, \u00273\u0027, \u00273\u0027, \u00273\u0027, \u00273\u0027, \u00273\u0027, \u00273\u0027, \u00273\u0027,\n        \u00274\u0027, \u00274\u0027, \u00274\u0027, \u00274\u0027, \u00274\u0027, \u00274\u0027, \u00274\u0027, \u00274\u0027, \u00274\u0027, \u00274\u0027,\n        \u00275\u0027, \u00275\u0027, \u00275\u0027, \u00275\u0027, \u00275\u0027, \u00275\u0027, \u00275\u0027, \u00275\u0027, \u00275\u0027, \u00275\u0027,\n        \u00276\u0027, \u00276\u0027, \u00276\u0027, \u00276\u0027, \u00276\u0027, \u00276\u0027, \u00276\u0027, \u00276\u0027, \u00276\u0027, \u00276\u0027,\n        \u00277\u0027, \u00277\u0027, \u00277\u0027, \u00277\u0027, \u00277\u0027, \u00277\u0027, \u00277\u0027, \u00277\u0027, \u00277\u0027, \u00277\u0027,\n        \u00278\u0027, \u00278\u0027, \u00278\u0027, \u00278\u0027, \u00278\u0027, \u00278\u0027, \u00278\u0027, \u00278\u0027, \u00278\u0027, \u00278\u0027,\n        \u00279\u0027, \u00279\u0027, \u00279\u0027, \u00279\u0027, \u00279\u0027, \u00279\u0027, \u00279\u0027, \u00279\u0027, \u00279\u0027, \u00279\u0027,\n        } ;\n\n    static final byte[] DigitOnes \u003d {\n        \u00270\u0027, \u00271\u0027, \u00272\u0027, \u00273\u0027, \u00274\u0027, \u00275\u0027, \u00276\u0027, \u00277\u0027, \u00278\u0027, \u00279\u0027,\n        \u00270\u0027, \u00271\u0027, \u00272\u0027, \u00273\u0027, \u00274\u0027, \u00275\u0027, \u00276\u0027, \u00277\u0027, \u00278\u0027, \u00279\u0027,\n        \u00270\u0027, \u00271\u0027, \u00272\u0027, \u00273\u0027, \u00274\u0027, \u00275\u0027, \u00276\u0027, \u00277\u0027, \u00278\u0027, \u00279\u0027,\n        \u00270\u0027, \u00271\u0027, \u00272\u0027, \u00273\u0027, \u00274\u0027, \u00275\u0027, \u00276\u0027, \u00277\u0027, \u00278\u0027, \u00279\u0027,\n        \u00270\u0027, \u00271\u0027, \u00272\u0027, \u00273\u0027, \u00274\u0027, \u00275\u0027, \u00276\u0027, \u00277\u0027, \u00278\u0027, \u00279\u0027,\n        \u00270\u0027, \u00271\u0027, \u00272\u0027, \u00273\u0027, \u00274\u0027, \u00275\u0027, \u00276\u0027, \u00277\u0027, \u00278\u0027, \u00279\u0027,\n        \u00270\u0027, \u00271\u0027, \u00272\u0027, \u00273\u0027, \u00274\u0027, \u00275\u0027, \u00276\u0027, \u00277\u0027, \u00278\u0027, \u00279\u0027,\n        \u00270\u0027, \u00271\u0027, \u00272\u0027, \u00273\u0027, \u00274\u0027, \u00275\u0027, \u00276\u0027, \u00277\u0027, \u00278\u0027, \u00279\u0027,\n        \u00270\u0027, \u00271\u0027, \u00272\u0027, \u00273\u0027, \u00274\u0027, \u00275\u0027, \u00276\u0027, \u00277\u0027, \u00278\u0027, \u00279\u0027,\n        \u00270\u0027, \u00271\u0027, \u00272\u0027, \u00273\u0027, \u00274\u0027, \u00275\u0027, \u00276\u0027, \u00277\u0027, \u00278\u0027, \u00279\u0027,\n        } ;\n\n\n    /**\n     * Returns a {@code String} object representing the\n     * specified integer. The argument is converted to signed decimal\n     * representation and returned as a string, exactly as if the\n     * argument and radix 10 were given as arguments to the {@link\n     * #toString(int, int)} method.\n     *\n     * @param   i   an integer to be converted.\n     * @return  a string representation of the argument in base\u0026nbsp;10.\n     */\n    @IntrinsicCandidate\n    public static String toString(int i) {\n        int size \u003d stringSize(i);\n        if (COMPACT_STRINGS) {\n            byte[] buf \u003d new byte[size];\n            getChars(i, size, buf);\n            return new String(buf, LATIN1);\n        } else {\n            byte[] buf \u003d new byte[size * 2];\n            StringUTF16.getChars(i, size, buf);\n            return new String(buf, UTF16);\n        }\n    }\n\n    /**\n     * Returns a string representation of the argument as an unsigned\n     * decimal value.\n     *\n     * The argument is converted to unsigned decimal representation\n     * and returned as a string exactly as if the argument and radix\n     * 10 were given as arguments to the {@link #toUnsignedString(int,\n     * int)} method.\n     *\n     * @param   i  an integer to be converted to an unsigned string.\n     * @return  an unsigned string representation of the argument.\n     * @see     #toUnsignedString(int, int)\n     * @since 1.8\n     */\n    public static String toUnsignedString(int i) {\n        return Long.toString(toUnsignedLong(i));\n    }\n\n    /**\n     * Places characters representing the integer i into the\n     * character array buf. The characters are placed into\n     * the buffer backwards starting with the least significant\n     * digit at the specified index (exclusive), and working\n     * backwards from there.\n     *\n     * @implNote This method converts positive inputs into negative\n     * values, to cover the Integer.MIN_VALUE case. Converting otherwise\n     * (negative to positive) will expose -Integer.MIN_VALUE that overflows\n     * integer.\n     *\n     * @param i     value to convert\n     * @param index next index, after the least significant digit\n     * @param buf   target buffer, Latin1-encoded\n     * @return index of the most significant digit or minus sign, if present\n     */\n    static int getChars(int i, int index, byte[] buf) {\n        int q, r;\n        int charPos \u003d index;\n\n        boolean negative \u003d i \u003c 0;\n        if (!negative) {\n            i \u003d -i;\n        }\n\n        // Generate two digits per iteration\n        while (i \u003c\u003d -100) {\n            q \u003d i / 100;\n            r \u003d (q * 100) - i;\n            i \u003d q;\n            buf[--charPos] \u003d DigitOnes[r];\n            buf[--charPos] \u003d DigitTens[r];\n        }\n\n        // We know there are at most two digits left at this point.\n        q \u003d i / 10;\n        r \u003d (q * 10) - i;\n        buf[--charPos] \u003d (byte)(\u00270\u0027 + r);\n\n        // Whatever left is the remaining digit.\n        if (q \u003c 0) {\n            buf[--charPos] \u003d (byte)(\u00270\u0027 - q);\n        }\n\n        if (negative) {\n            buf[--charPos] \u003d (byte)\u0027-\u0027;\n        }\n        return charPos;\n    }\n\n    // Left here for compatibility reasons, see JDK-8143900.\n    static final int [] sizeTable \u003d { 9, 99, 999, 9999, 99999, 999999, 9999999,\n                                      99999999, 999999999, Integer.MAX_VALUE };\n\n    /**\n     * Returns the string representation size for a given int value.\n     *\n     * @param x int value\n     * @return string size\n     *\n     * @implNote There are other ways to compute this: e.g. binary search,\n     * but values are biased heavily towards zero, and therefore linear search\n     * wins. The iteration results are also routinely inlined in the generated\n     * code after loop unrolling.\n     */\n    static int stringSize(int x) {\n        int d \u003d 1;\n        if (x \u003e\u003d 0) {\n            d \u003d 0;\n            x \u003d -x;\n        }\n        int p \u003d -10;\n        for (int i \u003d 1; i \u003c 10; i++) {\n            if (x \u003e p)\n                return i + d;\n            p \u003d 10 * p;\n        }\n        return 10 + d;\n    }\n\n    /**\n     * Parses the string argument as a signed integer in the radix\n     * specified by the second argument. The characters in the string\n     * must all be digits of the specified radix (as determined by\n     * whether {@link java.lang.Character#digit(char, int)} returns a\n     * nonnegative value), except that the first character may be an\n     * ASCII minus sign {@code \u0027-\u0027} ({@code \u0027\\u005Cu002D\u0027}) to\n     * indicate a negative value or an ASCII plus sign {@code \u0027+\u0027}\n     * ({@code \u0027\\u005Cu002B\u0027}) to indicate a positive value. The\n     * resulting integer value is returned.\n     *\n     * \u003cp\u003eAn exception of type {@code NumberFormatException} is\n     * thrown if any of the following situations occurs:\n     * \u003cul\u003e\n     * \u003cli\u003eThe first argument is {@code null} or is a string of\n     * length zero.\n     *\n     * \u003cli\u003eThe radix is either smaller than\n     * {@link java.lang.Character#MIN_RADIX} or\n     * larger than {@link java.lang.Character#MAX_RADIX}.\n     *\n     * \u003cli\u003eAny character of the string is not a digit of the specified\n     * radix, except that the first character may be a minus sign\n     * {@code \u0027-\u0027} ({@code \u0027\\u005Cu002D\u0027}) or plus sign\n     * {@code \u0027+\u0027} ({@code \u0027\\u005Cu002B\u0027}) provided that the\n     * string is longer than length 1.\n     *\n     * \u003cli\u003eThe value represented by the string is not a value of type\n     * {@code int}.\n     * \u003c/ul\u003e\n     *\n     * \u003cp\u003eExamples:\n     * \u003cblockquote\u003e\u003cpre\u003e\n     * parseInt(\"0\", 10) returns 0\n     * parseInt(\"473\", 10) returns 473\n     * parseInt(\"+42\", 10) returns 42\n     * parseInt(\"-0\", 10) returns 0\n     * parseInt(\"-FF\", 16) returns -255\n     * parseInt(\"1100110\", 2) returns 102\n     * parseInt(\"2147483647\", 10) returns 2147483647\n     * parseInt(\"-2147483648\", 10) returns -2147483648\n     * parseInt(\"2147483648\", 10) throws a NumberFormatException\n     * parseInt(\"99\", 8) throws a NumberFormatException\n     * parseInt(\"Kona\", 10) throws a NumberFormatException\n     * parseInt(\"Kona\", 27) returns 411787\n     * \u003c/pre\u003e\u003c/blockquote\u003e\n     *\n     * @param      s   the {@code String} containing the integer\n     *                  representation to be parsed\n     * @param      radix   the radix to be used while parsing {@code s}.\n     * @return     the integer represented by the string argument in the\n     *             specified radix.\n     * @throws     NumberFormatException if the {@code String}\n     *             does not contain a parsable {@code int}.\n     */\n    public static int parseInt(String s, int radix)\n                throws NumberFormatException\n    {\n        /*\n         * WARNING: This method may be invoked early during VM initialization\n         * before IntegerCache is initialized. Care must be taken to not use\n         * the valueOf method.\n         */\n\n        if (s \u003d\u003d null) {\n            throw new NumberFormatException(\"Cannot parse null string\");\n        }\n\n        if (radix \u003c Character.MIN_RADIX) {\n            throw new NumberFormatException(\"radix \" + radix +\n                                            \" less than Character.MIN_RADIX\");\n        }\n\n        if (radix \u003e Character.MAX_RADIX) {\n            throw new NumberFormatException(\"radix \" + radix +\n                                            \" greater than Character.MAX_RADIX\");\n        }\n\n        boolean negative \u003d false;\n        int i \u003d 0, len \u003d s.length();\n        int limit \u003d -Integer.MAX_VALUE;\n\n        if (len \u003e 0) {\n            char firstChar \u003d s.charAt(0);\n            if (firstChar \u003c \u00270\u0027) { // Possible leading \"+\" or \"-\"\n                if (firstChar \u003d\u003d \u0027-\u0027) {\n                    negative \u003d true;\n                    limit \u003d Integer.MIN_VALUE;\n                } else if (firstChar !\u003d \u0027+\u0027) {\n                    throw NumberFormatException.forInputString(s, radix);\n                }\n\n                if (len \u003d\u003d 1) { // Cannot have lone \"+\" or \"-\"\n                    throw NumberFormatException.forInputString(s, radix);\n                }\n                i++;\n            }\n            int multmin \u003d limit / radix;\n            int result \u003d 0;\n            while (i \u003c len) {\n                // Accumulating negatively avoids surprises near MAX_VALUE\n                int digit \u003d Character.digit(s.charAt(i++), radix);\n                if (digit \u003c 0 || result \u003c multmin) {\n                    throw NumberFormatException.forInputString(s, radix);\n                }\n                result *\u003d radix;\n                if (result \u003c limit + digit) {\n                    throw NumberFormatException.forInputString(s, radix);\n                }\n                result -\u003d digit;\n            }\n            return negative ? result : -result;\n        } else {\n            throw NumberFormatException.forInputString(s, radix);\n        }\n    }\n\n    /**\n     * Parses the {@link CharSequence} argument as a signed {@code int} in the\n     * specified {@code radix}, beginning at the specified {@code beginIndex}\n     * and extending to {@code endIndex - 1}.\n     *\n     * \u003cp\u003eThe method does not take steps to guard against the\n     * {@code CharSequence} being mutated while parsing.\n     *\n     * @param      s   the {@code CharSequence} containing the {@code int}\n     *                  representation to be parsed\n     * @param      beginIndex   the beginning index, inclusive.\n     * @param      endIndex     the ending index, exclusive.\n     * @param      radix   the radix to be used while parsing {@code s}.\n     * @return     the signed {@code int} represented by the subsequence in\n     *             the specified radix.\n     * @throws     NullPointerException  if {@code s} is null.\n     * @throws     IndexOutOfBoundsException  if {@code beginIndex} is\n     *             negative, or if {@code beginIndex} is greater than\n     *             {@code endIndex} or if {@code endIndex} is greater than\n     *             {@code s.length()}.\n     * @throws     NumberFormatException  if the {@code CharSequence} does not\n     *             contain a parsable {@code int} in the specified\n     *             {@code radix}, or if {@code radix} is either smaller than\n     *             {@link java.lang.Character#MIN_RADIX} or larger than\n     *             {@link java.lang.Character#MAX_RADIX}.\n     * @since  9\n     */\n    public static int parseInt(CharSequence s, int beginIndex, int endIndex, int radix)\n                throws NumberFormatException {\n        Objects.requireNonNull(s);\n\n        if (beginIndex \u003c 0 || beginIndex \u003e endIndex || endIndex \u003e s.length()) {\n            throw new IndexOutOfBoundsException();\n        }\n        if (radix \u003c Character.MIN_RADIX) {\n            throw new NumberFormatException(\"radix \" + radix +\n                                            \" less than Character.MIN_RADIX\");\n        }\n        if (radix \u003e Character.MAX_RADIX) {\n            throw new NumberFormatException(\"radix \" + radix +\n                                            \" greater than Character.MAX_RADIX\");\n        }\n\n        boolean negative \u003d false;\n        int i \u003d beginIndex;\n        int limit \u003d -Integer.MAX_VALUE;\n\n        if (i \u003c endIndex) {\n            char firstChar \u003d s.charAt(i);\n            if (firstChar \u003c \u00270\u0027) { // Possible leading \"+\" or \"-\"\n                if (firstChar \u003d\u003d \u0027-\u0027) {\n                    negative \u003d true;\n                    limit \u003d Integer.MIN_VALUE;\n                } else if (firstChar !\u003d \u0027+\u0027) {\n                    throw NumberFormatException.forCharSequence(s, beginIndex,\n                            endIndex, i);\n                }\n                i++;\n                if (i \u003d\u003d endIndex) { // Cannot have lone \"+\" or \"-\"\n                    throw NumberFormatException.forCharSequence(s, beginIndex,\n                            endIndex, i);\n                }\n            }\n            int multmin \u003d limit / radix;\n            int result \u003d 0;\n            while (i \u003c endIndex) {\n                // Accumulating negatively avoids surprises near MAX_VALUE\n                int digit \u003d Character.digit(s.charAt(i), radix);\n                if (digit \u003c 0 || result \u003c multmin) {\n                    throw NumberFormatException.forCharSequence(s, beginIndex,\n                            endIndex, i);\n                }\n                result *\u003d radix;\n                if (result \u003c limit + digit) {\n                    throw NumberFormatException.forCharSequence(s, beginIndex,\n                            endIndex, i);\n                }\n                i++;\n                result -\u003d digit;\n            }\n            return negative ? result : -result;\n        } else {\n            throw NumberFormatException.forInputString(\"\", radix);\n        }\n    }\n\n    /**\n     * Parses the string argument as a signed decimal integer. The\n     * characters in the string must all be decimal digits, except\n     * that the first character may be an ASCII minus sign {@code \u0027-\u0027}\n     * ({@code \u0027\\u005Cu002D\u0027}) to indicate a negative value or an\n     * ASCII plus sign {@code \u0027+\u0027} ({@code \u0027\\u005Cu002B\u0027}) to\n     * indicate a positive value. The resulting integer value is\n     * returned, exactly as if the argument and the radix 10 were\n     * given as arguments to the {@link #parseInt(java.lang.String,\n     * int)} method.\n     *\n     * @param s    a {@code String} containing the {@code int}\n     *             representation to be parsed\n     * @return     the integer value represented by the argument in decimal.\n     * @throws     NumberFormatException  if the string does not contain a\n     *               parsable integer.\n     */\n    public static int parseInt(String s) throws NumberFormatException {\n        return parseInt(s,10);\n    }\n\n    /**\n     * Parses the string argument as an unsigned integer in the radix\n     * specified by the second argument.  An unsigned integer maps the\n     * values usually associated with negative numbers to positive\n     * numbers larger than {@code MAX_VALUE}.\n     *\n     * The characters in the string must all be digits of the\n     * specified radix (as determined by whether {@link\n     * java.lang.Character#digit(char, int)} returns a nonnegative\n     * value), except that the first character may be an ASCII plus\n     * sign {@code \u0027+\u0027} ({@code \u0027\\u005Cu002B\u0027}). The resulting\n     * integer value is returned.\n     *\n     * \u003cp\u003eAn exception of type {@code NumberFormatException} is\n     * thrown if any of the following situations occurs:\n     * \u003cul\u003e\n     * \u003cli\u003eThe first argument is {@code null} or is a string of\n     * length zero.\n     *\n     * \u003cli\u003eThe radix is either smaller than\n     * {@link java.lang.Character#MIN_RADIX} or\n     * larger than {@link java.lang.Character#MAX_RADIX}.\n     *\n     * \u003cli\u003eAny character of the string is not a digit of the specified\n     * radix, except that the first character may be a plus sign\n     * {@code \u0027+\u0027} ({@code \u0027\\u005Cu002B\u0027}) provided that the\n     * string is longer than length 1.\n     *\n     * \u003cli\u003eThe value represented by the string is larger than the\n     * largest unsigned {@code int}, 2\u003csup\u003e32\u003c/sup\u003e-1.\n     *\n     * \u003c/ul\u003e\n     *\n     *\n     * @param      s   the {@code String} containing the unsigned integer\n     *                  representation to be parsed\n     * @param      radix   the radix to be used while parsing {@code s}.\n     * @return     the integer represented by the string argument in the\n     *             specified radix.\n     * @throws     NumberFormatException if the {@code String}\n     *             does not contain a parsable {@code int}.\n     * @since 1.8\n     */\n    public static int parseUnsignedInt(String s, int radix)\n                throws NumberFormatException {\n        if (s \u003d\u003d null)  {\n            throw new NumberFormatException(\"Cannot parse null string\");\n        }\n\n        int len \u003d s.length();\n        if (len \u003e 0) {\n            char firstChar \u003d s.charAt(0);\n            if (firstChar \u003d\u003d \u0027-\u0027) {\n                throw new\n                    NumberFormatException(String.format(\"Illegal leading minus sign \" +\n                                                       \"on unsigned string %s.\", s));\n            } else {\n                if (len \u003c\u003d 5 || // Integer.MAX_VALUE in Character.MAX_RADIX is 6 digits\n                    (radix \u003d\u003d 10 \u0026\u0026 len \u003c\u003d 9) ) { // Integer.MAX_VALUE in base 10 is 10 digits\n                    return parseInt(s, radix);\n                } else {\n                    long ell \u003d Long.parseLong(s, radix);\n                    if ((ell \u0026 0xffff_ffff_0000_0000L) \u003d\u003d 0) {\n                        return (int) ell;\n                    } else {\n                        throw new\n                            NumberFormatException(String.format(\"String value %s exceeds \" +\n                                                                \"range of unsigned int.\", s));\n                    }\n                }\n            }\n        } else {\n            throw NumberFormatException.forInputString(s, radix);\n        }\n    }\n\n    /**\n     * Parses the {@link CharSequence} argument as an unsigned {@code int} in\n     * the specified {@code radix}, beginning at the specified\n     * {@code beginIndex} and extending to {@code endIndex - 1}.\n     *\n     * \u003cp\u003eThe method does not take steps to guard against the\n     * {@code CharSequence} being mutated while parsing.\n     *\n     * @param      s   the {@code CharSequence} containing the unsigned\n     *                 {@code int} representation to be parsed\n     * @param      beginIndex   the beginning index, inclusive.\n     * @param      endIndex     the ending index, exclusive.\n     * @param      radix   the radix to be used while parsing {@code s}.\n     * @return     the unsigned {@code int} represented by the subsequence in\n     *             the specified radix.\n     * @throws     NullPointerException  if {@code s} is null.\n     * @throws     IndexOutOfBoundsException  if {@code beginIndex} is\n     *             negative, or if {@code beginIndex} is greater than\n     *             {@code endIndex} or if {@code endIndex} is greater than\n     *             {@code s.length()}.\n     * @throws     NumberFormatException  if the {@code CharSequence} does not\n     *             contain a parsable unsigned {@code int} in the specified\n     *             {@code radix}, or if {@code radix} is either smaller than\n     *             {@link java.lang.Character#MIN_RADIX} or larger than\n     *             {@link java.lang.Character#MAX_RADIX}.\n     * @since  9\n     */\n    public static int parseUnsignedInt(CharSequence s, int beginIndex, int endIndex, int radix)\n                throws NumberFormatException {\n        Objects.requireNonNull(s);\n\n        if (beginIndex \u003c 0 || beginIndex \u003e endIndex || endIndex \u003e s.length()) {\n            throw new IndexOutOfBoundsException();\n        }\n        int start \u003d beginIndex, len \u003d endIndex - beginIndex;\n\n        if (len \u003e 0) {\n            char firstChar \u003d s.charAt(start);\n            if (firstChar \u003d\u003d \u0027-\u0027) {\n                throw new\n                    NumberFormatException(String.format(\"Illegal leading minus sign \" +\n                                                       \"on unsigned string %s.\", s));\n            } else {\n                if (len \u003c\u003d 5 || // Integer.MAX_VALUE in Character.MAX_RADIX is 6 digits\n                        (radix \u003d\u003d 10 \u0026\u0026 len \u003c\u003d 9)) { // Integer.MAX_VALUE in base 10 is 10 digits\n                    return parseInt(s, start, start + len, radix);\n                } else {\n                    long ell \u003d Long.parseLong(s, start, start + len, radix);\n                    if ((ell \u0026 0xffff_ffff_0000_0000L) \u003d\u003d 0) {\n                        return (int) ell;\n                    } else {\n                        throw new\n                            NumberFormatException(String.format(\"String value %s exceeds \" +\n                                                                \"range of unsigned int.\", s));\n                    }\n                }\n            }\n        } else {\n            throw new NumberFormatException(\"\");\n        }\n    }\n\n    /**\n     * Parses the string argument as an unsigned decimal integer. The\n     * characters in the string must all be decimal digits, except\n     * that the first character may be an ASCII plus sign {@code\n     * \u0027+\u0027} ({@code \u0027\\u005Cu002B\u0027}). The resulting integer value\n     * is returned, exactly as if the argument and the radix 10 were\n     * given as arguments to the {@link\n     * #parseUnsignedInt(java.lang.String, int)} method.\n     *\n     * @param s   a {@code String} containing the unsigned {@code int}\n     *            representation to be parsed\n     * @return    the unsigned integer value represented by the argument in decimal.\n     * @throws    NumberFormatException  if the string does not contain a\n     *            parsable unsigned integer.\n     * @since 1.8\n     */\n    public static int parseUnsignedInt(String s) throws NumberFormatException {\n        return parseUnsignedInt(s, 10);\n    }\n\n    /**\n     * Returns an {@code Integer} object holding the value\n     * extracted from the specified {@code String} when parsed\n     * with the radix given by the second argument. The first argument\n     * is interpreted as representing a signed integer in the radix\n     * specified by the second argument, exactly as if the arguments\n     * were given to the {@link #parseInt(java.lang.String, int)}\n     * method. The result is an {@code Integer} object that\n     * represents the integer value specified by the string.\n     *\n     * \u003cp\u003eIn other words, this method returns an {@code Integer}\n     * object equal to the value of:\n     *\n     * \u003cblockquote\u003e\n     *  {@code new Integer(Integer.parseInt(s, radix))}\n     * \u003c/blockquote\u003e\n     *\n     * @param      s   the string to be parsed.\n     * @param      radix the radix to be used in interpreting {@code s}\n     * @return     an {@code Integer} object holding the value\n     *             represented by the string argument in the specified\n     *             radix.\n     * @throws    NumberFormatException if the {@code String}\n     *            does not contain a parsable {@code int}.\n     */\n    public static Integer valueOf(String s, int radix) throws NumberFormatException {\n        return Integer.valueOf(parseInt(s,radix));\n    }\n\n    /**\n     * Returns an {@code Integer} object holding the\n     * value of the specified {@code String}. The argument is\n     * interpreted as representing a signed decimal integer, exactly\n     * as if the argument were given to the {@link\n     * #parseInt(java.lang.String)} method. The result is an\n     * {@code Integer} object that represents the integer value\n     * specified by the string.\n     *\n     * \u003cp\u003eIn other words, this method returns an {@code Integer}\n     * object equal to the value of:\n     *\n     * \u003cblockquote\u003e\n     *  {@code new Integer(Integer.parseInt(s))}\n     * \u003c/blockquote\u003e\n     *\n     * @param      s   the string to be parsed.\n     * @return     an {@code Integer} object holding the value\n     *             represented by the string argument.\n     * @throws     NumberFormatException  if the string cannot be parsed\n     *             as an integer.\n     */\n    public static Integer valueOf(String s) throws NumberFormatException {\n        return Integer.valueOf(parseInt(s, 10));\n    }\n\n    /**\n     * Cache to support the object identity semantics of autoboxing for values between\n     * -128 and 127 (inclusive) as required by JLS.\n     *\n     * The cache is initialized on first usage.  The size of the cache\n     * may be controlled by the {@code -XX:AutoBoxCacheMax\u003d\u003csize\u003e} option.\n     * During VM initialization, java.lang.Integer.IntegerCache.high property\n     * may be set and saved in the private system properties in the\n     * jdk.internal.misc.VM class.\n     *\n     * WARNING: The cache is archived with CDS and reloaded from the shared\n     * archive at runtime. The archived cache (Integer[]) and Integer objects\n     * reside in the closed archive heap regions. Care should be taken when\n     * changing the implementation and the cache array should not be assigned\n     * with new Integer object(s) after initialization.\n     */\n\n    private static class IntegerCache {\n        static final int low \u003d -128;\n        static final int high;\n        static final Integer[] cache;\n        static Integer[] archivedCache;\n\n        static {\n            // high value may be configured by property\n            int h \u003d 127;\n            String integerCacheHighPropValue \u003d\n                VM.getSavedProperty(\"java.lang.Integer.IntegerCache.high\");\n            if (integerCacheHighPropValue !\u003d null) {\n                try {\n                    h \u003d Math.max(parseInt(integerCacheHighPropValue), 127);\n                    // Maximum array size is Integer.MAX_VALUE\n                    h \u003d Math.min(h, Integer.MAX_VALUE - (-low) -1);\n                } catch( NumberFormatException nfe) {\n                    // If the property cannot be parsed into an int, ignore it.\n                }\n            }\n            high \u003d h;\n\n            // Load IntegerCache.archivedCache from archive, if possible\n            CDS.initializeFromArchive(IntegerCache.class);\n            int size \u003d (high - low) + 1;\n\n            // Use the archived cache if it exists and is large enough\n            if (archivedCache \u003d\u003d null || size \u003e archivedCache.length) {\n                Integer[] c \u003d new Integer[size];\n                int j \u003d low;\n                for(int i \u003d 0; i \u003c c.length; i++) {\n                    c[i] \u003d new Integer(j++);\n                }\n                archivedCache \u003d c;\n            }\n            cache \u003d archivedCache;\n            // range [-128, 127] must be interned (JLS7 5.1.7)\n            assert IntegerCache.high \u003e\u003d 127;\n        }\n\n        private IntegerCache() {}\n    }\n\n    /**\n     * Returns an {@code Integer} instance representing the specified\n     * {@code int} value.  If a new {@code Integer} instance is not\n     * required, this method should generally be used in preference to\n     * the constructor {@link #Integer(int)}, as this method is likely\n     * to yield significantly better space and time performance by\n     * caching frequently requested values.\n     *\n     * This method will always cache values in the range -128 to 127,\n     * inclusive, and may cache other values outside of this range.\n     *\n     * @param  i an {@code int} value.\n     * @return an {@code Integer} instance representing {@code i}.\n     * @since  1.5\n     */\n    @IntrinsicCandidate\n    public static Integer valueOf(int i) {\n        if (i \u003e\u003d IntegerCache.low \u0026\u0026 i \u003c\u003d IntegerCache.high)\n            return IntegerCache.cache[i + (-IntegerCache.low)];\n        return new Integer(i);\n    }\n\n    /**\n     * The value of the {@code Integer}.\n     *\n     * @serial\n     */\n    private final int value;\n\n    /**\n     * Constructs a newly allocated {@code Integer} object that\n     * represents the specified {@code int} value.\n     *\n     * @param   value   the value to be represented by the\n     *                  {@code Integer} object.\n     *\n     * @deprecated\n     * It is rarely appropriate to use this constructor. The static factory\n     * {@link #valueOf(int)} is generally a better choice, as it is\n     * likely to yield significantly better space and time performance.\n     */\n    @Deprecated(since\u003d\"9\", forRemoval \u003d true)\n    public Integer(int value) {\n        this.value \u003d value;\n    }\n\n    /**\n     * Constructs a newly allocated {@code Integer} object that\n     * represents the {@code int} value indicated by the\n     * {@code String} parameter. The string is converted to an\n     * {@code int} value in exactly the manner used by the\n     * {@code parseInt} method for radix 10.\n     *\n     * @param   s   the {@code String} to be converted to an {@code Integer}.\n     * @throws      NumberFormatException if the {@code String} does not\n     *              contain a parsable integer.\n     *\n     * @deprecated\n     * It is rarely appropriate to use this constructor.\n     * Use {@link #parseInt(String)} to convert a string to a\n     * {@code int} primitive, or use {@link #valueOf(String)}\n     * to convert a string to an {@code Integer} object.\n     */\n    @Deprecated(since\u003d\"9\", forRemoval \u003d true)\n    public Integer(String s) throws NumberFormatException {\n        this.value \u003d parseInt(s, 10);\n    }\n\n    /**\n     * Returns the value of this {@code Integer} as a {@code byte}\n     * after a narrowing primitive conversion.\n     * @jls 5.1.3 Narrowing Primitive Conversion\n     */\n    public byte byteValue() {\n        return (byte)value;\n    }\n\n    /**\n     * Returns the value of this {@code Integer} as a {@code short}\n     * after a narrowing primitive conversion.\n     * @jls 5.1.3 Narrowing Primitive Conversion\n     */\n    public short shortValue() {\n        return (short)value;\n    }\n\n    /**\n     * Returns the value of this {@code Integer} as an\n     * {@code int}.\n     */\n    @IntrinsicCandidate\n    public int intValue() {\n        return value;\n    }\n\n    /**\n     * Returns the value of this {@code Integer} as a {@code long}\n     * after a widening primitive conversion.\n     * @jls 5.1.2 Widening Primitive Conversion\n     * @see Integer#toUnsignedLong(int)\n     */\n    public long longValue() {\n        return (long)value;\n    }\n\n    /**\n     * Returns the value of this {@code Integer} as a {@code float}\n     * after a widening primitive conversion.\n     * @jls 5.1.2 Widening Primitive Conversion\n     */\n    public float floatValue() {\n        return (float)value;\n    }\n\n    /**\n     * Returns the value of this {@code Integer} as a {@code double}\n     * after a widening primitive conversion.\n     * @jls 5.1.2 Widening Primitive Conversion\n     */\n    public double doubleValue() {\n        return (double)value;\n    }\n\n    /**\n     * Returns a {@code String} object representing this\n     * {@code Integer}\u0027s value. The value is converted to signed\n     * decimal representation and returned as a string, exactly as if\n     * the integer value were given as an argument to the {@link\n     * java.lang.Integer#toString(int)} method.\n     *\n     * @return  a string representation of the value of this object in\n     *          base\u0026nbsp;10.\n     */\n    public String toString() {\n        return toString(value);\n    }\n\n    /**\n     * Returns a hash code for this {@code Integer}.\n     *\n     * @return  a hash code value for this object, equal to the\n     *          primitive {@code int} value represented by this\n     *          {@code Integer} object.\n     */\n    @Override\n    public int hashCode() {\n        return Integer.hashCode(value);\n    }\n\n    /**\n     * Returns a hash code for an {@code int} value; compatible with\n     * {@code Integer.hashCode()}.\n     *\n     * @param value the value to hash\n     * @since 1.8\n     *\n     * @return a hash code value for an {@code int} value.\n     */\n    public static int hashCode(int value) {\n        return value;\n    }\n\n    /**\n     * Compares this object to the specified object.  The result is\n     * {@code true} if and only if the argument is not\n     * {@code null} and is an {@code Integer} object that\n     * contains the same {@code int} value as this object.\n     *\n     * @param   obj   the object to compare with.\n     * @return  {@code true} if the objects are the same;\n     *          {@code false} otherwise.\n     */\n    public boolean equals(Object obj) {\n        if (obj instanceof Integer) {\n            return value \u003d\u003d ((Integer)obj).intValue();\n        }\n        return false;\n    }\n\n    /**\n     * Determines the integer value of the system property with the\n     * specified name.\n     *\n     * \u003cp\u003eThe first argument is treated as the name of a system\n     * property.  System properties are accessible through the {@link\n     * java.lang.System#getProperty(java.lang.String)} method. The\n     * string value of this property is then interpreted as an integer\n     * value using the grammar supported by {@link Integer#decode decode} and\n     * an {@code Integer} object representing this value is returned.\n     *\n     * \u003cp\u003eIf there is no property with the specified name, if the\n     * specified name is empty or {@code null}, or if the property\n     * does not have the correct numeric format, then {@code null} is\n     * returned.\n     *\n     * \u003cp\u003eIn other words, this method returns an {@code Integer}\n     * object equal to the value of:\n     *\n     * \u003cblockquote\u003e\n     *  {@code getInteger(nm, null)}\n     * \u003c/blockquote\u003e\n     *\n     * @param   nm   property name.\n     * @return  the {@code Integer} value of the property.\n     * @throws  SecurityException for the same reasons as\n     *          {@link System#getProperty(String) System.getProperty}\n     * @see     java.lang.System#getProperty(java.lang.String)\n     * @see     java.lang.System#getProperty(java.lang.String, java.lang.String)\n     */\n    public static Integer getInteger(String nm) {\n        return getInteger(nm, null);\n    }\n\n    /**\n     * Determines the integer value of the system property with the\n     * specified name.\n     *\n     * \u003cp\u003eThe first argument is treated as the name of a system\n     * property.  System properties are accessible through the {@link\n     * java.lang.System#getProperty(java.lang.String)} method. The\n     * string value of this property is then interpreted as an integer\n     * value using the grammar supported by {@link Integer#decode decode} and\n     * an {@code Integer} object representing this value is returned.\n     *\n     * \u003cp\u003eThe second argument is the default value. An {@code Integer} object\n     * that represents the value of the second argument is returned if there\n     * is no property of the specified name, if the property does not have\n     * the correct numeric format, or if the specified name is empty or\n     * {@code null}.\n     *\n     * \u003cp\u003eIn other words, this method returns an {@code Integer} object\n     * equal to the value of:\n     *\n     * \u003cblockquote\u003e\n     *  {@code getInteger(nm, new Integer(val))}\n     * \u003c/blockquote\u003e\n     *\n     * but in practice it may be implemented in a manner such as:\n     *\n     * \u003cblockquote\u003e\u003cpre\u003e\n     * Integer result \u003d getInteger(nm, null);\n     * return (result \u003d\u003d null) ? new Integer(val) : result;\n     * \u003c/pre\u003e\u003c/blockquote\u003e\n     *\n     * to avoid the unnecessary allocation of an {@code Integer}\n     * object when the default value is not needed.\n     *\n     * @param   nm   property name.\n     * @param   val   default value.\n     * @return  the {@code Integer} value of the property.\n     * @throws  SecurityException for the same reasons as\n     *          {@link System#getProperty(String) System.getProperty}\n     * @see     java.lang.System#getProperty(java.lang.String)\n     * @see     java.lang.System#getProperty(java.lang.String, java.lang.String)\n     */\n    public static Integer getInteger(String nm, int val) {\n        Integer result \u003d getInteger(nm, null);\n        return (result \u003d\u003d null) ? Integer.valueOf(val) : result;\n    }\n\n    /**\n     * Returns the integer value of the system property with the\n     * specified name.  The first argument is treated as the name of a\n     * system property.  System properties are accessible through the\n     * {@link java.lang.System#getProperty(java.lang.String)} method.\n     * The string value of this property is then interpreted as an\n     * integer value, as per the {@link Integer#decode decode} method,\n     * and an {@code Integer} object representing this value is\n     * returned; in summary:\n     *\n     * \u003cul\u003e\u003cli\u003eIf the property value begins with the two ASCII characters\n     *         {@code 0x} or the ASCII character {@code #}, not\n     *      followed by a minus sign, then the rest of it is parsed as a\n     *      hexadecimal integer exactly as by the method\n     *      {@link #valueOf(java.lang.String, int)} with radix 16.\n     * \u003cli\u003eIf the property value begins with the ASCII character\n     *     {@code 0} followed by another character, it is parsed as an\n     *     octal integer exactly as by the method\n     *     {@link #valueOf(java.lang.String, int)} with radix 8.\n     * \u003cli\u003eOtherwise, the property value is parsed as a decimal integer\n     * exactly as by the method {@link #valueOf(java.lang.String, int)}\n     * with radix 10.\n     * \u003c/ul\u003e\n     *\n     * \u003cp\u003eThe second argument is the default value. The default value is\n     * returned if there is no property of the specified name, if the\n     * property does not have the correct numeric format, or if the\n     * specified name is empty or {@code null}.\n     *\n     * @param   nm   property name.\n     * @param   val   default value.\n     * @return  the {@code Integer} value of the property.\n     * @throws  SecurityException for the same reasons as\n     *          {@link System#getProperty(String) System.getProperty}\n     * @see     System#getProperty(java.lang.String)\n     * @see     System#getProperty(java.lang.String, java.lang.String)\n     */\n    public static Integer getInteger(String nm, Integer val) {\n        String v \u003d null;\n        try {\n            v \u003d System.getProperty(nm);\n        } catch (IllegalArgumentException | NullPointerException e) {\n        }\n        if (v !\u003d null) {\n            try {\n                return Integer.decode(v);\n            } catch (NumberFormatException e) {\n            }\n        }\n        return val;\n    }\n\n    /**\n     * Decodes a {@code String} into an {@code Integer}.\n     * Accepts decimal, hexadecimal, and octal numbers given\n     * by the following grammar:\n     *\n     * \u003cblockquote\u003e\n     * \u003cdl\u003e\n     * \u003cdt\u003e\u003ci\u003eDecodableString:\u003c/i\u003e\n     * \u003cdd\u003e\u003ci\u003eSign\u003csub\u003eopt\u003c/sub\u003e DecimalNumeral\u003c/i\u003e\n     * \u003cdd\u003e\u003ci\u003eSign\u003csub\u003eopt\u003c/sub\u003e\u003c/i\u003e {@code 0x} \u003ci\u003eHexDigits\u003c/i\u003e\n     * \u003cdd\u003e\u003ci\u003eSign\u003csub\u003eopt\u003c/sub\u003e\u003c/i\u003e {@code 0X} \u003ci\u003eHexDigits\u003c/i\u003e\n     * \u003cdd\u003e\u003ci\u003eSign\u003csub\u003eopt\u003c/sub\u003e\u003c/i\u003e {@code #} \u003ci\u003eHexDigits\u003c/i\u003e\n     * \u003cdd\u003e\u003ci\u003eSign\u003csub\u003eopt\u003c/sub\u003e\u003c/i\u003e {@code 0} \u003ci\u003eOctalDigits\u003c/i\u003e\n     *\n     * \u003cdt\u003e\u003ci\u003eSign:\u003c/i\u003e\n     * \u003cdd\u003e{@code -}\n     * \u003cdd\u003e{@code +}\n     * \u003c/dl\u003e\n     * \u003c/blockquote\u003e\n     *\n     * \u003ci\u003eDecimalNumeral\u003c/i\u003e, \u003ci\u003eHexDigits\u003c/i\u003e, and \u003ci\u003eOctalDigits\u003c/i\u003e\n     * are as defined in section {@jls 3.10.1} of\n     * \u003ccite\u003eThe Java Language Specification\u003c/cite\u003e,\n     * except that underscores are not accepted between digits.\n     *\n     * \u003cp\u003eThe sequence of characters following an optional\n     * sign and/or radix specifier (\"{@code 0x}\", \"{@code 0X}\",\n     * \"{@code #}\", or leading zero) is parsed as by the {@code\n     * Integer.parseInt} method with the indicated radix (10, 16, or\n     * 8).  This sequence of characters must represent a positive\n     * value or a {@link NumberFormatException} will be thrown.  The\n     * result is negated if first character of the specified {@code\n     * String} is the minus sign.  No whitespace characters are\n     * permitted in the {@code String}.\n     *\n     * @param     nm the {@code String} to decode.\n     * @return    an {@code Integer} object holding the {@code int}\n     *             value represented by {@code nm}\n     * @throws    NumberFormatException  if the {@code String} does not\n     *            contain a parsable integer.\n     * @see java.lang.Integer#parseInt(java.lang.String, int)\n     */\n    public static Integer decode(String nm) throws NumberFormatException {\n        int radix \u003d 10;\n        int index \u003d 0;\n        boolean negative \u003d false;\n        Integer result;\n\n        if (nm.isEmpty())\n            throw new NumberFormatException(\"Zero length string\");\n        char firstChar \u003d nm.charAt(0);\n        // Handle sign, if present\n        if (firstChar \u003d\u003d \u0027-\u0027) {\n            negative \u003d true;\n            index++;\n        } else if (firstChar \u003d\u003d \u0027+\u0027)\n            index++;\n\n        // Handle radix specifier, if present\n        if (nm.startsWith(\"0x\", index) || nm.startsWith(\"0X\", index)) {\n            index +\u003d 2;\n            radix \u003d 16;\n        }\n        else if (nm.startsWith(\"#\", index)) {\n            index ++;\n            radix \u003d 16;\n        }\n        else if (nm.startsWith(\"0\", index) \u0026\u0026 nm.length() \u003e 1 + index) {\n            index ++;\n            radix \u003d 8;\n        }\n\n        if (nm.startsWith(\"-\", index) || nm.startsWith(\"+\", index))\n            throw new NumberFormatException(\"Sign character in wrong position\");\n\n        try {\n            result \u003d Integer.valueOf(nm.substring(index), radix);\n            result \u003d negative ? Integer.valueOf(-result.intValue()) : result;\n        } catch (NumberFormatException e) {\n            // If number is Integer.MIN_VALUE, we\u0027ll end up here. The next line\n            // handles this case, and causes any genuine format error to be\n            // rethrown.\n            String constant \u003d negative ? (\"-\" + nm.substring(index))\n                                       : nm.substring(index);\n            result \u003d Integer.valueOf(constant, radix);\n        }\n        return result;\n    }\n\n    /**\n     * Compares two {@code Integer} objects numerically.\n     *\n     * @param   anotherInteger   the {@code Integer} to be compared.\n     * @return  the value {@code 0} if this {@code Integer} is\n     *          equal to the argument {@code Integer}; a value less than\n     *          {@code 0} if this {@code Integer} is numerically less\n     *          than the argument {@code Integer}; and a value greater\n     *          than {@code 0} if this {@code Integer} is numerically\n     *           greater than the argument {@code Integer} (signed\n     *           comparison).\n     * @since   1.2\n     */\n    public int compareTo(Integer anotherInteger) {\n        return compare(this.value, anotherInteger.value);\n    }\n\n    /**\n     * Compares two {@code int} values numerically.\n     * The value returned is identical to what would be returned by:\n     * \u003cpre\u003e\n     *    Integer.valueOf(x).compareTo(Integer.valueOf(y))\n     * \u003c/pre\u003e\n     *\n     * @param  x the first {@code int} to compare\n     * @param  y the second {@code int} to compare\n     * @return the value {@code 0} if {@code x \u003d\u003d y};\n     *         a value less than {@code 0} if {@code x \u003c y}; and\n     *         a value greater than {@code 0} if {@code x \u003e y}\n     * @since 1.7\n     */\n    public static int compare(int x, int y) {\n        return (x \u003c y) ? -1 : ((x \u003d\u003d y) ? 0 : 1);\n    }\n\n    /**\n     * Compares two {@code int} values numerically treating the values\n     * as unsigned.\n     *\n     * @param  x the first {@code int} to compare\n     * @param  y the second {@code int} to compare\n     * @return the value {@code 0} if {@code x \u003d\u003d y}; a value less\n     *         than {@code 0} if {@code x \u003c y} as unsigned values; and\n     *         a value greater than {@code 0} if {@code x \u003e y} as\n     *         unsigned values\n     * @since 1.8\n     */\n    public static int compareUnsigned(int x, int y) {\n        return compare(x + MIN_VALUE, y + MIN_VALUE);\n    }\n\n    /**\n     * Converts the argument to a {@code long} by an unsigned\n     * conversion.  In an unsigned conversion to a {@code long}, the\n     * high-order 32 bits of the {@code long} are zero and the\n     * low-order 32 bits are equal to the bits of the integer\n     * argument.\n     *\n     * Consequently, zero and positive {@code int} values are mapped\n     * to a numerically equal {@code long} value and negative {@code\n     * int} values are mapped to a {@code long} value equal to the\n     * input plus 2\u003csup\u003e32\u003c/sup\u003e.\n     *\n     * @param  x the value to convert to an unsigned {@code long}\n     * @return the argument converted to {@code long} by an unsigned\n     *         conversion\n     * @since 1.8\n     */\n    public static long toUnsignedLong(int x) {\n        return ((long) x) \u0026 0xffffffffL;\n    }\n\n    /**\n     * Returns the unsigned quotient of dividing the first argument by\n     * the second where each argument and the result is interpreted as\n     * an unsigned value.\n     *\n     * \u003cp\u003eNote that in two\u0027s complement arithmetic, the three other\n     * basic arithmetic operations of add, subtract, and multiply are\n     * bit-wise identical if the two operands are regarded as both\n     * being signed or both being unsigned.  Therefore separate {@code\n     * addUnsigned}, etc. methods are not provided.\n     *\n     * @param dividend the value to be divided\n     * @param divisor the value doing the dividing\n     * @return the unsigned quotient of the first argument divided by\n     * the second argument\n     * @see #remainderUnsigned\n     * @since 1.8\n     */\n    public static int divideUnsigned(int dividend, int divisor) {\n        // In lieu of tricky code, for now just use long arithmetic.\n        return (int)(toUnsignedLong(dividend) / toUnsignedLong(divisor));\n    }\n\n    /**\n     * Returns the unsigned remainder from dividing the first argument\n     * by the second where each argument and the result is interpreted\n     * as an unsigned value.\n     *\n     * @param dividend the value to be divided\n     * @param divisor the value doing the dividing\n     * @return the unsigned remainder of the first argument divided by\n     * the second argument\n     * @see #divideUnsigned\n     * @since 1.8\n     */\n    public static int remainderUnsigned(int dividend, int divisor) {\n        // In lieu of tricky code, for now just use long arithmetic.\n        return (int)(toUnsignedLong(dividend) % toUnsignedLong(divisor));\n    }\n\n\n    // Bit twiddling\n\n    /**\n     * The number of bits used to represent an {@code int} value in two\u0027s\n     * complement binary form.\n     *\n     * @since 1.5\n     */\n    @Native public static final int SIZE \u003d 32;\n\n    /**\n     * The number of bytes used to represent an {@code int} value in two\u0027s\n     * complement binary form.\n     *\n     * @since 1.8\n     */\n    public static final int BYTES \u003d SIZE / Byte.SIZE;\n\n    /**\n     * Returns an {@code int} value with at most a single one-bit, in the\n     * position of the highest-order (\"leftmost\") one-bit in the specified\n     * {@code int} value.  Returns zero if the specified value has no\n     * one-bits in its two\u0027s complement binary representation, that is, if it\n     * is equal to zero.\n     *\n     * @param i the value whose highest one bit is to be computed\n     * @return an {@code int} value with a single one-bit, in the position\n     *     of the highest-order one-bit in the specified value, or zero if\n     *     the specified value is itself equal to zero.\n     * @since 1.5\n     */\n    public static int highestOneBit(int i) {\n        return i \u0026 (MIN_VALUE \u003e\u003e\u003e numberOfLeadingZeros(i));\n    }\n\n    /**\n     * Returns an {@code int} value with at most a single one-bit, in the\n     * position of the lowest-order (\"rightmost\") one-bit in the specified\n     * {@code int} value.  Returns zero if the specified value has no\n     * one-bits in its two\u0027s complement binary representation, that is, if it\n     * is equal to zero.\n     *\n     * @param i the value whose lowest one bit is to be computed\n     * @return an {@code int} value with a single one-bit, in the position\n     *     of the lowest-order one-bit in the specified value, or zero if\n     *     the specified value is itself equal to zero.\n     * @since 1.5\n     */\n    public static int lowestOneBit(int i) {\n        // HD, Section 2-1\n        return i \u0026 -i;\n    }\n\n    /**\n     * Returns the number of zero bits preceding the highest-order\n     * (\"leftmost\") one-bit in the two\u0027s complement binary representation\n     * of the specified {@code int} value.  Returns 32 if the\n     * specified value has no one-bits in its two\u0027s complement representation,\n     * in other words if it is equal to zero.\n     *\n     * \u003cp\u003eNote that this method is closely related to the logarithm base 2.\n     * For all positive {@code int} values x:\n     * \u003cul\u003e\n     * \u003cli\u003efloor(log\u003csub\u003e2\u003c/sub\u003e(x)) \u003d {@code 31 - numberOfLeadingZeros(x)}\n     * \u003cli\u003eceil(log\u003csub\u003e2\u003c/sub\u003e(x)) \u003d {@code 32 - numberOfLeadingZeros(x - 1)}\n     * \u003c/ul\u003e\n     *\n     * @param i the value whose number of leading zeros is to be computed\n     * @return the number of zero bits preceding the highest-order\n     *     (\"leftmost\") one-bit in the two\u0027s complement binary representation\n     *     of the specified {@code int} value, or 32 if the value\n     *     is equal to zero.\n     * @since 1.5\n     */\n    @IntrinsicCandidate\n    public static int numberOfLeadingZeros(int i) {\n        // HD, Count leading 0\u0027s\n        if (i \u003c\u003d 0)\n            return i \u003d\u003d 0 ? 32 : 0;\n        int n \u003d 31;\n        if (i \u003e\u003d 1 \u003c\u003c 16) { n -\u003d 16; i \u003e\u003e\u003e\u003d 16; }\n        if (i \u003e\u003d 1 \u003c\u003c  8) { n -\u003d  8; i \u003e\u003e\u003e\u003d  8; }\n        if (i \u003e\u003d 1 \u003c\u003c  4) { n -\u003d  4; i \u003e\u003e\u003e\u003d  4; }\n        if (i \u003e\u003d 1 \u003c\u003c  2) { n -\u003d  2; i \u003e\u003e\u003e\u003d  2; }\n        return n - (i \u003e\u003e\u003e 1);\n    }\n\n    /**\n     * Returns the number of zero bits following the lowest-order (\"rightmost\")\n     * one-bit in the two\u0027s complement binary representation of the specified\n     * {@code int} value.  Returns 32 if the specified value has no\n     * one-bits in its two\u0027s complement representation, in other words if it is\n     * equal to zero.\n     *\n     * @param i the value whose number of trailing zeros is to be computed\n     * @return the number of zero bits following the lowest-order (\"rightmost\")\n     *     one-bit in the two\u0027s complement binary representation of the\n     *     specified {@code int} value, or 32 if the value is equal\n     *     to zero.\n     * @since 1.5\n     */\n    @IntrinsicCandidate\n    public static int numberOfTrailingZeros(int i) {\n        // HD, Count trailing 0\u0027s\n        i \u003d ~i \u0026 (i - 1);\n        if (i \u003c\u003d 0) return i \u0026 32;\n        int n \u003d 1;\n        if (i \u003e 1 \u003c\u003c 16) { n +\u003d 16; i \u003e\u003e\u003e\u003d 16; }\n        if (i \u003e 1 \u003c\u003c  8) { n +\u003d  8; i \u003e\u003e\u003e\u003d  8; }\n        if (i \u003e 1 \u003c\u003c  4) { n +\u003d  4; i \u003e\u003e\u003e\u003d  4; }\n        if (i \u003e 1 \u003c\u003c  2) { n +\u003d  2; i \u003e\u003e\u003e\u003d  2; }\n        return n + (i \u003e\u003e\u003e 1);\n    }\n\n    /**\n     * Returns the number of one-bits in the two\u0027s complement binary\n     * representation of the specified {@code int} value.  This function is\n     * sometimes referred to as the \u003ci\u003epopulation count\u003c/i\u003e.\n     *\n     * @param i the value whose bits are to be counted\n     * @return the number of one-bits in the two\u0027s complement binary\n     *     representation of the specified {@code int} value.\n     * @since 1.5\n     */\n    @IntrinsicCandidate\n    public static int bitCount(int i) {\n        // HD, Figure 5-2\n        i \u003d i - ((i \u003e\u003e\u003e 1) \u0026 0x55555555);\n        i \u003d (i \u0026 0x33333333) + ((i \u003e\u003e\u003e 2) \u0026 0x33333333);\n        i \u003d (i + (i \u003e\u003e\u003e 4)) \u0026 0x0f0f0f0f;\n        i \u003d i + (i \u003e\u003e\u003e 8);\n        i \u003d i + (i \u003e\u003e\u003e 16);\n        return i \u0026 0x3f;\n    }\n\n    /**\n     * Returns the value obtained by rotating the two\u0027s complement binary\n     * representation of the specified {@code int} value left by the\n     * specified number of bits.  (Bits shifted out of the left hand, or\n     * high-order, side reenter on the right, or low-order.)\n     *\n     * \u003cp\u003eNote that left rotation with a negative distance is equivalent to\n     * right rotation: {@code rotateLeft(val, -distance) \u003d\u003d rotateRight(val,\n     * distance)}.  Note also that rotation by any multiple of 32 is a\n     * no-op, so all but the last five bits of the rotation distance can be\n     * ignored, even if the distance is negative: {@code rotateLeft(val,\n     * distance) \u003d\u003d rotateLeft(val, distance \u0026 0x1F)}.\n     *\n     * @param i the value whose bits are to be rotated left\n     * @param distance the number of bit positions to rotate left\n     * @return the value obtained by rotating the two\u0027s complement binary\n     *     representation of the specified {@code int} value left by the\n     *     specified number of bits.\n     * @since 1.5\n     */\n    public static int rotateLeft(int i, int distance) {\n        return (i \u003c\u003c distance) | (i \u003e\u003e\u003e -distance);\n    }\n\n    /**\n     * Returns the value obtained by rotating the two\u0027s complement binary\n     * representation of the specified {@code int} value right by the\n     * specified number of bits.  (Bits shifted out of the right hand, or\n     * low-order, side reenter on the left, or high-order.)\n     *\n     * \u003cp\u003eNote that right rotation with a negative distance is equivalent to\n     * left rotation: {@code rotateRight(val, -distance) \u003d\u003d rotateLeft(val,\n     * distance)}.  Note also that rotation by any multiple of 32 is a\n     * no-op, so all but the last five bits of the rotation distance can be\n     * ignored, even if the distance is negative: {@code rotateRight(val,\n     * distance) \u003d\u003d rotateRight(val, distance \u0026 0x1F)}.\n     *\n     * @param i the value whose bits are to be rotated right\n     * @param distance the number of bit positions to rotate right\n     * @return the value obtained by rotating the two\u0027s complement binary\n     *     representation of the specified {@code int} value right by the\n     *     specified number of bits.\n     * @since 1.5\n     */\n    public static int rotateRight(int i, int distance) {\n        return (i \u003e\u003e\u003e distance) | (i \u003c\u003c -distance);\n    }\n\n    /**\n     * Returns the value obtained by reversing the order of the bits in the\n     * two\u0027s complement binary representation of the specified {@code int}\n     * value.\n     *\n     * @param i the value to be reversed\n     * @return the value obtained by reversing order of the bits in the\n     *     specified {@code int} value.\n     * @since 1.5\n     */\n    public static int reverse(int i) {\n        // HD, Figure 7-1\n        i \u003d (i \u0026 0x55555555) \u003c\u003c 1 | (i \u003e\u003e\u003e 1) \u0026 0x55555555;\n        i \u003d (i \u0026 0x33333333) \u003c\u003c 2 | (i \u003e\u003e\u003e 2) \u0026 0x33333333;\n        i \u003d (i \u0026 0x0f0f0f0f) \u003c\u003c 4 | (i \u003e\u003e\u003e 4) \u0026 0x0f0f0f0f;\n\n        return reverseBytes(i);\n    }\n\n    /**\n     * Returns the signum function of the specified {@code int} value.  (The\n     * return value is -1 if the specified value is negative; 0 if the\n     * specified value is zero; and 1 if the specified value is positive.)\n     *\n     * @param i the value whose signum is to be computed\n     * @return the signum function of the specified {@code int} value.\n     * @since 1.5\n     */\n    public static int signum(int i) {\n        // HD, Section 2-7\n        return (i \u003e\u003e 31) | (-i \u003e\u003e\u003e 31);\n    }\n\n    /**\n     * Returns the value obtained by reversing the order of the bytes in the\n     * two\u0027s complement representation of the specified {@code int} value.\n     *\n     * @param i the value whose bytes are to be reversed\n     * @return the value obtained by reversing the bytes in the specified\n     *     {@code int} value.\n     * @since 1.5\n     */\n    @IntrinsicCandidate\n    public static int reverseBytes(int i) {\n        return (i \u003c\u003c 24)            |\n               ((i \u0026 0xff00) \u003c\u003c 8)  |\n               ((i \u003e\u003e\u003e 8) \u0026 0xff00) |\n               (i \u003e\u003e\u003e 24);\n    }\n\n    /**\n     * Adds two integers together as per the + operator.\n     *\n     * @param a the first operand\n     * @param b the second operand\n     * @return the sum of {@code a} and {@code b}\n     * @see java.util.function.BinaryOperator\n     * @since 1.8\n     */\n    public static int sum(int a, int b) {\n        return a + b;\n    }\n\n    /**\n     * Returns the greater of two {@code int} values\n     * as if by calling {@link Math#max(int, int) Math.max}.\n     *\n     * @param a the first operand\n     * @param b the second operand\n     * @return the greater of {@code a} and {@code b}\n     * @see java.util.function.BinaryOperator\n     * @since 1.8\n     */\n    public static int max(int a, int b) {\n        return Math.max(a, b);\n    }\n\n    /**\n     * Returns the smaller of two {@code int} values\n     * as if by calling {@link Math#min(int, int) Math.min}.\n     *\n     * @param a the first operand\n     * @param b the second operand\n     * @return the smaller of {@code a} and {@code b}\n     * @see java.util.function.BinaryOperator\n     * @since 1.8\n     */\n    public static int min(int a, int b) {\n        return Math.min(a, b);\n    }\n\n    /**\n     * Returns an {@link Optional} containing the nominal descriptor for this\n     * instance, which is the instance itself.\n     *\n     * @return an {@link Optional} describing the {@linkplain Integer} instance\n     * @since 12\n     */\n    @Override\n    public Optional\u003cInteger\u003e describeConstable() {\n        return Optional.of(this);\n    }\n\n    /**\n     * Resolves this instance as a {@link ConstantDesc}, the result of which is\n     * the instance itself.\n     *\n     * @param lookup ignored\n     * @return the {@linkplain Integer} instance\n     * @since 12\n     */\n    @Override\n    public Integer resolveConstantDesc(MethodHandles.Lookup lookup) {\n        return this;\n    }\n\n    /** use serialVersionUID from JDK 1.0.2 for interoperability */\n    @java.io.Serial\n    @Native private static final long serialVersionUID \u003d 1360826667806852920L;\n}\n"
    }
  }
}
java.lang.IllegalArgumentException: Illegal character in opaque part at index 188: jar:file:///C:/Users/Vinicius/AppData/Local/Coursier/cache/arc/https/github.com/adoptium/temurin17-binaries/releases/download/jdk-17%2B35/OpenJDK17-jdk_x64_windows_hotspot_17_35.zip/jdk-17 35/lib/src.zip!/java.base/java/lang/Integer.java
	at java.base/java.net.URI.create(URI.java:906)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:178)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.$anonfun$toAbsolutePath$3(MtagsEnrichments.scala:175)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.withTryDecode$1(MtagsEnrichments.scala:153)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:175)
	at scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:756)
	at scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:753)
	at scala.meta.internal.metals.WorkspaceLspService.didOpen(WorkspaceLspService.scala:388)
	at scala.meta.metals.lsp.DelegatingScalaService.didOpen(DelegatingScalaService.scala:39)
	at jdk.internal.reflect.GeneratedMethodAccessor23.invoke(Unknown Source)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:568)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$recursiveFindRpcMethods$0(GenericEndpoint.java:65)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.notify(GenericEndpoint.java:160)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleNotification(RemoteEndpoint.java:231)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:198)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:185)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:97)
	at org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:114)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:539)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.base/java.lang.Thread.run(Thread.java:833)
Caused by: java.net.URISyntaxException: Illegal character in opaque part at index 188: jar:file:///C:/Users/Vinicius/AppData/Local/Coursier/cache/arc/https/github.com/adoptium/temurin17-binaries/releases/download/jdk-17%2B35/OpenJDK17-jdk_x64_windows_hotspot_17_35.zip/jdk-17 35/lib/src.zip!/java.base/java/lang/Integer.java
	at java.base/java.net.URI$Parser.fail(URI.java:2974)
	at java.base/java.net.URI$Parser.checkChars(URI.java:3145)
	at java.base/java.net.URI$Parser.parse(URI.java:3181)
	at java.base/java.net.URI.<init>(URI.java:623)
	at java.base/java.net.URI.create(URI.java:904)
	... 23 more

jul. 19, 2024 1:33:57 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleNotification
ADVERTÊNCIA: Notification threw an exception: {
  "jsonrpc": "2.0",
  "method": "textDocument/didClose",
  "params": {
    "textDocument": {
      "uri": "jar:file%3A///C%3A/Users/Vinicius/AppData/Local/Coursier/cache/arc/https/github.com/adoptium/temurin17-binaries/releases/download/jdk-17%25252B35/OpenJDK17-jdk_x64_windows_hotspot_17_35.zip/jdk-17%2B35/lib/src.zip%21/java.base/java/lang/Integer.java"
    }
  }
}
java.lang.IllegalArgumentException: Illegal character in opaque part at index 188: jar:file:///C:/Users/Vinicius/AppData/Local/Coursier/cache/arc/https/github.com/adoptium/temurin17-binaries/releases/download/jdk-17%2B35/OpenJDK17-jdk_x64_windows_hotspot_17_35.zip/jdk-17 35/lib/src.zip!/java.base/java/lang/Integer.java
	at java.base/java.net.URI.create(URI.java:906)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:178)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.$anonfun$toAbsolutePath$3(MtagsEnrichments.scala:175)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.withTryDecode$1(MtagsEnrichments.scala:153)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:175)
	at scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:756)
	at scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:753)
	at scala.meta.internal.metals.WorkspaceLspService.didClose(WorkspaceLspService.scala:407)
	at scala.meta.metals.lsp.DelegatingScalaService.didClose(DelegatingScalaService.scala:53)
	at jdk.internal.reflect.GeneratedMethodAccessor26.invoke(Unknown Source)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:568)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$recursiveFindRpcMethods$0(GenericEndpoint.java:65)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.notify(GenericEndpoint.java:160)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleNotification(RemoteEndpoint.java:231)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:198)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:185)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:97)
	at org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:114)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:539)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.base/java.lang.Thread.run(Thread.java:833)
Caused by: java.net.URISyntaxException: Illegal character in opaque part at index 188: jar:file:///C:/Users/Vinicius/AppData/Local/Coursier/cache/arc/https/github.com/adoptium/temurin17-binaries/releases/download/jdk-17%2B35/OpenJDK17-jdk_x64_windows_hotspot_17_35.zip/jdk-17 35/lib/src.zip!/java.base/java/lang/Integer.java
	at java.base/java.net.URI$Parser.fail(URI.java:2974)
	at java.base/java.net.URI$Parser.checkChars(URI.java:3145)
	at java.base/java.net.URI$Parser.parse(URI.java:3181)
	at java.base/java.net.URI.<init>(URI.java:623)
	at java.base/java.net.URI.create(URI.java:904)
	... 23 more

2024.07.19 13:33:58 WARN  Using indexes to guess the definition of State
2024.07.19 13:34:00 INFO  Can not organize imports if file has error
2024.07.19 13:34:00 INFO  compiling root (2 scala sources)
2024.07.19 13:34:00 INFO  time: compiled root in 0.2s
2024.07.19 13:38:04 INFO  compiling root (2 scala sources)
2024.07.19 13:38:04 INFO  time: compiled root in 0.2s
2024.07.19 13:39:17 INFO  compiling root (2 scala sources)
2024.07.19 13:39:17 INFO  time: compiled root in 0.26s
jul. 19, 2024 1:39:36 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleNotification
ADVERTÊNCIA: Notification threw an exception: {
  "jsonrpc": "2.0",
  "method": "textDocument/didOpen",
  "params": {
    "textDocument": {
      "uri": "jar:file%3A///C%3A/Users/Vinicius/AppData/Local/Coursier/cache/arc/https/github.com/adoptium/temurin17-binaries/releases/download/jdk-17%25252B35/OpenJDK17-jdk_x64_windows_hotspot_17_35.zip/jdk-17%2B35/lib/src.zip%21/java.base/java/lang/Integer.java",
      "languageId": "java",
      "version": 1,
      "text": "/*\n * Copyright (c) 1994, 2021, Oracle and/or its affiliates. All rights reserved.\n * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n *\n * This code is free software; you can redistribute it and/or modify it\n * under the terms of the GNU General Public License version 2 only, as\n * published by the Free Software Foundation.  Oracle designates this\n * particular file as subject to the \"Classpath\" exception as provided\n * by Oracle in the LICENSE file that accompanied this code.\n *\n * This code is distributed in the hope that it will be useful, but WITHOUT\n * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n * version 2 for more details (a copy is included in the LICENSE file that\n * accompanied this code).\n *\n * You should have received a copy of the GNU General Public License version\n * 2 along with this work; if not, write to the Free Software Foundation,\n * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n *\n * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n * or visit www.oracle.com if you need additional information or have any\n * questions.\n */\n\npackage java.lang;\n\nimport java.lang.annotation.Native;\nimport java.lang.invoke.MethodHandles;\nimport java.lang.constant.Constable;\nimport java.lang.constant.ConstantDesc;\nimport java.util.Objects;\nimport java.util.Optional;\n\nimport jdk.internal.misc.CDS;\nimport jdk.internal.misc.VM;\nimport jdk.internal.vm.annotation.IntrinsicCandidate;\n\nimport static java.lang.String.COMPACT_STRINGS;\nimport static java.lang.String.LATIN1;\nimport static java.lang.String.UTF16;\n\n/**\n * The {@code Integer} class wraps a value of the primitive type\n * {@code int} in an object. An object of type {@code Integer}\n * contains a single field whose type is {@code int}.\n *\n * \u003cp\u003eIn addition, this class provides several methods for converting\n * an {@code int} to a {@code String} and a {@code String} to an\n * {@code int}, as well as other constants and methods useful when\n * dealing with an {@code int}.\n *\n * \u003cp\u003eThis is a \u003ca href\u003d\"{@docRoot}/java.base/java/lang/doc-files/ValueBased.html\"\u003evalue-based\u003c/a\u003e\n * class; programmers should treat instances that are\n * {@linkplain #equals(Object) equal} as interchangeable and should not\n * use instances for synchronization, or unpredictable behavior may\n * occur. For example, in a future release, synchronization may fail.\n *\n * \u003cp\u003eImplementation note: The implementations of the \"bit twiddling\"\n * methods (such as {@link #highestOneBit(int) highestOneBit} and\n * {@link #numberOfTrailingZeros(int) numberOfTrailingZeros}) are\n * based on material from Henry S. Warren, Jr.\u0027s \u003ci\u003eHacker\u0027s\n * Delight\u003c/i\u003e, (Addison Wesley, 2002).\n *\n * @author  Lee Boynton\n * @author  Arthur van Hoff\n * @author  Josh Bloch\n * @author  Joseph D. Darcy\n * @since 1.0\n */\n@jdk.internal.ValueBased\npublic final class Integer extends Number\n        implements Comparable\u003cInteger\u003e, Constable, ConstantDesc {\n    /**\n     * A constant holding the minimum value an {@code int} can\n     * have, -2\u003csup\u003e31\u003c/sup\u003e.\n     */\n    @Native public static final int   MIN_VALUE \u003d 0x80000000;\n\n    /**\n     * A constant holding the maximum value an {@code int} can\n     * have, 2\u003csup\u003e31\u003c/sup\u003e-1.\n     */\n    @Native public static final int   MAX_VALUE \u003d 0x7fffffff;\n\n    /**\n     * The {@code Class} instance representing the primitive type\n     * {@code int}.\n     *\n     * @since   1.1\n     */\n    @SuppressWarnings(\"unchecked\")\n    public static final Class\u003cInteger\u003e  TYPE \u003d (Class\u003cInteger\u003e) Class.getPrimitiveClass(\"int\");\n\n    /**\n     * All possible chars for representing a number as a String\n     */\n    static final char[] digits \u003d {\n        \u00270\u0027 , \u00271\u0027 , \u00272\u0027 , \u00273\u0027 , \u00274\u0027 , \u00275\u0027 ,\n        \u00276\u0027 , \u00277\u0027 , \u00278\u0027 , \u00279\u0027 , \u0027a\u0027 , \u0027b\u0027 ,\n        \u0027c\u0027 , \u0027d\u0027 , \u0027e\u0027 , \u0027f\u0027 , \u0027g\u0027 , \u0027h\u0027 ,\n        \u0027i\u0027 , \u0027j\u0027 , \u0027k\u0027 , \u0027l\u0027 , \u0027m\u0027 , \u0027n\u0027 ,\n        \u0027o\u0027 , \u0027p\u0027 , \u0027q\u0027 , \u0027r\u0027 , \u0027s\u0027 , \u0027t\u0027 ,\n        \u0027u\u0027 , \u0027v\u0027 , \u0027w\u0027 , \u0027x\u0027 , \u0027y\u0027 , \u0027z\u0027\n    };\n\n    /**\n     * Returns a string representation of the first argument in the\n     * radix specified by the second argument.\n     *\n     * \u003cp\u003eIf the radix is smaller than {@code Character.MIN_RADIX}\n     * or larger than {@code Character.MAX_RADIX}, then the radix\n     * {@code 10} is used instead.\n     *\n     * \u003cp\u003eIf the first argument is negative, the first element of the\n     * result is the ASCII minus character {@code \u0027-\u0027}\n     * ({@code \u0027\\u005Cu002D\u0027}). If the first argument is not\n     * negative, no sign character appears in the result.\n     *\n     * \u003cp\u003eThe remaining characters of the result represent the magnitude\n     * of the first argument. If the magnitude is zero, it is\n     * represented by a single zero character {@code \u00270\u0027}\n     * ({@code \u0027\\u005Cu0030\u0027}); otherwise, the first character of\n     * the representation of the magnitude will not be the zero\n     * character.  The following ASCII characters are used as digits:\n     *\n     * \u003cblockquote\u003e\n     *   {@code 0123456789abcdefghijklmnopqrstuvwxyz}\n     * \u003c/blockquote\u003e\n     *\n     * These are {@code \u0027\\u005Cu0030\u0027} through\n     * {@code \u0027\\u005Cu0039\u0027} and {@code \u0027\\u005Cu0061\u0027} through\n     * {@code \u0027\\u005Cu007A\u0027}. If {@code radix} is\n     * \u003cvar\u003eN\u003c/var\u003e, then the first \u003cvar\u003eN\u003c/var\u003e of these characters\n     * are used as radix-\u003cvar\u003eN\u003c/var\u003e digits in the order shown. Thus,\n     * the digits for hexadecimal (radix 16) are\n     * {@code 0123456789abcdef}. If uppercase letters are\n     * desired, the {@link java.lang.String#toUpperCase()} method may\n     * be called on the result:\n     *\n     * \u003cblockquote\u003e\n     *  {@code Integer.toString(n, 16).toUpperCase()}\n     * \u003c/blockquote\u003e\n     *\n     * @param   i       an integer to be converted to a string.\n     * @param   radix   the radix to use in the string representation.\n     * @return  a string representation of the argument in the specified radix.\n     * @see     java.lang.Character#MAX_RADIX\n     * @see     java.lang.Character#MIN_RADIX\n     */\n    public static String toString(int i, int radix) {\n        if (radix \u003c Character.MIN_RADIX || radix \u003e Character.MAX_RADIX)\n            radix \u003d 10;\n\n        /* Use the faster version */\n        if (radix \u003d\u003d 10) {\n            return toString(i);\n        }\n\n        if (COMPACT_STRINGS) {\n            byte[] buf \u003d new byte[33];\n            boolean negative \u003d (i \u003c 0);\n            int charPos \u003d 32;\n\n            if (!negative) {\n                i \u003d -i;\n            }\n\n            while (i \u003c\u003d -radix) {\n                buf[charPos--] \u003d (byte)digits[-(i % radix)];\n                i \u003d i / radix;\n            }\n            buf[charPos] \u003d (byte)digits[-i];\n\n            if (negative) {\n                buf[--charPos] \u003d \u0027-\u0027;\n            }\n\n            return StringLatin1.newString(buf, charPos, (33 - charPos));\n        }\n        return toStringUTF16(i, radix);\n    }\n\n    private static String toStringUTF16(int i, int radix) {\n        byte[] buf \u003d new byte[33 * 2];\n        boolean negative \u003d (i \u003c 0);\n        int charPos \u003d 32;\n        if (!negative) {\n            i \u003d -i;\n        }\n        while (i \u003c\u003d -radix) {\n            StringUTF16.putChar(buf, charPos--, digits[-(i % radix)]);\n            i \u003d i / radix;\n        }\n        StringUTF16.putChar(buf, charPos, digits[-i]);\n\n        if (negative) {\n            StringUTF16.putChar(buf, --charPos, \u0027-\u0027);\n        }\n        return StringUTF16.newString(buf, charPos, (33 - charPos));\n    }\n\n    /**\n     * Returns a string representation of the first argument as an\n     * unsigned integer value in the radix specified by the second\n     * argument.\n     *\n     * \u003cp\u003eIf the radix is smaller than {@code Character.MIN_RADIX}\n     * or larger than {@code Character.MAX_RADIX}, then the radix\n     * {@code 10} is used instead.\n     *\n     * \u003cp\u003eNote that since the first argument is treated as an unsigned\n     * value, no leading sign character is printed.\n     *\n     * \u003cp\u003eIf the magnitude is zero, it is represented by a single zero\n     * character {@code \u00270\u0027} ({@code \u0027\\u005Cu0030\u0027}); otherwise,\n     * the first character of the representation of the magnitude will\n     * not be the zero character.\n     *\n     * \u003cp\u003eThe behavior of radixes and the characters used as digits\n     * are the same as {@link #toString(int, int) toString}.\n     *\n     * @param   i       an integer to be converted to an unsigned string.\n     * @param   radix   the radix to use in the string representation.\n     * @return  an unsigned string representation of the argument in the specified radix.\n     * @see     #toString(int, int)\n     * @since 1.8\n     */\n    public static String toUnsignedString(int i, int radix) {\n        return Long.toUnsignedString(toUnsignedLong(i), radix);\n    }\n\n    /**\n     * Returns a string representation of the integer argument as an\n     * unsigned integer in base\u0026nbsp;16.\n     *\n     * \u003cp\u003eThe unsigned integer value is the argument plus 2\u003csup\u003e32\u003c/sup\u003e\n     * if the argument is negative; otherwise, it is equal to the\n     * argument.  This value is converted to a string of ASCII digits\n     * in hexadecimal (base\u0026nbsp;16) with no extra leading\n     * {@code 0}s.\n     *\n     * \u003cp\u003eThe value of the argument can be recovered from the returned\n     * string {@code s} by calling {@link\n     * Integer#parseUnsignedInt(String, int)\n     * Integer.parseUnsignedInt(s, 16)}.\n     *\n     * \u003cp\u003eIf the unsigned magnitude is zero, it is represented by a\n     * single zero character {@code \u00270\u0027} ({@code \u0027\\u005Cu0030\u0027});\n     * otherwise, the first character of the representation of the\n     * unsigned magnitude will not be the zero character. The\n     * following characters are used as hexadecimal digits:\n     *\n     * \u003cblockquote\u003e\n     *  {@code 0123456789abcdef}\n     * \u003c/blockquote\u003e\n     *\n     * These are the characters {@code \u0027\\u005Cu0030\u0027} through\n     * {@code \u0027\\u005Cu0039\u0027} and {@code \u0027\\u005Cu0061\u0027} through\n     * {@code \u0027\\u005Cu0066\u0027}. If uppercase letters are\n     * desired, the {@link java.lang.String#toUpperCase()} method may\n     * be called on the result:\n     *\n     * \u003cblockquote\u003e\n     *  {@code Integer.toHexString(n).toUpperCase()}\n     * \u003c/blockquote\u003e\n     *\n     * @apiNote\n     * The {@link java.util.HexFormat} class provides formatting and parsing\n     * of byte arrays and primitives to return a string or adding to an {@link Appendable}.\n     * {@code HexFormat} formats and parses uppercase or lowercase hexadecimal characters,\n     * with leading zeros and for byte arrays includes for each byte\n     * a delimiter, prefix, and suffix.\n     *\n     * @param   i   an integer to be converted to a string.\n     * @return  the string representation of the unsigned integer value\n     *          represented by the argument in hexadecimal (base\u0026nbsp;16).\n     * @see java.util.HexFormat\n     * @see #parseUnsignedInt(String, int)\n     * @see #toUnsignedString(int, int)\n     * @since   1.0.2\n     */\n    public static String toHexString(int i) {\n        return toUnsignedString0(i, 4);\n    }\n\n    /**\n     * Returns a string representation of the integer argument as an\n     * unsigned integer in base\u0026nbsp;8.\n     *\n     * \u003cp\u003eThe unsigned integer value is the argument plus 2\u003csup\u003e32\u003c/sup\u003e\n     * if the argument is negative; otherwise, it is equal to the\n     * argument.  This value is converted to a string of ASCII digits\n     * in octal (base\u0026nbsp;8) with no extra leading {@code 0}s.\n     *\n     * \u003cp\u003eThe value of the argument can be recovered from the returned\n     * string {@code s} by calling {@link\n     * Integer#parseUnsignedInt(String, int)\n     * Integer.parseUnsignedInt(s, 8)}.\n     *\n     * \u003cp\u003eIf the unsigned magnitude is zero, it is represented by a\n     * single zero character {@code \u00270\u0027} ({@code \u0027\\u005Cu0030\u0027});\n     * otherwise, the first character of the representation of the\n     * unsigned magnitude will not be the zero character. The\n     * following characters are used as octal digits:\n     *\n     * \u003cblockquote\u003e\n     * {@code 01234567}\n     * \u003c/blockquote\u003e\n     *\n     * These are the characters {@code \u0027\\u005Cu0030\u0027} through\n     * {@code \u0027\\u005Cu0037\u0027}.\n     *\n     * @param   i   an integer to be converted to a string.\n     * @return  the string representation of the unsigned integer value\n     *          represented by the argument in octal (base\u0026nbsp;8).\n     * @see #parseUnsignedInt(String, int)\n     * @see #toUnsignedString(int, int)\n     * @since   1.0.2\n     */\n    public static String toOctalString(int i) {\n        return toUnsignedString0(i, 3);\n    }\n\n    /**\n     * Returns a string representation of the integer argument as an\n     * unsigned integer in base\u0026nbsp;2.\n     *\n     * \u003cp\u003eThe unsigned integer value is the argument plus 2\u003csup\u003e32\u003c/sup\u003e\n     * if the argument is negative; otherwise it is equal to the\n     * argument.  This value is converted to a string of ASCII digits\n     * in binary (base\u0026nbsp;2) with no extra leading {@code 0}s.\n     *\n     * \u003cp\u003eThe value of the argument can be recovered from the returned\n     * string {@code s} by calling {@link\n     * Integer#parseUnsignedInt(String, int)\n     * Integer.parseUnsignedInt(s, 2)}.\n     *\n     * \u003cp\u003eIf the unsigned magnitude is zero, it is represented by a\n     * single zero character {@code \u00270\u0027} ({@code \u0027\\u005Cu0030\u0027});\n     * otherwise, the first character of the representation of the\n     * unsigned magnitude will not be the zero character. The\n     * characters {@code \u00270\u0027} ({@code \u0027\\u005Cu0030\u0027}) and {@code\n     * \u00271\u0027} ({@code \u0027\\u005Cu0031\u0027}) are used as binary digits.\n     *\n     * @param   i   an integer to be converted to a string.\n     * @return  the string representation of the unsigned integer value\n     *          represented by the argument in binary (base\u0026nbsp;2).\n     * @see #parseUnsignedInt(String, int)\n     * @see #toUnsignedString(int, int)\n     * @since   1.0.2\n     */\n    public static String toBinaryString(int i) {\n        return toUnsignedString0(i, 1);\n    }\n\n    /**\n     * Convert the integer to an unsigned number.\n     */\n    private static String toUnsignedString0(int val, int shift) {\n        // assert shift \u003e 0 \u0026\u0026 shift \u003c\u003d5 : \"Illegal shift value\";\n        int mag \u003d Integer.SIZE - Integer.numberOfLeadingZeros(val);\n        int chars \u003d Math.max(((mag + (shift - 1)) / shift), 1);\n        if (COMPACT_STRINGS) {\n            byte[] buf \u003d new byte[chars];\n            formatUnsignedInt(val, shift, buf, chars);\n            return new String(buf, LATIN1);\n        } else {\n            byte[] buf \u003d new byte[chars * 2];\n            formatUnsignedIntUTF16(val, shift, buf, chars);\n            return new String(buf, UTF16);\n        }\n    }\n\n    /**\n     * Format an {@code int} (treated as unsigned) into a byte buffer (LATIN1 version). If\n     * {@code len} exceeds the formatted ASCII representation of {@code val},\n     * {@code buf} will be padded with leading zeroes.\n     *\n     * @param val the unsigned int to format\n     * @param shift the log2 of the base to format in (4 for hex, 3 for octal, 1 for binary)\n     * @param buf the byte buffer to write to\n     * @param len the number of characters to write\n     */\n    private static void formatUnsignedInt(int val, int shift, byte[] buf, int len) {\n        int charPos \u003d len;\n        int radix \u003d 1 \u003c\u003c shift;\n        int mask \u003d radix - 1;\n        do {\n            buf[--charPos] \u003d (byte)Integer.digits[val \u0026 mask];\n            val \u003e\u003e\u003e\u003d shift;\n        } while (charPos \u003e 0);\n    }\n\n    /**\n     * Format an {@code int} (treated as unsigned) into a byte buffer (UTF16 version). If\n     * {@code len} exceeds the formatted ASCII representation of {@code val},\n     * {@code buf} will be padded with leading zeroes.\n     *\n     * @param val the unsigned int to format\n     * @param shift the log2 of the base to format in (4 for hex, 3 for octal, 1 for binary)\n     * @param buf the byte buffer to write to\n     * @param len the number of characters to write\n     */\n    private static void formatUnsignedIntUTF16(int val, int shift, byte[] buf, int len) {\n        int charPos \u003d len;\n        int radix \u003d 1 \u003c\u003c shift;\n        int mask \u003d radix - 1;\n        do {\n            StringUTF16.putChar(buf, --charPos, Integer.digits[val \u0026 mask]);\n            val \u003e\u003e\u003e\u003d shift;\n        } while (charPos \u003e 0);\n    }\n\n    static final byte[] DigitTens \u003d {\n        \u00270\u0027, \u00270\u0027, \u00270\u0027, \u00270\u0027, \u00270\u0027, \u00270\u0027, \u00270\u0027, \u00270\u0027, \u00270\u0027, \u00270\u0027,\n        \u00271\u0027, \u00271\u0027, \u00271\u0027, \u00271\u0027, \u00271\u0027, \u00271\u0027, \u00271\u0027, \u00271\u0027, \u00271\u0027, \u00271\u0027,\n        \u00272\u0027, \u00272\u0027, \u00272\u0027, \u00272\u0027, \u00272\u0027, \u00272\u0027, \u00272\u0027, \u00272\u0027, \u00272\u0027, \u00272\u0027,\n        \u00273\u0027, \u00273\u0027, \u00273\u0027, \u00273\u0027, \u00273\u0027, \u00273\u0027, \u00273\u0027, \u00273\u0027, \u00273\u0027, \u00273\u0027,\n        \u00274\u0027, \u00274\u0027, \u00274\u0027, \u00274\u0027, \u00274\u0027, \u00274\u0027, \u00274\u0027, \u00274\u0027, \u00274\u0027, \u00274\u0027,\n        \u00275\u0027, \u00275\u0027, \u00275\u0027, \u00275\u0027, \u00275\u0027, \u00275\u0027, \u00275\u0027, \u00275\u0027, \u00275\u0027, \u00275\u0027,\n        \u00276\u0027, \u00276\u0027, \u00276\u0027, \u00276\u0027, \u00276\u0027, \u00276\u0027, \u00276\u0027, \u00276\u0027, \u00276\u0027, \u00276\u0027,\n        \u00277\u0027, \u00277\u0027, \u00277\u0027, \u00277\u0027, \u00277\u0027, \u00277\u0027, \u00277\u0027, \u00277\u0027, \u00277\u0027, \u00277\u0027,\n        \u00278\u0027, \u00278\u0027, \u00278\u0027, \u00278\u0027, \u00278\u0027, \u00278\u0027, \u00278\u0027, \u00278\u0027, \u00278\u0027, \u00278\u0027,\n        \u00279\u0027, \u00279\u0027, \u00279\u0027, \u00279\u0027, \u00279\u0027, \u00279\u0027, \u00279\u0027, \u00279\u0027, \u00279\u0027, \u00279\u0027,\n        } ;\n\n    static final byte[] DigitOnes \u003d {\n        \u00270\u0027, \u00271\u0027, \u00272\u0027, \u00273\u0027, \u00274\u0027, \u00275\u0027, \u00276\u0027, \u00277\u0027, \u00278\u0027, \u00279\u0027,\n        \u00270\u0027, \u00271\u0027, \u00272\u0027, \u00273\u0027, \u00274\u0027, \u00275\u0027, \u00276\u0027, \u00277\u0027, \u00278\u0027, \u00279\u0027,\n        \u00270\u0027, \u00271\u0027, \u00272\u0027, \u00273\u0027, \u00274\u0027, \u00275\u0027, \u00276\u0027, \u00277\u0027, \u00278\u0027, \u00279\u0027,\n        \u00270\u0027, \u00271\u0027, \u00272\u0027, \u00273\u0027, \u00274\u0027, \u00275\u0027, \u00276\u0027, \u00277\u0027, \u00278\u0027, \u00279\u0027,\n        \u00270\u0027, \u00271\u0027, \u00272\u0027, \u00273\u0027, \u00274\u0027, \u00275\u0027, \u00276\u0027, \u00277\u0027, \u00278\u0027, \u00279\u0027,\n        \u00270\u0027, \u00271\u0027, \u00272\u0027, \u00273\u0027, \u00274\u0027, \u00275\u0027, \u00276\u0027, \u00277\u0027, \u00278\u0027, \u00279\u0027,\n        \u00270\u0027, \u00271\u0027, \u00272\u0027, \u00273\u0027, \u00274\u0027, \u00275\u0027, \u00276\u0027, \u00277\u0027, \u00278\u0027, \u00279\u0027,\n        \u00270\u0027, \u00271\u0027, \u00272\u0027, \u00273\u0027, \u00274\u0027, \u00275\u0027, \u00276\u0027, \u00277\u0027, \u00278\u0027, \u00279\u0027,\n        \u00270\u0027, \u00271\u0027, \u00272\u0027, \u00273\u0027, \u00274\u0027, \u00275\u0027, \u00276\u0027, \u00277\u0027, \u00278\u0027, \u00279\u0027,\n        \u00270\u0027, \u00271\u0027, \u00272\u0027, \u00273\u0027, \u00274\u0027, \u00275\u0027, \u00276\u0027, \u00277\u0027, \u00278\u0027, \u00279\u0027,\n        } ;\n\n\n    /**\n     * Returns a {@code String} object representing the\n     * specified integer. The argument is converted to signed decimal\n     * representation and returned as a string, exactly as if the\n     * argument and radix 10 were given as arguments to the {@link\n     * #toString(int, int)} method.\n     *\n     * @param   i   an integer to be converted.\n     * @return  a string representation of the argument in base\u0026nbsp;10.\n     */\n    @IntrinsicCandidate\n    public static String toString(int i) {\n        int size \u003d stringSize(i);\n        if (COMPACT_STRINGS) {\n            byte[] buf \u003d new byte[size];\n            getChars(i, size, buf);\n            return new String(buf, LATIN1);\n        } else {\n            byte[] buf \u003d new byte[size * 2];\n            StringUTF16.getChars(i, size, buf);\n            return new String(buf, UTF16);\n        }\n    }\n\n    /**\n     * Returns a string representation of the argument as an unsigned\n     * decimal value.\n     *\n     * The argument is converted to unsigned decimal representation\n     * and returned as a string exactly as if the argument and radix\n     * 10 were given as arguments to the {@link #toUnsignedString(int,\n     * int)} method.\n     *\n     * @param   i  an integer to be converted to an unsigned string.\n     * @return  an unsigned string representation of the argument.\n     * @see     #toUnsignedString(int, int)\n     * @since 1.8\n     */\n    public static String toUnsignedString(int i) {\n        return Long.toString(toUnsignedLong(i));\n    }\n\n    /**\n     * Places characters representing the integer i into the\n     * character array buf. The characters are placed into\n     * the buffer backwards starting with the least significant\n     * digit at the specified index (exclusive), and working\n     * backwards from there.\n     *\n     * @implNote This method converts positive inputs into negative\n     * values, to cover the Integer.MIN_VALUE case. Converting otherwise\n     * (negative to positive) will expose -Integer.MIN_VALUE that overflows\n     * integer.\n     *\n     * @param i     value to convert\n     * @param index next index, after the least significant digit\n     * @param buf   target buffer, Latin1-encoded\n     * @return index of the most significant digit or minus sign, if present\n     */\n    static int getChars(int i, int index, byte[] buf) {\n        int q, r;\n        int charPos \u003d index;\n\n        boolean negative \u003d i \u003c 0;\n        if (!negative) {\n            i \u003d -i;\n        }\n\n        // Generate two digits per iteration\n        while (i \u003c\u003d -100) {\n            q \u003d i / 100;\n            r \u003d (q * 100) - i;\n            i \u003d q;\n            buf[--charPos] \u003d DigitOnes[r];\n            buf[--charPos] \u003d DigitTens[r];\n        }\n\n        // We know there are at most two digits left at this point.\n        q \u003d i / 10;\n        r \u003d (q * 10) - i;\n        buf[--charPos] \u003d (byte)(\u00270\u0027 + r);\n\n        // Whatever left is the remaining digit.\n        if (q \u003c 0) {\n            buf[--charPos] \u003d (byte)(\u00270\u0027 - q);\n        }\n\n        if (negative) {\n            buf[--charPos] \u003d (byte)\u0027-\u0027;\n        }\n        return charPos;\n    }\n\n    // Left here for compatibility reasons, see JDK-8143900.\n    static final int [] sizeTable \u003d { 9, 99, 999, 9999, 99999, 999999, 9999999,\n                                      99999999, 999999999, Integer.MAX_VALUE };\n\n    /**\n     * Returns the string representation size for a given int value.\n     *\n     * @param x int value\n     * @return string size\n     *\n     * @implNote There are other ways to compute this: e.g. binary search,\n     * but values are biased heavily towards zero, and therefore linear search\n     * wins. The iteration results are also routinely inlined in the generated\n     * code after loop unrolling.\n     */\n    static int stringSize(int x) {\n        int d \u003d 1;\n        if (x \u003e\u003d 0) {\n            d \u003d 0;\n            x \u003d -x;\n        }\n        int p \u003d -10;\n        for (int i \u003d 1; i \u003c 10; i++) {\n            if (x \u003e p)\n                return i + d;\n            p \u003d 10 * p;\n        }\n        return 10 + d;\n    }\n\n    /**\n     * Parses the string argument as a signed integer in the radix\n     * specified by the second argument. The characters in the string\n     * must all be digits of the specified radix (as determined by\n     * whether {@link java.lang.Character#digit(char, int)} returns a\n     * nonnegative value), except that the first character may be an\n     * ASCII minus sign {@code \u0027-\u0027} ({@code \u0027\\u005Cu002D\u0027}) to\n     * indicate a negative value or an ASCII plus sign {@code \u0027+\u0027}\n     * ({@code \u0027\\u005Cu002B\u0027}) to indicate a positive value. The\n     * resulting integer value is returned.\n     *\n     * \u003cp\u003eAn exception of type {@code NumberFormatException} is\n     * thrown if any of the following situations occurs:\n     * \u003cul\u003e\n     * \u003cli\u003eThe first argument is {@code null} or is a string of\n     * length zero.\n     *\n     * \u003cli\u003eThe radix is either smaller than\n     * {@link java.lang.Character#MIN_RADIX} or\n     * larger than {@link java.lang.Character#MAX_RADIX}.\n     *\n     * \u003cli\u003eAny character of the string is not a digit of the specified\n     * radix, except that the first character may be a minus sign\n     * {@code \u0027-\u0027} ({@code \u0027\\u005Cu002D\u0027}) or plus sign\n     * {@code \u0027+\u0027} ({@code \u0027\\u005Cu002B\u0027}) provided that the\n     * string is longer than length 1.\n     *\n     * \u003cli\u003eThe value represented by the string is not a value of type\n     * {@code int}.\n     * \u003c/ul\u003e\n     *\n     * \u003cp\u003eExamples:\n     * \u003cblockquote\u003e\u003cpre\u003e\n     * parseInt(\"0\", 10) returns 0\n     * parseInt(\"473\", 10) returns 473\n     * parseInt(\"+42\", 10) returns 42\n     * parseInt(\"-0\", 10) returns 0\n     * parseInt(\"-FF\", 16) returns -255\n     * parseInt(\"1100110\", 2) returns 102\n     * parseInt(\"2147483647\", 10) returns 2147483647\n     * parseInt(\"-2147483648\", 10) returns -2147483648\n     * parseInt(\"2147483648\", 10) throws a NumberFormatException\n     * parseInt(\"99\", 8) throws a NumberFormatException\n     * parseInt(\"Kona\", 10) throws a NumberFormatException\n     * parseInt(\"Kona\", 27) returns 411787\n     * \u003c/pre\u003e\u003c/blockquote\u003e\n     *\n     * @param      s   the {@code String} containing the integer\n     *                  representation to be parsed\n     * @param      radix   the radix to be used while parsing {@code s}.\n     * @return     the integer represented by the string argument in the\n     *             specified radix.\n     * @throws     NumberFormatException if the {@code String}\n     *             does not contain a parsable {@code int}.\n     */\n    public static int parseInt(String s, int radix)\n                throws NumberFormatException\n    {\n        /*\n         * WARNING: This method may be invoked early during VM initialization\n         * before IntegerCache is initialized. Care must be taken to not use\n         * the valueOf method.\n         */\n\n        if (s \u003d\u003d null) {\n            throw new NumberFormatException(\"Cannot parse null string\");\n        }\n\n        if (radix \u003c Character.MIN_RADIX) {\n            throw new NumberFormatException(\"radix \" + radix +\n                                            \" less than Character.MIN_RADIX\");\n        }\n\n        if (radix \u003e Character.MAX_RADIX) {\n            throw new NumberFormatException(\"radix \" + radix +\n                                            \" greater than Character.MAX_RADIX\");\n        }\n\n        boolean negative \u003d false;\n        int i \u003d 0, len \u003d s.length();\n        int limit \u003d -Integer.MAX_VALUE;\n\n        if (len \u003e 0) {\n            char firstChar \u003d s.charAt(0);\n            if (firstChar \u003c \u00270\u0027) { // Possible leading \"+\" or \"-\"\n                if (firstChar \u003d\u003d \u0027-\u0027) {\n                    negative \u003d true;\n                    limit \u003d Integer.MIN_VALUE;\n                } else if (firstChar !\u003d \u0027+\u0027) {\n                    throw NumberFormatException.forInputString(s, radix);\n                }\n\n                if (len \u003d\u003d 1) { // Cannot have lone \"+\" or \"-\"\n                    throw NumberFormatException.forInputString(s, radix);\n                }\n                i++;\n            }\n            int multmin \u003d limit / radix;\n            int result \u003d 0;\n            while (i \u003c len) {\n                // Accumulating negatively avoids surprises near MAX_VALUE\n                int digit \u003d Character.digit(s.charAt(i++), radix);\n                if (digit \u003c 0 || result \u003c multmin) {\n                    throw NumberFormatException.forInputString(s, radix);\n                }\n                result *\u003d radix;\n                if (result \u003c limit + digit) {\n                    throw NumberFormatException.forInputString(s, radix);\n                }\n                result -\u003d digit;\n            }\n            return negative ? result : -result;\n        } else {\n            throw NumberFormatException.forInputString(s, radix);\n        }\n    }\n\n    /**\n     * Parses the {@link CharSequence} argument as a signed {@code int} in the\n     * specified {@code radix}, beginning at the specified {@code beginIndex}\n     * and extending to {@code endIndex - 1}.\n     *\n     * \u003cp\u003eThe method does not take steps to guard against the\n     * {@code CharSequence} being mutated while parsing.\n     *\n     * @param      s   the {@code CharSequence} containing the {@code int}\n     *                  representation to be parsed\n     * @param      beginIndex   the beginning index, inclusive.\n     * @param      endIndex     the ending index, exclusive.\n     * @param      radix   the radix to be used while parsing {@code s}.\n     * @return     the signed {@code int} represented by the subsequence in\n     *             the specified radix.\n     * @throws     NullPointerException  if {@code s} is null.\n     * @throws     IndexOutOfBoundsException  if {@code beginIndex} is\n     *             negative, or if {@code beginIndex} is greater than\n     *             {@code endIndex} or if {@code endIndex} is greater than\n     *             {@code s.length()}.\n     * @throws     NumberFormatException  if the {@code CharSequence} does not\n     *             contain a parsable {@code int} in the specified\n     *             {@code radix}, or if {@code radix} is either smaller than\n     *             {@link java.lang.Character#MIN_RADIX} or larger than\n     *             {@link java.lang.Character#MAX_RADIX}.\n     * @since  9\n     */\n    public static int parseInt(CharSequence s, int beginIndex, int endIndex, int radix)\n                throws NumberFormatException {\n        Objects.requireNonNull(s);\n\n        if (beginIndex \u003c 0 || beginIndex \u003e endIndex || endIndex \u003e s.length()) {\n            throw new IndexOutOfBoundsException();\n        }\n        if (radix \u003c Character.MIN_RADIX) {\n            throw new NumberFormatException(\"radix \" + radix +\n                                            \" less than Character.MIN_RADIX\");\n        }\n        if (radix \u003e Character.MAX_RADIX) {\n            throw new NumberFormatException(\"radix \" + radix +\n                                            \" greater than Character.MAX_RADIX\");\n        }\n\n        boolean negative \u003d false;\n        int i \u003d beginIndex;\n        int limit \u003d -Integer.MAX_VALUE;\n\n        if (i \u003c endIndex) {\n            char firstChar \u003d s.charAt(i);\n            if (firstChar \u003c \u00270\u0027) { // Possible leading \"+\" or \"-\"\n                if (firstChar \u003d\u003d \u0027-\u0027) {\n                    negative \u003d true;\n                    limit \u003d Integer.MIN_VALUE;\n                } else if (firstChar !\u003d \u0027+\u0027) {\n                    throw NumberFormatException.forCharSequence(s, beginIndex,\n                            endIndex, i);\n                }\n                i++;\n                if (i \u003d\u003d endIndex) { // Cannot have lone \"+\" or \"-\"\n                    throw NumberFormatException.forCharSequence(s, beginIndex,\n                            endIndex, i);\n                }\n            }\n            int multmin \u003d limit / radix;\n            int result \u003d 0;\n            while (i \u003c endIndex) {\n                // Accumulating negatively avoids surprises near MAX_VALUE\n                int digit \u003d Character.digit(s.charAt(i), radix);\n                if (digit \u003c 0 || result \u003c multmin) {\n                    throw NumberFormatException.forCharSequence(s, beginIndex,\n                            endIndex, i);\n                }\n                result *\u003d radix;\n                if (result \u003c limit + digit) {\n                    throw NumberFormatException.forCharSequence(s, beginIndex,\n                            endIndex, i);\n                }\n                i++;\n                result -\u003d digit;\n            }\n            return negative ? result : -result;\n        } else {\n            throw NumberFormatException.forInputString(\"\", radix);\n        }\n    }\n\n    /**\n     * Parses the string argument as a signed decimal integer. The\n     * characters in the string must all be decimal digits, except\n     * that the first character may be an ASCII minus sign {@code \u0027-\u0027}\n     * ({@code \u0027\\u005Cu002D\u0027}) to indicate a negative value or an\n     * ASCII plus sign {@code \u0027+\u0027} ({@code \u0027\\u005Cu002B\u0027}) to\n     * indicate a positive value. The resulting integer value is\n     * returned, exactly as if the argument and the radix 10 were\n     * given as arguments to the {@link #parseInt(java.lang.String,\n     * int)} method.\n     *\n     * @param s    a {@code String} containing the {@code int}\n     *             representation to be parsed\n     * @return     the integer value represented by the argument in decimal.\n     * @throws     NumberFormatException  if the string does not contain a\n     *               parsable integer.\n     */\n    public static int parseInt(String s) throws NumberFormatException {\n        return parseInt(s,10);\n    }\n\n    /**\n     * Parses the string argument as an unsigned integer in the radix\n     * specified by the second argument.  An unsigned integer maps the\n     * values usually associated with negative numbers to positive\n     * numbers larger than {@code MAX_VALUE}.\n     *\n     * The characters in the string must all be digits of the\n     * specified radix (as determined by whether {@link\n     * java.lang.Character#digit(char, int)} returns a nonnegative\n     * value), except that the first character may be an ASCII plus\n     * sign {@code \u0027+\u0027} ({@code \u0027\\u005Cu002B\u0027}). The resulting\n     * integer value is returned.\n     *\n     * \u003cp\u003eAn exception of type {@code NumberFormatException} is\n     * thrown if any of the following situations occurs:\n     * \u003cul\u003e\n     * \u003cli\u003eThe first argument is {@code null} or is a string of\n     * length zero.\n     *\n     * \u003cli\u003eThe radix is either smaller than\n     * {@link java.lang.Character#MIN_RADIX} or\n     * larger than {@link java.lang.Character#MAX_RADIX}.\n     *\n     * \u003cli\u003eAny character of the string is not a digit of the specified\n     * radix, except that the first character may be a plus sign\n     * {@code \u0027+\u0027} ({@code \u0027\\u005Cu002B\u0027}) provided that the\n     * string is longer than length 1.\n     *\n     * \u003cli\u003eThe value represented by the string is larger than the\n     * largest unsigned {@code int}, 2\u003csup\u003e32\u003c/sup\u003e-1.\n     *\n     * \u003c/ul\u003e\n     *\n     *\n     * @param      s   the {@code String} containing the unsigned integer\n     *                  representation to be parsed\n     * @param      radix   the radix to be used while parsing {@code s}.\n     * @return     the integer represented by the string argument in the\n     *             specified radix.\n     * @throws     NumberFormatException if the {@code String}\n     *             does not contain a parsable {@code int}.\n     * @since 1.8\n     */\n    public static int parseUnsignedInt(String s, int radix)\n                throws NumberFormatException {\n        if (s \u003d\u003d null)  {\n            throw new NumberFormatException(\"Cannot parse null string\");\n        }\n\n        int len \u003d s.length();\n        if (len \u003e 0) {\n            char firstChar \u003d s.charAt(0);\n            if (firstChar \u003d\u003d \u0027-\u0027) {\n                throw new\n                    NumberFormatException(String.format(\"Illegal leading minus sign \" +\n                                                       \"on unsigned string %s.\", s));\n            } else {\n                if (len \u003c\u003d 5 || // Integer.MAX_VALUE in Character.MAX_RADIX is 6 digits\n                    (radix \u003d\u003d 10 \u0026\u0026 len \u003c\u003d 9) ) { // Integer.MAX_VALUE in base 10 is 10 digits\n                    return parseInt(s, radix);\n                } else {\n                    long ell \u003d Long.parseLong(s, radix);\n                    if ((ell \u0026 0xffff_ffff_0000_0000L) \u003d\u003d 0) {\n                        return (int) ell;\n                    } else {\n                        throw new\n                            NumberFormatException(String.format(\"String value %s exceeds \" +\n                                                                \"range of unsigned int.\", s));\n                    }\n                }\n            }\n        } else {\n            throw NumberFormatException.forInputString(s, radix);\n        }\n    }\n\n    /**\n     * Parses the {@link CharSequence} argument as an unsigned {@code int} in\n     * the specified {@code radix}, beginning at the specified\n     * {@code beginIndex} and extending to {@code endIndex - 1}.\n     *\n     * \u003cp\u003eThe method does not take steps to guard against the\n     * {@code CharSequence} being mutated while parsing.\n     *\n     * @param      s   the {@code CharSequence} containing the unsigned\n     *                 {@code int} representation to be parsed\n     * @param      beginIndex   the beginning index, inclusive.\n     * @param      endIndex     the ending index, exclusive.\n     * @param      radix   the radix to be used while parsing {@code s}.\n     * @return     the unsigned {@code int} represented by the subsequence in\n     *             the specified radix.\n     * @throws     NullPointerException  if {@code s} is null.\n     * @throws     IndexOutOfBoundsException  if {@code beginIndex} is\n     *             negative, or if {@code beginIndex} is greater than\n     *             {@code endIndex} or if {@code endIndex} is greater than\n     *             {@code s.length()}.\n     * @throws     NumberFormatException  if the {@code CharSequence} does not\n     *             contain a parsable unsigned {@code int} in the specified\n     *             {@code radix}, or if {@code radix} is either smaller than\n     *             {@link java.lang.Character#MIN_RADIX} or larger than\n     *             {@link java.lang.Character#MAX_RADIX}.\n     * @since  9\n     */\n    public static int parseUnsignedInt(CharSequence s, int beginIndex, int endIndex, int radix)\n                throws NumberFormatException {\n        Objects.requireNonNull(s);\n\n        if (beginIndex \u003c 0 || beginIndex \u003e endIndex || endIndex \u003e s.length()) {\n            throw new IndexOutOfBoundsException();\n        }\n        int start \u003d beginIndex, len \u003d endIndex - beginIndex;\n\n        if (len \u003e 0) {\n            char firstChar \u003d s.charAt(start);\n            if (firstChar \u003d\u003d \u0027-\u0027) {\n                throw new\n                    NumberFormatException(String.format(\"Illegal leading minus sign \" +\n                                                       \"on unsigned string %s.\", s));\n            } else {\n                if (len \u003c\u003d 5 || // Integer.MAX_VALUE in Character.MAX_RADIX is 6 digits\n                        (radix \u003d\u003d 10 \u0026\u0026 len \u003c\u003d 9)) { // Integer.MAX_VALUE in base 10 is 10 digits\n                    return parseInt(s, start, start + len, radix);\n                } else {\n                    long ell \u003d Long.parseLong(s, start, start + len, radix);\n                    if ((ell \u0026 0xffff_ffff_0000_0000L) \u003d\u003d 0) {\n                        return (int) ell;\n                    } else {\n                        throw new\n                            NumberFormatException(String.format(\"String value %s exceeds \" +\n                                                                \"range of unsigned int.\", s));\n                    }\n                }\n            }\n        } else {\n            throw new NumberFormatException(\"\");\n        }\n    }\n\n    /**\n     * Parses the string argument as an unsigned decimal integer. The\n     * characters in the string must all be decimal digits, except\n     * that the first character may be an ASCII plus sign {@code\n     * \u0027+\u0027} ({@code \u0027\\u005Cu002B\u0027}). The resulting integer value\n     * is returned, exactly as if the argument and the radix 10 were\n     * given as arguments to the {@link\n     * #parseUnsignedInt(java.lang.String, int)} method.\n     *\n     * @param s   a {@code String} containing the unsigned {@code int}\n     *            representation to be parsed\n     * @return    the unsigned integer value represented by the argument in decimal.\n     * @throws    NumberFormatException  if the string does not contain a\n     *            parsable unsigned integer.\n     * @since 1.8\n     */\n    public static int parseUnsignedInt(String s) throws NumberFormatException {\n        return parseUnsignedInt(s, 10);\n    }\n\n    /**\n     * Returns an {@code Integer} object holding the value\n     * extracted from the specified {@code String} when parsed\n     * with the radix given by the second argument. The first argument\n     * is interpreted as representing a signed integer in the radix\n     * specified by the second argument, exactly as if the arguments\n     * were given to the {@link #parseInt(java.lang.String, int)}\n     * method. The result is an {@code Integer} object that\n     * represents the integer value specified by the string.\n     *\n     * \u003cp\u003eIn other words, this method returns an {@code Integer}\n     * object equal to the value of:\n     *\n     * \u003cblockquote\u003e\n     *  {@code new Integer(Integer.parseInt(s, radix))}\n     * \u003c/blockquote\u003e\n     *\n     * @param      s   the string to be parsed.\n     * @param      radix the radix to be used in interpreting {@code s}\n     * @return     an {@code Integer} object holding the value\n     *             represented by the string argument in the specified\n     *             radix.\n     * @throws    NumberFormatException if the {@code String}\n     *            does not contain a parsable {@code int}.\n     */\n    public static Integer valueOf(String s, int radix) throws NumberFormatException {\n        return Integer.valueOf(parseInt(s,radix));\n    }\n\n    /**\n     * Returns an {@code Integer} object holding the\n     * value of the specified {@code String}. The argument is\n     * interpreted as representing a signed decimal integer, exactly\n     * as if the argument were given to the {@link\n     * #parseInt(java.lang.String)} method. The result is an\n     * {@code Integer} object that represents the integer value\n     * specified by the string.\n     *\n     * \u003cp\u003eIn other words, this method returns an {@code Integer}\n     * object equal to the value of:\n     *\n     * \u003cblockquote\u003e\n     *  {@code new Integer(Integer.parseInt(s))}\n     * \u003c/blockquote\u003e\n     *\n     * @param      s   the string to be parsed.\n     * @return     an {@code Integer} object holding the value\n     *             represented by the string argument.\n     * @throws     NumberFormatException  if the string cannot be parsed\n     *             as an integer.\n     */\n    public static Integer valueOf(String s) throws NumberFormatException {\n        return Integer.valueOf(parseInt(s, 10));\n    }\n\n    /**\n     * Cache to support the object identity semantics of autoboxing for values between\n     * -128 and 127 (inclusive) as required by JLS.\n     *\n     * The cache is initialized on first usage.  The size of the cache\n     * may be controlled by the {@code -XX:AutoBoxCacheMax\u003d\u003csize\u003e} option.\n     * During VM initialization, java.lang.Integer.IntegerCache.high property\n     * may be set and saved in the private system properties in the\n     * jdk.internal.misc.VM class.\n     *\n     * WARNING: The cache is archived with CDS and reloaded from the shared\n     * archive at runtime. The archived cache (Integer[]) and Integer objects\n     * reside in the closed archive heap regions. Care should be taken when\n     * changing the implementation and the cache array should not be assigned\n     * with new Integer object(s) after initialization.\n     */\n\n    private static class IntegerCache {\n        static final int low \u003d -128;\n        static final int high;\n        static final Integer[] cache;\n        static Integer[] archivedCache;\n\n        static {\n            // high value may be configured by property\n            int h \u003d 127;\n            String integerCacheHighPropValue \u003d\n                VM.getSavedProperty(\"java.lang.Integer.IntegerCache.high\");\n            if (integerCacheHighPropValue !\u003d null) {\n                try {\n                    h \u003d Math.max(parseInt(integerCacheHighPropValue), 127);\n                    // Maximum array size is Integer.MAX_VALUE\n                    h \u003d Math.min(h, Integer.MAX_VALUE - (-low) -1);\n                } catch( NumberFormatException nfe) {\n                    // If the property cannot be parsed into an int, ignore it.\n                }\n            }\n            high \u003d h;\n\n            // Load IntegerCache.archivedCache from archive, if possible\n            CDS.initializeFromArchive(IntegerCache.class);\n            int size \u003d (high - low) + 1;\n\n            // Use the archived cache if it exists and is large enough\n            if (archivedCache \u003d\u003d null || size \u003e archivedCache.length) {\n                Integer[] c \u003d new Integer[size];\n                int j \u003d low;\n                for(int i \u003d 0; i \u003c c.length; i++) {\n                    c[i] \u003d new Integer(j++);\n                }\n                archivedCache \u003d c;\n            }\n            cache \u003d archivedCache;\n            // range [-128, 127] must be interned (JLS7 5.1.7)\n            assert IntegerCache.high \u003e\u003d 127;\n        }\n\n        private IntegerCache() {}\n    }\n\n    /**\n     * Returns an {@code Integer} instance representing the specified\n     * {@code int} value.  If a new {@code Integer} instance is not\n     * required, this method should generally be used in preference to\n     * the constructor {@link #Integer(int)}, as this method is likely\n     * to yield significantly better space and time performance by\n     * caching frequently requested values.\n     *\n     * This method will always cache values in the range -128 to 127,\n     * inclusive, and may cache other values outside of this range.\n     *\n     * @param  i an {@code int} value.\n     * @return an {@code Integer} instance representing {@code i}.\n     * @since  1.5\n     */\n    @IntrinsicCandidate\n    public static Integer valueOf(int i) {\n        if (i \u003e\u003d IntegerCache.low \u0026\u0026 i \u003c\u003d IntegerCache.high)\n            return IntegerCache.cache[i + (-IntegerCache.low)];\n        return new Integer(i);\n    }\n\n    /**\n     * The value of the {@code Integer}.\n     *\n     * @serial\n     */\n    private final int value;\n\n    /**\n     * Constructs a newly allocated {@code Integer} object that\n     * represents the specified {@code int} value.\n     *\n     * @param   value   the value to be represented by the\n     *                  {@code Integer} object.\n     *\n     * @deprecated\n     * It is rarely appropriate to use this constructor. The static factory\n     * {@link #valueOf(int)} is generally a better choice, as it is\n     * likely to yield significantly better space and time performance.\n     */\n    @Deprecated(since\u003d\"9\", forRemoval \u003d true)\n    public Integer(int value) {\n        this.value \u003d value;\n    }\n\n    /**\n     * Constructs a newly allocated {@code Integer} object that\n     * represents the {@code int} value indicated by the\n     * {@code String} parameter. The string is converted to an\n     * {@code int} value in exactly the manner used by the\n     * {@code parseInt} method for radix 10.\n     *\n     * @param   s   the {@code String} to be converted to an {@code Integer}.\n     * @throws      NumberFormatException if the {@code String} does not\n     *              contain a parsable integer.\n     *\n     * @deprecated\n     * It is rarely appropriate to use this constructor.\n     * Use {@link #parseInt(String)} to convert a string to a\n     * {@code int} primitive, or use {@link #valueOf(String)}\n     * to convert a string to an {@code Integer} object.\n     */\n    @Deprecated(since\u003d\"9\", forRemoval \u003d true)\n    public Integer(String s) throws NumberFormatException {\n        this.value \u003d parseInt(s, 10);\n    }\n\n    /**\n     * Returns the value of this {@code Integer} as a {@code byte}\n     * after a narrowing primitive conversion.\n     * @jls 5.1.3 Narrowing Primitive Conversion\n     */\n    public byte byteValue() {\n        return (byte)value;\n    }\n\n    /**\n     * Returns the value of this {@code Integer} as a {@code short}\n     * after a narrowing primitive conversion.\n     * @jls 5.1.3 Narrowing Primitive Conversion\n     */\n    public short shortValue() {\n        return (short)value;\n    }\n\n    /**\n     * Returns the value of this {@code Integer} as an\n     * {@code int}.\n     */\n    @IntrinsicCandidate\n    public int intValue() {\n        return value;\n    }\n\n    /**\n     * Returns the value of this {@code Integer} as a {@code long}\n     * after a widening primitive conversion.\n     * @jls 5.1.2 Widening Primitive Conversion\n     * @see Integer#toUnsignedLong(int)\n     */\n    public long longValue() {\n        return (long)value;\n    }\n\n    /**\n     * Returns the value of this {@code Integer} as a {@code float}\n     * after a widening primitive conversion.\n     * @jls 5.1.2 Widening Primitive Conversion\n     */\n    public float floatValue() {\n        return (float)value;\n    }\n\n    /**\n     * Returns the value of this {@code Integer} as a {@code double}\n     * after a widening primitive conversion.\n     * @jls 5.1.2 Widening Primitive Conversion\n     */\n    public double doubleValue() {\n        return (double)value;\n    }\n\n    /**\n     * Returns a {@code String} object representing this\n     * {@code Integer}\u0027s value. The value is converted to signed\n     * decimal representation and returned as a string, exactly as if\n     * the integer value were given as an argument to the {@link\n     * java.lang.Integer#toString(int)} method.\n     *\n     * @return  a string representation of the value of this object in\n     *          base\u0026nbsp;10.\n     */\n    public String toString() {\n        return toString(value);\n    }\n\n    /**\n     * Returns a hash code for this {@code Integer}.\n     *\n     * @return  a hash code value for this object, equal to the\n     *          primitive {@code int} value represented by this\n     *          {@code Integer} object.\n     */\n    @Override\n    public int hashCode() {\n        return Integer.hashCode(value);\n    }\n\n    /**\n     * Returns a hash code for an {@code int} value; compatible with\n     * {@code Integer.hashCode()}.\n     *\n     * @param value the value to hash\n     * @since 1.8\n     *\n     * @return a hash code value for an {@code int} value.\n     */\n    public static int hashCode(int value) {\n        return value;\n    }\n\n    /**\n     * Compares this object to the specified object.  The result is\n     * {@code true} if and only if the argument is not\n     * {@code null} and is an {@code Integer} object that\n     * contains the same {@code int} value as this object.\n     *\n     * @param   obj   the object to compare with.\n     * @return  {@code true} if the objects are the same;\n     *          {@code false} otherwise.\n     */\n    public boolean equals(Object obj) {\n        if (obj instanceof Integer) {\n            return value \u003d\u003d ((Integer)obj).intValue();\n        }\n        return false;\n    }\n\n    /**\n     * Determines the integer value of the system property with the\n     * specified name.\n     *\n     * \u003cp\u003eThe first argument is treated as the name of a system\n     * property.  System properties are accessible through the {@link\n     * java.lang.System#getProperty(java.lang.String)} method. The\n     * string value of this property is then interpreted as an integer\n     * value using the grammar supported by {@link Integer#decode decode} and\n     * an {@code Integer} object representing this value is returned.\n     *\n     * \u003cp\u003eIf there is no property with the specified name, if the\n     * specified name is empty or {@code null}, or if the property\n     * does not have the correct numeric format, then {@code null} is\n     * returned.\n     *\n     * \u003cp\u003eIn other words, this method returns an {@code Integer}\n     * object equal to the value of:\n     *\n     * \u003cblockquote\u003e\n     *  {@code getInteger(nm, null)}\n     * \u003c/blockquote\u003e\n     *\n     * @param   nm   property name.\n     * @return  the {@code Integer} value of the property.\n     * @throws  SecurityException for the same reasons as\n     *          {@link System#getProperty(String) System.getProperty}\n     * @see     java.lang.System#getProperty(java.lang.String)\n     * @see     java.lang.System#getProperty(java.lang.String, java.lang.String)\n     */\n    public static Integer getInteger(String nm) {\n        return getInteger(nm, null);\n    }\n\n    /**\n     * Determines the integer value of the system property with the\n     * specified name.\n     *\n     * \u003cp\u003eThe first argument is treated as the name of a system\n     * property.  System properties are accessible through the {@link\n     * java.lang.System#getProperty(java.lang.String)} method. The\n     * string value of this property is then interpreted as an integer\n     * value using the grammar supported by {@link Integer#decode decode} and\n     * an {@code Integer} object representing this value is returned.\n     *\n     * \u003cp\u003eThe second argument is the default value. An {@code Integer} object\n     * that represents the value of the second argument is returned if there\n     * is no property of the specified name, if the property does not have\n     * the correct numeric format, or if the specified name is empty or\n     * {@code null}.\n     *\n     * \u003cp\u003eIn other words, this method returns an {@code Integer} object\n     * equal to the value of:\n     *\n     * \u003cblockquote\u003e\n     *  {@code getInteger(nm, new Integer(val))}\n     * \u003c/blockquote\u003e\n     *\n     * but in practice it may be implemented in a manner such as:\n     *\n     * \u003cblockquote\u003e\u003cpre\u003e\n     * Integer result \u003d getInteger(nm, null);\n     * return (result \u003d\u003d null) ? new Integer(val) : result;\n     * \u003c/pre\u003e\u003c/blockquote\u003e\n     *\n     * to avoid the unnecessary allocation of an {@code Integer}\n     * object when the default value is not needed.\n     *\n     * @param   nm   property name.\n     * @param   val   default value.\n     * @return  the {@code Integer} value of the property.\n     * @throws  SecurityException for the same reasons as\n     *          {@link System#getProperty(String) System.getProperty}\n     * @see     java.lang.System#getProperty(java.lang.String)\n     * @see     java.lang.System#getProperty(java.lang.String, java.lang.String)\n     */\n    public static Integer getInteger(String nm, int val) {\n        Integer result \u003d getInteger(nm, null);\n        return (result \u003d\u003d null) ? Integer.valueOf(val) : result;\n    }\n\n    /**\n     * Returns the integer value of the system property with the\n     * specified name.  The first argument is treated as the name of a\n     * system property.  System properties are accessible through the\n     * {@link java.lang.System#getProperty(java.lang.String)} method.\n     * The string value of this property is then interpreted as an\n     * integer value, as per the {@link Integer#decode decode} method,\n     * and an {@code Integer} object representing this value is\n     * returned; in summary:\n     *\n     * \u003cul\u003e\u003cli\u003eIf the property value begins with the two ASCII characters\n     *         {@code 0x} or the ASCII character {@code #}, not\n     *      followed by a minus sign, then the rest of it is parsed as a\n     *      hexadecimal integer exactly as by the method\n     *      {@link #valueOf(java.lang.String, int)} with radix 16.\n     * \u003cli\u003eIf the property value begins with the ASCII character\n     *     {@code 0} followed by another character, it is parsed as an\n     *     octal integer exactly as by the method\n     *     {@link #valueOf(java.lang.String, int)} with radix 8.\n     * \u003cli\u003eOtherwise, the property value is parsed as a decimal integer\n     * exactly as by the method {@link #valueOf(java.lang.String, int)}\n     * with radix 10.\n     * \u003c/ul\u003e\n     *\n     * \u003cp\u003eThe second argument is the default value. The default value is\n     * returned if there is no property of the specified name, if the\n     * property does not have the correct numeric format, or if the\n     * specified name is empty or {@code null}.\n     *\n     * @param   nm   property name.\n     * @param   val   default value.\n     * @return  the {@code Integer} value of the property.\n     * @throws  SecurityException for the same reasons as\n     *          {@link System#getProperty(String) System.getProperty}\n     * @see     System#getProperty(java.lang.String)\n     * @see     System#getProperty(java.lang.String, java.lang.String)\n     */\n    public static Integer getInteger(String nm, Integer val) {\n        String v \u003d null;\n        try {\n            v \u003d System.getProperty(nm);\n        } catch (IllegalArgumentException | NullPointerException e) {\n        }\n        if (v !\u003d null) {\n            try {\n                return Integer.decode(v);\n            } catch (NumberFormatException e) {\n            }\n        }\n        return val;\n    }\n\n    /**\n     * Decodes a {@code String} into an {@code Integer}.\n     * Accepts decimal, hexadecimal, and octal numbers given\n     * by the following grammar:\n     *\n     * \u003cblockquote\u003e\n     * \u003cdl\u003e\n     * \u003cdt\u003e\u003ci\u003eDecodableString:\u003c/i\u003e\n     * \u003cdd\u003e\u003ci\u003eSign\u003csub\u003eopt\u003c/sub\u003e DecimalNumeral\u003c/i\u003e\n     * \u003cdd\u003e\u003ci\u003eSign\u003csub\u003eopt\u003c/sub\u003e\u003c/i\u003e {@code 0x} \u003ci\u003eHexDigits\u003c/i\u003e\n     * \u003cdd\u003e\u003ci\u003eSign\u003csub\u003eopt\u003c/sub\u003e\u003c/i\u003e {@code 0X} \u003ci\u003eHexDigits\u003c/i\u003e\n     * \u003cdd\u003e\u003ci\u003eSign\u003csub\u003eopt\u003c/sub\u003e\u003c/i\u003e {@code #} \u003ci\u003eHexDigits\u003c/i\u003e\n     * \u003cdd\u003e\u003ci\u003eSign\u003csub\u003eopt\u003c/sub\u003e\u003c/i\u003e {@code 0} \u003ci\u003eOctalDigits\u003c/i\u003e\n     *\n     * \u003cdt\u003e\u003ci\u003eSign:\u003c/i\u003e\n     * \u003cdd\u003e{@code -}\n     * \u003cdd\u003e{@code +}\n     * \u003c/dl\u003e\n     * \u003c/blockquote\u003e\n     *\n     * \u003ci\u003eDecimalNumeral\u003c/i\u003e, \u003ci\u003eHexDigits\u003c/i\u003e, and \u003ci\u003eOctalDigits\u003c/i\u003e\n     * are as defined in section {@jls 3.10.1} of\n     * \u003ccite\u003eThe Java Language Specification\u003c/cite\u003e,\n     * except that underscores are not accepted between digits.\n     *\n     * \u003cp\u003eThe sequence of characters following an optional\n     * sign and/or radix specifier (\"{@code 0x}\", \"{@code 0X}\",\n     * \"{@code #}\", or leading zero) is parsed as by the {@code\n     * Integer.parseInt} method with the indicated radix (10, 16, or\n     * 8).  This sequence of characters must represent a positive\n     * value or a {@link NumberFormatException} will be thrown.  The\n     * result is negated if first character of the specified {@code\n     * String} is the minus sign.  No whitespace characters are\n     * permitted in the {@code String}.\n     *\n     * @param     nm the {@code String} to decode.\n     * @return    an {@code Integer} object holding the {@code int}\n     *             value represented by {@code nm}\n     * @throws    NumberFormatException  if the {@code String} does not\n     *            contain a parsable integer.\n     * @see java.lang.Integer#parseInt(java.lang.String, int)\n     */\n    public static Integer decode(String nm) throws NumberFormatException {\n        int radix \u003d 10;\n        int index \u003d 0;\n        boolean negative \u003d false;\n        Integer result;\n\n        if (nm.isEmpty())\n            throw new NumberFormatException(\"Zero length string\");\n        char firstChar \u003d nm.charAt(0);\n        // Handle sign, if present\n        if (firstChar \u003d\u003d \u0027-\u0027) {\n            negative \u003d true;\n            index++;\n        } else if (firstChar \u003d\u003d \u0027+\u0027)\n            index++;\n\n        // Handle radix specifier, if present\n        if (nm.startsWith(\"0x\", index) || nm.startsWith(\"0X\", index)) {\n            index +\u003d 2;\n            radix \u003d 16;\n        }\n        else if (nm.startsWith(\"#\", index)) {\n            index ++;\n            radix \u003d 16;\n        }\n        else if (nm.startsWith(\"0\", index) \u0026\u0026 nm.length() \u003e 1 + index) {\n            index ++;\n            radix \u003d 8;\n        }\n\n        if (nm.startsWith(\"-\", index) || nm.startsWith(\"+\", index))\n            throw new NumberFormatException(\"Sign character in wrong position\");\n\n        try {\n            result \u003d Integer.valueOf(nm.substring(index), radix);\n            result \u003d negative ? Integer.valueOf(-result.intValue()) : result;\n        } catch (NumberFormatException e) {\n            // If number is Integer.MIN_VALUE, we\u0027ll end up here. The next line\n            // handles this case, and causes any genuine format error to be\n            // rethrown.\n            String constant \u003d negative ? (\"-\" + nm.substring(index))\n                                       : nm.substring(index);\n            result \u003d Integer.valueOf(constant, radix);\n        }\n        return result;\n    }\n\n    /**\n     * Compares two {@code Integer} objects numerically.\n     *\n     * @param   anotherInteger   the {@code Integer} to be compared.\n     * @return  the value {@code 0} if this {@code Integer} is\n     *          equal to the argument {@code Integer}; a value less than\n     *          {@code 0} if this {@code Integer} is numerically less\n     *          than the argument {@code Integer}; and a value greater\n     *          than {@code 0} if this {@code Integer} is numerically\n     *           greater than the argument {@code Integer} (signed\n     *           comparison).\n     * @since   1.2\n     */\n    public int compareTo(Integer anotherInteger) {\n        return compare(this.value, anotherInteger.value);\n    }\n\n    /**\n     * Compares two {@code int} values numerically.\n     * The value returned is identical to what would be returned by:\n     * \u003cpre\u003e\n     *    Integer.valueOf(x).compareTo(Integer.valueOf(y))\n     * \u003c/pre\u003e\n     *\n     * @param  x the first {@code int} to compare\n     * @param  y the second {@code int} to compare\n     * @return the value {@code 0} if {@code x \u003d\u003d y};\n     *         a value less than {@code 0} if {@code x \u003c y}; and\n     *         a value greater than {@code 0} if {@code x \u003e y}\n     * @since 1.7\n     */\n    public static int compare(int x, int y) {\n        return (x \u003c y) ? -1 : ((x \u003d\u003d y) ? 0 : 1);\n    }\n\n    /**\n     * Compares two {@code int} values numerically treating the values\n     * as unsigned.\n     *\n     * @param  x the first {@code int} to compare\n     * @param  y the second {@code int} to compare\n     * @return the value {@code 0} if {@code x \u003d\u003d y}; a value less\n     *         than {@code 0} if {@code x \u003c y} as unsigned values; and\n     *         a value greater than {@code 0} if {@code x \u003e y} as\n     *         unsigned values\n     * @since 1.8\n     */\n    public static int compareUnsigned(int x, int y) {\n        return compare(x + MIN_VALUE, y + MIN_VALUE);\n    }\n\n    /**\n     * Converts the argument to a {@code long} by an unsigned\n     * conversion.  In an unsigned conversion to a {@code long}, the\n     * high-order 32 bits of the {@code long} are zero and the\n     * low-order 32 bits are equal to the bits of the integer\n     * argument.\n     *\n     * Consequently, zero and positive {@code int} values are mapped\n     * to a numerically equal {@code long} value and negative {@code\n     * int} values are mapped to a {@code long} value equal to the\n     * input plus 2\u003csup\u003e32\u003c/sup\u003e.\n     *\n     * @param  x the value to convert to an unsigned {@code long}\n     * @return the argument converted to {@code long} by an unsigned\n     *         conversion\n     * @since 1.8\n     */\n    public static long toUnsignedLong(int x) {\n        return ((long) x) \u0026 0xffffffffL;\n    }\n\n    /**\n     * Returns the unsigned quotient of dividing the first argument by\n     * the second where each argument and the result is interpreted as\n     * an unsigned value.\n     *\n     * \u003cp\u003eNote that in two\u0027s complement arithmetic, the three other\n     * basic arithmetic operations of add, subtract, and multiply are\n     * bit-wise identical if the two operands are regarded as both\n     * being signed or both being unsigned.  Therefore separate {@code\n     * addUnsigned}, etc. methods are not provided.\n     *\n     * @param dividend the value to be divided\n     * @param divisor the value doing the dividing\n     * @return the unsigned quotient of the first argument divided by\n     * the second argument\n     * @see #remainderUnsigned\n     * @since 1.8\n     */\n    public static int divideUnsigned(int dividend, int divisor) {\n        // In lieu of tricky code, for now just use long arithmetic.\n        return (int)(toUnsignedLong(dividend) / toUnsignedLong(divisor));\n    }\n\n    /**\n     * Returns the unsigned remainder from dividing the first argument\n     * by the second where each argument and the result is interpreted\n     * as an unsigned value.\n     *\n     * @param dividend the value to be divided\n     * @param divisor the value doing the dividing\n     * @return the unsigned remainder of the first argument divided by\n     * the second argument\n     * @see #divideUnsigned\n     * @since 1.8\n     */\n    public static int remainderUnsigned(int dividend, int divisor) {\n        // In lieu of tricky code, for now just use long arithmetic.\n        return (int)(toUnsignedLong(dividend) % toUnsignedLong(divisor));\n    }\n\n\n    // Bit twiddling\n\n    /**\n     * The number of bits used to represent an {@code int} value in two\u0027s\n     * complement binary form.\n     *\n     * @since 1.5\n     */\n    @Native public static final int SIZE \u003d 32;\n\n    /**\n     * The number of bytes used to represent an {@code int} value in two\u0027s\n     * complement binary form.\n     *\n     * @since 1.8\n     */\n    public static final int BYTES \u003d SIZE / Byte.SIZE;\n\n    /**\n     * Returns an {@code int} value with at most a single one-bit, in the\n     * position of the highest-order (\"leftmost\") one-bit in the specified\n     * {@code int} value.  Returns zero if the specified value has no\n     * one-bits in its two\u0027s complement binary representation, that is, if it\n     * is equal to zero.\n     *\n     * @param i the value whose highest one bit is to be computed\n     * @return an {@code int} value with a single one-bit, in the position\n     *     of the highest-order one-bit in the specified value, or zero if\n     *     the specified value is itself equal to zero.\n     * @since 1.5\n     */\n    public static int highestOneBit(int i) {\n        return i \u0026 (MIN_VALUE \u003e\u003e\u003e numberOfLeadingZeros(i));\n    }\n\n    /**\n     * Returns an {@code int} value with at most a single one-bit, in the\n     * position of the lowest-order (\"rightmost\") one-bit in the specified\n     * {@code int} value.  Returns zero if the specified value has no\n     * one-bits in its two\u0027s complement binary representation, that is, if it\n     * is equal to zero.\n     *\n     * @param i the value whose lowest one bit is to be computed\n     * @return an {@code int} value with a single one-bit, in the position\n     *     of the lowest-order one-bit in the specified value, or zero if\n     *     the specified value is itself equal to zero.\n     * @since 1.5\n     */\n    public static int lowestOneBit(int i) {\n        // HD, Section 2-1\n        return i \u0026 -i;\n    }\n\n    /**\n     * Returns the number of zero bits preceding the highest-order\n     * (\"leftmost\") one-bit in the two\u0027s complement binary representation\n     * of the specified {@code int} value.  Returns 32 if the\n     * specified value has no one-bits in its two\u0027s complement representation,\n     * in other words if it is equal to zero.\n     *\n     * \u003cp\u003eNote that this method is closely related to the logarithm base 2.\n     * For all positive {@code int} values x:\n     * \u003cul\u003e\n     * \u003cli\u003efloor(log\u003csub\u003e2\u003c/sub\u003e(x)) \u003d {@code 31 - numberOfLeadingZeros(x)}\n     * \u003cli\u003eceil(log\u003csub\u003e2\u003c/sub\u003e(x)) \u003d {@code 32 - numberOfLeadingZeros(x - 1)}\n     * \u003c/ul\u003e\n     *\n     * @param i the value whose number of leading zeros is to be computed\n     * @return the number of zero bits preceding the highest-order\n     *     (\"leftmost\") one-bit in the two\u0027s complement binary representation\n     *     of the specified {@code int} value, or 32 if the value\n     *     is equal to zero.\n     * @since 1.5\n     */\n    @IntrinsicCandidate\n    public static int numberOfLeadingZeros(int i) {\n        // HD, Count leading 0\u0027s\n        if (i \u003c\u003d 0)\n            return i \u003d\u003d 0 ? 32 : 0;\n        int n \u003d 31;\n        if (i \u003e\u003d 1 \u003c\u003c 16) { n -\u003d 16; i \u003e\u003e\u003e\u003d 16; }\n        if (i \u003e\u003d 1 \u003c\u003c  8) { n -\u003d  8; i \u003e\u003e\u003e\u003d  8; }\n        if (i \u003e\u003d 1 \u003c\u003c  4) { n -\u003d  4; i \u003e\u003e\u003e\u003d  4; }\n        if (i \u003e\u003d 1 \u003c\u003c  2) { n -\u003d  2; i \u003e\u003e\u003e\u003d  2; }\n        return n - (i \u003e\u003e\u003e 1);\n    }\n\n    /**\n     * Returns the number of zero bits following the lowest-order (\"rightmost\")\n     * one-bit in the two\u0027s complement binary representation of the specified\n     * {@code int} value.  Returns 32 if the specified value has no\n     * one-bits in its two\u0027s complement representation, in other words if it is\n     * equal to zero.\n     *\n     * @param i the value whose number of trailing zeros is to be computed\n     * @return the number of zero bits following the lowest-order (\"rightmost\")\n     *     one-bit in the two\u0027s complement binary representation of the\n     *     specified {@code int} value, or 32 if the value is equal\n     *     to zero.\n     * @since 1.5\n     */\n    @IntrinsicCandidate\n    public static int numberOfTrailingZeros(int i) {\n        // HD, Count trailing 0\u0027s\n        i \u003d ~i \u0026 (i - 1);\n        if (i \u003c\u003d 0) return i \u0026 32;\n        int n \u003d 1;\n        if (i \u003e 1 \u003c\u003c 16) { n +\u003d 16; i \u003e\u003e\u003e\u003d 16; }\n        if (i \u003e 1 \u003c\u003c  8) { n +\u003d  8; i \u003e\u003e\u003e\u003d  8; }\n        if (i \u003e 1 \u003c\u003c  4) { n +\u003d  4; i \u003e\u003e\u003e\u003d  4; }\n        if (i \u003e 1 \u003c\u003c  2) { n +\u003d  2; i \u003e\u003e\u003e\u003d  2; }\n        return n + (i \u003e\u003e\u003e 1);\n    }\n\n    /**\n     * Returns the number of one-bits in the two\u0027s complement binary\n     * representation of the specified {@code int} value.  This function is\n     * sometimes referred to as the \u003ci\u003epopulation count\u003c/i\u003e.\n     *\n     * @param i the value whose bits are to be counted\n     * @return the number of one-bits in the two\u0027s complement binary\n     *     representation of the specified {@code int} value.\n     * @since 1.5\n     */\n    @IntrinsicCandidate\n    public static int bitCount(int i) {\n        // HD, Figure 5-2\n        i \u003d i - ((i \u003e\u003e\u003e 1) \u0026 0x55555555);\n        i \u003d (i \u0026 0x33333333) + ((i \u003e\u003e\u003e 2) \u0026 0x33333333);\n        i \u003d (i + (i \u003e\u003e\u003e 4)) \u0026 0x0f0f0f0f;\n        i \u003d i + (i \u003e\u003e\u003e 8);\n        i \u003d i + (i \u003e\u003e\u003e 16);\n        return i \u0026 0x3f;\n    }\n\n    /**\n     * Returns the value obtained by rotating the two\u0027s complement binary\n     * representation of the specified {@code int} value left by the\n     * specified number of bits.  (Bits shifted out of the left hand, or\n     * high-order, side reenter on the right, or low-order.)\n     *\n     * \u003cp\u003eNote that left rotation with a negative distance is equivalent to\n     * right rotation: {@code rotateLeft(val, -distance) \u003d\u003d rotateRight(val,\n     * distance)}.  Note also that rotation by any multiple of 32 is a\n     * no-op, so all but the last five bits of the rotation distance can be\n     * ignored, even if the distance is negative: {@code rotateLeft(val,\n     * distance) \u003d\u003d rotateLeft(val, distance \u0026 0x1F)}.\n     *\n     * @param i the value whose bits are to be rotated left\n     * @param distance the number of bit positions to rotate left\n     * @return the value obtained by rotating the two\u0027s complement binary\n     *     representation of the specified {@code int} value left by the\n     *     specified number of bits.\n     * @since 1.5\n     */\n    public static int rotateLeft(int i, int distance) {\n        return (i \u003c\u003c distance) | (i \u003e\u003e\u003e -distance);\n    }\n\n    /**\n     * Returns the value obtained by rotating the two\u0027s complement binary\n     * representation of the specified {@code int} value right by the\n     * specified number of bits.  (Bits shifted out of the right hand, or\n     * low-order, side reenter on the left, or high-order.)\n     *\n     * \u003cp\u003eNote that right rotation with a negative distance is equivalent to\n     * left rotation: {@code rotateRight(val, -distance) \u003d\u003d rotateLeft(val,\n     * distance)}.  Note also that rotation by any multiple of 32 is a\n     * no-op, so all but the last five bits of the rotation distance can be\n     * ignored, even if the distance is negative: {@code rotateRight(val,\n     * distance) \u003d\u003d rotateRight(val, distance \u0026 0x1F)}.\n     *\n     * @param i the value whose bits are to be rotated right\n     * @param distance the number of bit positions to rotate right\n     * @return the value obtained by rotating the two\u0027s complement binary\n     *     representation of the specified {@code int} value right by the\n     *     specified number of bits.\n     * @since 1.5\n     */\n    public static int rotateRight(int i, int distance) {\n        return (i \u003e\u003e\u003e distance) | (i \u003c\u003c -distance);\n    }\n\n    /**\n     * Returns the value obtained by reversing the order of the bits in the\n     * two\u0027s complement binary representation of the specified {@code int}\n     * value.\n     *\n     * @param i the value to be reversed\n     * @return the value obtained by reversing order of the bits in the\n     *     specified {@code int} value.\n     * @since 1.5\n     */\n    public static int reverse(int i) {\n        // HD, Figure 7-1\n        i \u003d (i \u0026 0x55555555) \u003c\u003c 1 | (i \u003e\u003e\u003e 1) \u0026 0x55555555;\n        i \u003d (i \u0026 0x33333333) \u003c\u003c 2 | (i \u003e\u003e\u003e 2) \u0026 0x33333333;\n        i \u003d (i \u0026 0x0f0f0f0f) \u003c\u003c 4 | (i \u003e\u003e\u003e 4) \u0026 0x0f0f0f0f;\n\n        return reverseBytes(i);\n    }\n\n    /**\n     * Returns the signum function of the specified {@code int} value.  (The\n     * return value is -1 if the specified value is negative; 0 if the\n     * specified value is zero; and 1 if the specified value is positive.)\n     *\n     * @param i the value whose signum is to be computed\n     * @return the signum function of the specified {@code int} value.\n     * @since 1.5\n     */\n    public static int signum(int i) {\n        // HD, Section 2-7\n        return (i \u003e\u003e 31) | (-i \u003e\u003e\u003e 31);\n    }\n\n    /**\n     * Returns the value obtained by reversing the order of the bytes in the\n     * two\u0027s complement representation of the specified {@code int} value.\n     *\n     * @param i the value whose bytes are to be reversed\n     * @return the value obtained by reversing the bytes in the specified\n     *     {@code int} value.\n     * @since 1.5\n     */\n    @IntrinsicCandidate\n    public static int reverseBytes(int i) {\n        return (i \u003c\u003c 24)            |\n               ((i \u0026 0xff00) \u003c\u003c 8)  |\n               ((i \u003e\u003e\u003e 8) \u0026 0xff00) |\n               (i \u003e\u003e\u003e 24);\n    }\n\n    /**\n     * Adds two integers together as per the + operator.\n     *\n     * @param a the first operand\n     * @param b the second operand\n     * @return the sum of {@code a} and {@code b}\n     * @see java.util.function.BinaryOperator\n     * @since 1.8\n     */\n    public static int sum(int a, int b) {\n        return a + b;\n    }\n\n    /**\n     * Returns the greater of two {@code int} values\n     * as if by calling {@link Math#max(int, int) Math.max}.\n     *\n     * @param a the first operand\n     * @param b the second operand\n     * @return the greater of {@code a} and {@code b}\n     * @see java.util.function.BinaryOperator\n     * @since 1.8\n     */\n    public static int max(int a, int b) {\n        return Math.max(a, b);\n    }\n\n    /**\n     * Returns the smaller of two {@code int} values\n     * as if by calling {@link Math#min(int, int) Math.min}.\n     *\n     * @param a the first operand\n     * @param b the second operand\n     * @return the smaller of {@code a} and {@code b}\n     * @see java.util.function.BinaryOperator\n     * @since 1.8\n     */\n    public static int min(int a, int b) {\n        return Math.min(a, b);\n    }\n\n    /**\n     * Returns an {@link Optional} containing the nominal descriptor for this\n     * instance, which is the instance itself.\n     *\n     * @return an {@link Optional} describing the {@linkplain Integer} instance\n     * @since 12\n     */\n    @Override\n    public Optional\u003cInteger\u003e describeConstable() {\n        return Optional.of(this);\n    }\n\n    /**\n     * Resolves this instance as a {@link ConstantDesc}, the result of which is\n     * the instance itself.\n     *\n     * @param lookup ignored\n     * @return the {@linkplain Integer} instance\n     * @since 12\n     */\n    @Override\n    public Integer resolveConstantDesc(MethodHandles.Lookup lookup) {\n        return this;\n    }\n\n    /** use serialVersionUID from JDK 1.0.2 for interoperability */\n    @java.io.Serial\n    @Native private static final long serialVersionUID \u003d 1360826667806852920L;\n}\n"
    }
  }
}
java.lang.IllegalArgumentException: Illegal character in opaque part at index 188: jar:file:///C:/Users/Vinicius/AppData/Local/Coursier/cache/arc/https/github.com/adoptium/temurin17-binaries/releases/download/jdk-17%2B35/OpenJDK17-jdk_x64_windows_hotspot_17_35.zip/jdk-17 35/lib/src.zip!/java.base/java/lang/Integer.java
	at java.base/java.net.URI.create(URI.java:906)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:178)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.$anonfun$toAbsolutePath$3(MtagsEnrichments.scala:175)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.withTryDecode$1(MtagsEnrichments.scala:153)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:175)
	at scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:756)
	at scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:753)
	at scala.meta.internal.metals.WorkspaceLspService.didOpen(WorkspaceLspService.scala:388)
	at scala.meta.metals.lsp.DelegatingScalaService.didOpen(DelegatingScalaService.scala:39)
	at jdk.internal.reflect.GeneratedMethodAccessor23.invoke(Unknown Source)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:568)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$recursiveFindRpcMethods$0(GenericEndpoint.java:65)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.notify(GenericEndpoint.java:160)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleNotification(RemoteEndpoint.java:231)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:198)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:185)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:97)
	at org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:114)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:539)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.base/java.lang.Thread.run(Thread.java:833)
Caused by: java.net.URISyntaxException: Illegal character in opaque part at index 188: jar:file:///C:/Users/Vinicius/AppData/Local/Coursier/cache/arc/https/github.com/adoptium/temurin17-binaries/releases/download/jdk-17%2B35/OpenJDK17-jdk_x64_windows_hotspot_17_35.zip/jdk-17 35/lib/src.zip!/java.base/java/lang/Integer.java
	at java.base/java.net.URI$Parser.fail(URI.java:2974)
	at java.base/java.net.URI$Parser.checkChars(URI.java:3145)
	at java.base/java.net.URI$Parser.parse(URI.java:3181)
	at java.base/java.net.URI.<init>(URI.java:623)
	at java.base/java.net.URI.create(URI.java:904)
	... 23 more

jul. 19, 2024 1:39:36 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleNotification
ADVERTÊNCIA: Notification threw an exception: {
  "jsonrpc": "2.0",
  "method": "textDocument/didClose",
  "params": {
    "textDocument": {
      "uri": "jar:file%3A///C%3A/Users/Vinicius/AppData/Local/Coursier/cache/arc/https/github.com/adoptium/temurin17-binaries/releases/download/jdk-17%25252B35/OpenJDK17-jdk_x64_windows_hotspot_17_35.zip/jdk-17%2B35/lib/src.zip%21/java.base/java/lang/Integer.java"
    }
  }
}
java.lang.IllegalArgumentException: Illegal character in opaque part at index 188: jar:file:///C:/Users/Vinicius/AppData/Local/Coursier/cache/arc/https/github.com/adoptium/temurin17-binaries/releases/download/jdk-17%2B35/OpenJDK17-jdk_x64_windows_hotspot_17_35.zip/jdk-17 35/lib/src.zip!/java.base/java/lang/Integer.java
	at java.base/java.net.URI.create(URI.java:906)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:178)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.$anonfun$toAbsolutePath$3(MtagsEnrichments.scala:175)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.withTryDecode$1(MtagsEnrichments.scala:153)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:175)
	at scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:756)
	at scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:753)
	at scala.meta.internal.metals.WorkspaceLspService.didClose(WorkspaceLspService.scala:407)
	at scala.meta.metals.lsp.DelegatingScalaService.didClose(DelegatingScalaService.scala:53)
	at jdk.internal.reflect.GeneratedMethodAccessor26.invoke(Unknown Source)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:568)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$recursiveFindRpcMethods$0(GenericEndpoint.java:65)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.notify(GenericEndpoint.java:160)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleNotification(RemoteEndpoint.java:231)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:198)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:185)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:97)
	at org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:114)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:539)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.base/java.lang.Thread.run(Thread.java:833)
Caused by: java.net.URISyntaxException: Illegal character in opaque part at index 188: jar:file:///C:/Users/Vinicius/AppData/Local/Coursier/cache/arc/https/github.com/adoptium/temurin17-binaries/releases/download/jdk-17%2B35/OpenJDK17-jdk_x64_windows_hotspot_17_35.zip/jdk-17 35/lib/src.zip!/java.base/java/lang/Integer.java
	at java.base/java.net.URI$Parser.fail(URI.java:2974)
	at java.base/java.net.URI$Parser.checkChars(URI.java:3145)
	at java.base/java.net.URI$Parser.parse(URI.java:3181)
	at java.base/java.net.URI.<init>(URI.java:623)
	at java.base/java.net.URI.create(URI.java:904)
	... 23 more

jul. 19, 2024 1:39:36 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleNotification
ADVERTÊNCIA: Notification threw an exception: {
  "jsonrpc": "2.0",
  "method": "textDocument/didOpen",
  "params": {
    "textDocument": {
      "uri": "jar:file%3A///C%3A/Users/Vinicius/AppData/Local/Coursier/cache/arc/https/github.com/adoptium/temurin17-binaries/releases/download/jdk-17%25252B35/OpenJDK17-jdk_x64_windows_hotspot_17_35.zip/jdk-17%2B35/lib/src.zip%21/java.base/java/lang/Integer.java",
      "languageId": "java",
      "version": 1,
      "text": "/*\n * Copyright (c) 1994, 2021, Oracle and/or its affiliates. All rights reserved.\n * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n *\n * This code is free software; you can redistribute it and/or modify it\n * under the terms of the GNU General Public License version 2 only, as\n * published by the Free Software Foundation.  Oracle designates this\n * particular file as subject to the \"Classpath\" exception as provided\n * by Oracle in the LICENSE file that accompanied this code.\n *\n * This code is distributed in the hope that it will be useful, but WITHOUT\n * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n * version 2 for more details (a copy is included in the LICENSE file that\n * accompanied this code).\n *\n * You should have received a copy of the GNU General Public License version\n * 2 along with this work; if not, write to the Free Software Foundation,\n * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n *\n * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n * or visit www.oracle.com if you need additional information or have any\n * questions.\n */\n\npackage java.lang;\n\nimport java.lang.annotation.Native;\nimport java.lang.invoke.MethodHandles;\nimport java.lang.constant.Constable;\nimport java.lang.constant.ConstantDesc;\nimport java.util.Objects;\nimport java.util.Optional;\n\nimport jdk.internal.misc.CDS;\nimport jdk.internal.misc.VM;\nimport jdk.internal.vm.annotation.IntrinsicCandidate;\n\nimport static java.lang.String.COMPACT_STRINGS;\nimport static java.lang.String.LATIN1;\nimport static java.lang.String.UTF16;\n\n/**\n * The {@code Integer} class wraps a value of the primitive type\n * {@code int} in an object. An object of type {@code Integer}\n * contains a single field whose type is {@code int}.\n *\n * \u003cp\u003eIn addition, this class provides several methods for converting\n * an {@code int} to a {@code String} and a {@code String} to an\n * {@code int}, as well as other constants and methods useful when\n * dealing with an {@code int}.\n *\n * \u003cp\u003eThis is a \u003ca href\u003d\"{@docRoot}/java.base/java/lang/doc-files/ValueBased.html\"\u003evalue-based\u003c/a\u003e\n * class; programmers should treat instances that are\n * {@linkplain #equals(Object) equal} as interchangeable and should not\n * use instances for synchronization, or unpredictable behavior may\n * occur. For example, in a future release, synchronization may fail.\n *\n * \u003cp\u003eImplementation note: The implementations of the \"bit twiddling\"\n * methods (such as {@link #highestOneBit(int) highestOneBit} and\n * {@link #numberOfTrailingZeros(int) numberOfTrailingZeros}) are\n * based on material from Henry S. Warren, Jr.\u0027s \u003ci\u003eHacker\u0027s\n * Delight\u003c/i\u003e, (Addison Wesley, 2002).\n *\n * @author  Lee Boynton\n * @author  Arthur van Hoff\n * @author  Josh Bloch\n * @author  Joseph D. Darcy\n * @since 1.0\n */\n@jdk.internal.ValueBased\npublic final class Integer extends Number\n        implements Comparable\u003cInteger\u003e, Constable, ConstantDesc {\n    /**\n     * A constant holding the minimum value an {@code int} can\n     * have, -2\u003csup\u003e31\u003c/sup\u003e.\n     */\n    @Native public static final int   MIN_VALUE \u003d 0x80000000;\n\n    /**\n     * A constant holding the maximum value an {@code int} can\n     * have, 2\u003csup\u003e31\u003c/sup\u003e-1.\n     */\n    @Native public static final int   MAX_VALUE \u003d 0x7fffffff;\n\n    /**\n     * The {@code Class} instance representing the primitive type\n     * {@code int}.\n     *\n     * @since   1.1\n     */\n    @SuppressWarnings(\"unchecked\")\n    public static final Class\u003cInteger\u003e  TYPE \u003d (Class\u003cInteger\u003e) Class.getPrimitiveClass(\"int\");\n\n    /**\n     * All possible chars for representing a number as a String\n     */\n    static final char[] digits \u003d {\n        \u00270\u0027 , \u00271\u0027 , \u00272\u0027 , \u00273\u0027 , \u00274\u0027 , \u00275\u0027 ,\n        \u00276\u0027 , \u00277\u0027 , \u00278\u0027 , \u00279\u0027 , \u0027a\u0027 , \u0027b\u0027 ,\n        \u0027c\u0027 , \u0027d\u0027 , \u0027e\u0027 , \u0027f\u0027 , \u0027g\u0027 , \u0027h\u0027 ,\n        \u0027i\u0027 , \u0027j\u0027 , \u0027k\u0027 , \u0027l\u0027 , \u0027m\u0027 , \u0027n\u0027 ,\n        \u0027o\u0027 , \u0027p\u0027 , \u0027q\u0027 , \u0027r\u0027 , \u0027s\u0027 , \u0027t\u0027 ,\n        \u0027u\u0027 , \u0027v\u0027 , \u0027w\u0027 , \u0027x\u0027 , \u0027y\u0027 , \u0027z\u0027\n    };\n\n    /**\n     * Returns a string representation of the first argument in the\n     * radix specified by the second argument.\n     *\n     * \u003cp\u003eIf the radix is smaller than {@code Character.MIN_RADIX}\n     * or larger than {@code Character.MAX_RADIX}, then the radix\n     * {@code 10} is used instead.\n     *\n     * \u003cp\u003eIf the first argument is negative, the first element of the\n     * result is the ASCII minus character {@code \u0027-\u0027}\n     * ({@code \u0027\\u005Cu002D\u0027}). If the first argument is not\n     * negative, no sign character appears in the result.\n     *\n     * \u003cp\u003eThe remaining characters of the result represent the magnitude\n     * of the first argument. If the magnitude is zero, it is\n     * represented by a single zero character {@code \u00270\u0027}\n     * ({@code \u0027\\u005Cu0030\u0027}); otherwise, the first character of\n     * the representation of the magnitude will not be the zero\n     * character.  The following ASCII characters are used as digits:\n     *\n     * \u003cblockquote\u003e\n     *   {@code 0123456789abcdefghijklmnopqrstuvwxyz}\n     * \u003c/blockquote\u003e\n     *\n     * These are {@code \u0027\\u005Cu0030\u0027} through\n     * {@code \u0027\\u005Cu0039\u0027} and {@code \u0027\\u005Cu0061\u0027} through\n     * {@code \u0027\\u005Cu007A\u0027}. If {@code radix} is\n     * \u003cvar\u003eN\u003c/var\u003e, then the first \u003cvar\u003eN\u003c/var\u003e of these characters\n     * are used as radix-\u003cvar\u003eN\u003c/var\u003e digits in the order shown. Thus,\n     * the digits for hexadecimal (radix 16) are\n     * {@code 0123456789abcdef}. If uppercase letters are\n     * desired, the {@link java.lang.String#toUpperCase()} method may\n     * be called on the result:\n     *\n     * \u003cblockquote\u003e\n     *  {@code Integer.toString(n, 16).toUpperCase()}\n     * \u003c/blockquote\u003e\n     *\n     * @param   i       an integer to be converted to a string.\n     * @param   radix   the radix to use in the string representation.\n     * @return  a string representation of the argument in the specified radix.\n     * @see     java.lang.Character#MAX_RADIX\n     * @see     java.lang.Character#MIN_RADIX\n     */\n    public static String toString(int i, int radix) {\n        if (radix \u003c Character.MIN_RADIX || radix \u003e Character.MAX_RADIX)\n            radix \u003d 10;\n\n        /* Use the faster version */\n        if (radix \u003d\u003d 10) {\n            return toString(i);\n        }\n\n        if (COMPACT_STRINGS) {\n            byte[] buf \u003d new byte[33];\n            boolean negative \u003d (i \u003c 0);\n            int charPos \u003d 32;\n\n            if (!negative) {\n                i \u003d -i;\n            }\n\n            while (i \u003c\u003d -radix) {\n                buf[charPos--] \u003d (byte)digits[-(i % radix)];\n                i \u003d i / radix;\n            }\n            buf[charPos] \u003d (byte)digits[-i];\n\n            if (negative) {\n                buf[--charPos] \u003d \u0027-\u0027;\n            }\n\n            return StringLatin1.newString(buf, charPos, (33 - charPos));\n        }\n        return toStringUTF16(i, radix);\n    }\n\n    private static String toStringUTF16(int i, int radix) {\n        byte[] buf \u003d new byte[33 * 2];\n        boolean negative \u003d (i \u003c 0);\n        int charPos \u003d 32;\n        if (!negative) {\n            i \u003d -i;\n        }\n        while (i \u003c\u003d -radix) {\n            StringUTF16.putChar(buf, charPos--, digits[-(i % radix)]);\n            i \u003d i / radix;\n        }\n        StringUTF16.putChar(buf, charPos, digits[-i]);\n\n        if (negative) {\n            StringUTF16.putChar(buf, --charPos, \u0027-\u0027);\n        }\n        return StringUTF16.newString(buf, charPos, (33 - charPos));\n    }\n\n    /**\n     * Returns a string representation of the first argument as an\n     * unsigned integer value in the radix specified by the second\n     * argument.\n     *\n     * \u003cp\u003eIf the radix is smaller than {@code Character.MIN_RADIX}\n     * or larger than {@code Character.MAX_RADIX}, then the radix\n     * {@code 10} is used instead.\n     *\n     * \u003cp\u003eNote that since the first argument is treated as an unsigned\n     * value, no leading sign character is printed.\n     *\n     * \u003cp\u003eIf the magnitude is zero, it is represented by a single zero\n     * character {@code \u00270\u0027} ({@code \u0027\\u005Cu0030\u0027}); otherwise,\n     * the first character of the representation of the magnitude will\n     * not be the zero character.\n     *\n     * \u003cp\u003eThe behavior of radixes and the characters used as digits\n     * are the same as {@link #toString(int, int) toString}.\n     *\n     * @param   i       an integer to be converted to an unsigned string.\n     * @param   radix   the radix to use in the string representation.\n     * @return  an unsigned string representation of the argument in the specified radix.\n     * @see     #toString(int, int)\n     * @since 1.8\n     */\n    public static String toUnsignedString(int i, int radix) {\n        return Long.toUnsignedString(toUnsignedLong(i), radix);\n    }\n\n    /**\n     * Returns a string representation of the integer argument as an\n     * unsigned integer in base\u0026nbsp;16.\n     *\n     * \u003cp\u003eThe unsigned integer value is the argument plus 2\u003csup\u003e32\u003c/sup\u003e\n     * if the argument is negative; otherwise, it is equal to the\n     * argument.  This value is converted to a string of ASCII digits\n     * in hexadecimal (base\u0026nbsp;16) with no extra leading\n     * {@code 0}s.\n     *\n     * \u003cp\u003eThe value of the argument can be recovered from the returned\n     * string {@code s} by calling {@link\n     * Integer#parseUnsignedInt(String, int)\n     * Integer.parseUnsignedInt(s, 16)}.\n     *\n     * \u003cp\u003eIf the unsigned magnitude is zero, it is represented by a\n     * single zero character {@code \u00270\u0027} ({@code \u0027\\u005Cu0030\u0027});\n     * otherwise, the first character of the representation of the\n     * unsigned magnitude will not be the zero character. The\n     * following characters are used as hexadecimal digits:\n     *\n     * \u003cblockquote\u003e\n     *  {@code 0123456789abcdef}\n     * \u003c/blockquote\u003e\n     *\n     * These are the characters {@code \u0027\\u005Cu0030\u0027} through\n     * {@code \u0027\\u005Cu0039\u0027} and {@code \u0027\\u005Cu0061\u0027} through\n     * {@code \u0027\\u005Cu0066\u0027}. If uppercase letters are\n     * desired, the {@link java.lang.String#toUpperCase()} method may\n     * be called on the result:\n     *\n     * \u003cblockquote\u003e\n     *  {@code Integer.toHexString(n).toUpperCase()}\n     * \u003c/blockquote\u003e\n     *\n     * @apiNote\n     * The {@link java.util.HexFormat} class provides formatting and parsing\n     * of byte arrays and primitives to return a string or adding to an {@link Appendable}.\n     * {@code HexFormat} formats and parses uppercase or lowercase hexadecimal characters,\n     * with leading zeros and for byte arrays includes for each byte\n     * a delimiter, prefix, and suffix.\n     *\n     * @param   i   an integer to be converted to a string.\n     * @return  the string representation of the unsigned integer value\n     *          represented by the argument in hexadecimal (base\u0026nbsp;16).\n     * @see java.util.HexFormat\n     * @see #parseUnsignedInt(String, int)\n     * @see #toUnsignedString(int, int)\n     * @since   1.0.2\n     */\n    public static String toHexString(int i) {\n        return toUnsignedString0(i, 4);\n    }\n\n    /**\n     * Returns a string representation of the integer argument as an\n     * unsigned integer in base\u0026nbsp;8.\n     *\n     * \u003cp\u003eThe unsigned integer value is the argument plus 2\u003csup\u003e32\u003c/sup\u003e\n     * if the argument is negative; otherwise, it is equal to the\n     * argument.  This value is converted to a string of ASCII digits\n     * in octal (base\u0026nbsp;8) with no extra leading {@code 0}s.\n     *\n     * \u003cp\u003eThe value of the argument can be recovered from the returned\n     * string {@code s} by calling {@link\n     * Integer#parseUnsignedInt(String, int)\n     * Integer.parseUnsignedInt(s, 8)}.\n     *\n     * \u003cp\u003eIf the unsigned magnitude is zero, it is represented by a\n     * single zero character {@code \u00270\u0027} ({@code \u0027\\u005Cu0030\u0027});\n     * otherwise, the first character of the representation of the\n     * unsigned magnitude will not be the zero character. The\n     * following characters are used as octal digits:\n     *\n     * \u003cblockquote\u003e\n     * {@code 01234567}\n     * \u003c/blockquote\u003e\n     *\n     * These are the characters {@code \u0027\\u005Cu0030\u0027} through\n     * {@code \u0027\\u005Cu0037\u0027}.\n     *\n     * @param   i   an integer to be converted to a string.\n     * @return  the string representation of the unsigned integer value\n     *          represented by the argument in octal (base\u0026nbsp;8).\n     * @see #parseUnsignedInt(String, int)\n     * @see #toUnsignedString(int, int)\n     * @since   1.0.2\n     */\n    public static String toOctalString(int i) {\n        return toUnsignedString0(i, 3);\n    }\n\n    /**\n     * Returns a string representation of the integer argument as an\n     * unsigned integer in base\u0026nbsp;2.\n     *\n     * \u003cp\u003eThe unsigned integer value is the argument plus 2\u003csup\u003e32\u003c/sup\u003e\n     * if the argument is negative; otherwise it is equal to the\n     * argument.  This value is converted to a string of ASCII digits\n     * in binary (base\u0026nbsp;2) with no extra leading {@code 0}s.\n     *\n     * \u003cp\u003eThe value of the argument can be recovered from the returned\n     * string {@code s} by calling {@link\n     * Integer#parseUnsignedInt(String, int)\n     * Integer.parseUnsignedInt(s, 2)}.\n     *\n     * \u003cp\u003eIf the unsigned magnitude is zero, it is represented by a\n     * single zero character {@code \u00270\u0027} ({@code \u0027\\u005Cu0030\u0027});\n     * otherwise, the first character of the representation of the\n     * unsigned magnitude will not be the zero character. The\n     * characters {@code \u00270\u0027} ({@code \u0027\\u005Cu0030\u0027}) and {@code\n     * \u00271\u0027} ({@code \u0027\\u005Cu0031\u0027}) are used as binary digits.\n     *\n     * @param   i   an integer to be converted to a string.\n     * @return  the string representation of the unsigned integer value\n     *          represented by the argument in binary (base\u0026nbsp;2).\n     * @see #parseUnsignedInt(String, int)\n     * @see #toUnsignedString(int, int)\n     * @since   1.0.2\n     */\n    public static String toBinaryString(int i) {\n        return toUnsignedString0(i, 1);\n    }\n\n    /**\n     * Convert the integer to an unsigned number.\n     */\n    private static String toUnsignedString0(int val, int shift) {\n        // assert shift \u003e 0 \u0026\u0026 shift \u003c\u003d5 : \"Illegal shift value\";\n        int mag \u003d Integer.SIZE - Integer.numberOfLeadingZeros(val);\n        int chars \u003d Math.max(((mag + (shift - 1)) / shift), 1);\n        if (COMPACT_STRINGS) {\n            byte[] buf \u003d new byte[chars];\n            formatUnsignedInt(val, shift, buf, chars);\n            return new String(buf, LATIN1);\n        } else {\n            byte[] buf \u003d new byte[chars * 2];\n            formatUnsignedIntUTF16(val, shift, buf, chars);\n            return new String(buf, UTF16);\n        }\n    }\n\n    /**\n     * Format an {@code int} (treated as unsigned) into a byte buffer (LATIN1 version). If\n     * {@code len} exceeds the formatted ASCII representation of {@code val},\n     * {@code buf} will be padded with leading zeroes.\n     *\n     * @param val the unsigned int to format\n     * @param shift the log2 of the base to format in (4 for hex, 3 for octal, 1 for binary)\n     * @param buf the byte buffer to write to\n     * @param len the number of characters to write\n     */\n    private static void formatUnsignedInt(int val, int shift, byte[] buf, int len) {\n        int charPos \u003d len;\n        int radix \u003d 1 \u003c\u003c shift;\n        int mask \u003d radix - 1;\n        do {\n            buf[--charPos] \u003d (byte)Integer.digits[val \u0026 mask];\n            val \u003e\u003e\u003e\u003d shift;\n        } while (charPos \u003e 0);\n    }\n\n    /**\n     * Format an {@code int} (treated as unsigned) into a byte buffer (UTF16 version). If\n     * {@code len} exceeds the formatted ASCII representation of {@code val},\n     * {@code buf} will be padded with leading zeroes.\n     *\n     * @param val the unsigned int to format\n     * @param shift the log2 of the base to format in (4 for hex, 3 for octal, 1 for binary)\n     * @param buf the byte buffer to write to\n     * @param len the number of characters to write\n     */\n    private static void formatUnsignedIntUTF16(int val, int shift, byte[] buf, int len) {\n        int charPos \u003d len;\n        int radix \u003d 1 \u003c\u003c shift;\n        int mask \u003d radix - 1;\n        do {\n            StringUTF16.putChar(buf, --charPos, Integer.digits[val \u0026 mask]);\n            val \u003e\u003e\u003e\u003d shift;\n        } while (charPos \u003e 0);\n    }\n\n    static final byte[] DigitTens \u003d {\n        \u00270\u0027, \u00270\u0027, \u00270\u0027, \u00270\u0027, \u00270\u0027, \u00270\u0027, \u00270\u0027, \u00270\u0027, \u00270\u0027, \u00270\u0027,\n        \u00271\u0027, \u00271\u0027, \u00271\u0027, \u00271\u0027, \u00271\u0027, \u00271\u0027, \u00271\u0027, \u00271\u0027, \u00271\u0027, \u00271\u0027,\n        \u00272\u0027, \u00272\u0027, \u00272\u0027, \u00272\u0027, \u00272\u0027, \u00272\u0027, \u00272\u0027, \u00272\u0027, \u00272\u0027, \u00272\u0027,\n        \u00273\u0027, \u00273\u0027, \u00273\u0027, \u00273\u0027, \u00273\u0027, \u00273\u0027, \u00273\u0027, \u00273\u0027, \u00273\u0027, \u00273\u0027,\n        \u00274\u0027, \u00274\u0027, \u00274\u0027, \u00274\u0027, \u00274\u0027, \u00274\u0027, \u00274\u0027, \u00274\u0027, \u00274\u0027, \u00274\u0027,\n        \u00275\u0027, \u00275\u0027, \u00275\u0027, \u00275\u0027, \u00275\u0027, \u00275\u0027, \u00275\u0027, \u00275\u0027, \u00275\u0027, \u00275\u0027,\n        \u00276\u0027, \u00276\u0027, \u00276\u0027, \u00276\u0027, \u00276\u0027, \u00276\u0027, \u00276\u0027, \u00276\u0027, \u00276\u0027, \u00276\u0027,\n        \u00277\u0027, \u00277\u0027, \u00277\u0027, \u00277\u0027, \u00277\u0027, \u00277\u0027, \u00277\u0027, \u00277\u0027, \u00277\u0027, \u00277\u0027,\n        \u00278\u0027, \u00278\u0027, \u00278\u0027, \u00278\u0027, \u00278\u0027, \u00278\u0027, \u00278\u0027, \u00278\u0027, \u00278\u0027, \u00278\u0027,\n        \u00279\u0027, \u00279\u0027, \u00279\u0027, \u00279\u0027, \u00279\u0027, \u00279\u0027, \u00279\u0027, \u00279\u0027, \u00279\u0027, \u00279\u0027,\n        } ;\n\n    static final byte[] DigitOnes \u003d {\n        \u00270\u0027, \u00271\u0027, \u00272\u0027, \u00273\u0027, \u00274\u0027, \u00275\u0027, \u00276\u0027, \u00277\u0027, \u00278\u0027, \u00279\u0027,\n        \u00270\u0027, \u00271\u0027, \u00272\u0027, \u00273\u0027, \u00274\u0027, \u00275\u0027, \u00276\u0027, \u00277\u0027, \u00278\u0027, \u00279\u0027,\n        \u00270\u0027, \u00271\u0027, \u00272\u0027, \u00273\u0027, \u00274\u0027, \u00275\u0027, \u00276\u0027, \u00277\u0027, \u00278\u0027, \u00279\u0027,\n        \u00270\u0027, \u00271\u0027, \u00272\u0027, \u00273\u0027, \u00274\u0027, \u00275\u0027, \u00276\u0027, \u00277\u0027, \u00278\u0027, \u00279\u0027,\n        \u00270\u0027, \u00271\u0027, \u00272\u0027, \u00273\u0027, \u00274\u0027, \u00275\u0027, \u00276\u0027, \u00277\u0027, \u00278\u0027, \u00279\u0027,\n        \u00270\u0027, \u00271\u0027, \u00272\u0027, \u00273\u0027, \u00274\u0027, \u00275\u0027, \u00276\u0027, \u00277\u0027, \u00278\u0027, \u00279\u0027,\n        \u00270\u0027, \u00271\u0027, \u00272\u0027, \u00273\u0027, \u00274\u0027, \u00275\u0027, \u00276\u0027, \u00277\u0027, \u00278\u0027, \u00279\u0027,\n        \u00270\u0027, \u00271\u0027, \u00272\u0027, \u00273\u0027, \u00274\u0027, \u00275\u0027, \u00276\u0027, \u00277\u0027, \u00278\u0027, \u00279\u0027,\n        \u00270\u0027, \u00271\u0027, \u00272\u0027, \u00273\u0027, \u00274\u0027, \u00275\u0027, \u00276\u0027, \u00277\u0027, \u00278\u0027, \u00279\u0027,\n        \u00270\u0027, \u00271\u0027, \u00272\u0027, \u00273\u0027, \u00274\u0027, \u00275\u0027, \u00276\u0027, \u00277\u0027, \u00278\u0027, \u00279\u0027,\n        } ;\n\n\n    /**\n     * Returns a {@code String} object representing the\n     * specified integer. The argument is converted to signed decimal\n     * representation and returned as a string, exactly as if the\n     * argument and radix 10 were given as arguments to the {@link\n     * #toString(int, int)} method.\n     *\n     * @param   i   an integer to be converted.\n     * @return  a string representation of the argument in base\u0026nbsp;10.\n     */\n    @IntrinsicCandidate\n    public static String toString(int i) {\n        int size \u003d stringSize(i);\n        if (COMPACT_STRINGS) {\n            byte[] buf \u003d new byte[size];\n            getChars(i, size, buf);\n            return new String(buf, LATIN1);\n        } else {\n            byte[] buf \u003d new byte[size * 2];\n            StringUTF16.getChars(i, size, buf);\n            return new String(buf, UTF16);\n        }\n    }\n\n    /**\n     * Returns a string representation of the argument as an unsigned\n     * decimal value.\n     *\n     * The argument is converted to unsigned decimal representation\n     * and returned as a string exactly as if the argument and radix\n     * 10 were given as arguments to the {@link #toUnsignedString(int,\n     * int)} method.\n     *\n     * @param   i  an integer to be converted to an unsigned string.\n     * @return  an unsigned string representation of the argument.\n     * @see     #toUnsignedString(int, int)\n     * @since 1.8\n     */\n    public static String toUnsignedString(int i) {\n        return Long.toString(toUnsignedLong(i));\n    }\n\n    /**\n     * Places characters representing the integer i into the\n     * character array buf. The characters are placed into\n     * the buffer backwards starting with the least significant\n     * digit at the specified index (exclusive), and working\n     * backwards from there.\n     *\n     * @implNote This method converts positive inputs into negative\n     * values, to cover the Integer.MIN_VALUE case. Converting otherwise\n     * (negative to positive) will expose -Integer.MIN_VALUE that overflows\n     * integer.\n     *\n     * @param i     value to convert\n     * @param index next index, after the least significant digit\n     * @param buf   target buffer, Latin1-encoded\n     * @return index of the most significant digit or minus sign, if present\n     */\n    static int getChars(int i, int index, byte[] buf) {\n        int q, r;\n        int charPos \u003d index;\n\n        boolean negative \u003d i \u003c 0;\n        if (!negative) {\n            i \u003d -i;\n        }\n\n        // Generate two digits per iteration\n        while (i \u003c\u003d -100) {\n            q \u003d i / 100;\n            r \u003d (q * 100) - i;\n            i \u003d q;\n            buf[--charPos] \u003d DigitOnes[r];\n            buf[--charPos] \u003d DigitTens[r];\n        }\n\n        // We know there are at most two digits left at this point.\n        q \u003d i / 10;\n        r \u003d (q * 10) - i;\n        buf[--charPos] \u003d (byte)(\u00270\u0027 + r);\n\n        // Whatever left is the remaining digit.\n        if (q \u003c 0) {\n            buf[--charPos] \u003d (byte)(\u00270\u0027 - q);\n        }\n\n        if (negative) {\n            buf[--charPos] \u003d (byte)\u0027-\u0027;\n        }\n        return charPos;\n    }\n\n    // Left here for compatibility reasons, see JDK-8143900.\n    static final int [] sizeTable \u003d { 9, 99, 999, 9999, 99999, 999999, 9999999,\n                                      99999999, 999999999, Integer.MAX_VALUE };\n\n    /**\n     * Returns the string representation size for a given int value.\n     *\n     * @param x int value\n     * @return string size\n     *\n     * @implNote There are other ways to compute this: e.g. binary search,\n     * but values are biased heavily towards zero, and therefore linear search\n     * wins. The iteration results are also routinely inlined in the generated\n     * code after loop unrolling.\n     */\n    static int stringSize(int x) {\n        int d \u003d 1;\n        if (x \u003e\u003d 0) {\n            d \u003d 0;\n            x \u003d -x;\n        }\n        int p \u003d -10;\n        for (int i \u003d 1; i \u003c 10; i++) {\n            if (x \u003e p)\n                return i + d;\n            p \u003d 10 * p;\n        }\n        return 10 + d;\n    }\n\n    /**\n     * Parses the string argument as a signed integer in the radix\n     * specified by the second argument. The characters in the string\n     * must all be digits of the specified radix (as determined by\n     * whether {@link java.lang.Character#digit(char, int)} returns a\n     * nonnegative value), except that the first character may be an\n     * ASCII minus sign {@code \u0027-\u0027} ({@code \u0027\\u005Cu002D\u0027}) to\n     * indicate a negative value or an ASCII plus sign {@code \u0027+\u0027}\n     * ({@code \u0027\\u005Cu002B\u0027}) to indicate a positive value. The\n     * resulting integer value is returned.\n     *\n     * \u003cp\u003eAn exception of type {@code NumberFormatException} is\n     * thrown if any of the following situations occurs:\n     * \u003cul\u003e\n     * \u003cli\u003eThe first argument is {@code null} or is a string of\n     * length zero.\n     *\n     * \u003cli\u003eThe radix is either smaller than\n     * {@link java.lang.Character#MIN_RADIX} or\n     * larger than {@link java.lang.Character#MAX_RADIX}.\n     *\n     * \u003cli\u003eAny character of the string is not a digit of the specified\n     * radix, except that the first character may be a minus sign\n     * {@code \u0027-\u0027} ({@code \u0027\\u005Cu002D\u0027}) or plus sign\n     * {@code \u0027+\u0027} ({@code \u0027\\u005Cu002B\u0027}) provided that the\n     * string is longer than length 1.\n     *\n     * \u003cli\u003eThe value represented by the string is not a value of type\n     * {@code int}.\n     * \u003c/ul\u003e\n     *\n     * \u003cp\u003eExamples:\n     * \u003cblockquote\u003e\u003cpre\u003e\n     * parseInt(\"0\", 10) returns 0\n     * parseInt(\"473\", 10) returns 473\n     * parseInt(\"+42\", 10) returns 42\n     * parseInt(\"-0\", 10) returns 0\n     * parseInt(\"-FF\", 16) returns -255\n     * parseInt(\"1100110\", 2) returns 102\n     * parseInt(\"2147483647\", 10) returns 2147483647\n     * parseInt(\"-2147483648\", 10) returns -2147483648\n     * parseInt(\"2147483648\", 10) throws a NumberFormatException\n     * parseInt(\"99\", 8) throws a NumberFormatException\n     * parseInt(\"Kona\", 10) throws a NumberFormatException\n     * parseInt(\"Kona\", 27) returns 411787\n     * \u003c/pre\u003e\u003c/blockquote\u003e\n     *\n     * @param      s   the {@code String} containing the integer\n     *                  representation to be parsed\n     * @param      radix   the radix to be used while parsing {@code s}.\n     * @return     the integer represented by the string argument in the\n     *             specified radix.\n     * @throws     NumberFormatException if the {@code String}\n     *             does not contain a parsable {@code int}.\n     */\n    public static int parseInt(String s, int radix)\n                throws NumberFormatException\n    {\n        /*\n         * WARNING: This method may be invoked early during VM initialization\n         * before IntegerCache is initialized. Care must be taken to not use\n         * the valueOf method.\n         */\n\n        if (s \u003d\u003d null) {\n            throw new NumberFormatException(\"Cannot parse null string\");\n        }\n\n        if (radix \u003c Character.MIN_RADIX) {\n            throw new NumberFormatException(\"radix \" + radix +\n                                            \" less than Character.MIN_RADIX\");\n        }\n\n        if (radix \u003e Character.MAX_RADIX) {\n            throw new NumberFormatException(\"radix \" + radix +\n                                            \" greater than Character.MAX_RADIX\");\n        }\n\n        boolean negative \u003d false;\n        int i \u003d 0, len \u003d s.length();\n        int limit \u003d -Integer.MAX_VALUE;\n\n        if (len \u003e 0) {\n            char firstChar \u003d s.charAt(0);\n            if (firstChar \u003c \u00270\u0027) { // Possible leading \"+\" or \"-\"\n                if (firstChar \u003d\u003d \u0027-\u0027) {\n                    negative \u003d true;\n                    limit \u003d Integer.MIN_VALUE;\n                } else if (firstChar !\u003d \u0027+\u0027) {\n                    throw NumberFormatException.forInputString(s, radix);\n                }\n\n                if (len \u003d\u003d 1) { // Cannot have lone \"+\" or \"-\"\n                    throw NumberFormatException.forInputString(s, radix);\n                }\n                i++;\n            }\n            int multmin \u003d limit / radix;\n            int result \u003d 0;\n            while (i \u003c len) {\n                // Accumulating negatively avoids surprises near MAX_VALUE\n                int digit \u003d Character.digit(s.charAt(i++), radix);\n                if (digit \u003c 0 || result \u003c multmin) {\n                    throw NumberFormatException.forInputString(s, radix);\n                }\n                result *\u003d radix;\n                if (result \u003c limit + digit) {\n                    throw NumberFormatException.forInputString(s, radix);\n                }\n                result -\u003d digit;\n            }\n            return negative ? result : -result;\n        } else {\n            throw NumberFormatException.forInputString(s, radix);\n        }\n    }\n\n    /**\n     * Parses the {@link CharSequence} argument as a signed {@code int} in the\n     * specified {@code radix}, beginning at the specified {@code beginIndex}\n     * and extending to {@code endIndex - 1}.\n     *\n     * \u003cp\u003eThe method does not take steps to guard against the\n     * {@code CharSequence} being mutated while parsing.\n     *\n     * @param      s   the {@code CharSequence} containing the {@code int}\n     *                  representation to be parsed\n     * @param      beginIndex   the beginning index, inclusive.\n     * @param      endIndex     the ending index, exclusive.\n     * @param      radix   the radix to be used while parsing {@code s}.\n     * @return     the signed {@code int} represented by the subsequence in\n     *             the specified radix.\n     * @throws     NullPointerException  if {@code s} is null.\n     * @throws     IndexOutOfBoundsException  if {@code beginIndex} is\n     *             negative, or if {@code beginIndex} is greater than\n     *             {@code endIndex} or if {@code endIndex} is greater than\n     *             {@code s.length()}.\n     * @throws     NumberFormatException  if the {@code CharSequence} does not\n     *             contain a parsable {@code int} in the specified\n     *             {@code radix}, or if {@code radix} is either smaller than\n     *             {@link java.lang.Character#MIN_RADIX} or larger than\n     *             {@link java.lang.Character#MAX_RADIX}.\n     * @since  9\n     */\n    public static int parseInt(CharSequence s, int beginIndex, int endIndex, int radix)\n                throws NumberFormatException {\n        Objects.requireNonNull(s);\n\n        if (beginIndex \u003c 0 || beginIndex \u003e endIndex || endIndex \u003e s.length()) {\n            throw new IndexOutOfBoundsException();\n        }\n        if (radix \u003c Character.MIN_RADIX) {\n            throw new NumberFormatException(\"radix \" + radix +\n                                            \" less than Character.MIN_RADIX\");\n        }\n        if (radix \u003e Character.MAX_RADIX) {\n            throw new NumberFormatException(\"radix \" + radix +\n                                            \" greater than Character.MAX_RADIX\");\n        }\n\n        boolean negative \u003d false;\n        int i \u003d beginIndex;\n        int limit \u003d -Integer.MAX_VALUE;\n\n        if (i \u003c endIndex) {\n            char firstChar \u003d s.charAt(i);\n            if (firstChar \u003c \u00270\u0027) { // Possible leading \"+\" or \"-\"\n                if (firstChar \u003d\u003d \u0027-\u0027) {\n                    negative \u003d true;\n                    limit \u003d Integer.MIN_VALUE;\n                } else if (firstChar !\u003d \u0027+\u0027) {\n                    throw NumberFormatException.forCharSequence(s, beginIndex,\n                            endIndex, i);\n                }\n                i++;\n                if (i \u003d\u003d endIndex) { // Cannot have lone \"+\" or \"-\"\n                    throw NumberFormatException.forCharSequence(s, beginIndex,\n                            endIndex, i);\n                }\n            }\n            int multmin \u003d limit / radix;\n            int result \u003d 0;\n            while (i \u003c endIndex) {\n                // Accumulating negatively avoids surprises near MAX_VALUE\n                int digit \u003d Character.digit(s.charAt(i), radix);\n                if (digit \u003c 0 || result \u003c multmin) {\n                    throw NumberFormatException.forCharSequence(s, beginIndex,\n                            endIndex, i);\n                }\n                result *\u003d radix;\n                if (result \u003c limit + digit) {\n                    throw NumberFormatException.forCharSequence(s, beginIndex,\n                            endIndex, i);\n                }\n                i++;\n                result -\u003d digit;\n            }\n            return negative ? result : -result;\n        } else {\n            throw NumberFormatException.forInputString(\"\", radix);\n        }\n    }\n\n    /**\n     * Parses the string argument as a signed decimal integer. The\n     * characters in the string must all be decimal digits, except\n     * that the first character may be an ASCII minus sign {@code \u0027-\u0027}\n     * ({@code \u0027\\u005Cu002D\u0027}) to indicate a negative value or an\n     * ASCII plus sign {@code \u0027+\u0027} ({@code \u0027\\u005Cu002B\u0027}) to\n     * indicate a positive value. The resulting integer value is\n     * returned, exactly as if the argument and the radix 10 were\n     * given as arguments to the {@link #parseInt(java.lang.String,\n     * int)} method.\n     *\n     * @param s    a {@code String} containing the {@code int}\n     *             representation to be parsed\n     * @return     the integer value represented by the argument in decimal.\n     * @throws     NumberFormatException  if the string does not contain a\n     *               parsable integer.\n     */\n    public static int parseInt(String s) throws NumberFormatException {\n        return parseInt(s,10);\n    }\n\n    /**\n     * Parses the string argument as an unsigned integer in the radix\n     * specified by the second argument.  An unsigned integer maps the\n     * values usually associated with negative numbers to positive\n     * numbers larger than {@code MAX_VALUE}.\n     *\n     * The characters in the string must all be digits of the\n     * specified radix (as determined by whether {@link\n     * java.lang.Character#digit(char, int)} returns a nonnegative\n     * value), except that the first character may be an ASCII plus\n     * sign {@code \u0027+\u0027} ({@code \u0027\\u005Cu002B\u0027}). The resulting\n     * integer value is returned.\n     *\n     * \u003cp\u003eAn exception of type {@code NumberFormatException} is\n     * thrown if any of the following situations occurs:\n     * \u003cul\u003e\n     * \u003cli\u003eThe first argument is {@code null} or is a string of\n     * length zero.\n     *\n     * \u003cli\u003eThe radix is either smaller than\n     * {@link java.lang.Character#MIN_RADIX} or\n     * larger than {@link java.lang.Character#MAX_RADIX}.\n     *\n     * \u003cli\u003eAny character of the string is not a digit of the specified\n     * radix, except that the first character may be a plus sign\n     * {@code \u0027+\u0027} ({@code \u0027\\u005Cu002B\u0027}) provided that the\n     * string is longer than length 1.\n     *\n     * \u003cli\u003eThe value represented by the string is larger than the\n     * largest unsigned {@code int}, 2\u003csup\u003e32\u003c/sup\u003e-1.\n     *\n     * \u003c/ul\u003e\n     *\n     *\n     * @param      s   the {@code String} containing the unsigned integer\n     *                  representation to be parsed\n     * @param      radix   the radix to be used while parsing {@code s}.\n     * @return     the integer represented by the string argument in the\n     *             specified radix.\n     * @throws     NumberFormatException if the {@code String}\n     *             does not contain a parsable {@code int}.\n     * @since 1.8\n     */\n    public static int parseUnsignedInt(String s, int radix)\n                throws NumberFormatException {\n        if (s \u003d\u003d null)  {\n            throw new NumberFormatException(\"Cannot parse null string\");\n        }\n\n        int len \u003d s.length();\n        if (len \u003e 0) {\n            char firstChar \u003d s.charAt(0);\n            if (firstChar \u003d\u003d \u0027-\u0027) {\n                throw new\n                    NumberFormatException(String.format(\"Illegal leading minus sign \" +\n                                                       \"on unsigned string %s.\", s));\n            } else {\n                if (len \u003c\u003d 5 || // Integer.MAX_VALUE in Character.MAX_RADIX is 6 digits\n                    (radix \u003d\u003d 10 \u0026\u0026 len \u003c\u003d 9) ) { // Integer.MAX_VALUE in base 10 is 10 digits\n                    return parseInt(s, radix);\n                } else {\n                    long ell \u003d Long.parseLong(s, radix);\n                    if ((ell \u0026 0xffff_ffff_0000_0000L) \u003d\u003d 0) {\n                        return (int) ell;\n                    } else {\n                        throw new\n                            NumberFormatException(String.format(\"String value %s exceeds \" +\n                                                                \"range of unsigned int.\", s));\n                    }\n                }\n            }\n        } else {\n            throw NumberFormatException.forInputString(s, radix);\n        }\n    }\n\n    /**\n     * Parses the {@link CharSequence} argument as an unsigned {@code int} in\n     * the specified {@code radix}, beginning at the specified\n     * {@code beginIndex} and extending to {@code endIndex - 1}.\n     *\n     * \u003cp\u003eThe method does not take steps to guard against the\n     * {@code CharSequence} being mutated while parsing.\n     *\n     * @param      s   the {@code CharSequence} containing the unsigned\n     *                 {@code int} representation to be parsed\n     * @param      beginIndex   the beginning index, inclusive.\n     * @param      endIndex     the ending index, exclusive.\n     * @param      radix   the radix to be used while parsing {@code s}.\n     * @return     the unsigned {@code int} represented by the subsequence in\n     *             the specified radix.\n     * @throws     NullPointerException  if {@code s} is null.\n     * @throws     IndexOutOfBoundsException  if {@code beginIndex} is\n     *             negative, or if {@code beginIndex} is greater than\n     *             {@code endIndex} or if {@code endIndex} is greater than\n     *             {@code s.length()}.\n     * @throws     NumberFormatException  if the {@code CharSequence} does not\n     *             contain a parsable unsigned {@code int} in the specified\n     *             {@code radix}, or if {@code radix} is either smaller than\n     *             {@link java.lang.Character#MIN_RADIX} or larger than\n     *             {@link java.lang.Character#MAX_RADIX}.\n     * @since  9\n     */\n    public static int parseUnsignedInt(CharSequence s, int beginIndex, int endIndex, int radix)\n                throws NumberFormatException {\n        Objects.requireNonNull(s);\n\n        if (beginIndex \u003c 0 || beginIndex \u003e endIndex || endIndex \u003e s.length()) {\n            throw new IndexOutOfBoundsException();\n        }\n        int start \u003d beginIndex, len \u003d endIndex - beginIndex;\n\n        if (len \u003e 0) {\n            char firstChar \u003d s.charAt(start);\n            if (firstChar \u003d\u003d \u0027-\u0027) {\n                throw new\n                    NumberFormatException(String.format(\"Illegal leading minus sign \" +\n                                                       \"on unsigned string %s.\", s));\n            } else {\n                if (len \u003c\u003d 5 || // Integer.MAX_VALUE in Character.MAX_RADIX is 6 digits\n                        (radix \u003d\u003d 10 \u0026\u0026 len \u003c\u003d 9)) { // Integer.MAX_VALUE in base 10 is 10 digits\n                    return parseInt(s, start, start + len, radix);\n                } else {\n                    long ell \u003d Long.parseLong(s, start, start + len, radix);\n                    if ((ell \u0026 0xffff_ffff_0000_0000L) \u003d\u003d 0) {\n                        return (int) ell;\n                    } else {\n                        throw new\n                            NumberFormatException(String.format(\"String value %s exceeds \" +\n                                                                \"range of unsigned int.\", s));\n                    }\n                }\n            }\n        } else {\n            throw new NumberFormatException(\"\");\n        }\n    }\n\n    /**\n     * Parses the string argument as an unsigned decimal integer. The\n     * characters in the string must all be decimal digits, except\n     * that the first character may be an ASCII plus sign {@code\n     * \u0027+\u0027} ({@code \u0027\\u005Cu002B\u0027}). The resulting integer value\n     * is returned, exactly as if the argument and the radix 10 were\n     * given as arguments to the {@link\n     * #parseUnsignedInt(java.lang.String, int)} method.\n     *\n     * @param s   a {@code String} containing the unsigned {@code int}\n     *            representation to be parsed\n     * @return    the unsigned integer value represented by the argument in decimal.\n     * @throws    NumberFormatException  if the string does not contain a\n     *            parsable unsigned integer.\n     * @since 1.8\n     */\n    public static int parseUnsignedInt(String s) throws NumberFormatException {\n        return parseUnsignedInt(s, 10);\n    }\n\n    /**\n     * Returns an {@code Integer} object holding the value\n     * extracted from the specified {@code String} when parsed\n     * with the radix given by the second argument. The first argument\n     * is interpreted as representing a signed integer in the radix\n     * specified by the second argument, exactly as if the arguments\n     * were given to the {@link #parseInt(java.lang.String, int)}\n     * method. The result is an {@code Integer} object that\n     * represents the integer value specified by the string.\n     *\n     * \u003cp\u003eIn other words, this method returns an {@code Integer}\n     * object equal to the value of:\n     *\n     * \u003cblockquote\u003e\n     *  {@code new Integer(Integer.parseInt(s, radix))}\n     * \u003c/blockquote\u003e\n     *\n     * @param      s   the string to be parsed.\n     * @param      radix the radix to be used in interpreting {@code s}\n     * @return     an {@code Integer} object holding the value\n     *             represented by the string argument in the specified\n     *             radix.\n     * @throws    NumberFormatException if the {@code String}\n     *            does not contain a parsable {@code int}.\n     */\n    public static Integer valueOf(String s, int radix) throws NumberFormatException {\n        return Integer.valueOf(parseInt(s,radix));\n    }\n\n    /**\n     * Returns an {@code Integer} object holding the\n     * value of the specified {@code String}. The argument is\n     * interpreted as representing a signed decimal integer, exactly\n     * as if the argument were given to the {@link\n     * #parseInt(java.lang.String)} method. The result is an\n     * {@code Integer} object that represents the integer value\n     * specified by the string.\n     *\n     * \u003cp\u003eIn other words, this method returns an {@code Integer}\n     * object equal to the value of:\n     *\n     * \u003cblockquote\u003e\n     *  {@code new Integer(Integer.parseInt(s))}\n     * \u003c/blockquote\u003e\n     *\n     * @param      s   the string to be parsed.\n     * @return     an {@code Integer} object holding the value\n     *             represented by the string argument.\n     * @throws     NumberFormatException  if the string cannot be parsed\n     *             as an integer.\n     */\n    public static Integer valueOf(String s) throws NumberFormatException {\n        return Integer.valueOf(parseInt(s, 10));\n    }\n\n    /**\n     * Cache to support the object identity semantics of autoboxing for values between\n     * -128 and 127 (inclusive) as required by JLS.\n     *\n     * The cache is initialized on first usage.  The size of the cache\n     * may be controlled by the {@code -XX:AutoBoxCacheMax\u003d\u003csize\u003e} option.\n     * During VM initialization, java.lang.Integer.IntegerCache.high property\n     * may be set and saved in the private system properties in the\n     * jdk.internal.misc.VM class.\n     *\n     * WARNING: The cache is archived with CDS and reloaded from the shared\n     * archive at runtime. The archived cache (Integer[]) and Integer objects\n     * reside in the closed archive heap regions. Care should be taken when\n     * changing the implementation and the cache array should not be assigned\n     * with new Integer object(s) after initialization.\n     */\n\n    private static class IntegerCache {\n        static final int low \u003d -128;\n        static final int high;\n        static final Integer[] cache;\n        static Integer[] archivedCache;\n\n        static {\n            // high value may be configured by property\n            int h \u003d 127;\n            String integerCacheHighPropValue \u003d\n                VM.getSavedProperty(\"java.lang.Integer.IntegerCache.high\");\n            if (integerCacheHighPropValue !\u003d null) {\n                try {\n                    h \u003d Math.max(parseInt(integerCacheHighPropValue), 127);\n                    // Maximum array size is Integer.MAX_VALUE\n                    h \u003d Math.min(h, Integer.MAX_VALUE - (-low) -1);\n                } catch( NumberFormatException nfe) {\n                    // If the property cannot be parsed into an int, ignore it.\n                }\n            }\n            high \u003d h;\n\n            // Load IntegerCache.archivedCache from archive, if possible\n            CDS.initializeFromArchive(IntegerCache.class);\n            int size \u003d (high - low) + 1;\n\n            // Use the archived cache if it exists and is large enough\n            if (archivedCache \u003d\u003d null || size \u003e archivedCache.length) {\n                Integer[] c \u003d new Integer[size];\n                int j \u003d low;\n                for(int i \u003d 0; i \u003c c.length; i++) {\n                    c[i] \u003d new Integer(j++);\n                }\n                archivedCache \u003d c;\n            }\n            cache \u003d archivedCache;\n            // range [-128, 127] must be interned (JLS7 5.1.7)\n            assert IntegerCache.high \u003e\u003d 127;\n        }\n\n        private IntegerCache() {}\n    }\n\n    /**\n     * Returns an {@code Integer} instance representing the specified\n     * {@code int} value.  If a new {@code Integer} instance is not\n     * required, this method should generally be used in preference to\n     * the constructor {@link #Integer(int)}, as this method is likely\n     * to yield significantly better space and time performance by\n     * caching frequently requested values.\n     *\n     * This method will always cache values in the range -128 to 127,\n     * inclusive, and may cache other values outside of this range.\n     *\n     * @param  i an {@code int} value.\n     * @return an {@code Integer} instance representing {@code i}.\n     * @since  1.5\n     */\n    @IntrinsicCandidate\n    public static Integer valueOf(int i) {\n        if (i \u003e\u003d IntegerCache.low \u0026\u0026 i \u003c\u003d IntegerCache.high)\n            return IntegerCache.cache[i + (-IntegerCache.low)];\n        return new Integer(i);\n    }\n\n    /**\n     * The value of the {@code Integer}.\n     *\n     * @serial\n     */\n    private final int value;\n\n    /**\n     * Constructs a newly allocated {@code Integer} object that\n     * represents the specified {@code int} value.\n     *\n     * @param   value   the value to be represented by the\n     *                  {@code Integer} object.\n     *\n     * @deprecated\n     * It is rarely appropriate to use this constructor. The static factory\n     * {@link #valueOf(int)} is generally a better choice, as it is\n     * likely to yield significantly better space and time performance.\n     */\n    @Deprecated(since\u003d\"9\", forRemoval \u003d true)\n    public Integer(int value) {\n        this.value \u003d value;\n    }\n\n    /**\n     * Constructs a newly allocated {@code Integer} object that\n     * represents the {@code int} value indicated by the\n     * {@code String} parameter. The string is converted to an\n     * {@code int} value in exactly the manner used by the\n     * {@code parseInt} method for radix 10.\n     *\n     * @param   s   the {@code String} to be converted to an {@code Integer}.\n     * @throws      NumberFormatException if the {@code String} does not\n     *              contain a parsable integer.\n     *\n     * @deprecated\n     * It is rarely appropriate to use this constructor.\n     * Use {@link #parseInt(String)} to convert a string to a\n     * {@code int} primitive, or use {@link #valueOf(String)}\n     * to convert a string to an {@code Integer} object.\n     */\n    @Deprecated(since\u003d\"9\", forRemoval \u003d true)\n    public Integer(String s) throws NumberFormatException {\n        this.value \u003d parseInt(s, 10);\n    }\n\n    /**\n     * Returns the value of this {@code Integer} as a {@code byte}\n     * after a narrowing primitive conversion.\n     * @jls 5.1.3 Narrowing Primitive Conversion\n     */\n    public byte byteValue() {\n        return (byte)value;\n    }\n\n    /**\n     * Returns the value of this {@code Integer} as a {@code short}\n     * after a narrowing primitive conversion.\n     * @jls 5.1.3 Narrowing Primitive Conversion\n     */\n    public short shortValue() {\n        return (short)value;\n    }\n\n    /**\n     * Returns the value of this {@code Integer} as an\n     * {@code int}.\n     */\n    @IntrinsicCandidate\n    public int intValue() {\n        return value;\n    }\n\n    /**\n     * Returns the value of this {@code Integer} as a {@code long}\n     * after a widening primitive conversion.\n     * @jls 5.1.2 Widening Primitive Conversion\n     * @see Integer#toUnsignedLong(int)\n     */\n    public long longValue() {\n        return (long)value;\n    }\n\n    /**\n     * Returns the value of this {@code Integer} as a {@code float}\n     * after a widening primitive conversion.\n     * @jls 5.1.2 Widening Primitive Conversion\n     */\n    public float floatValue() {\n        return (float)value;\n    }\n\n    /**\n     * Returns the value of this {@code Integer} as a {@code double}\n     * after a widening primitive conversion.\n     * @jls 5.1.2 Widening Primitive Conversion\n     */\n    public double doubleValue() {\n        return (double)value;\n    }\n\n    /**\n     * Returns a {@code String} object representing this\n     * {@code Integer}\u0027s value. The value is converted to signed\n     * decimal representation and returned as a string, exactly as if\n     * the integer value were given as an argument to the {@link\n     * java.lang.Integer#toString(int)} method.\n     *\n     * @return  a string representation of the value of this object in\n     *          base\u0026nbsp;10.\n     */\n    public String toString() {\n        return toString(value);\n    }\n\n    /**\n     * Returns a hash code for this {@code Integer}.\n     *\n     * @return  a hash code value for this object, equal to the\n     *          primitive {@code int} value represented by this\n     *          {@code Integer} object.\n     */\n    @Override\n    public int hashCode() {\n        return Integer.hashCode(value);\n    }\n\n    /**\n     * Returns a hash code for an {@code int} value; compatible with\n     * {@code Integer.hashCode()}.\n     *\n     * @param value the value to hash\n     * @since 1.8\n     *\n     * @return a hash code value for an {@code int} value.\n     */\n    public static int hashCode(int value) {\n        return value;\n    }\n\n    /**\n     * Compares this object to the specified object.  The result is\n     * {@code true} if and only if the argument is not\n     * {@code null} and is an {@code Integer} object that\n     * contains the same {@code int} value as this object.\n     *\n     * @param   obj   the object to compare with.\n     * @return  {@code true} if the objects are the same;\n     *          {@code false} otherwise.\n     */\n    public boolean equals(Object obj) {\n        if (obj instanceof Integer) {\n            return value \u003d\u003d ((Integer)obj).intValue();\n        }\n        return false;\n    }\n\n    /**\n     * Determines the integer value of the system property with the\n     * specified name.\n     *\n     * \u003cp\u003eThe first argument is treated as the name of a system\n     * property.  System properties are accessible through the {@link\n     * java.lang.System#getProperty(java.lang.String)} method. The\n     * string value of this property is then interpreted as an integer\n     * value using the grammar supported by {@link Integer#decode decode} and\n     * an {@code Integer} object representing this value is returned.\n     *\n     * \u003cp\u003eIf there is no property with the specified name, if the\n     * specified name is empty or {@code null}, or if the property\n     * does not have the correct numeric format, then {@code null} is\n     * returned.\n     *\n     * \u003cp\u003eIn other words, this method returns an {@code Integer}\n     * object equal to the value of:\n     *\n     * \u003cblockquote\u003e\n     *  {@code getInteger(nm, null)}\n     * \u003c/blockquote\u003e\n     *\n     * @param   nm   property name.\n     * @return  the {@code Integer} value of the property.\n     * @throws  SecurityException for the same reasons as\n     *          {@link System#getProperty(String) System.getProperty}\n     * @see     java.lang.System#getProperty(java.lang.String)\n     * @see     java.lang.System#getProperty(java.lang.String, java.lang.String)\n     */\n    public static Integer getInteger(String nm) {\n        return getInteger(nm, null);\n    }\n\n    /**\n     * Determines the integer value of the system property with the\n     * specified name.\n     *\n     * \u003cp\u003eThe first argument is treated as the name of a system\n     * property.  System properties are accessible through the {@link\n     * java.lang.System#getProperty(java.lang.String)} method. The\n     * string value of this property is then interpreted as an integer\n     * value using the grammar supported by {@link Integer#decode decode} and\n     * an {@code Integer} object representing this value is returned.\n     *\n     * \u003cp\u003eThe second argument is the default value. An {@code Integer} object\n     * that represents the value of the second argument is returned if there\n     * is no property of the specified name, if the property does not have\n     * the correct numeric format, or if the specified name is empty or\n     * {@code null}.\n     *\n     * \u003cp\u003eIn other words, this method returns an {@code Integer} object\n     * equal to the value of:\n     *\n     * \u003cblockquote\u003e\n     *  {@code getInteger(nm, new Integer(val))}\n     * \u003c/blockquote\u003e\n     *\n     * but in practice it may be implemented in a manner such as:\n     *\n     * \u003cblockquote\u003e\u003cpre\u003e\n     * Integer result \u003d getInteger(nm, null);\n     * return (result \u003d\u003d null) ? new Integer(val) : result;\n     * \u003c/pre\u003e\u003c/blockquote\u003e\n     *\n     * to avoid the unnecessary allocation of an {@code Integer}\n     * object when the default value is not needed.\n     *\n     * @param   nm   property name.\n     * @param   val   default value.\n     * @return  the {@code Integer} value of the property.\n     * @throws  SecurityException for the same reasons as\n     *          {@link System#getProperty(String) System.getProperty}\n     * @see     java.lang.System#getProperty(java.lang.String)\n     * @see     java.lang.System#getProperty(java.lang.String, java.lang.String)\n     */\n    public static Integer getInteger(String nm, int val) {\n        Integer result \u003d getInteger(nm, null);\n        return (result \u003d\u003d null) ? Integer.valueOf(val) : result;\n    }\n\n    /**\n     * Returns the integer value of the system property with the\n     * specified name.  The first argument is treated as the name of a\n     * system property.  System properties are accessible through the\n     * {@link java.lang.System#getProperty(java.lang.String)} method.\n     * The string value of this property is then interpreted as an\n     * integer value, as per the {@link Integer#decode decode} method,\n     * and an {@code Integer} object representing this value is\n     * returned; in summary:\n     *\n     * \u003cul\u003e\u003cli\u003eIf the property value begins with the two ASCII characters\n     *         {@code 0x} or the ASCII character {@code #}, not\n     *      followed by a minus sign, then the rest of it is parsed as a\n     *      hexadecimal integer exactly as by the method\n     *      {@link #valueOf(java.lang.String, int)} with radix 16.\n     * \u003cli\u003eIf the property value begins with the ASCII character\n     *     {@code 0} followed by another character, it is parsed as an\n     *     octal integer exactly as by the method\n     *     {@link #valueOf(java.lang.String, int)} with radix 8.\n     * \u003cli\u003eOtherwise, the property value is parsed as a decimal integer\n     * exactly as by the method {@link #valueOf(java.lang.String, int)}\n     * with radix 10.\n     * \u003c/ul\u003e\n     *\n     * \u003cp\u003eThe second argument is the default value. The default value is\n     * returned if there is no property of the specified name, if the\n     * property does not have the correct numeric format, or if the\n     * specified name is empty or {@code null}.\n     *\n     * @param   nm   property name.\n     * @param   val   default value.\n     * @return  the {@code Integer} value of the property.\n     * @throws  SecurityException for the same reasons as\n     *          {@link System#getProperty(String) System.getProperty}\n     * @see     System#getProperty(java.lang.String)\n     * @see     System#getProperty(java.lang.String, java.lang.String)\n     */\n    public static Integer getInteger(String nm, Integer val) {\n        String v \u003d null;\n        try {\n            v \u003d System.getProperty(nm);\n        } catch (IllegalArgumentException | NullPointerException e) {\n        }\n        if (v !\u003d null) {\n            try {\n                return Integer.decode(v);\n            } catch (NumberFormatException e) {\n            }\n        }\n        return val;\n    }\n\n    /**\n     * Decodes a {@code String} into an {@code Integer}.\n     * Accepts decimal, hexadecimal, and octal numbers given\n     * by the following grammar:\n     *\n     * \u003cblockquote\u003e\n     * \u003cdl\u003e\n     * \u003cdt\u003e\u003ci\u003eDecodableString:\u003c/i\u003e\n     * \u003cdd\u003e\u003ci\u003eSign\u003csub\u003eopt\u003c/sub\u003e DecimalNumeral\u003c/i\u003e\n     * \u003cdd\u003e\u003ci\u003eSign\u003csub\u003eopt\u003c/sub\u003e\u003c/i\u003e {@code 0x} \u003ci\u003eHexDigits\u003c/i\u003e\n     * \u003cdd\u003e\u003ci\u003eSign\u003csub\u003eopt\u003c/sub\u003e\u003c/i\u003e {@code 0X} \u003ci\u003eHexDigits\u003c/i\u003e\n     * \u003cdd\u003e\u003ci\u003eSign\u003csub\u003eopt\u003c/sub\u003e\u003c/i\u003e {@code #} \u003ci\u003eHexDigits\u003c/i\u003e\n     * \u003cdd\u003e\u003ci\u003eSign\u003csub\u003eopt\u003c/sub\u003e\u003c/i\u003e {@code 0} \u003ci\u003eOctalDigits\u003c/i\u003e\n     *\n     * \u003cdt\u003e\u003ci\u003eSign:\u003c/i\u003e\n     * \u003cdd\u003e{@code -}\n     * \u003cdd\u003e{@code +}\n     * \u003c/dl\u003e\n     * \u003c/blockquote\u003e\n     *\n     * \u003ci\u003eDecimalNumeral\u003c/i\u003e, \u003ci\u003eHexDigits\u003c/i\u003e, and \u003ci\u003eOctalDigits\u003c/i\u003e\n     * are as defined in section {@jls 3.10.1} of\n     * \u003ccite\u003eThe Java Language Specification\u003c/cite\u003e,\n     * except that underscores are not accepted between digits.\n     *\n     * \u003cp\u003eThe sequence of characters following an optional\n     * sign and/or radix specifier (\"{@code 0x}\", \"{@code 0X}\",\n     * \"{@code #}\", or leading zero) is parsed as by the {@code\n     * Integer.parseInt} method with the indicated radix (10, 16, or\n     * 8).  This sequence of characters must represent a positive\n     * value or a {@link NumberFormatException} will be thrown.  The\n     * result is negated if first character of the specified {@code\n     * String} is the minus sign.  No whitespace characters are\n     * permitted in the {@code String}.\n     *\n     * @param     nm the {@code String} to decode.\n     * @return    an {@code Integer} object holding the {@code int}\n     *             value represented by {@code nm}\n     * @throws    NumberFormatException  if the {@code String} does not\n     *            contain a parsable integer.\n     * @see java.lang.Integer#parseInt(java.lang.String, int)\n     */\n    public static Integer decode(String nm) throws NumberFormatException {\n        int radix \u003d 10;\n        int index \u003d 0;\n        boolean negative \u003d false;\n        Integer result;\n\n        if (nm.isEmpty())\n            throw new NumberFormatException(\"Zero length string\");\n        char firstChar \u003d nm.charAt(0);\n        // Handle sign, if present\n        if (firstChar \u003d\u003d \u0027-\u0027) {\n            negative \u003d true;\n            index++;\n        } else if (firstChar \u003d\u003d \u0027+\u0027)\n            index++;\n\n        // Handle radix specifier, if present\n        if (nm.startsWith(\"0x\", index) || nm.startsWith(\"0X\", index)) {\n            index +\u003d 2;\n            radix \u003d 16;\n        }\n        else if (nm.startsWith(\"#\", index)) {\n            index ++;\n            radix \u003d 16;\n        }\n        else if (nm.startsWith(\"0\", index) \u0026\u0026 nm.length() \u003e 1 + index) {\n            index ++;\n            radix \u003d 8;\n        }\n\n        if (nm.startsWith(\"-\", index) || nm.startsWith(\"+\", index))\n            throw new NumberFormatException(\"Sign character in wrong position\");\n\n        try {\n            result \u003d Integer.valueOf(nm.substring(index), radix);\n            result \u003d negative ? Integer.valueOf(-result.intValue()) : result;\n        } catch (NumberFormatException e) {\n            // If number is Integer.MIN_VALUE, we\u0027ll end up here. The next line\n            // handles this case, and causes any genuine format error to be\n            // rethrown.\n            String constant \u003d negative ? (\"-\" + nm.substring(index))\n                                       : nm.substring(index);\n            result \u003d Integer.valueOf(constant, radix);\n        }\n        return result;\n    }\n\n    /**\n     * Compares two {@code Integer} objects numerically.\n     *\n     * @param   anotherInteger   the {@code Integer} to be compared.\n     * @return  the value {@code 0} if this {@code Integer} is\n     *          equal to the argument {@code Integer}; a value less than\n     *          {@code 0} if this {@code Integer} is numerically less\n     *          than the argument {@code Integer}; and a value greater\n     *          than {@code 0} if this {@code Integer} is numerically\n     *           greater than the argument {@code Integer} (signed\n     *           comparison).\n     * @since   1.2\n     */\n    public int compareTo(Integer anotherInteger) {\n        return compare(this.value, anotherInteger.value);\n    }\n\n    /**\n     * Compares two {@code int} values numerically.\n     * The value returned is identical to what would be returned by:\n     * \u003cpre\u003e\n     *    Integer.valueOf(x).compareTo(Integer.valueOf(y))\n     * \u003c/pre\u003e\n     *\n     * @param  x the first {@code int} to compare\n     * @param  y the second {@code int} to compare\n     * @return the value {@code 0} if {@code x \u003d\u003d y};\n     *         a value less than {@code 0} if {@code x \u003c y}; and\n     *         a value greater than {@code 0} if {@code x \u003e y}\n     * @since 1.7\n     */\n    public static int compare(int x, int y) {\n        return (x \u003c y) ? -1 : ((x \u003d\u003d y) ? 0 : 1);\n    }\n\n    /**\n     * Compares two {@code int} values numerically treating the values\n     * as unsigned.\n     *\n     * @param  x the first {@code int} to compare\n     * @param  y the second {@code int} to compare\n     * @return the value {@code 0} if {@code x \u003d\u003d y}; a value less\n     *         than {@code 0} if {@code x \u003c y} as unsigned values; and\n     *         a value greater than {@code 0} if {@code x \u003e y} as\n     *         unsigned values\n     * @since 1.8\n     */\n    public static int compareUnsigned(int x, int y) {\n        return compare(x + MIN_VALUE, y + MIN_VALUE);\n    }\n\n    /**\n     * Converts the argument to a {@code long} by an unsigned\n     * conversion.  In an unsigned conversion to a {@code long}, the\n     * high-order 32 bits of the {@code long} are zero and the\n     * low-order 32 bits are equal to the bits of the integer\n     * argument.\n     *\n     * Consequently, zero and positive {@code int} values are mapped\n     * to a numerically equal {@code long} value and negative {@code\n     * int} values are mapped to a {@code long} value equal to the\n     * input plus 2\u003csup\u003e32\u003c/sup\u003e.\n     *\n     * @param  x the value to convert to an unsigned {@code long}\n     * @return the argument converted to {@code long} by an unsigned\n     *         conversion\n     * @since 1.8\n     */\n    public static long toUnsignedLong(int x) {\n        return ((long) x) \u0026 0xffffffffL;\n    }\n\n    /**\n     * Returns the unsigned quotient of dividing the first argument by\n     * the second where each argument and the result is interpreted as\n     * an unsigned value.\n     *\n     * \u003cp\u003eNote that in two\u0027s complement arithmetic, the three other\n     * basic arithmetic operations of add, subtract, and multiply are\n     * bit-wise identical if the two operands are regarded as both\n     * being signed or both being unsigned.  Therefore separate {@code\n     * addUnsigned}, etc. methods are not provided.\n     *\n     * @param dividend the value to be divided\n     * @param divisor the value doing the dividing\n     * @return the unsigned quotient of the first argument divided by\n     * the second argument\n     * @see #remainderUnsigned\n     * @since 1.8\n     */\n    public static int divideUnsigned(int dividend, int divisor) {\n        // In lieu of tricky code, for now just use long arithmetic.\n        return (int)(toUnsignedLong(dividend) / toUnsignedLong(divisor));\n    }\n\n    /**\n     * Returns the unsigned remainder from dividing the first argument\n     * by the second where each argument and the result is interpreted\n     * as an unsigned value.\n     *\n     * @param dividend the value to be divided\n     * @param divisor the value doing the dividing\n     * @return the unsigned remainder of the first argument divided by\n     * the second argument\n     * @see #divideUnsigned\n     * @since 1.8\n     */\n    public static int remainderUnsigned(int dividend, int divisor) {\n        // In lieu of tricky code, for now just use long arithmetic.\n        return (int)(toUnsignedLong(dividend) % toUnsignedLong(divisor));\n    }\n\n\n    // Bit twiddling\n\n    /**\n     * The number of bits used to represent an {@code int} value in two\u0027s\n     * complement binary form.\n     *\n     * @since 1.5\n     */\n    @Native public static final int SIZE \u003d 32;\n\n    /**\n     * The number of bytes used to represent an {@code int} value in two\u0027s\n     * complement binary form.\n     *\n     * @since 1.8\n     */\n    public static final int BYTES \u003d SIZE / Byte.SIZE;\n\n    /**\n     * Returns an {@code int} value with at most a single one-bit, in the\n     * position of the highest-order (\"leftmost\") one-bit in the specified\n     * {@code int} value.  Returns zero if the specified value has no\n     * one-bits in its two\u0027s complement binary representation, that is, if it\n     * is equal to zero.\n     *\n     * @param i the value whose highest one bit is to be computed\n     * @return an {@code int} value with a single one-bit, in the position\n     *     of the highest-order one-bit in the specified value, or zero if\n     *     the specified value is itself equal to zero.\n     * @since 1.5\n     */\n    public static int highestOneBit(int i) {\n        return i \u0026 (MIN_VALUE \u003e\u003e\u003e numberOfLeadingZeros(i));\n    }\n\n    /**\n     * Returns an {@code int} value with at most a single one-bit, in the\n     * position of the lowest-order (\"rightmost\") one-bit in the specified\n     * {@code int} value.  Returns zero if the specified value has no\n     * one-bits in its two\u0027s complement binary representation, that is, if it\n     * is equal to zero.\n     *\n     * @param i the value whose lowest one bit is to be computed\n     * @return an {@code int} value with a single one-bit, in the position\n     *     of the lowest-order one-bit in the specified value, or zero if\n     *     the specified value is itself equal to zero.\n     * @since 1.5\n     */\n    public static int lowestOneBit(int i) {\n        // HD, Section 2-1\n        return i \u0026 -i;\n    }\n\n    /**\n     * Returns the number of zero bits preceding the highest-order\n     * (\"leftmost\") one-bit in the two\u0027s complement binary representation\n     * of the specified {@code int} value.  Returns 32 if the\n     * specified value has no one-bits in its two\u0027s complement representation,\n     * in other words if it is equal to zero.\n     *\n     * \u003cp\u003eNote that this method is closely related to the logarithm base 2.\n     * For all positive {@code int} values x:\n     * \u003cul\u003e\n     * \u003cli\u003efloor(log\u003csub\u003e2\u003c/sub\u003e(x)) \u003d {@code 31 - numberOfLeadingZeros(x)}\n     * \u003cli\u003eceil(log\u003csub\u003e2\u003c/sub\u003e(x)) \u003d {@code 32 - numberOfLeadingZeros(x - 1)}\n     * \u003c/ul\u003e\n     *\n     * @param i the value whose number of leading zeros is to be computed\n     * @return the number of zero bits preceding the highest-order\n     *     (\"leftmost\") one-bit in the two\u0027s complement binary representation\n     *     of the specified {@code int} value, or 32 if the value\n     *     is equal to zero.\n     * @since 1.5\n     */\n    @IntrinsicCandidate\n    public static int numberOfLeadingZeros(int i) {\n        // HD, Count leading 0\u0027s\n        if (i \u003c\u003d 0)\n            return i \u003d\u003d 0 ? 32 : 0;\n        int n \u003d 31;\n        if (i \u003e\u003d 1 \u003c\u003c 16) { n -\u003d 16; i \u003e\u003e\u003e\u003d 16; }\n        if (i \u003e\u003d 1 \u003c\u003c  8) { n -\u003d  8; i \u003e\u003e\u003e\u003d  8; }\n        if (i \u003e\u003d 1 \u003c\u003c  4) { n -\u003d  4; i \u003e\u003e\u003e\u003d  4; }\n        if (i \u003e\u003d 1 \u003c\u003c  2) { n -\u003d  2; i \u003e\u003e\u003e\u003d  2; }\n        return n - (i \u003e\u003e\u003e 1);\n    }\n\n    /**\n     * Returns the number of zero bits following the lowest-order (\"rightmost\")\n     * one-bit in the two\u0027s complement binary representation of the specified\n     * {@code int} value.  Returns 32 if the specified value has no\n     * one-bits in its two\u0027s complement representation, in other words if it is\n     * equal to zero.\n     *\n     * @param i the value whose number of trailing zeros is to be computed\n     * @return the number of zero bits following the lowest-order (\"rightmost\")\n     *     one-bit in the two\u0027s complement binary representation of the\n     *     specified {@code int} value, or 32 if the value is equal\n     *     to zero.\n     * @since 1.5\n     */\n    @IntrinsicCandidate\n    public static int numberOfTrailingZeros(int i) {\n        // HD, Count trailing 0\u0027s\n        i \u003d ~i \u0026 (i - 1);\n        if (i \u003c\u003d 0) return i \u0026 32;\n        int n \u003d 1;\n        if (i \u003e 1 \u003c\u003c 16) { n +\u003d 16; i \u003e\u003e\u003e\u003d 16; }\n        if (i \u003e 1 \u003c\u003c  8) { n +\u003d  8; i \u003e\u003e\u003e\u003d  8; }\n        if (i \u003e 1 \u003c\u003c  4) { n +\u003d  4; i \u003e\u003e\u003e\u003d  4; }\n        if (i \u003e 1 \u003c\u003c  2) { n +\u003d  2; i \u003e\u003e\u003e\u003d  2; }\n        return n + (i \u003e\u003e\u003e 1);\n    }\n\n    /**\n     * Returns the number of one-bits in the two\u0027s complement binary\n     * representation of the specified {@code int} value.  This function is\n     * sometimes referred to as the \u003ci\u003epopulation count\u003c/i\u003e.\n     *\n     * @param i the value whose bits are to be counted\n     * @return the number of one-bits in the two\u0027s complement binary\n     *     representation of the specified {@code int} value.\n     * @since 1.5\n     */\n    @IntrinsicCandidate\n    public static int bitCount(int i) {\n        // HD, Figure 5-2\n        i \u003d i - ((i \u003e\u003e\u003e 1) \u0026 0x55555555);\n        i \u003d (i \u0026 0x33333333) + ((i \u003e\u003e\u003e 2) \u0026 0x33333333);\n        i \u003d (i + (i \u003e\u003e\u003e 4)) \u0026 0x0f0f0f0f;\n        i \u003d i + (i \u003e\u003e\u003e 8);\n        i \u003d i + (i \u003e\u003e\u003e 16);\n        return i \u0026 0x3f;\n    }\n\n    /**\n     * Returns the value obtained by rotating the two\u0027s complement binary\n     * representation of the specified {@code int} value left by the\n     * specified number of bits.  (Bits shifted out of the left hand, or\n     * high-order, side reenter on the right, or low-order.)\n     *\n     * \u003cp\u003eNote that left rotation with a negative distance is equivalent to\n     * right rotation: {@code rotateLeft(val, -distance) \u003d\u003d rotateRight(val,\n     * distance)}.  Note also that rotation by any multiple of 32 is a\n     * no-op, so all but the last five bits of the rotation distance can be\n     * ignored, even if the distance is negative: {@code rotateLeft(val,\n     * distance) \u003d\u003d rotateLeft(val, distance \u0026 0x1F)}.\n     *\n     * @param i the value whose bits are to be rotated left\n     * @param distance the number of bit positions to rotate left\n     * @return the value obtained by rotating the two\u0027s complement binary\n     *     representation of the specified {@code int} value left by the\n     *     specified number of bits.\n     * @since 1.5\n     */\n    public static int rotateLeft(int i, int distance) {\n        return (i \u003c\u003c distance) | (i \u003e\u003e\u003e -distance);\n    }\n\n    /**\n     * Returns the value obtained by rotating the two\u0027s complement binary\n     * representation of the specified {@code int} value right by the\n     * specified number of bits.  (Bits shifted out of the right hand, or\n     * low-order, side reenter on the left, or high-order.)\n     *\n     * \u003cp\u003eNote that right rotation with a negative distance is equivalent to\n     * left rotation: {@code rotateRight(val, -distance) \u003d\u003d rotateLeft(val,\n     * distance)}.  Note also that rotation by any multiple of 32 is a\n     * no-op, so all but the last five bits of the rotation distance can be\n     * ignored, even if the distance is negative: {@code rotateRight(val,\n     * distance) \u003d\u003d rotateRight(val, distance \u0026 0x1F)}.\n     *\n     * @param i the value whose bits are to be rotated right\n     * @param distance the number of bit positions to rotate right\n     * @return the value obtained by rotating the two\u0027s complement binary\n     *     representation of the specified {@code int} value right by the\n     *     specified number of bits.\n     * @since 1.5\n     */\n    public static int rotateRight(int i, int distance) {\n        return (i \u003e\u003e\u003e distance) | (i \u003c\u003c -distance);\n    }\n\n    /**\n     * Returns the value obtained by reversing the order of the bits in the\n     * two\u0027s complement binary representation of the specified {@code int}\n     * value.\n     *\n     * @param i the value to be reversed\n     * @return the value obtained by reversing order of the bits in the\n     *     specified {@code int} value.\n     * @since 1.5\n     */\n    public static int reverse(int i) {\n        // HD, Figure 7-1\n        i \u003d (i \u0026 0x55555555) \u003c\u003c 1 | (i \u003e\u003e\u003e 1) \u0026 0x55555555;\n        i \u003d (i \u0026 0x33333333) \u003c\u003c 2 | (i \u003e\u003e\u003e 2) \u0026 0x33333333;\n        i \u003d (i \u0026 0x0f0f0f0f) \u003c\u003c 4 | (i \u003e\u003e\u003e 4) \u0026 0x0f0f0f0f;\n\n        return reverseBytes(i);\n    }\n\n    /**\n     * Returns the signum function of the specified {@code int} value.  (The\n     * return value is -1 if the specified value is negative; 0 if the\n     * specified value is zero; and 1 if the specified value is positive.)\n     *\n     * @param i the value whose signum is to be computed\n     * @return the signum function of the specified {@code int} value.\n     * @since 1.5\n     */\n    public static int signum(int i) {\n        // HD, Section 2-7\n        return (i \u003e\u003e 31) | (-i \u003e\u003e\u003e 31);\n    }\n\n    /**\n     * Returns the value obtained by reversing the order of the bytes in the\n     * two\u0027s complement representation of the specified {@code int} value.\n     *\n     * @param i the value whose bytes are to be reversed\n     * @return the value obtained by reversing the bytes in the specified\n     *     {@code int} value.\n     * @since 1.5\n     */\n    @IntrinsicCandidate\n    public static int reverseBytes(int i) {\n        return (i \u003c\u003c 24)            |\n               ((i \u0026 0xff00) \u003c\u003c 8)  |\n               ((i \u003e\u003e\u003e 8) \u0026 0xff00) |\n               (i \u003e\u003e\u003e 24);\n    }\n\n    /**\n     * Adds two integers together as per the + operator.\n     *\n     * @param a the first operand\n     * @param b the second operand\n     * @return the sum of {@code a} and {@code b}\n     * @see java.util.function.BinaryOperator\n     * @since 1.8\n     */\n    public static int sum(int a, int b) {\n        return a + b;\n    }\n\n    /**\n     * Returns the greater of two {@code int} values\n     * as if by calling {@link Math#max(int, int) Math.max}.\n     *\n     * @param a the first operand\n     * @param b the second operand\n     * @return the greater of {@code a} and {@code b}\n     * @see java.util.function.BinaryOperator\n     * @since 1.8\n     */\n    public static int max(int a, int b) {\n        return Math.max(a, b);\n    }\n\n    /**\n     * Returns the smaller of two {@code int} values\n     * as if by calling {@link Math#min(int, int) Math.min}.\n     *\n     * @param a the first operand\n     * @param b the second operand\n     * @return the smaller of {@code a} and {@code b}\n     * @see java.util.function.BinaryOperator\n     * @since 1.8\n     */\n    public static int min(int a, int b) {\n        return Math.min(a, b);\n    }\n\n    /**\n     * Returns an {@link Optional} containing the nominal descriptor for this\n     * instance, which is the instance itself.\n     *\n     * @return an {@link Optional} describing the {@linkplain Integer} instance\n     * @since 12\n     */\n    @Override\n    public Optional\u003cInteger\u003e describeConstable() {\n        return Optional.of(this);\n    }\n\n    /**\n     * Resolves this instance as a {@link ConstantDesc}, the result of which is\n     * the instance itself.\n     *\n     * @param lookup ignored\n     * @return the {@linkplain Integer} instance\n     * @since 12\n     */\n    @Override\n    public Integer resolveConstantDesc(MethodHandles.Lookup lookup) {\n        return this;\n    }\n\n    /** use serialVersionUID from JDK 1.0.2 for interoperability */\n    @java.io.Serial\n    @Native private static final long serialVersionUID \u003d 1360826667806852920L;\n}\n"
    }
  }
}
java.lang.IllegalArgumentException: Illegal character in opaque part at index 188: jar:file:///C:/Users/Vinicius/AppData/Local/Coursier/cache/arc/https/github.com/adoptium/temurin17-binaries/releases/download/jdk-17%2B35/OpenJDK17-jdk_x64_windows_hotspot_17_35.zip/jdk-17 35/lib/src.zip!/java.base/java/lang/Integer.java
	at java.base/java.net.URI.create(URI.java:906)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:178)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.$anonfun$toAbsolutePath$3(MtagsEnrichments.scala:175)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.withTryDecode$1(MtagsEnrichments.scala:153)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:175)
	at scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:756)
	at scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:753)
	at scala.meta.internal.metals.WorkspaceLspService.didOpen(WorkspaceLspService.scala:388)
	at scala.meta.metals.lsp.DelegatingScalaService.didOpen(DelegatingScalaService.scala:39)
	at jdk.internal.reflect.GeneratedMethodAccessor23.invoke(Unknown Source)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:568)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$recursiveFindRpcMethods$0(GenericEndpoint.java:65)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.notify(GenericEndpoint.java:160)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleNotification(RemoteEndpoint.java:231)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:198)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:185)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:97)
	at org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:114)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:539)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.base/java.lang.Thread.run(Thread.java:833)
Caused by: java.net.URISyntaxException: Illegal character in opaque part at index 188: jar:file:///C:/Users/Vinicius/AppData/Local/Coursier/cache/arc/https/github.com/adoptium/temurin17-binaries/releases/download/jdk-17%2B35/OpenJDK17-jdk_x64_windows_hotspot_17_35.zip/jdk-17 35/lib/src.zip!/java.base/java/lang/Integer.java
	at java.base/java.net.URI$Parser.fail(URI.java:2974)
	at java.base/java.net.URI$Parser.checkChars(URI.java:3145)
	at java.base/java.net.URI$Parser.parse(URI.java:3181)
	at java.base/java.net.URI.<init>(URI.java:623)
	at java.base/java.net.URI.create(URI.java:904)
	... 23 more

jul. 19, 2024 1:39:36 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleNotification
ADVERTÊNCIA: Notification threw an exception: {
  "jsonrpc": "2.0",
  "method": "textDocument/didClose",
  "params": {
    "textDocument": {
      "uri": "jar:file%3A///C%3A/Users/Vinicius/AppData/Local/Coursier/cache/arc/https/github.com/adoptium/temurin17-binaries/releases/download/jdk-17%25252B35/OpenJDK17-jdk_x64_windows_hotspot_17_35.zip/jdk-17%2B35/lib/src.zip%21/java.base/java/lang/Integer.java"
    }
  }
}
java.lang.IllegalArgumentException: Illegal character in opaque part at index 188: jar:file:///C:/Users/Vinicius/AppData/Local/Coursier/cache/arc/https/github.com/adoptium/temurin17-binaries/releases/download/jdk-17%2B35/OpenJDK17-jdk_x64_windows_hotspot_17_35.zip/jdk-17 35/lib/src.zip!/java.base/java/lang/Integer.java
	at java.base/java.net.URI.create(URI.java:906)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:178)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.$anonfun$toAbsolutePath$3(MtagsEnrichments.scala:175)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.withTryDecode$1(MtagsEnrichments.scala:153)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:175)
	at scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:756)
	at scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:753)
	at scala.meta.internal.metals.WorkspaceLspService.didClose(WorkspaceLspService.scala:407)
	at scala.meta.metals.lsp.DelegatingScalaService.didClose(DelegatingScalaService.scala:53)
	at jdk.internal.reflect.GeneratedMethodAccessor26.invoke(Unknown Source)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:568)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$recursiveFindRpcMethods$0(GenericEndpoint.java:65)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.notify(GenericEndpoint.java:160)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleNotification(RemoteEndpoint.java:231)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:198)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:185)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:97)
	at org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:114)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:539)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.base/java.lang.Thread.run(Thread.java:833)
Caused by: java.net.URISyntaxException: Illegal character in opaque part at index 188: jar:file:///C:/Users/Vinicius/AppData/Local/Coursier/cache/arc/https/github.com/adoptium/temurin17-binaries/releases/download/jdk-17%2B35/OpenJDK17-jdk_x64_windows_hotspot_17_35.zip/jdk-17 35/lib/src.zip!/java.base/java/lang/Integer.java
	at java.base/java.net.URI$Parser.fail(URI.java:2974)
	at java.base/java.net.URI$Parser.checkChars(URI.java:3145)
	at java.base/java.net.URI$Parser.parse(URI.java:3181)
	at java.base/java.net.URI.<init>(URI.java:623)
	at java.base/java.net.URI.create(URI.java:904)
	... 23 more

2024.07.19 13:39:38 INFO  compiling root (2 scala sources)
2024.07.19 13:39:38 INFO  time: compiled root in 0.41s
2024.07.19 13:40:06 ERROR Failed to tokenize input for semantic tokens for C:\Users\Vinicius\UnB\FLanguage\src\main\scala\br\unb\cic\flang\MonadState.scala
scala.meta.tokenizers.TokenizeException: <input>:18: error: unclosed character literal
    teste.run(List(('')))
                    ^
	at scala.meta.internal.tokenizers.Reporter.syntaxError(Reporter.scala:23)
	at scala.meta.internal.tokenizers.Reporter.syntaxError$(Reporter.scala:23)
	at scala.meta.internal.tokenizers.Reporter$$anon$1.syntaxError(Reporter.scala:32)
	at scala.meta.internal.tokenizers.Reporter.syntaxError(Reporter.scala:25)
	at scala.meta.internal.tokenizers.Reporter.syntaxError$(Reporter.scala:25)
	at scala.meta.internal.tokenizers.Reporter$$anon$1.syntaxError(Reporter.scala:32)
	at scala.meta.internal.tokenizers.LegacyScanner.fetchSingleQuote$1(LegacyScanner.scala:391)
	at scala.meta.internal.tokenizers.LegacyScanner.fetchToken(LegacyScanner.scala:395)
	at scala.meta.internal.tokenizers.LegacyScanner.nextToken(LegacyScanner.scala:201)
	at scala.meta.internal.tokenizers.LegacyScanner.foreach(LegacyScanner.scala:912)
	at scala.meta.internal.tokenizers.ScalametaTokenizer.uncachedTokenize(ScalametaTokenizer.scala:23)
	at scala.meta.internal.tokenizers.ScalametaTokenizer.$anonfun$tokenize$1(ScalametaTokenizer.scala:17)
	at scala.collection.concurrent.TrieMap.getOrElseUpdate(TrieMap.scala:960)
	at scala.meta.internal.tokenizers.ScalametaTokenizer.tokenize(ScalametaTokenizer.scala:17)
	at scala.meta.internal.tokenizers.ScalametaTokenizer$$anon$2.apply(ScalametaTokenizer.scala:322)
	at scala.meta.tokenizers.Api$XtensionTokenizeDialectInput.tokenize(Api.scala:22)
	at scala.meta.tokenizers.Api$XtensionTokenizeInputLike.tokenize(Api.scala:13)
	at scala.meta.internal.metals.SemanticTokensProvider$.getTokens(SemanticTokensProvider.scala:30)
	at scala.meta.internal.metals.SemanticTokensProvider$.provide(SemanticTokensProvider.scala:89)
	at scala.meta.internal.metals.Compilers.$anonfun$semanticTokens$3(Compilers.scala:545)
	at scala.concurrent.impl.Promise$Transformation.run(Promise.scala:467)
	at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.lang.Thread.run(Thread.java:833)

2024.07.19 13:40:08 INFO  Can not organize imports if file has error
2024.07.19 13:40:08 INFO  compiling root (2 scala sources)
2024.07.19 13:40:08 INFO  time: compiled root in 0.19s
2024.07.19 13:40:31 INFO  compiling root (2 scala sources)
2024.07.19 13:40:31 INFO  time: compiled root in 0.24s
2024.07.19 13:40:35 INFO  compiling root (2 scala sources)
2024.07.19 13:40:35 INFO  time: compiled root in 0.22s
2024.07.19 13:41:39 INFO  compiling root (2 scala sources)
2024.07.19 13:41:39 INFO  time: compiled root in 0.2s
2024.07.19 13:41:40 INFO  Can not organize imports if file has error
2024.07.19 13:41:41 INFO  compiling root (2 scala sources)
2024.07.19 13:41:41 INFO  time: compiled root in 0.32s
jul. 19, 2024 1:42:04 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
ADVERTÊNCIA: Unmatched cancel notification for request id 8496
2024.07.19 13:42:05 INFO  compiling root (2 scala sources)
2024.07.19 13:42:05 INFO  time: compiled root in 0.22s
2024.07.19 13:42:10 INFO  Can not organize imports if file has error
2024.07.19 13:42:10 INFO  compiling root (2 scala sources)
2024.07.19 13:42:10 INFO  time: compiled root in 0.23s
jul. 19, 2024 1:42:12 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleNotification
ADVERTÊNCIA: Notification threw an exception: {
  "jsonrpc": "2.0",
  "method": "textDocument/didOpen",
  "params": {
    "textDocument": {
      "uri": "jar:file%3A///C%3A/Users/Vinicius/AppData/Local/Coursier/cache/arc/https/github.com/adoptium/temurin17-binaries/releases/download/jdk-17%25252B35/OpenJDK17-jdk_x64_windows_hotspot_17_35.zip/jdk-17%2B35/lib/src.zip%21/java.base/java/lang/Integer.java",
      "languageId": "java",
      "version": 1,
      "text": "/*\n * Copyright (c) 1994, 2021, Oracle and/or its affiliates. All rights reserved.\n * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n *\n * This code is free software; you can redistribute it and/or modify it\n * under the terms of the GNU General Public License version 2 only, as\n * published by the Free Software Foundation.  Oracle designates this\n * particular file as subject to the \"Classpath\" exception as provided\n * by Oracle in the LICENSE file that accompanied this code.\n *\n * This code is distributed in the hope that it will be useful, but WITHOUT\n * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n * version 2 for more details (a copy is included in the LICENSE file that\n * accompanied this code).\n *\n * You should have received a copy of the GNU General Public License version\n * 2 along with this work; if not, write to the Free Software Foundation,\n * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n *\n * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n * or visit www.oracle.com if you need additional information or have any\n * questions.\n */\n\npackage java.lang;\n\nimport java.lang.annotation.Native;\nimport java.lang.invoke.MethodHandles;\nimport java.lang.constant.Constable;\nimport java.lang.constant.ConstantDesc;\nimport java.util.Objects;\nimport java.util.Optional;\n\nimport jdk.internal.misc.CDS;\nimport jdk.internal.misc.VM;\nimport jdk.internal.vm.annotation.IntrinsicCandidate;\n\nimport static java.lang.String.COMPACT_STRINGS;\nimport static java.lang.String.LATIN1;\nimport static java.lang.String.UTF16;\n\n/**\n * The {@code Integer} class wraps a value of the primitive type\n * {@code int} in an object. An object of type {@code Integer}\n * contains a single field whose type is {@code int}.\n *\n * \u003cp\u003eIn addition, this class provides several methods for converting\n * an {@code int} to a {@code String} and a {@code String} to an\n * {@code int}, as well as other constants and methods useful when\n * dealing with an {@code int}.\n *\n * \u003cp\u003eThis is a \u003ca href\u003d\"{@docRoot}/java.base/java/lang/doc-files/ValueBased.html\"\u003evalue-based\u003c/a\u003e\n * class; programmers should treat instances that are\n * {@linkplain #equals(Object) equal} as interchangeable and should not\n * use instances for synchronization, or unpredictable behavior may\n * occur. For example, in a future release, synchronization may fail.\n *\n * \u003cp\u003eImplementation note: The implementations of the \"bit twiddling\"\n * methods (such as {@link #highestOneBit(int) highestOneBit} and\n * {@link #numberOfTrailingZeros(int) numberOfTrailingZeros}) are\n * based on material from Henry S. Warren, Jr.\u0027s \u003ci\u003eHacker\u0027s\n * Delight\u003c/i\u003e, (Addison Wesley, 2002).\n *\n * @author  Lee Boynton\n * @author  Arthur van Hoff\n * @author  Josh Bloch\n * @author  Joseph D. Darcy\n * @since 1.0\n */\n@jdk.internal.ValueBased\npublic final class Integer extends Number\n        implements Comparable\u003cInteger\u003e, Constable, ConstantDesc {\n    /**\n     * A constant holding the minimum value an {@code int} can\n     * have, -2\u003csup\u003e31\u003c/sup\u003e.\n     */\n    @Native public static final int   MIN_VALUE \u003d 0x80000000;\n\n    /**\n     * A constant holding the maximum value an {@code int} can\n     * have, 2\u003csup\u003e31\u003c/sup\u003e-1.\n     */\n    @Native public static final int   MAX_VALUE \u003d 0x7fffffff;\n\n    /**\n     * The {@code Class} instance representing the primitive type\n     * {@code int}.\n     *\n     * @since   1.1\n     */\n    @SuppressWarnings(\"unchecked\")\n    public static final Class\u003cInteger\u003e  TYPE \u003d (Class\u003cInteger\u003e) Class.getPrimitiveClass(\"int\");\n\n    /**\n     * All possible chars for representing a number as a String\n     */\n    static final char[] digits \u003d {\n        \u00270\u0027 , \u00271\u0027 , \u00272\u0027 , \u00273\u0027 , \u00274\u0027 , \u00275\u0027 ,\n        \u00276\u0027 , \u00277\u0027 , \u00278\u0027 , \u00279\u0027 , \u0027a\u0027 , \u0027b\u0027 ,\n        \u0027c\u0027 , \u0027d\u0027 , \u0027e\u0027 , \u0027f\u0027 , \u0027g\u0027 , \u0027h\u0027 ,\n        \u0027i\u0027 , \u0027j\u0027 , \u0027k\u0027 , \u0027l\u0027 , \u0027m\u0027 , \u0027n\u0027 ,\n        \u0027o\u0027 , \u0027p\u0027 , \u0027q\u0027 , \u0027r\u0027 , \u0027s\u0027 , \u0027t\u0027 ,\n        \u0027u\u0027 , \u0027v\u0027 , \u0027w\u0027 , \u0027x\u0027 , \u0027y\u0027 , \u0027z\u0027\n    };\n\n    /**\n     * Returns a string representation of the first argument in the\n     * radix specified by the second argument.\n     *\n     * \u003cp\u003eIf the radix is smaller than {@code Character.MIN_RADIX}\n     * or larger than {@code Character.MAX_RADIX}, then the radix\n     * {@code 10} is used instead.\n     *\n     * \u003cp\u003eIf the first argument is negative, the first element of the\n     * result is the ASCII minus character {@code \u0027-\u0027}\n     * ({@code \u0027\\u005Cu002D\u0027}). If the first argument is not\n     * negative, no sign character appears in the result.\n     *\n     * \u003cp\u003eThe remaining characters of the result represent the magnitude\n     * of the first argument. If the magnitude is zero, it is\n     * represented by a single zero character {@code \u00270\u0027}\n     * ({@code \u0027\\u005Cu0030\u0027}); otherwise, the first character of\n     * the representation of the magnitude will not be the zero\n     * character.  The following ASCII characters are used as digits:\n     *\n     * \u003cblockquote\u003e\n     *   {@code 0123456789abcdefghijklmnopqrstuvwxyz}\n     * \u003c/blockquote\u003e\n     *\n     * These are {@code \u0027\\u005Cu0030\u0027} through\n     * {@code \u0027\\u005Cu0039\u0027} and {@code \u0027\\u005Cu0061\u0027} through\n     * {@code \u0027\\u005Cu007A\u0027}. If {@code radix} is\n     * \u003cvar\u003eN\u003c/var\u003e, then the first \u003cvar\u003eN\u003c/var\u003e of these characters\n     * are used as radix-\u003cvar\u003eN\u003c/var\u003e digits in the order shown. Thus,\n     * the digits for hexadecimal (radix 16) are\n     * {@code 0123456789abcdef}. If uppercase letters are\n     * desired, the {@link java.lang.String#toUpperCase()} method may\n     * be called on the result:\n     *\n     * \u003cblockquote\u003e\n     *  {@code Integer.toString(n, 16).toUpperCase()}\n     * \u003c/blockquote\u003e\n     *\n     * @param   i       an integer to be converted to a string.\n     * @param   radix   the radix to use in the string representation.\n     * @return  a string representation of the argument in the specified radix.\n     * @see     java.lang.Character#MAX_RADIX\n     * @see     java.lang.Character#MIN_RADIX\n     */\n    public static String toString(int i, int radix) {\n        if (radix \u003c Character.MIN_RADIX || radix \u003e Character.MAX_RADIX)\n            radix \u003d 10;\n\n        /* Use the faster version */\n        if (radix \u003d\u003d 10) {\n            return toString(i);\n        }\n\n        if (COMPACT_STRINGS) {\n            byte[] buf \u003d new byte[33];\n            boolean negative \u003d (i \u003c 0);\n            int charPos \u003d 32;\n\n            if (!negative) {\n                i \u003d -i;\n            }\n\n            while (i \u003c\u003d -radix) {\n                buf[charPos--] \u003d (byte)digits[-(i % radix)];\n                i \u003d i / radix;\n            }\n            buf[charPos] \u003d (byte)digits[-i];\n\n            if (negative) {\n                buf[--charPos] \u003d \u0027-\u0027;\n            }\n\n            return StringLatin1.newString(buf, charPos, (33 - charPos));\n        }\n        return toStringUTF16(i, radix);\n    }\n\n    private static String toStringUTF16(int i, int radix) {\n        byte[] buf \u003d new byte[33 * 2];\n        boolean negative \u003d (i \u003c 0);\n        int charPos \u003d 32;\n        if (!negative) {\n            i \u003d -i;\n        }\n        while (i \u003c\u003d -radix) {\n            StringUTF16.putChar(buf, charPos--, digits[-(i % radix)]);\n            i \u003d i / radix;\n        }\n        StringUTF16.putChar(buf, charPos, digits[-i]);\n\n        if (negative) {\n            StringUTF16.putChar(buf, --charPos, \u0027-\u0027);\n        }\n        return StringUTF16.newString(buf, charPos, (33 - charPos));\n    }\n\n    /**\n     * Returns a string representation of the first argument as an\n     * unsigned integer value in the radix specified by the second\n     * argument.\n     *\n     * \u003cp\u003eIf the radix is smaller than {@code Character.MIN_RADIX}\n     * or larger than {@code Character.MAX_RADIX}, then the radix\n     * {@code 10} is used instead.\n     *\n     * \u003cp\u003eNote that since the first argument is treated as an unsigned\n     * value, no leading sign character is printed.\n     *\n     * \u003cp\u003eIf the magnitude is zero, it is represented by a single zero\n     * character {@code \u00270\u0027} ({@code \u0027\\u005Cu0030\u0027}); otherwise,\n     * the first character of the representation of the magnitude will\n     * not be the zero character.\n     *\n     * \u003cp\u003eThe behavior of radixes and the characters used as digits\n     * are the same as {@link #toString(int, int) toString}.\n     *\n     * @param   i       an integer to be converted to an unsigned string.\n     * @param   radix   the radix to use in the string representation.\n     * @return  an unsigned string representation of the argument in the specified radix.\n     * @see     #toString(int, int)\n     * @since 1.8\n     */\n    public static String toUnsignedString(int i, int radix) {\n        return Long.toUnsignedString(toUnsignedLong(i), radix);\n    }\n\n    /**\n     * Returns a string representation of the integer argument as an\n     * unsigned integer in base\u0026nbsp;16.\n     *\n     * \u003cp\u003eThe unsigned integer value is the argument plus 2\u003csup\u003e32\u003c/sup\u003e\n     * if the argument is negative; otherwise, it is equal to the\n     * argument.  This value is converted to a string of ASCII digits\n     * in hexadecimal (base\u0026nbsp;16) with no extra leading\n     * {@code 0}s.\n     *\n     * \u003cp\u003eThe value of the argument can be recovered from the returned\n     * string {@code s} by calling {@link\n     * Integer#parseUnsignedInt(String, int)\n     * Integer.parseUnsignedInt(s, 16)}.\n     *\n     * \u003cp\u003eIf the unsigned magnitude is zero, it is represented by a\n     * single zero character {@code \u00270\u0027} ({@code \u0027\\u005Cu0030\u0027});\n     * otherwise, the first character of the representation of the\n     * unsigned magnitude will not be the zero character. The\n     * following characters are used as hexadecimal digits:\n     *\n     * \u003cblockquote\u003e\n     *  {@code 0123456789abcdef}\n     * \u003c/blockquote\u003e\n     *\n     * These are the characters {@code \u0027\\u005Cu0030\u0027} through\n     * {@code \u0027\\u005Cu0039\u0027} and {@code \u0027\\u005Cu0061\u0027} through\n     * {@code \u0027\\u005Cu0066\u0027}. If uppercase letters are\n     * desired, the {@link java.lang.String#toUpperCase()} method may\n     * be called on the result:\n     *\n     * \u003cblockquote\u003e\n     *  {@code Integer.toHexString(n).toUpperCase()}\n     * \u003c/blockquote\u003e\n     *\n     * @apiNote\n     * The {@link java.util.HexFormat} class provides formatting and parsing\n     * of byte arrays and primitives to return a string or adding to an {@link Appendable}.\n     * {@code HexFormat} formats and parses uppercase or lowercase hexadecimal characters,\n     * with leading zeros and for byte arrays includes for each byte\n     * a delimiter, prefix, and suffix.\n     *\n     * @param   i   an integer to be converted to a string.\n     * @return  the string representation of the unsigned integer value\n     *          represented by the argument in hexadecimal (base\u0026nbsp;16).\n     * @see java.util.HexFormat\n     * @see #parseUnsignedInt(String, int)\n     * @see #toUnsignedString(int, int)\n     * @since   1.0.2\n     */\n    public static String toHexString(int i) {\n        return toUnsignedString0(i, 4);\n    }\n\n    /**\n     * Returns a string representation of the integer argument as an\n     * unsigned integer in base\u0026nbsp;8.\n     *\n     * \u003cp\u003eThe unsigned integer value is the argument plus 2\u003csup\u003e32\u003c/sup\u003e\n     * if the argument is negative; otherwise, it is equal to the\n     * argument.  This value is converted to a string of ASCII digits\n     * in octal (base\u0026nbsp;8) with no extra leading {@code 0}s.\n     *\n     * \u003cp\u003eThe value of the argument can be recovered from the returned\n     * string {@code s} by calling {@link\n     * Integer#parseUnsignedInt(String, int)\n     * Integer.parseUnsignedInt(s, 8)}.\n     *\n     * \u003cp\u003eIf the unsigned magnitude is zero, it is represented by a\n     * single zero character {@code \u00270\u0027} ({@code \u0027\\u005Cu0030\u0027});\n     * otherwise, the first character of the representation of the\n     * unsigned magnitude will not be the zero character. The\n     * following characters are used as octal digits:\n     *\n     * \u003cblockquote\u003e\n     * {@code 01234567}\n     * \u003c/blockquote\u003e\n     *\n     * These are the characters {@code \u0027\\u005Cu0030\u0027} through\n     * {@code \u0027\\u005Cu0037\u0027}.\n     *\n     * @param   i   an integer to be converted to a string.\n     * @return  the string representation of the unsigned integer value\n     *          represented by the argument in octal (base\u0026nbsp;8).\n     * @see #parseUnsignedInt(String, int)\n     * @see #toUnsignedString(int, int)\n     * @since   1.0.2\n     */\n    public static String toOctalString(int i) {\n        return toUnsignedString0(i, 3);\n    }\n\n    /**\n     * Returns a string representation of the integer argument as an\n     * unsigned integer in base\u0026nbsp;2.\n     *\n     * \u003cp\u003eThe unsigned integer value is the argument plus 2\u003csup\u003e32\u003c/sup\u003e\n     * if the argument is negative; otherwise it is equal to the\n     * argument.  This value is converted to a string of ASCII digits\n     * in binary (base\u0026nbsp;2) with no extra leading {@code 0}s.\n     *\n     * \u003cp\u003eThe value of the argument can be recovered from the returned\n     * string {@code s} by calling {@link\n     * Integer#parseUnsignedInt(String, int)\n     * Integer.parseUnsignedInt(s, 2)}.\n     *\n     * \u003cp\u003eIf the unsigned magnitude is zero, it is represented by a\n     * single zero character {@code \u00270\u0027} ({@code \u0027\\u005Cu0030\u0027});\n     * otherwise, the first character of the representation of the\n     * unsigned magnitude will not be the zero character. The\n     * characters {@code \u00270\u0027} ({@code \u0027\\u005Cu0030\u0027}) and {@code\n     * \u00271\u0027} ({@code \u0027\\u005Cu0031\u0027}) are used as binary digits.\n     *\n     * @param   i   an integer to be converted to a string.\n     * @return  the string representation of the unsigned integer value\n     *          represented by the argument in binary (base\u0026nbsp;2).\n     * @see #parseUnsignedInt(String, int)\n     * @see #toUnsignedString(int, int)\n     * @since   1.0.2\n     */\n    public static String toBinaryString(int i) {\n        return toUnsignedString0(i, 1);\n    }\n\n    /**\n     * Convert the integer to an unsigned number.\n     */\n    private static String toUnsignedString0(int val, int shift) {\n        // assert shift \u003e 0 \u0026\u0026 shift \u003c\u003d5 : \"Illegal shift value\";\n        int mag \u003d Integer.SIZE - Integer.numberOfLeadingZeros(val);\n        int chars \u003d Math.max(((mag + (shift - 1)) / shift), 1);\n        if (COMPACT_STRINGS) {\n            byte[] buf \u003d new byte[chars];\n            formatUnsignedInt(val, shift, buf, chars);\n            return new String(buf, LATIN1);\n        } else {\n            byte[] buf \u003d new byte[chars * 2];\n            formatUnsignedIntUTF16(val, shift, buf, chars);\n            return new String(buf, UTF16);\n        }\n    }\n\n    /**\n     * Format an {@code int} (treated as unsigned) into a byte buffer (LATIN1 version). If\n     * {@code len} exceeds the formatted ASCII representation of {@code val},\n     * {@code buf} will be padded with leading zeroes.\n     *\n     * @param val the unsigned int to format\n     * @param shift the log2 of the base to format in (4 for hex, 3 for octal, 1 for binary)\n     * @param buf the byte buffer to write to\n     * @param len the number of characters to write\n     */\n    private static void formatUnsignedInt(int val, int shift, byte[] buf, int len) {\n        int charPos \u003d len;\n        int radix \u003d 1 \u003c\u003c shift;\n        int mask \u003d radix - 1;\n        do {\n            buf[--charPos] \u003d (byte)Integer.digits[val \u0026 mask];\n            val \u003e\u003e\u003e\u003d shift;\n        } while (charPos \u003e 0);\n    }\n\n    /**\n     * Format an {@code int} (treated as unsigned) into a byte buffer (UTF16 version). If\n     * {@code len} exceeds the formatted ASCII representation of {@code val},\n     * {@code buf} will be padded with leading zeroes.\n     *\n     * @param val the unsigned int to format\n     * @param shift the log2 of the base to format in (4 for hex, 3 for octal, 1 for binary)\n     * @param buf the byte buffer to write to\n     * @param len the number of characters to write\n     */\n    private static void formatUnsignedIntUTF16(int val, int shift, byte[] buf, int len) {\n        int charPos \u003d len;\n        int radix \u003d 1 \u003c\u003c shift;\n        int mask \u003d radix - 1;\n        do {\n            StringUTF16.putChar(buf, --charPos, Integer.digits[val \u0026 mask]);\n            val \u003e\u003e\u003e\u003d shift;\n        } while (charPos \u003e 0);\n    }\n\n    static final byte[] DigitTens \u003d {\n        \u00270\u0027, \u00270\u0027, \u00270\u0027, \u00270\u0027, \u00270\u0027, \u00270\u0027, \u00270\u0027, \u00270\u0027, \u00270\u0027, \u00270\u0027,\n        \u00271\u0027, \u00271\u0027, \u00271\u0027, \u00271\u0027, \u00271\u0027, \u00271\u0027, \u00271\u0027, \u00271\u0027, \u00271\u0027, \u00271\u0027,\n        \u00272\u0027, \u00272\u0027, \u00272\u0027, \u00272\u0027, \u00272\u0027, \u00272\u0027, \u00272\u0027, \u00272\u0027, \u00272\u0027, \u00272\u0027,\n        \u00273\u0027, \u00273\u0027, \u00273\u0027, \u00273\u0027, \u00273\u0027, \u00273\u0027, \u00273\u0027, \u00273\u0027, \u00273\u0027, \u00273\u0027,\n        \u00274\u0027, \u00274\u0027, \u00274\u0027, \u00274\u0027, \u00274\u0027, \u00274\u0027, \u00274\u0027, \u00274\u0027, \u00274\u0027, \u00274\u0027,\n        \u00275\u0027, \u00275\u0027, \u00275\u0027, \u00275\u0027, \u00275\u0027, \u00275\u0027, \u00275\u0027, \u00275\u0027, \u00275\u0027, \u00275\u0027,\n        \u00276\u0027, \u00276\u0027, \u00276\u0027, \u00276\u0027, \u00276\u0027, \u00276\u0027, \u00276\u0027, \u00276\u0027, \u00276\u0027, \u00276\u0027,\n        \u00277\u0027, \u00277\u0027, \u00277\u0027, \u00277\u0027, \u00277\u0027, \u00277\u0027, \u00277\u0027, \u00277\u0027, \u00277\u0027, \u00277\u0027,\n        \u00278\u0027, \u00278\u0027, \u00278\u0027, \u00278\u0027, \u00278\u0027, \u00278\u0027, \u00278\u0027, \u00278\u0027, \u00278\u0027, \u00278\u0027,\n        \u00279\u0027, \u00279\u0027, \u00279\u0027, \u00279\u0027, \u00279\u0027, \u00279\u0027, \u00279\u0027, \u00279\u0027, \u00279\u0027, \u00279\u0027,\n        } ;\n\n    static final byte[] DigitOnes \u003d {\n        \u00270\u0027, \u00271\u0027, \u00272\u0027, \u00273\u0027, \u00274\u0027, \u00275\u0027, \u00276\u0027, \u00277\u0027, \u00278\u0027, \u00279\u0027,\n        \u00270\u0027, \u00271\u0027, \u00272\u0027, \u00273\u0027, \u00274\u0027, \u00275\u0027, \u00276\u0027, \u00277\u0027, \u00278\u0027, \u00279\u0027,\n        \u00270\u0027, \u00271\u0027, \u00272\u0027, \u00273\u0027, \u00274\u0027, \u00275\u0027, \u00276\u0027, \u00277\u0027, \u00278\u0027, \u00279\u0027,\n        \u00270\u0027, \u00271\u0027, \u00272\u0027, \u00273\u0027, \u00274\u0027, \u00275\u0027, \u00276\u0027, \u00277\u0027, \u00278\u0027, \u00279\u0027,\n        \u00270\u0027, \u00271\u0027, \u00272\u0027, \u00273\u0027, \u00274\u0027, \u00275\u0027, \u00276\u0027, \u00277\u0027, \u00278\u0027, \u00279\u0027,\n        \u00270\u0027, \u00271\u0027, \u00272\u0027, \u00273\u0027, \u00274\u0027, \u00275\u0027, \u00276\u0027, \u00277\u0027, \u00278\u0027, \u00279\u0027,\n        \u00270\u0027, \u00271\u0027, \u00272\u0027, \u00273\u0027, \u00274\u0027, \u00275\u0027, \u00276\u0027, \u00277\u0027, \u00278\u0027, \u00279\u0027,\n        \u00270\u0027, \u00271\u0027, \u00272\u0027, \u00273\u0027, \u00274\u0027, \u00275\u0027, \u00276\u0027, \u00277\u0027, \u00278\u0027, \u00279\u0027,\n        \u00270\u0027, \u00271\u0027, \u00272\u0027, \u00273\u0027, \u00274\u0027, \u00275\u0027, \u00276\u0027, \u00277\u0027, \u00278\u0027, \u00279\u0027,\n        \u00270\u0027, \u00271\u0027, \u00272\u0027, \u00273\u0027, \u00274\u0027, \u00275\u0027, \u00276\u0027, \u00277\u0027, \u00278\u0027, \u00279\u0027,\n        } ;\n\n\n    /**\n     * Returns a {@code String} object representing the\n     * specified integer. The argument is converted to signed decimal\n     * representation and returned as a string, exactly as if the\n     * argument and radix 10 were given as arguments to the {@link\n     * #toString(int, int)} method.\n     *\n     * @param   i   an integer to be converted.\n     * @return  a string representation of the argument in base\u0026nbsp;10.\n     */\n    @IntrinsicCandidate\n    public static String toString(int i) {\n        int size \u003d stringSize(i);\n        if (COMPACT_STRINGS) {\n            byte[] buf \u003d new byte[size];\n            getChars(i, size, buf);\n            return new String(buf, LATIN1);\n        } else {\n            byte[] buf \u003d new byte[size * 2];\n            StringUTF16.getChars(i, size, buf);\n            return new String(buf, UTF16);\n        }\n    }\n\n    /**\n     * Returns a string representation of the argument as an unsigned\n     * decimal value.\n     *\n     * The argument is converted to unsigned decimal representation\n     * and returned as a string exactly as if the argument and radix\n     * 10 were given as arguments to the {@link #toUnsignedString(int,\n     * int)} method.\n     *\n     * @param   i  an integer to be converted to an unsigned string.\n     * @return  an unsigned string representation of the argument.\n     * @see     #toUnsignedString(int, int)\n     * @since 1.8\n     */\n    public static String toUnsignedString(int i) {\n        return Long.toString(toUnsignedLong(i));\n    }\n\n    /**\n     * Places characters representing the integer i into the\n     * character array buf. The characters are placed into\n     * the buffer backwards starting with the least significant\n     * digit at the specified index (exclusive), and working\n     * backwards from there.\n     *\n     * @implNote This method converts positive inputs into negative\n     * values, to cover the Integer.MIN_VALUE case. Converting otherwise\n     * (negative to positive) will expose -Integer.MIN_VALUE that overflows\n     * integer.\n     *\n     * @param i     value to convert\n     * @param index next index, after the least significant digit\n     * @param buf   target buffer, Latin1-encoded\n     * @return index of the most significant digit or minus sign, if present\n     */\n    static int getChars(int i, int index, byte[] buf) {\n        int q, r;\n        int charPos \u003d index;\n\n        boolean negative \u003d i \u003c 0;\n        if (!negative) {\n            i \u003d -i;\n        }\n\n        // Generate two digits per iteration\n        while (i \u003c\u003d -100) {\n            q \u003d i / 100;\n            r \u003d (q * 100) - i;\n            i \u003d q;\n            buf[--charPos] \u003d DigitOnes[r];\n            buf[--charPos] \u003d DigitTens[r];\n        }\n\n        // We know there are at most two digits left at this point.\n        q \u003d i / 10;\n        r \u003d (q * 10) - i;\n        buf[--charPos] \u003d (byte)(\u00270\u0027 + r);\n\n        // Whatever left is the remaining digit.\n        if (q \u003c 0) {\n            buf[--charPos] \u003d (byte)(\u00270\u0027 - q);\n        }\n\n        if (negative) {\n            buf[--charPos] \u003d (byte)\u0027-\u0027;\n        }\n        return charPos;\n    }\n\n    // Left here for compatibility reasons, see JDK-8143900.\n    static final int [] sizeTable \u003d { 9, 99, 999, 9999, 99999, 999999, 9999999,\n                                      99999999, 999999999, Integer.MAX_VALUE };\n\n    /**\n     * Returns the string representation size for a given int value.\n     *\n     * @param x int value\n     * @return string size\n     *\n     * @implNote There are other ways to compute this: e.g. binary search,\n     * but values are biased heavily towards zero, and therefore linear search\n     * wins. The iteration results are also routinely inlined in the generated\n     * code after loop unrolling.\n     */\n    static int stringSize(int x) {\n        int d \u003d 1;\n        if (x \u003e\u003d 0) {\n            d \u003d 0;\n            x \u003d -x;\n        }\n        int p \u003d -10;\n        for (int i \u003d 1; i \u003c 10; i++) {\n            if (x \u003e p)\n                return i + d;\n            p \u003d 10 * p;\n        }\n        return 10 + d;\n    }\n\n    /**\n     * Parses the string argument as a signed integer in the radix\n     * specified by the second argument. The characters in the string\n     * must all be digits of the specified radix (as determined by\n     * whether {@link java.lang.Character#digit(char, int)} returns a\n     * nonnegative value), except that the first character may be an\n     * ASCII minus sign {@code \u0027-\u0027} ({@code \u0027\\u005Cu002D\u0027}) to\n     * indicate a negative value or an ASCII plus sign {@code \u0027+\u0027}\n     * ({@code \u0027\\u005Cu002B\u0027}) to indicate a positive value. The\n     * resulting integer value is returned.\n     *\n     * \u003cp\u003eAn exception of type {@code NumberFormatException} is\n     * thrown if any of the following situations occurs:\n     * \u003cul\u003e\n     * \u003cli\u003eThe first argument is {@code null} or is a string of\n     * length zero.\n     *\n     * \u003cli\u003eThe radix is either smaller than\n     * {@link java.lang.Character#MIN_RADIX} or\n     * larger than {@link java.lang.Character#MAX_RADIX}.\n     *\n     * \u003cli\u003eAny character of the string is not a digit of the specified\n     * radix, except that the first character may be a minus sign\n     * {@code \u0027-\u0027} ({@code \u0027\\u005Cu002D\u0027}) or plus sign\n     * {@code \u0027+\u0027} ({@code \u0027\\u005Cu002B\u0027}) provided that the\n     * string is longer than length 1.\n     *\n     * \u003cli\u003eThe value represented by the string is not a value of type\n     * {@code int}.\n     * \u003c/ul\u003e\n     *\n     * \u003cp\u003eExamples:\n     * \u003cblockquote\u003e\u003cpre\u003e\n     * parseInt(\"0\", 10) returns 0\n     * parseInt(\"473\", 10) returns 473\n     * parseInt(\"+42\", 10) returns 42\n     * parseInt(\"-0\", 10) returns 0\n     * parseInt(\"-FF\", 16) returns -255\n     * parseInt(\"1100110\", 2) returns 102\n     * parseInt(\"2147483647\", 10) returns 2147483647\n     * parseInt(\"-2147483648\", 10) returns -2147483648\n     * parseInt(\"2147483648\", 10) throws a NumberFormatException\n     * parseInt(\"99\", 8) throws a NumberFormatException\n     * parseInt(\"Kona\", 10) throws a NumberFormatException\n     * parseInt(\"Kona\", 27) returns 411787\n     * \u003c/pre\u003e\u003c/blockquote\u003e\n     *\n     * @param      s   the {@code String} containing the integer\n     *                  representation to be parsed\n     * @param      radix   the radix to be used while parsing {@code s}.\n     * @return     the integer represented by the string argument in the\n     *             specified radix.\n     * @throws     NumberFormatException if the {@code String}\n     *             does not contain a parsable {@code int}.\n     */\n    public static int parseInt(String s, int radix)\n                throws NumberFormatException\n    {\n        /*\n         * WARNING: This method may be invoked early during VM initialization\n         * before IntegerCache is initialized. Care must be taken to not use\n         * the valueOf method.\n         */\n\n        if (s \u003d\u003d null) {\n            throw new NumberFormatException(\"Cannot parse null string\");\n        }\n\n        if (radix \u003c Character.MIN_RADIX) {\n            throw new NumberFormatException(\"radix \" + radix +\n                                            \" less than Character.MIN_RADIX\");\n        }\n\n        if (radix \u003e Character.MAX_RADIX) {\n            throw new NumberFormatException(\"radix \" + radix +\n                                            \" greater than Character.MAX_RADIX\");\n        }\n\n        boolean negative \u003d false;\n        int i \u003d 0, len \u003d s.length();\n        int limit \u003d -Integer.MAX_VALUE;\n\n        if (len \u003e 0) {\n            char firstChar \u003d s.charAt(0);\n            if (firstChar \u003c \u00270\u0027) { // Possible leading \"+\" or \"-\"\n                if (firstChar \u003d\u003d \u0027-\u0027) {\n                    negative \u003d true;\n                    limit \u003d Integer.MIN_VALUE;\n                } else if (firstChar !\u003d \u0027+\u0027) {\n                    throw NumberFormatException.forInputString(s, radix);\n                }\n\n                if (len \u003d\u003d 1) { // Cannot have lone \"+\" or \"-\"\n                    throw NumberFormatException.forInputString(s, radix);\n                }\n                i++;\n            }\n            int multmin \u003d limit / radix;\n            int result \u003d 0;\n            while (i \u003c len) {\n                // Accumulating negatively avoids surprises near MAX_VALUE\n                int digit \u003d Character.digit(s.charAt(i++), radix);\n                if (digit \u003c 0 || result \u003c multmin) {\n                    throw NumberFormatException.forInputString(s, radix);\n                }\n                result *\u003d radix;\n                if (result \u003c limit + digit) {\n                    throw NumberFormatException.forInputString(s, radix);\n                }\n                result -\u003d digit;\n            }\n            return negative ? result : -result;\n        } else {\n            throw NumberFormatException.forInputString(s, radix);\n        }\n    }\n\n    /**\n     * Parses the {@link CharSequence} argument as a signed {@code int} in the\n     * specified {@code radix}, beginning at the specified {@code beginIndex}\n     * and extending to {@code endIndex - 1}.\n     *\n     * \u003cp\u003eThe method does not take steps to guard against the\n     * {@code CharSequence} being mutated while parsing.\n     *\n     * @param      s   the {@code CharSequence} containing the {@code int}\n     *                  representation to be parsed\n     * @param      beginIndex   the beginning index, inclusive.\n     * @param      endIndex     the ending index, exclusive.\n     * @param      radix   the radix to be used while parsing {@code s}.\n     * @return     the signed {@code int} represented by the subsequence in\n     *             the specified radix.\n     * @throws     NullPointerException  if {@code s} is null.\n     * @throws     IndexOutOfBoundsException  if {@code beginIndex} is\n     *             negative, or if {@code beginIndex} is greater than\n     *             {@code endIndex} or if {@code endIndex} is greater than\n     *             {@code s.length()}.\n     * @throws     NumberFormatException  if the {@code CharSequence} does not\n     *             contain a parsable {@code int} in the specified\n     *             {@code radix}, or if {@code radix} is either smaller than\n     *             {@link java.lang.Character#MIN_RADIX} or larger than\n     *             {@link java.lang.Character#MAX_RADIX}.\n     * @since  9\n     */\n    public static int parseInt(CharSequence s, int beginIndex, int endIndex, int radix)\n                throws NumberFormatException {\n        Objects.requireNonNull(s);\n\n        if (beginIndex \u003c 0 || beginIndex \u003e endIndex || endIndex \u003e s.length()) {\n            throw new IndexOutOfBoundsException();\n        }\n        if (radix \u003c Character.MIN_RADIX) {\n            throw new NumberFormatException(\"radix \" + radix +\n                                            \" less than Character.MIN_RADIX\");\n        }\n        if (radix \u003e Character.MAX_RADIX) {\n            throw new NumberFormatException(\"radix \" + radix +\n                                            \" greater than Character.MAX_RADIX\");\n        }\n\n        boolean negative \u003d false;\n        int i \u003d beginIndex;\n        int limit \u003d -Integer.MAX_VALUE;\n\n        if (i \u003c endIndex) {\n            char firstChar \u003d s.charAt(i);\n            if (firstChar \u003c \u00270\u0027) { // Possible leading \"+\" or \"-\"\n                if (firstChar \u003d\u003d \u0027-\u0027) {\n                    negative \u003d true;\n                    limit \u003d Integer.MIN_VALUE;\n                } else if (firstChar !\u003d \u0027+\u0027) {\n                    throw NumberFormatException.forCharSequence(s, beginIndex,\n                            endIndex, i);\n                }\n                i++;\n                if (i \u003d\u003d endIndex) { // Cannot have lone \"+\" or \"-\"\n                    throw NumberFormatException.forCharSequence(s, beginIndex,\n                            endIndex, i);\n                }\n            }\n            int multmin \u003d limit / radix;\n            int result \u003d 0;\n            while (i \u003c endIndex) {\n                // Accumulating negatively avoids surprises near MAX_VALUE\n                int digit \u003d Character.digit(s.charAt(i), radix);\n                if (digit \u003c 0 || result \u003c multmin) {\n                    throw NumberFormatException.forCharSequence(s, beginIndex,\n                            endIndex, i);\n                }\n                result *\u003d radix;\n                if (result \u003c limit + digit) {\n                    throw NumberFormatException.forCharSequence(s, beginIndex,\n                            endIndex, i);\n                }\n                i++;\n                result -\u003d digit;\n            }\n            return negative ? result : -result;\n        } else {\n            throw NumberFormatException.forInputString(\"\", radix);\n        }\n    }\n\n    /**\n     * Parses the string argument as a signed decimal integer. The\n     * characters in the string must all be decimal digits, except\n     * that the first character may be an ASCII minus sign {@code \u0027-\u0027}\n     * ({@code \u0027\\u005Cu002D\u0027}) to indicate a negative value or an\n     * ASCII plus sign {@code \u0027+\u0027} ({@code \u0027\\u005Cu002B\u0027}) to\n     * indicate a positive value. The resulting integer value is\n     * returned, exactly as if the argument and the radix 10 were\n     * given as arguments to the {@link #parseInt(java.lang.String,\n     * int)} method.\n     *\n     * @param s    a {@code String} containing the {@code int}\n     *             representation to be parsed\n     * @return     the integer value represented by the argument in decimal.\n     * @throws     NumberFormatException  if the string does not contain a\n     *               parsable integer.\n     */\n    public static int parseInt(String s) throws NumberFormatException {\n        return parseInt(s,10);\n    }\n\n    /**\n     * Parses the string argument as an unsigned integer in the radix\n     * specified by the second argument.  An unsigned integer maps the\n     * values usually associated with negative numbers to positive\n     * numbers larger than {@code MAX_VALUE}.\n     *\n     * The characters in the string must all be digits of the\n     * specified radix (as determined by whether {@link\n     * java.lang.Character#digit(char, int)} returns a nonnegative\n     * value), except that the first character may be an ASCII plus\n     * sign {@code \u0027+\u0027} ({@code \u0027\\u005Cu002B\u0027}). The resulting\n     * integer value is returned.\n     *\n     * \u003cp\u003eAn exception of type {@code NumberFormatException} is\n     * thrown if any of the following situations occurs:\n     * \u003cul\u003e\n     * \u003cli\u003eThe first argument is {@code null} or is a string of\n     * length zero.\n     *\n     * \u003cli\u003eThe radix is either smaller than\n     * {@link java.lang.Character#MIN_RADIX} or\n     * larger than {@link java.lang.Character#MAX_RADIX}.\n     *\n     * \u003cli\u003eAny character of the string is not a digit of the specified\n     * radix, except that the first character may be a plus sign\n     * {@code \u0027+\u0027} ({@code \u0027\\u005Cu002B\u0027}) provided that the\n     * string is longer than length 1.\n     *\n     * \u003cli\u003eThe value represented by the string is larger than the\n     * largest unsigned {@code int}, 2\u003csup\u003e32\u003c/sup\u003e-1.\n     *\n     * \u003c/ul\u003e\n     *\n     *\n     * @param      s   the {@code String} containing the unsigned integer\n     *                  representation to be parsed\n     * @param      radix   the radix to be used while parsing {@code s}.\n     * @return     the integer represented by the string argument in the\n     *             specified radix.\n     * @throws     NumberFormatException if the {@code String}\n     *             does not contain a parsable {@code int}.\n     * @since 1.8\n     */\n    public static int parseUnsignedInt(String s, int radix)\n                throws NumberFormatException {\n        if (s \u003d\u003d null)  {\n            throw new NumberFormatException(\"Cannot parse null string\");\n        }\n\n        int len \u003d s.length();\n        if (len \u003e 0) {\n            char firstChar \u003d s.charAt(0);\n            if (firstChar \u003d\u003d \u0027-\u0027) {\n                throw new\n                    NumberFormatException(String.format(\"Illegal leading minus sign \" +\n                                                       \"on unsigned string %s.\", s));\n            } else {\n                if (len \u003c\u003d 5 || // Integer.MAX_VALUE in Character.MAX_RADIX is 6 digits\n                    (radix \u003d\u003d 10 \u0026\u0026 len \u003c\u003d 9) ) { // Integer.MAX_VALUE in base 10 is 10 digits\n                    return parseInt(s, radix);\n                } else {\n                    long ell \u003d Long.parseLong(s, radix);\n                    if ((ell \u0026 0xffff_ffff_0000_0000L) \u003d\u003d 0) {\n                        return (int) ell;\n                    } else {\n                        throw new\n                            NumberFormatException(String.format(\"String value %s exceeds \" +\n                                                                \"range of unsigned int.\", s));\n                    }\n                }\n            }\n        } else {\n            throw NumberFormatException.forInputString(s, radix);\n        }\n    }\n\n    /**\n     * Parses the {@link CharSequence} argument as an unsigned {@code int} in\n     * the specified {@code radix}, beginning at the specified\n     * {@code beginIndex} and extending to {@code endIndex - 1}.\n     *\n     * \u003cp\u003eThe method does not take steps to guard against the\n     * {@code CharSequence} being mutated while parsing.\n     *\n     * @param      s   the {@code CharSequence} containing the unsigned\n     *                 {@code int} representation to be parsed\n     * @param      beginIndex   the beginning index, inclusive.\n     * @param      endIndex     the ending index, exclusive.\n     * @param      radix   the radix to be used while parsing {@code s}.\n     * @return     the unsigned {@code int} represented by the subsequence in\n     *             the specified radix.\n     * @throws     NullPointerException  if {@code s} is null.\n     * @throws     IndexOutOfBoundsException  if {@code beginIndex} is\n     *             negative, or if {@code beginIndex} is greater than\n     *             {@code endIndex} or if {@code endIndex} is greater than\n     *             {@code s.length()}.\n     * @throws     NumberFormatException  if the {@code CharSequence} does not\n     *             contain a parsable unsigned {@code int} in the specified\n     *             {@code radix}, or if {@code radix} is either smaller than\n     *             {@link java.lang.Character#MIN_RADIX} or larger than\n     *             {@link java.lang.Character#MAX_RADIX}.\n     * @since  9\n     */\n    public static int parseUnsignedInt(CharSequence s, int beginIndex, int endIndex, int radix)\n                throws NumberFormatException {\n        Objects.requireNonNull(s);\n\n        if (beginIndex \u003c 0 || beginIndex \u003e endIndex || endIndex \u003e s.length()) {\n            throw new IndexOutOfBoundsException();\n        }\n        int start \u003d beginIndex, len \u003d endIndex - beginIndex;\n\n        if (len \u003e 0) {\n            char firstChar \u003d s.charAt(start);\n            if (firstChar \u003d\u003d \u0027-\u0027) {\n                throw new\n                    NumberFormatException(String.format(\"Illegal leading minus sign \" +\n                                                       \"on unsigned string %s.\", s));\n            } else {\n                if (len \u003c\u003d 5 || // Integer.MAX_VALUE in Character.MAX_RADIX is 6 digits\n                        (radix \u003d\u003d 10 \u0026\u0026 len \u003c\u003d 9)) { // Integer.MAX_VALUE in base 10 is 10 digits\n                    return parseInt(s, start, start + len, radix);\n                } else {\n                    long ell \u003d Long.parseLong(s, start, start + len, radix);\n                    if ((ell \u0026 0xffff_ffff_0000_0000L) \u003d\u003d 0) {\n                        return (int) ell;\n                    } else {\n                        throw new\n                            NumberFormatException(String.format(\"String value %s exceeds \" +\n                                                                \"range of unsigned int.\", s));\n                    }\n                }\n            }\n        } else {\n            throw new NumberFormatException(\"\");\n        }\n    }\n\n    /**\n     * Parses the string argument as an unsigned decimal integer. The\n     * characters in the string must all be decimal digits, except\n     * that the first character may be an ASCII plus sign {@code\n     * \u0027+\u0027} ({@code \u0027\\u005Cu002B\u0027}). The resulting integer value\n     * is returned, exactly as if the argument and the radix 10 were\n     * given as arguments to the {@link\n     * #parseUnsignedInt(java.lang.String, int)} method.\n     *\n     * @param s   a {@code String} containing the unsigned {@code int}\n     *            representation to be parsed\n     * @return    the unsigned integer value represented by the argument in decimal.\n     * @throws    NumberFormatException  if the string does not contain a\n     *            parsable unsigned integer.\n     * @since 1.8\n     */\n    public static int parseUnsignedInt(String s) throws NumberFormatException {\n        return parseUnsignedInt(s, 10);\n    }\n\n    /**\n     * Returns an {@code Integer} object holding the value\n     * extracted from the specified {@code String} when parsed\n     * with the radix given by the second argument. The first argument\n     * is interpreted as representing a signed integer in the radix\n     * specified by the second argument, exactly as if the arguments\n     * were given to the {@link #parseInt(java.lang.String, int)}\n     * method. The result is an {@code Integer} object that\n     * represents the integer value specified by the string.\n     *\n     * \u003cp\u003eIn other words, this method returns an {@code Integer}\n     * object equal to the value of:\n     *\n     * \u003cblockquote\u003e\n     *  {@code new Integer(Integer.parseInt(s, radix))}\n     * \u003c/blockquote\u003e\n     *\n     * @param      s   the string to be parsed.\n     * @param      radix the radix to be used in interpreting {@code s}\n     * @return     an {@code Integer} object holding the value\n     *             represented by the string argument in the specified\n     *             radix.\n     * @throws    NumberFormatException if the {@code String}\n     *            does not contain a parsable {@code int}.\n     */\n    public static Integer valueOf(String s, int radix) throws NumberFormatException {\n        return Integer.valueOf(parseInt(s,radix));\n    }\n\n    /**\n     * Returns an {@code Integer} object holding the\n     * value of the specified {@code String}. The argument is\n     * interpreted as representing a signed decimal integer, exactly\n     * as if the argument were given to the {@link\n     * #parseInt(java.lang.String)} method. The result is an\n     * {@code Integer} object that represents the integer value\n     * specified by the string.\n     *\n     * \u003cp\u003eIn other words, this method returns an {@code Integer}\n     * object equal to the value of:\n     *\n     * \u003cblockquote\u003e\n     *  {@code new Integer(Integer.parseInt(s))}\n     * \u003c/blockquote\u003e\n     *\n     * @param      s   the string to be parsed.\n     * @return     an {@code Integer} object holding the value\n     *             represented by the string argument.\n     * @throws     NumberFormatException  if the string cannot be parsed\n     *             as an integer.\n     */\n    public static Integer valueOf(String s) throws NumberFormatException {\n        return Integer.valueOf(parseInt(s, 10));\n    }\n\n    /**\n     * Cache to support the object identity semantics of autoboxing for values between\n     * -128 and 127 (inclusive) as required by JLS.\n     *\n     * The cache is initialized on first usage.  The size of the cache\n     * may be controlled by the {@code -XX:AutoBoxCacheMax\u003d\u003csize\u003e} option.\n     * During VM initialization, java.lang.Integer.IntegerCache.high property\n     * may be set and saved in the private system properties in the\n     * jdk.internal.misc.VM class.\n     *\n     * WARNING: The cache is archived with CDS and reloaded from the shared\n     * archive at runtime. The archived cache (Integer[]) and Integer objects\n     * reside in the closed archive heap regions. Care should be taken when\n     * changing the implementation and the cache array should not be assigned\n     * with new Integer object(s) after initialization.\n     */\n\n    private static class IntegerCache {\n        static final int low \u003d -128;\n        static final int high;\n        static final Integer[] cache;\n        static Integer[] archivedCache;\n\n        static {\n            // high value may be configured by property\n            int h \u003d 127;\n            String integerCacheHighPropValue \u003d\n                VM.getSavedProperty(\"java.lang.Integer.IntegerCache.high\");\n            if (integerCacheHighPropValue !\u003d null) {\n                try {\n                    h \u003d Math.max(parseInt(integerCacheHighPropValue), 127);\n                    // Maximum array size is Integer.MAX_VALUE\n                    h \u003d Math.min(h, Integer.MAX_VALUE - (-low) -1);\n                } catch( NumberFormatException nfe) {\n                    // If the property cannot be parsed into an int, ignore it.\n                }\n            }\n            high \u003d h;\n\n            // Load IntegerCache.archivedCache from archive, if possible\n            CDS.initializeFromArchive(IntegerCache.class);\n            int size \u003d (high - low) + 1;\n\n            // Use the archived cache if it exists and is large enough\n            if (archivedCache \u003d\u003d null || size \u003e archivedCache.length) {\n                Integer[] c \u003d new Integer[size];\n                int j \u003d low;\n                for(int i \u003d 0; i \u003c c.length; i++) {\n                    c[i] \u003d new Integer(j++);\n                }\n                archivedCache \u003d c;\n            }\n            cache \u003d archivedCache;\n            // range [-128, 127] must be interned (JLS7 5.1.7)\n            assert IntegerCache.high \u003e\u003d 127;\n        }\n\n        private IntegerCache() {}\n    }\n\n    /**\n     * Returns an {@code Integer} instance representing the specified\n     * {@code int} value.  If a new {@code Integer} instance is not\n     * required, this method should generally be used in preference to\n     * the constructor {@link #Integer(int)}, as this method is likely\n     * to yield significantly better space and time performance by\n     * caching frequently requested values.\n     *\n     * This method will always cache values in the range -128 to 127,\n     * inclusive, and may cache other values outside of this range.\n     *\n     * @param  i an {@code int} value.\n     * @return an {@code Integer} instance representing {@code i}.\n     * @since  1.5\n     */\n    @IntrinsicCandidate\n    public static Integer valueOf(int i) {\n        if (i \u003e\u003d IntegerCache.low \u0026\u0026 i \u003c\u003d IntegerCache.high)\n            return IntegerCache.cache[i + (-IntegerCache.low)];\n        return new Integer(i);\n    }\n\n    /**\n     * The value of the {@code Integer}.\n     *\n     * @serial\n     */\n    private final int value;\n\n    /**\n     * Constructs a newly allocated {@code Integer} object that\n     * represents the specified {@code int} value.\n     *\n     * @param   value   the value to be represented by the\n     *                  {@code Integer} object.\n     *\n     * @deprecated\n     * It is rarely appropriate to use this constructor. The static factory\n     * {@link #valueOf(int)} is generally a better choice, as it is\n     * likely to yield significantly better space and time performance.\n     */\n    @Deprecated(since\u003d\"9\", forRemoval \u003d true)\n    public Integer(int value) {\n        this.value \u003d value;\n    }\n\n    /**\n     * Constructs a newly allocated {@code Integer} object that\n     * represents the {@code int} value indicated by the\n     * {@code String} parameter. The string is converted to an\n     * {@code int} value in exactly the manner used by the\n     * {@code parseInt} method for radix 10.\n     *\n     * @param   s   the {@code String} to be converted to an {@code Integer}.\n     * @throws      NumberFormatException if the {@code String} does not\n     *              contain a parsable integer.\n     *\n     * @deprecated\n     * It is rarely appropriate to use this constructor.\n     * Use {@link #parseInt(String)} to convert a string to a\n     * {@code int} primitive, or use {@link #valueOf(String)}\n     * to convert a string to an {@code Integer} object.\n     */\n    @Deprecated(since\u003d\"9\", forRemoval \u003d true)\n    public Integer(String s) throws NumberFormatException {\n        this.value \u003d parseInt(s, 10);\n    }\n\n    /**\n     * Returns the value of this {@code Integer} as a {@code byte}\n     * after a narrowing primitive conversion.\n     * @jls 5.1.3 Narrowing Primitive Conversion\n     */\n    public byte byteValue() {\n        return (byte)value;\n    }\n\n    /**\n     * Returns the value of this {@code Integer} as a {@code short}\n     * after a narrowing primitive conversion.\n     * @jls 5.1.3 Narrowing Primitive Conversion\n     */\n    public short shortValue() {\n        return (short)value;\n    }\n\n    /**\n     * Returns the value of this {@code Integer} as an\n     * {@code int}.\n     */\n    @IntrinsicCandidate\n    public int intValue() {\n        return value;\n    }\n\n    /**\n     * Returns the value of this {@code Integer} as a {@code long}\n     * after a widening primitive conversion.\n     * @jls 5.1.2 Widening Primitive Conversion\n     * @see Integer#toUnsignedLong(int)\n     */\n    public long longValue() {\n        return (long)value;\n    }\n\n    /**\n     * Returns the value of this {@code Integer} as a {@code float}\n     * after a widening primitive conversion.\n     * @jls 5.1.2 Widening Primitive Conversion\n     */\n    public float floatValue() {\n        return (float)value;\n    }\n\n    /**\n     * Returns the value of this {@code Integer} as a {@code double}\n     * after a widening primitive conversion.\n     * @jls 5.1.2 Widening Primitive Conversion\n     */\n    public double doubleValue() {\n        return (double)value;\n    }\n\n    /**\n     * Returns a {@code String} object representing this\n     * {@code Integer}\u0027s value. The value is converted to signed\n     * decimal representation and returned as a string, exactly as if\n     * the integer value were given as an argument to the {@link\n     * java.lang.Integer#toString(int)} method.\n     *\n     * @return  a string representation of the value of this object in\n     *          base\u0026nbsp;10.\n     */\n    public String toString() {\n        return toString(value);\n    }\n\n    /**\n     * Returns a hash code for this {@code Integer}.\n     *\n     * @return  a hash code value for this object, equal to the\n     *          primitive {@code int} value represented by this\n     *          {@code Integer} object.\n     */\n    @Override\n    public int hashCode() {\n        return Integer.hashCode(value);\n    }\n\n    /**\n     * Returns a hash code for an {@code int} value; compatible with\n     * {@code Integer.hashCode()}.\n     *\n     * @param value the value to hash\n     * @since 1.8\n     *\n     * @return a hash code value for an {@code int} value.\n     */\n    public static int hashCode(int value) {\n        return value;\n    }\n\n    /**\n     * Compares this object to the specified object.  The result is\n     * {@code true} if and only if the argument is not\n     * {@code null} and is an {@code Integer} object that\n     * contains the same {@code int} value as this object.\n     *\n     * @param   obj   the object to compare with.\n     * @return  {@code true} if the objects are the same;\n     *          {@code false} otherwise.\n     */\n    public boolean equals(Object obj) {\n        if (obj instanceof Integer) {\n            return value \u003d\u003d ((Integer)obj).intValue();\n        }\n        return false;\n    }\n\n    /**\n     * Determines the integer value of the system property with the\n     * specified name.\n     *\n     * \u003cp\u003eThe first argument is treated as the name of a system\n     * property.  System properties are accessible through the {@link\n     * java.lang.System#getProperty(java.lang.String)} method. The\n     * string value of this property is then interpreted as an integer\n     * value using the grammar supported by {@link Integer#decode decode} and\n     * an {@code Integer} object representing this value is returned.\n     *\n     * \u003cp\u003eIf there is no property with the specified name, if the\n     * specified name is empty or {@code null}, or if the property\n     * does not have the correct numeric format, then {@code null} is\n     * returned.\n     *\n     * \u003cp\u003eIn other words, this method returns an {@code Integer}\n     * object equal to the value of:\n     *\n     * \u003cblockquote\u003e\n     *  {@code getInteger(nm, null)}\n     * \u003c/blockquote\u003e\n     *\n     * @param   nm   property name.\n     * @return  the {@code Integer} value of the property.\n     * @throws  SecurityException for the same reasons as\n     *          {@link System#getProperty(String) System.getProperty}\n     * @see     java.lang.System#getProperty(java.lang.String)\n     * @see     java.lang.System#getProperty(java.lang.String, java.lang.String)\n     */\n    public static Integer getInteger(String nm) {\n        return getInteger(nm, null);\n    }\n\n    /**\n     * Determines the integer value of the system property with the\n     * specified name.\n     *\n     * \u003cp\u003eThe first argument is treated as the name of a system\n     * property.  System properties are accessible through the {@link\n     * java.lang.System#getProperty(java.lang.String)} method. The\n     * string value of this property is then interpreted as an integer\n     * value using the grammar supported by {@link Integer#decode decode} and\n     * an {@code Integer} object representing this value is returned.\n     *\n     * \u003cp\u003eThe second argument is the default value. An {@code Integer} object\n     * that represents the value of the second argument is returned if there\n     * is no property of the specified name, if the property does not have\n     * the correct numeric format, or if the specified name is empty or\n     * {@code null}.\n     *\n     * \u003cp\u003eIn other words, this method returns an {@code Integer} object\n     * equal to the value of:\n     *\n     * \u003cblockquote\u003e\n     *  {@code getInteger(nm, new Integer(val))}\n     * \u003c/blockquote\u003e\n     *\n     * but in practice it may be implemented in a manner such as:\n     *\n     * \u003cblockquote\u003e\u003cpre\u003e\n     * Integer result \u003d getInteger(nm, null);\n     * return (result \u003d\u003d null) ? new Integer(val) : result;\n     * \u003c/pre\u003e\u003c/blockquote\u003e\n     *\n     * to avoid the unnecessary allocation of an {@code Integer}\n     * object when the default value is not needed.\n     *\n     * @param   nm   property name.\n     * @param   val   default value.\n     * @return  the {@code Integer} value of the property.\n     * @throws  SecurityException for the same reasons as\n     *          {@link System#getProperty(String) System.getProperty}\n     * @see     java.lang.System#getProperty(java.lang.String)\n     * @see     java.lang.System#getProperty(java.lang.String, java.lang.String)\n     */\n    public static Integer getInteger(String nm, int val) {\n        Integer result \u003d getInteger(nm, null);\n        return (result \u003d\u003d null) ? Integer.valueOf(val) : result;\n    }\n\n    /**\n     * Returns the integer value of the system property with the\n     * specified name.  The first argument is treated as the name of a\n     * system property.  System properties are accessible through the\n     * {@link java.lang.System#getProperty(java.lang.String)} method.\n     * The string value of this property is then interpreted as an\n     * integer value, as per the {@link Integer#decode decode} method,\n     * and an {@code Integer} object representing this value is\n     * returned; in summary:\n     *\n     * \u003cul\u003e\u003cli\u003eIf the property value begins with the two ASCII characters\n     *         {@code 0x} or the ASCII character {@code #}, not\n     *      followed by a minus sign, then the rest of it is parsed as a\n     *      hexadecimal integer exactly as by the method\n     *      {@link #valueOf(java.lang.String, int)} with radix 16.\n     * \u003cli\u003eIf the property value begins with the ASCII character\n     *     {@code 0} followed by another character, it is parsed as an\n     *     octal integer exactly as by the method\n     *     {@link #valueOf(java.lang.String, int)} with radix 8.\n     * \u003cli\u003eOtherwise, the property value is parsed as a decimal integer\n     * exactly as by the method {@link #valueOf(java.lang.String, int)}\n     * with radix 10.\n     * \u003c/ul\u003e\n     *\n     * \u003cp\u003eThe second argument is the default value. The default value is\n     * returned if there is no property of the specified name, if the\n     * property does not have the correct numeric format, or if the\n     * specified name is empty or {@code null}.\n     *\n     * @param   nm   property name.\n     * @param   val   default value.\n     * @return  the {@code Integer} value of the property.\n     * @throws  SecurityException for the same reasons as\n     *          {@link System#getProperty(String) System.getProperty}\n     * @see     System#getProperty(java.lang.String)\n     * @see     System#getProperty(java.lang.String, java.lang.String)\n     */\n    public static Integer getInteger(String nm, Integer val) {\n        String v \u003d null;\n        try {\n            v \u003d System.getProperty(nm);\n        } catch (IllegalArgumentException | NullPointerException e) {\n        }\n        if (v !\u003d null) {\n            try {\n                return Integer.decode(v);\n            } catch (NumberFormatException e) {\n            }\n        }\n        return val;\n    }\n\n    /**\n     * Decodes a {@code String} into an {@code Integer}.\n     * Accepts decimal, hexadecimal, and octal numbers given\n     * by the following grammar:\n     *\n     * \u003cblockquote\u003e\n     * \u003cdl\u003e\n     * \u003cdt\u003e\u003ci\u003eDecodableString:\u003c/i\u003e\n     * \u003cdd\u003e\u003ci\u003eSign\u003csub\u003eopt\u003c/sub\u003e DecimalNumeral\u003c/i\u003e\n     * \u003cdd\u003e\u003ci\u003eSign\u003csub\u003eopt\u003c/sub\u003e\u003c/i\u003e {@code 0x} \u003ci\u003eHexDigits\u003c/i\u003e\n     * \u003cdd\u003e\u003ci\u003eSign\u003csub\u003eopt\u003c/sub\u003e\u003c/i\u003e {@code 0X} \u003ci\u003eHexDigits\u003c/i\u003e\n     * \u003cdd\u003e\u003ci\u003eSign\u003csub\u003eopt\u003c/sub\u003e\u003c/i\u003e {@code #} \u003ci\u003eHexDigits\u003c/i\u003e\n     * \u003cdd\u003e\u003ci\u003eSign\u003csub\u003eopt\u003c/sub\u003e\u003c/i\u003e {@code 0} \u003ci\u003eOctalDigits\u003c/i\u003e\n     *\n     * \u003cdt\u003e\u003ci\u003eSign:\u003c/i\u003e\n     * \u003cdd\u003e{@code -}\n     * \u003cdd\u003e{@code +}\n     * \u003c/dl\u003e\n     * \u003c/blockquote\u003e\n     *\n     * \u003ci\u003eDecimalNumeral\u003c/i\u003e, \u003ci\u003eHexDigits\u003c/i\u003e, and \u003ci\u003eOctalDigits\u003c/i\u003e\n     * are as defined in section {@jls 3.10.1} of\n     * \u003ccite\u003eThe Java Language Specification\u003c/cite\u003e,\n     * except that underscores are not accepted between digits.\n     *\n     * \u003cp\u003eThe sequence of characters following an optional\n     * sign and/or radix specifier (\"{@code 0x}\", \"{@code 0X}\",\n     * \"{@code #}\", or leading zero) is parsed as by the {@code\n     * Integer.parseInt} method with the indicated radix (10, 16, or\n     * 8).  This sequence of characters must represent a positive\n     * value or a {@link NumberFormatException} will be thrown.  The\n     * result is negated if first character of the specified {@code\n     * String} is the minus sign.  No whitespace characters are\n     * permitted in the {@code String}.\n     *\n     * @param     nm the {@code String} to decode.\n     * @return    an {@code Integer} object holding the {@code int}\n     *             value represented by {@code nm}\n     * @throws    NumberFormatException  if the {@code String} does not\n     *            contain a parsable integer.\n     * @see java.lang.Integer#parseInt(java.lang.String, int)\n     */\n    public static Integer decode(String nm) throws NumberFormatException {\n        int radix \u003d 10;\n        int index \u003d 0;\n        boolean negative \u003d false;\n        Integer result;\n\n        if (nm.isEmpty())\n            throw new NumberFormatException(\"Zero length string\");\n        char firstChar \u003d nm.charAt(0);\n        // Handle sign, if present\n        if (firstChar \u003d\u003d \u0027-\u0027) {\n            negative \u003d true;\n            index++;\n        } else if (firstChar \u003d\u003d \u0027+\u0027)\n            index++;\n\n        // Handle radix specifier, if present\n        if (nm.startsWith(\"0x\", index) || nm.startsWith(\"0X\", index)) {\n            index +\u003d 2;\n            radix \u003d 16;\n        }\n        else if (nm.startsWith(\"#\", index)) {\n            index ++;\n            radix \u003d 16;\n        }\n        else if (nm.startsWith(\"0\", index) \u0026\u0026 nm.length() \u003e 1 + index) {\n            index ++;\n            radix \u003d 8;\n        }\n\n        if (nm.startsWith(\"-\", index) || nm.startsWith(\"+\", index))\n            throw new NumberFormatException(\"Sign character in wrong position\");\n\n        try {\n            result \u003d Integer.valueOf(nm.substring(index), radix);\n            result \u003d negative ? Integer.valueOf(-result.intValue()) : result;\n        } catch (NumberFormatException e) {\n            // If number is Integer.MIN_VALUE, we\u0027ll end up here. The next line\n            // handles this case, and causes any genuine format error to be\n            // rethrown.\n            String constant \u003d negative ? (\"-\" + nm.substring(index))\n                                       : nm.substring(index);\n            result \u003d Integer.valueOf(constant, radix);\n        }\n        return result;\n    }\n\n    /**\n     * Compares two {@code Integer} objects numerically.\n     *\n     * @param   anotherInteger   the {@code Integer} to be compared.\n     * @return  the value {@code 0} if this {@code Integer} is\n     *          equal to the argument {@code Integer}; a value less than\n     *          {@code 0} if this {@code Integer} is numerically less\n     *          than the argument {@code Integer}; and a value greater\n     *          than {@code 0} if this {@code Integer} is numerically\n     *           greater than the argument {@code Integer} (signed\n     *           comparison).\n     * @since   1.2\n     */\n    public int compareTo(Integer anotherInteger) {\n        return compare(this.value, anotherInteger.value);\n    }\n\n    /**\n     * Compares two {@code int} values numerically.\n     * The value returned is identical to what would be returned by:\n     * \u003cpre\u003e\n     *    Integer.valueOf(x).compareTo(Integer.valueOf(y))\n     * \u003c/pre\u003e\n     *\n     * @param  x the first {@code int} to compare\n     * @param  y the second {@code int} to compare\n     * @return the value {@code 0} if {@code x \u003d\u003d y};\n     *         a value less than {@code 0} if {@code x \u003c y}; and\n     *         a value greater than {@code 0} if {@code x \u003e y}\n     * @since 1.7\n     */\n    public static int compare(int x, int y) {\n        return (x \u003c y) ? -1 : ((x \u003d\u003d y) ? 0 : 1);\n    }\n\n    /**\n     * Compares two {@code int} values numerically treating the values\n     * as unsigned.\n     *\n     * @param  x the first {@code int} to compare\n     * @param  y the second {@code int} to compare\n     * @return the value {@code 0} if {@code x \u003d\u003d y}; a value less\n     *         than {@code 0} if {@code x \u003c y} as unsigned values; and\n     *         a value greater than {@code 0} if {@code x \u003e y} as\n     *         unsigned values\n     * @since 1.8\n     */\n    public static int compareUnsigned(int x, int y) {\n        return compare(x + MIN_VALUE, y + MIN_VALUE);\n    }\n\n    /**\n     * Converts the argument to a {@code long} by an unsigned\n     * conversion.  In an unsigned conversion to a {@code long}, the\n     * high-order 32 bits of the {@code long} are zero and the\n     * low-order 32 bits are equal to the bits of the integer\n     * argument.\n     *\n     * Consequently, zero and positive {@code int} values are mapped\n     * to a numerically equal {@code long} value and negative {@code\n     * int} values are mapped to a {@code long} value equal to the\n     * input plus 2\u003csup\u003e32\u003c/sup\u003e.\n     *\n     * @param  x the value to convert to an unsigned {@code long}\n     * @return the argument converted to {@code long} by an unsigned\n     *         conversion\n     * @since 1.8\n     */\n    public static long toUnsignedLong(int x) {\n        return ((long) x) \u0026 0xffffffffL;\n    }\n\n    /**\n     * Returns the unsigned quotient of dividing the first argument by\n     * the second where each argument and the result is interpreted as\n     * an unsigned value.\n     *\n     * \u003cp\u003eNote that in two\u0027s complement arithmetic, the three other\n     * basic arithmetic operations of add, subtract, and multiply are\n     * bit-wise identical if the two operands are regarded as both\n     * being signed or both being unsigned.  Therefore separate {@code\n     * addUnsigned}, etc. methods are not provided.\n     *\n     * @param dividend the value to be divided\n     * @param divisor the value doing the dividing\n     * @return the unsigned quotient of the first argument divided by\n     * the second argument\n     * @see #remainderUnsigned\n     * @since 1.8\n     */\n    public static int divideUnsigned(int dividend, int divisor) {\n        // In lieu of tricky code, for now just use long arithmetic.\n        return (int)(toUnsignedLong(dividend) / toUnsignedLong(divisor));\n    }\n\n    /**\n     * Returns the unsigned remainder from dividing the first argument\n     * by the second where each argument and the result is interpreted\n     * as an unsigned value.\n     *\n     * @param dividend the value to be divided\n     * @param divisor the value doing the dividing\n     * @return the unsigned remainder of the first argument divided by\n     * the second argument\n     * @see #divideUnsigned\n     * @since 1.8\n     */\n    public static int remainderUnsigned(int dividend, int divisor) {\n        // In lieu of tricky code, for now just use long arithmetic.\n        return (int)(toUnsignedLong(dividend) % toUnsignedLong(divisor));\n    }\n\n\n    // Bit twiddling\n\n    /**\n     * The number of bits used to represent an {@code int} value in two\u0027s\n     * complement binary form.\n     *\n     * @since 1.5\n     */\n    @Native public static final int SIZE \u003d 32;\n\n    /**\n     * The number of bytes used to represent an {@code int} value in two\u0027s\n     * complement binary form.\n     *\n     * @since 1.8\n     */\n    public static final int BYTES \u003d SIZE / Byte.SIZE;\n\n    /**\n     * Returns an {@code int} value with at most a single one-bit, in the\n     * position of the highest-order (\"leftmost\") one-bit in the specified\n     * {@code int} value.  Returns zero if the specified value has no\n     * one-bits in its two\u0027s complement binary representation, that is, if it\n     * is equal to zero.\n     *\n     * @param i the value whose highest one bit is to be computed\n     * @return an {@code int} value with a single one-bit, in the position\n     *     of the highest-order one-bit in the specified value, or zero if\n     *     the specified value is itself equal to zero.\n     * @since 1.5\n     */\n    public static int highestOneBit(int i) {\n        return i \u0026 (MIN_VALUE \u003e\u003e\u003e numberOfLeadingZeros(i));\n    }\n\n    /**\n     * Returns an {@code int} value with at most a single one-bit, in the\n     * position of the lowest-order (\"rightmost\") one-bit in the specified\n     * {@code int} value.  Returns zero if the specified value has no\n     * one-bits in its two\u0027s complement binary representation, that is, if it\n     * is equal to zero.\n     *\n     * @param i the value whose lowest one bit is to be computed\n     * @return an {@code int} value with a single one-bit, in the position\n     *     of the lowest-order one-bit in the specified value, or zero if\n     *     the specified value is itself equal to zero.\n     * @since 1.5\n     */\n    public static int lowestOneBit(int i) {\n        // HD, Section 2-1\n        return i \u0026 -i;\n    }\n\n    /**\n     * Returns the number of zero bits preceding the highest-order\n     * (\"leftmost\") one-bit in the two\u0027s complement binary representation\n     * of the specified {@code int} value.  Returns 32 if the\n     * specified value has no one-bits in its two\u0027s complement representation,\n     * in other words if it is equal to zero.\n     *\n     * \u003cp\u003eNote that this method is closely related to the logarithm base 2.\n     * For all positive {@code int} values x:\n     * \u003cul\u003e\n     * \u003cli\u003efloor(log\u003csub\u003e2\u003c/sub\u003e(x)) \u003d {@code 31 - numberOfLeadingZeros(x)}\n     * \u003cli\u003eceil(log\u003csub\u003e2\u003c/sub\u003e(x)) \u003d {@code 32 - numberOfLeadingZeros(x - 1)}\n     * \u003c/ul\u003e\n     *\n     * @param i the value whose number of leading zeros is to be computed\n     * @return the number of zero bits preceding the highest-order\n     *     (\"leftmost\") one-bit in the two\u0027s complement binary representation\n     *     of the specified {@code int} value, or 32 if the value\n     *     is equal to zero.\n     * @since 1.5\n     */\n    @IntrinsicCandidate\n    public static int numberOfLeadingZeros(int i) {\n        // HD, Count leading 0\u0027s\n        if (i \u003c\u003d 0)\n            return i \u003d\u003d 0 ? 32 : 0;\n        int n \u003d 31;\n        if (i \u003e\u003d 1 \u003c\u003c 16) { n -\u003d 16; i \u003e\u003e\u003e\u003d 16; }\n        if (i \u003e\u003d 1 \u003c\u003c  8) { n -\u003d  8; i \u003e\u003e\u003e\u003d  8; }\n        if (i \u003e\u003d 1 \u003c\u003c  4) { n -\u003d  4; i \u003e\u003e\u003e\u003d  4; }\n        if (i \u003e\u003d 1 \u003c\u003c  2) { n -\u003d  2; i \u003e\u003e\u003e\u003d  2; }\n        return n - (i \u003e\u003e\u003e 1);\n    }\n\n    /**\n     * Returns the number of zero bits following the lowest-order (\"rightmost\")\n     * one-bit in the two\u0027s complement binary representation of the specified\n     * {@code int} value.  Returns 32 if the specified value has no\n     * one-bits in its two\u0027s complement representation, in other words if it is\n     * equal to zero.\n     *\n     * @param i the value whose number of trailing zeros is to be computed\n     * @return the number of zero bits following the lowest-order (\"rightmost\")\n     *     one-bit in the two\u0027s complement binary representation of the\n     *     specified {@code int} value, or 32 if the value is equal\n     *     to zero.\n     * @since 1.5\n     */\n    @IntrinsicCandidate\n    public static int numberOfTrailingZeros(int i) {\n        // HD, Count trailing 0\u0027s\n        i \u003d ~i \u0026 (i - 1);\n        if (i \u003c\u003d 0) return i \u0026 32;\n        int n \u003d 1;\n        if (i \u003e 1 \u003c\u003c 16) { n +\u003d 16; i \u003e\u003e\u003e\u003d 16; }\n        if (i \u003e 1 \u003c\u003c  8) { n +\u003d  8; i \u003e\u003e\u003e\u003d  8; }\n        if (i \u003e 1 \u003c\u003c  4) { n +\u003d  4; i \u003e\u003e\u003e\u003d  4; }\n        if (i \u003e 1 \u003c\u003c  2) { n +\u003d  2; i \u003e\u003e\u003e\u003d  2; }\n        return n + (i \u003e\u003e\u003e 1);\n    }\n\n    /**\n     * Returns the number of one-bits in the two\u0027s complement binary\n     * representation of the specified {@code int} value.  This function is\n     * sometimes referred to as the \u003ci\u003epopulation count\u003c/i\u003e.\n     *\n     * @param i the value whose bits are to be counted\n     * @return the number of one-bits in the two\u0027s complement binary\n     *     representation of the specified {@code int} value.\n     * @since 1.5\n     */\n    @IntrinsicCandidate\n    public static int bitCount(int i) {\n        // HD, Figure 5-2\n        i \u003d i - ((i \u003e\u003e\u003e 1) \u0026 0x55555555);\n        i \u003d (i \u0026 0x33333333) + ((i \u003e\u003e\u003e 2) \u0026 0x33333333);\n        i \u003d (i + (i \u003e\u003e\u003e 4)) \u0026 0x0f0f0f0f;\n        i \u003d i + (i \u003e\u003e\u003e 8);\n        i \u003d i + (i \u003e\u003e\u003e 16);\n        return i \u0026 0x3f;\n    }\n\n    /**\n     * Returns the value obtained by rotating the two\u0027s complement binary\n     * representation of the specified {@code int} value left by the\n     * specified number of bits.  (Bits shifted out of the left hand, or\n     * high-order, side reenter on the right, or low-order.)\n     *\n     * \u003cp\u003eNote that left rotation with a negative distance is equivalent to\n     * right rotation: {@code rotateLeft(val, -distance) \u003d\u003d rotateRight(val,\n     * distance)}.  Note also that rotation by any multiple of 32 is a\n     * no-op, so all but the last five bits of the rotation distance can be\n     * ignored, even if the distance is negative: {@code rotateLeft(val,\n     * distance) \u003d\u003d rotateLeft(val, distance \u0026 0x1F)}.\n     *\n     * @param i the value whose bits are to be rotated left\n     * @param distance the number of bit positions to rotate left\n     * @return the value obtained by rotating the two\u0027s complement binary\n     *     representation of the specified {@code int} value left by the\n     *     specified number of bits.\n     * @since 1.5\n     */\n    public static int rotateLeft(int i, int distance) {\n        return (i \u003c\u003c distance) | (i \u003e\u003e\u003e -distance);\n    }\n\n    /**\n     * Returns the value obtained by rotating the two\u0027s complement binary\n     * representation of the specified {@code int} value right by the\n     * specified number of bits.  (Bits shifted out of the right hand, or\n     * low-order, side reenter on the left, or high-order.)\n     *\n     * \u003cp\u003eNote that right rotation with a negative distance is equivalent to\n     * left rotation: {@code rotateRight(val, -distance) \u003d\u003d rotateLeft(val,\n     * distance)}.  Note also that rotation by any multiple of 32 is a\n     * no-op, so all but the last five bits of the rotation distance can be\n     * ignored, even if the distance is negative: {@code rotateRight(val,\n     * distance) \u003d\u003d rotateRight(val, distance \u0026 0x1F)}.\n     *\n     * @param i the value whose bits are to be rotated right\n     * @param distance the number of bit positions to rotate right\n     * @return the value obtained by rotating the two\u0027s complement binary\n     *     representation of the specified {@code int} value right by the\n     *     specified number of bits.\n     * @since 1.5\n     */\n    public static int rotateRight(int i, int distance) {\n        return (i \u003e\u003e\u003e distance) | (i \u003c\u003c -distance);\n    }\n\n    /**\n     * Returns the value obtained by reversing the order of the bits in the\n     * two\u0027s complement binary representation of the specified {@code int}\n     * value.\n     *\n     * @param i the value to be reversed\n     * @return the value obtained by reversing order of the bits in the\n     *     specified {@code int} value.\n     * @since 1.5\n     */\n    public static int reverse(int i) {\n        // HD, Figure 7-1\n        i \u003d (i \u0026 0x55555555) \u003c\u003c 1 | (i \u003e\u003e\u003e 1) \u0026 0x55555555;\n        i \u003d (i \u0026 0x33333333) \u003c\u003c 2 | (i \u003e\u003e\u003e 2) \u0026 0x33333333;\n        i \u003d (i \u0026 0x0f0f0f0f) \u003c\u003c 4 | (i \u003e\u003e\u003e 4) \u0026 0x0f0f0f0f;\n\n        return reverseBytes(i);\n    }\n\n    /**\n     * Returns the signum function of the specified {@code int} value.  (The\n     * return value is -1 if the specified value is negative; 0 if the\n     * specified value is zero; and 1 if the specified value is positive.)\n     *\n     * @param i the value whose signum is to be computed\n     * @return the signum function of the specified {@code int} value.\n     * @since 1.5\n     */\n    public static int signum(int i) {\n        // HD, Section 2-7\n        return (i \u003e\u003e 31) | (-i \u003e\u003e\u003e 31);\n    }\n\n    /**\n     * Returns the value obtained by reversing the order of the bytes in the\n     * two\u0027s complement representation of the specified {@code int} value.\n     *\n     * @param i the value whose bytes are to be reversed\n     * @return the value obtained by reversing the bytes in the specified\n     *     {@code int} value.\n     * @since 1.5\n     */\n    @IntrinsicCandidate\n    public static int reverseBytes(int i) {\n        return (i \u003c\u003c 24)            |\n               ((i \u0026 0xff00) \u003c\u003c 8)  |\n               ((i \u003e\u003e\u003e 8) \u0026 0xff00) |\n               (i \u003e\u003e\u003e 24);\n    }\n\n    /**\n     * Adds two integers together as per the + operator.\n     *\n     * @param a the first operand\n     * @param b the second operand\n     * @return the sum of {@code a} and {@code b}\n     * @see java.util.function.BinaryOperator\n     * @since 1.8\n     */\n    public static int sum(int a, int b) {\n        return a + b;\n    }\n\n    /**\n     * Returns the greater of two {@code int} values\n     * as if by calling {@link Math#max(int, int) Math.max}.\n     *\n     * @param a the first operand\n     * @param b the second operand\n     * @return the greater of {@code a} and {@code b}\n     * @see java.util.function.BinaryOperator\n     * @since 1.8\n     */\n    public static int max(int a, int b) {\n        return Math.max(a, b);\n    }\n\n    /**\n     * Returns the smaller of two {@code int} values\n     * as if by calling {@link Math#min(int, int) Math.min}.\n     *\n     * @param a the first operand\n     * @param b the second operand\n     * @return the smaller of {@code a} and {@code b}\n     * @see java.util.function.BinaryOperator\n     * @since 1.8\n     */\n    public static int min(int a, int b) {\n        return Math.min(a, b);\n    }\n\n    /**\n     * Returns an {@link Optional} containing the nominal descriptor for this\n     * instance, which is the instance itself.\n     *\n     * @return an {@link Optional} describing the {@linkplain Integer} instance\n     * @since 12\n     */\n    @Override\n    public Optional\u003cInteger\u003e describeConstable() {\n        return Optional.of(this);\n    }\n\n    /**\n     * Resolves this instance as a {@link ConstantDesc}, the result of which is\n     * the instance itself.\n     *\n     * @param lookup ignored\n     * @return the {@linkplain Integer} instance\n     * @since 12\n     */\n    @Override\n    public Integer resolveConstantDesc(MethodHandles.Lookup lookup) {\n        return this;\n    }\n\n    /** use serialVersionUID from JDK 1.0.2 for interoperability */\n    @java.io.Serial\n    @Native private static final long serialVersionUID \u003d 1360826667806852920L;\n}\n"
    }
  }
}
java.lang.IllegalArgumentException: Illegal character in opaque part at index 188: jar:file:///C:/Users/Vinicius/AppData/Local/Coursier/cache/arc/https/github.com/adoptium/temurin17-binaries/releases/download/jdk-17%2B35/OpenJDK17-jdk_x64_windows_hotspot_17_35.zip/jdk-17 35/lib/src.zip!/java.base/java/lang/Integer.java
	at java.base/java.net.URI.create(URI.java:906)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:178)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.$anonfun$toAbsolutePath$3(MtagsEnrichments.scala:175)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.withTryDecode$1(MtagsEnrichments.scala:153)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:175)
	at scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:756)
	at scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:753)
	at scala.meta.internal.metals.WorkspaceLspService.didOpen(WorkspaceLspService.scala:388)
	at scala.meta.metals.lsp.DelegatingScalaService.didOpen(DelegatingScalaService.scala:39)
	at jdk.internal.reflect.GeneratedMethodAccessor23.invoke(Unknown Source)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:568)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$recursiveFindRpcMethods$0(GenericEndpoint.java:65)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.notify(GenericEndpoint.java:160)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleNotification(RemoteEndpoint.java:231)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:198)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:185)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:97)
	at org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:114)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:539)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.base/java.lang.Thread.run(Thread.java:833)
Caused by: java.net.URISyntaxException: Illegal character in opaque part at index 188: jar:file:///C:/Users/Vinicius/AppData/Local/Coursier/cache/arc/https/github.com/adoptium/temurin17-binaries/releases/download/jdk-17%2B35/OpenJDK17-jdk_x64_windows_hotspot_17_35.zip/jdk-17 35/lib/src.zip!/java.base/java/lang/Integer.java
	at java.base/java.net.URI$Parser.fail(URI.java:2974)
	at java.base/java.net.URI$Parser.checkChars(URI.java:3145)
	at java.base/java.net.URI$Parser.parse(URI.java:3181)
	at java.base/java.net.URI.<init>(URI.java:623)
	at java.base/java.net.URI.create(URI.java:904)
	... 23 more

jul. 19, 2024 1:42:12 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleNotification
ADVERTÊNCIA: Notification threw an exception: {
  "jsonrpc": "2.0",
  "method": "textDocument/didClose",
  "params": {
    "textDocument": {
      "uri": "jar:file%3A///C%3A/Users/Vinicius/AppData/Local/Coursier/cache/arc/https/github.com/adoptium/temurin17-binaries/releases/download/jdk-17%25252B35/OpenJDK17-jdk_x64_windows_hotspot_17_35.zip/jdk-17%2B35/lib/src.zip%21/java.base/java/lang/Integer.java"
    }
  }
}
java.lang.IllegalArgumentException: Illegal character in opaque part at index 188: jar:file:///C:/Users/Vinicius/AppData/Local/Coursier/cache/arc/https/github.com/adoptium/temurin17-binaries/releases/download/jdk-17%2B35/OpenJDK17-jdk_x64_windows_hotspot_17_35.zip/jdk-17 35/lib/src.zip!/java.base/java/lang/Integer.java
	at java.base/java.net.URI.create(URI.java:906)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:178)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.$anonfun$toAbsolutePath$3(MtagsEnrichments.scala:175)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.withTryDecode$1(MtagsEnrichments.scala:153)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:175)
	at scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:756)
	at scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:753)
	at scala.meta.internal.metals.WorkspaceLspService.didClose(WorkspaceLspService.scala:407)
	at scala.meta.metals.lsp.DelegatingScalaService.didClose(DelegatingScalaService.scala:53)
	at jdk.internal.reflect.GeneratedMethodAccessor26.invoke(Unknown Source)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:568)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$recursiveFindRpcMethods$0(GenericEndpoint.java:65)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.notify(GenericEndpoint.java:160)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleNotification(RemoteEndpoint.java:231)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:198)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:185)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:97)
	at org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:114)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:539)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.base/java.lang.Thread.run(Thread.java:833)
Caused by: java.net.URISyntaxException: Illegal character in opaque part at index 188: jar:file:///C:/Users/Vinicius/AppData/Local/Coursier/cache/arc/https/github.com/adoptium/temurin17-binaries/releases/download/jdk-17%2B35/OpenJDK17-jdk_x64_windows_hotspot_17_35.zip/jdk-17 35/lib/src.zip!/java.base/java/lang/Integer.java
	at java.base/java.net.URI$Parser.fail(URI.java:2974)
	at java.base/java.net.URI$Parser.checkChars(URI.java:3145)
	at java.base/java.net.URI$Parser.parse(URI.java:3181)
	at java.base/java.net.URI.<init>(URI.java:623)
	at java.base/java.net.URI.create(URI.java:904)
	... 23 more

jul. 19, 2024 1:42:12 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleNotification
ADVERTÊNCIA: Notification threw an exception: {
  "jsonrpc": "2.0",
  "method": "textDocument/didOpen",
  "params": {
    "textDocument": {
      "uri": "jar:file%3A///C%3A/Users/Vinicius/AppData/Local/Coursier/cache/arc/https/github.com/adoptium/temurin17-binaries/releases/download/jdk-17%25252B35/OpenJDK17-jdk_x64_windows_hotspot_17_35.zip/jdk-17%2B35/lib/src.zip%21/java.base/java/lang/Integer.java",
      "languageId": "java",
      "version": 1,
      "text": "/*\n * Copyright (c) 1994, 2021, Oracle and/or its affiliates. All rights reserved.\n * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n *\n * This code is free software; you can redistribute it and/or modify it\n * under the terms of the GNU General Public License version 2 only, as\n * published by the Free Software Foundation.  Oracle designates this\n * particular file as subject to the \"Classpath\" exception as provided\n * by Oracle in the LICENSE file that accompanied this code.\n *\n * This code is distributed in the hope that it will be useful, but WITHOUT\n * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n * version 2 for more details (a copy is included in the LICENSE file that\n * accompanied this code).\n *\n * You should have received a copy of the GNU General Public License version\n * 2 along with this work; if not, write to the Free Software Foundation,\n * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n *\n * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n * or visit www.oracle.com if you need additional information or have any\n * questions.\n */\n\npackage java.lang;\n\nimport java.lang.annotation.Native;\nimport java.lang.invoke.MethodHandles;\nimport java.lang.constant.Constable;\nimport java.lang.constant.ConstantDesc;\nimport java.util.Objects;\nimport java.util.Optional;\n\nimport jdk.internal.misc.CDS;\nimport jdk.internal.misc.VM;\nimport jdk.internal.vm.annotation.IntrinsicCandidate;\n\nimport static java.lang.String.COMPACT_STRINGS;\nimport static java.lang.String.LATIN1;\nimport static java.lang.String.UTF16;\n\n/**\n * The {@code Integer} class wraps a value of the primitive type\n * {@code int} in an object. An object of type {@code Integer}\n * contains a single field whose type is {@code int}.\n *\n * \u003cp\u003eIn addition, this class provides several methods for converting\n * an {@code int} to a {@code String} and a {@code String} to an\n * {@code int}, as well as other constants and methods useful when\n * dealing with an {@code int}.\n *\n * \u003cp\u003eThis is a \u003ca href\u003d\"{@docRoot}/java.base/java/lang/doc-files/ValueBased.html\"\u003evalue-based\u003c/a\u003e\n * class; programmers should treat instances that are\n * {@linkplain #equals(Object) equal} as interchangeable and should not\n * use instances for synchronization, or unpredictable behavior may\n * occur. For example, in a future release, synchronization may fail.\n *\n * \u003cp\u003eImplementation note: The implementations of the \"bit twiddling\"\n * methods (such as {@link #highestOneBit(int) highestOneBit} and\n * {@link #numberOfTrailingZeros(int) numberOfTrailingZeros}) are\n * based on material from Henry S. Warren, Jr.\u0027s \u003ci\u003eHacker\u0027s\n * Delight\u003c/i\u003e, (Addison Wesley, 2002).\n *\n * @author  Lee Boynton\n * @author  Arthur van Hoff\n * @author  Josh Bloch\n * @author  Joseph D. Darcy\n * @since 1.0\n */\n@jdk.internal.ValueBased\npublic final class Integer extends Number\n        implements Comparable\u003cInteger\u003e, Constable, ConstantDesc {\n    /**\n     * A constant holding the minimum value an {@code int} can\n     * have, -2\u003csup\u003e31\u003c/sup\u003e.\n     */\n    @Native public static final int   MIN_VALUE \u003d 0x80000000;\n\n    /**\n     * A constant holding the maximum value an {@code int} can\n     * have, 2\u003csup\u003e31\u003c/sup\u003e-1.\n     */\n    @Native public static final int   MAX_VALUE \u003d 0x7fffffff;\n\n    /**\n     * The {@code Class} instance representing the primitive type\n     * {@code int}.\n     *\n     * @since   1.1\n     */\n    @SuppressWarnings(\"unchecked\")\n    public static final Class\u003cInteger\u003e  TYPE \u003d (Class\u003cInteger\u003e) Class.getPrimitiveClass(\"int\");\n\n    /**\n     * All possible chars for representing a number as a String\n     */\n    static final char[] digits \u003d {\n        \u00270\u0027 , \u00271\u0027 , \u00272\u0027 , \u00273\u0027 , \u00274\u0027 , \u00275\u0027 ,\n        \u00276\u0027 , \u00277\u0027 , \u00278\u0027 , \u00279\u0027 , \u0027a\u0027 , \u0027b\u0027 ,\n        \u0027c\u0027 , \u0027d\u0027 , \u0027e\u0027 , \u0027f\u0027 , \u0027g\u0027 , \u0027h\u0027 ,\n        \u0027i\u0027 , \u0027j\u0027 , \u0027k\u0027 , \u0027l\u0027 , \u0027m\u0027 , \u0027n\u0027 ,\n        \u0027o\u0027 , \u0027p\u0027 , \u0027q\u0027 , \u0027r\u0027 , \u0027s\u0027 , \u0027t\u0027 ,\n        \u0027u\u0027 , \u0027v\u0027 , \u0027w\u0027 , \u0027x\u0027 , \u0027y\u0027 , \u0027z\u0027\n    };\n\n    /**\n     * Returns a string representation of the first argument in the\n     * radix specified by the second argument.\n     *\n     * \u003cp\u003eIf the radix is smaller than {@code Character.MIN_RADIX}\n     * or larger than {@code Character.MAX_RADIX}, then the radix\n     * {@code 10} is used instead.\n     *\n     * \u003cp\u003eIf the first argument is negative, the first element of the\n     * result is the ASCII minus character {@code \u0027-\u0027}\n     * ({@code \u0027\\u005Cu002D\u0027}). If the first argument is not\n     * negative, no sign character appears in the result.\n     *\n     * \u003cp\u003eThe remaining characters of the result represent the magnitude\n     * of the first argument. If the magnitude is zero, it is\n     * represented by a single zero character {@code \u00270\u0027}\n     * ({@code \u0027\\u005Cu0030\u0027}); otherwise, the first character of\n     * the representation of the magnitude will not be the zero\n     * character.  The following ASCII characters are used as digits:\n     *\n     * \u003cblockquote\u003e\n     *   {@code 0123456789abcdefghijklmnopqrstuvwxyz}\n     * \u003c/blockquote\u003e\n     *\n     * These are {@code \u0027\\u005Cu0030\u0027} through\n     * {@code \u0027\\u005Cu0039\u0027} and {@code \u0027\\u005Cu0061\u0027} through\n     * {@code \u0027\\u005Cu007A\u0027}. If {@code radix} is\n     * \u003cvar\u003eN\u003c/var\u003e, then the first \u003cvar\u003eN\u003c/var\u003e of these characters\n     * are used as radix-\u003cvar\u003eN\u003c/var\u003e digits in the order shown. Thus,\n     * the digits for hexadecimal (radix 16) are\n     * {@code 0123456789abcdef}. If uppercase letters are\n     * desired, the {@link java.lang.String#toUpperCase()} method may\n     * be called on the result:\n     *\n     * \u003cblockquote\u003e\n     *  {@code Integer.toString(n, 16).toUpperCase()}\n     * \u003c/blockquote\u003e\n     *\n     * @param   i       an integer to be converted to a string.\n     * @param   radix   the radix to use in the string representation.\n     * @return  a string representation of the argument in the specified radix.\n     * @see     java.lang.Character#MAX_RADIX\n     * @see     java.lang.Character#MIN_RADIX\n     */\n    public static String toString(int i, int radix) {\n        if (radix \u003c Character.MIN_RADIX || radix \u003e Character.MAX_RADIX)\n            radix \u003d 10;\n\n        /* Use the faster version */\n        if (radix \u003d\u003d 10) {\n            return toString(i);\n        }\n\n        if (COMPACT_STRINGS) {\n            byte[] buf \u003d new byte[33];\n            boolean negative \u003d (i \u003c 0);\n            int charPos \u003d 32;\n\n            if (!negative) {\n                i \u003d -i;\n            }\n\n            while (i \u003c\u003d -radix) {\n                buf[charPos--] \u003d (byte)digits[-(i % radix)];\n                i \u003d i / radix;\n            }\n            buf[charPos] \u003d (byte)digits[-i];\n\n            if (negative) {\n                buf[--charPos] \u003d \u0027-\u0027;\n            }\n\n            return StringLatin1.newString(buf, charPos, (33 - charPos));\n        }\n        return toStringUTF16(i, radix);\n    }\n\n    private static String toStringUTF16(int i, int radix) {\n        byte[] buf \u003d new byte[33 * 2];\n        boolean negative \u003d (i \u003c 0);\n        int charPos \u003d 32;\n        if (!negative) {\n            i \u003d -i;\n        }\n        while (i \u003c\u003d -radix) {\n            StringUTF16.putChar(buf, charPos--, digits[-(i % radix)]);\n            i \u003d i / radix;\n        }\n        StringUTF16.putChar(buf, charPos, digits[-i]);\n\n        if (negative) {\n            StringUTF16.putChar(buf, --charPos, \u0027-\u0027);\n        }\n        return StringUTF16.newString(buf, charPos, (33 - charPos));\n    }\n\n    /**\n     * Returns a string representation of the first argument as an\n     * unsigned integer value in the radix specified by the second\n     * argument.\n     *\n     * \u003cp\u003eIf the radix is smaller than {@code Character.MIN_RADIX}\n     * or larger than {@code Character.MAX_RADIX}, then the radix\n     * {@code 10} is used instead.\n     *\n     * \u003cp\u003eNote that since the first argument is treated as an unsigned\n     * value, no leading sign character is printed.\n     *\n     * \u003cp\u003eIf the magnitude is zero, it is represented by a single zero\n     * character {@code \u00270\u0027} ({@code \u0027\\u005Cu0030\u0027}); otherwise,\n     * the first character of the representation of the magnitude will\n     * not be the zero character.\n     *\n     * \u003cp\u003eThe behavior of radixes and the characters used as digits\n     * are the same as {@link #toString(int, int) toString}.\n     *\n     * @param   i       an integer to be converted to an unsigned string.\n     * @param   radix   the radix to use in the string representation.\n     * @return  an unsigned string representation of the argument in the specified radix.\n     * @see     #toString(int, int)\n     * @since 1.8\n     */\n    public static String toUnsignedString(int i, int radix) {\n        return Long.toUnsignedString(toUnsignedLong(i), radix);\n    }\n\n    /**\n     * Returns a string representation of the integer argument as an\n     * unsigned integer in base\u0026nbsp;16.\n     *\n     * \u003cp\u003eThe unsigned integer value is the argument plus 2\u003csup\u003e32\u003c/sup\u003e\n     * if the argument is negative; otherwise, it is equal to the\n     * argument.  This value is converted to a string of ASCII digits\n     * in hexadecimal (base\u0026nbsp;16) with no extra leading\n     * {@code 0}s.\n     *\n     * \u003cp\u003eThe value of the argument can be recovered from the returned\n     * string {@code s} by calling {@link\n     * Integer#parseUnsignedInt(String, int)\n     * Integer.parseUnsignedInt(s, 16)}.\n     *\n     * \u003cp\u003eIf the unsigned magnitude is zero, it is represented by a\n     * single zero character {@code \u00270\u0027} ({@code \u0027\\u005Cu0030\u0027});\n     * otherwise, the first character of the representation of the\n     * unsigned magnitude will not be the zero character. The\n     * following characters are used as hexadecimal digits:\n     *\n     * \u003cblockquote\u003e\n     *  {@code 0123456789abcdef}\n     * \u003c/blockquote\u003e\n     *\n     * These are the characters {@code \u0027\\u005Cu0030\u0027} through\n     * {@code \u0027\\u005Cu0039\u0027} and {@code \u0027\\u005Cu0061\u0027} through\n     * {@code \u0027\\u005Cu0066\u0027}. If uppercase letters are\n     * desired, the {@link java.lang.String#toUpperCase()} method may\n     * be called on the result:\n     *\n     * \u003cblockquote\u003e\n     *  {@code Integer.toHexString(n).toUpperCase()}\n     * \u003c/blockquote\u003e\n     *\n     * @apiNote\n     * The {@link java.util.HexFormat} class provides formatting and parsing\n     * of byte arrays and primitives to return a string or adding to an {@link Appendable}.\n     * {@code HexFormat} formats and parses uppercase or lowercase hexadecimal characters,\n     * with leading zeros and for byte arrays includes for each byte\n     * a delimiter, prefix, and suffix.\n     *\n     * @param   i   an integer to be converted to a string.\n     * @return  the string representation of the unsigned integer value\n     *          represented by the argument in hexadecimal (base\u0026nbsp;16).\n     * @see java.util.HexFormat\n     * @see #parseUnsignedInt(String, int)\n     * @see #toUnsignedString(int, int)\n     * @since   1.0.2\n     */\n    public static String toHexString(int i) {\n        return toUnsignedString0(i, 4);\n    }\n\n    /**\n     * Returns a string representation of the integer argument as an\n     * unsigned integer in base\u0026nbsp;8.\n     *\n     * \u003cp\u003eThe unsigned integer value is the argument plus 2\u003csup\u003e32\u003c/sup\u003e\n     * if the argument is negative; otherwise, it is equal to the\n     * argument.  This value is converted to a string of ASCII digits\n     * in octal (base\u0026nbsp;8) with no extra leading {@code 0}s.\n     *\n     * \u003cp\u003eThe value of the argument can be recovered from the returned\n     * string {@code s} by calling {@link\n     * Integer#parseUnsignedInt(String, int)\n     * Integer.parseUnsignedInt(s, 8)}.\n     *\n     * \u003cp\u003eIf the unsigned magnitude is zero, it is represented by a\n     * single zero character {@code \u00270\u0027} ({@code \u0027\\u005Cu0030\u0027});\n     * otherwise, the first character of the representation of the\n     * unsigned magnitude will not be the zero character. The\n     * following characters are used as octal digits:\n     *\n     * \u003cblockquote\u003e\n     * {@code 01234567}\n     * \u003c/blockquote\u003e\n     *\n     * These are the characters {@code \u0027\\u005Cu0030\u0027} through\n     * {@code \u0027\\u005Cu0037\u0027}.\n     *\n     * @param   i   an integer to be converted to a string.\n     * @return  the string representation of the unsigned integer value\n     *          represented by the argument in octal (base\u0026nbsp;8).\n     * @see #parseUnsignedInt(String, int)\n     * @see #toUnsignedString(int, int)\n     * @since   1.0.2\n     */\n    public static String toOctalString(int i) {\n        return toUnsignedString0(i, 3);\n    }\n\n    /**\n     * Returns a string representation of the integer argument as an\n     * unsigned integer in base\u0026nbsp;2.\n     *\n     * \u003cp\u003eThe unsigned integer value is the argument plus 2\u003csup\u003e32\u003c/sup\u003e\n     * if the argument is negative; otherwise it is equal to the\n     * argument.  This value is converted to a string of ASCII digits\n     * in binary (base\u0026nbsp;2) with no extra leading {@code 0}s.\n     *\n     * \u003cp\u003eThe value of the argument can be recovered from the returned\n     * string {@code s} by calling {@link\n     * Integer#parseUnsignedInt(String, int)\n     * Integer.parseUnsignedInt(s, 2)}.\n     *\n     * \u003cp\u003eIf the unsigned magnitude is zero, it is represented by a\n     * single zero character {@code \u00270\u0027} ({@code \u0027\\u005Cu0030\u0027});\n     * otherwise, the first character of the representation of the\n     * unsigned magnitude will not be the zero character. The\n     * characters {@code \u00270\u0027} ({@code \u0027\\u005Cu0030\u0027}) and {@code\n     * \u00271\u0027} ({@code \u0027\\u005Cu0031\u0027}) are used as binary digits.\n     *\n     * @param   i   an integer to be converted to a string.\n     * @return  the string representation of the unsigned integer value\n     *          represented by the argument in binary (base\u0026nbsp;2).\n     * @see #parseUnsignedInt(String, int)\n     * @see #toUnsignedString(int, int)\n     * @since   1.0.2\n     */\n    public static String toBinaryString(int i) {\n        return toUnsignedString0(i, 1);\n    }\n\n    /**\n     * Convert the integer to an unsigned number.\n     */\n    private static String toUnsignedString0(int val, int shift) {\n        // assert shift \u003e 0 \u0026\u0026 shift \u003c\u003d5 : \"Illegal shift value\";\n        int mag \u003d Integer.SIZE - Integer.numberOfLeadingZeros(val);\n        int chars \u003d Math.max(((mag + (shift - 1)) / shift), 1);\n        if (COMPACT_STRINGS) {\n            byte[] buf \u003d new byte[chars];\n            formatUnsignedInt(val, shift, buf, chars);\n            return new String(buf, LATIN1);\n        } else {\n            byte[] buf \u003d new byte[chars * 2];\n            formatUnsignedIntUTF16(val, shift, buf, chars);\n            return new String(buf, UTF16);\n        }\n    }\n\n    /**\n     * Format an {@code int} (treated as unsigned) into a byte buffer (LATIN1 version). If\n     * {@code len} exceeds the formatted ASCII representation of {@code val},\n     * {@code buf} will be padded with leading zeroes.\n     *\n     * @param val the unsigned int to format\n     * @param shift the log2 of the base to format in (4 for hex, 3 for octal, 1 for binary)\n     * @param buf the byte buffer to write to\n     * @param len the number of characters to write\n     */\n    private static void formatUnsignedInt(int val, int shift, byte[] buf, int len) {\n        int charPos \u003d len;\n        int radix \u003d 1 \u003c\u003c shift;\n        int mask \u003d radix - 1;\n        do {\n            buf[--charPos] \u003d (byte)Integer.digits[val \u0026 mask];\n            val \u003e\u003e\u003e\u003d shift;\n        } while (charPos \u003e 0);\n    }\n\n    /**\n     * Format an {@code int} (treated as unsigned) into a byte buffer (UTF16 version). If\n     * {@code len} exceeds the formatted ASCII representation of {@code val},\n     * {@code buf} will be padded with leading zeroes.\n     *\n     * @param val the unsigned int to format\n     * @param shift the log2 of the base to format in (4 for hex, 3 for octal, 1 for binary)\n     * @param buf the byte buffer to write to\n     * @param len the number of characters to write\n     */\n    private static void formatUnsignedIntUTF16(int val, int shift, byte[] buf, int len) {\n        int charPos \u003d len;\n        int radix \u003d 1 \u003c\u003c shift;\n        int mask \u003d radix - 1;\n        do {\n            StringUTF16.putChar(buf, --charPos, Integer.digits[val \u0026 mask]);\n            val \u003e\u003e\u003e\u003d shift;\n        } while (charPos \u003e 0);\n    }\n\n    static final byte[] DigitTens \u003d {\n        \u00270\u0027, \u00270\u0027, \u00270\u0027, \u00270\u0027, \u00270\u0027, \u00270\u0027, \u00270\u0027, \u00270\u0027, \u00270\u0027, \u00270\u0027,\n        \u00271\u0027, \u00271\u0027, \u00271\u0027, \u00271\u0027, \u00271\u0027, \u00271\u0027, \u00271\u0027, \u00271\u0027, \u00271\u0027, \u00271\u0027,\n        \u00272\u0027, \u00272\u0027, \u00272\u0027, \u00272\u0027, \u00272\u0027, \u00272\u0027, \u00272\u0027, \u00272\u0027, \u00272\u0027, \u00272\u0027,\n        \u00273\u0027, \u00273\u0027, \u00273\u0027, \u00273\u0027, \u00273\u0027, \u00273\u0027, \u00273\u0027, \u00273\u0027, \u00273\u0027, \u00273\u0027,\n        \u00274\u0027, \u00274\u0027, \u00274\u0027, \u00274\u0027, \u00274\u0027, \u00274\u0027, \u00274\u0027, \u00274\u0027, \u00274\u0027, \u00274\u0027,\n        \u00275\u0027, \u00275\u0027, \u00275\u0027, \u00275\u0027, \u00275\u0027, \u00275\u0027, \u00275\u0027, \u00275\u0027, \u00275\u0027, \u00275\u0027,\n        \u00276\u0027, \u00276\u0027, \u00276\u0027, \u00276\u0027, \u00276\u0027, \u00276\u0027, \u00276\u0027, \u00276\u0027, \u00276\u0027, \u00276\u0027,\n        \u00277\u0027, \u00277\u0027, \u00277\u0027, \u00277\u0027, \u00277\u0027, \u00277\u0027, \u00277\u0027, \u00277\u0027, \u00277\u0027, \u00277\u0027,\n        \u00278\u0027, \u00278\u0027, \u00278\u0027, \u00278\u0027, \u00278\u0027, \u00278\u0027, \u00278\u0027, \u00278\u0027, \u00278\u0027, \u00278\u0027,\n        \u00279\u0027, \u00279\u0027, \u00279\u0027, \u00279\u0027, \u00279\u0027, \u00279\u0027, \u00279\u0027, \u00279\u0027, \u00279\u0027, \u00279\u0027,\n        } ;\n\n    static final byte[] DigitOnes \u003d {\n        \u00270\u0027, \u00271\u0027, \u00272\u0027, \u00273\u0027, \u00274\u0027, \u00275\u0027, \u00276\u0027, \u00277\u0027, \u00278\u0027, \u00279\u0027,\n        \u00270\u0027, \u00271\u0027, \u00272\u0027, \u00273\u0027, \u00274\u0027, \u00275\u0027, \u00276\u0027, \u00277\u0027, \u00278\u0027, \u00279\u0027,\n        \u00270\u0027, \u00271\u0027, \u00272\u0027, \u00273\u0027, \u00274\u0027, \u00275\u0027, \u00276\u0027, \u00277\u0027, \u00278\u0027, \u00279\u0027,\n        \u00270\u0027, \u00271\u0027, \u00272\u0027, \u00273\u0027, \u00274\u0027, \u00275\u0027, \u00276\u0027, \u00277\u0027, \u00278\u0027, \u00279\u0027,\n        \u00270\u0027, \u00271\u0027, \u00272\u0027, \u00273\u0027, \u00274\u0027, \u00275\u0027, \u00276\u0027, \u00277\u0027, \u00278\u0027, \u00279\u0027,\n        \u00270\u0027, \u00271\u0027, \u00272\u0027, \u00273\u0027, \u00274\u0027, \u00275\u0027, \u00276\u0027, \u00277\u0027, \u00278\u0027, \u00279\u0027,\n        \u00270\u0027, \u00271\u0027, \u00272\u0027, \u00273\u0027, \u00274\u0027, \u00275\u0027, \u00276\u0027, \u00277\u0027, \u00278\u0027, \u00279\u0027,\n        \u00270\u0027, \u00271\u0027, \u00272\u0027, \u00273\u0027, \u00274\u0027, \u00275\u0027, \u00276\u0027, \u00277\u0027, \u00278\u0027, \u00279\u0027,\n        \u00270\u0027, \u00271\u0027, \u00272\u0027, \u00273\u0027, \u00274\u0027, \u00275\u0027, \u00276\u0027, \u00277\u0027, \u00278\u0027, \u00279\u0027,\n        \u00270\u0027, \u00271\u0027, \u00272\u0027, \u00273\u0027, \u00274\u0027, \u00275\u0027, \u00276\u0027, \u00277\u0027, \u00278\u0027, \u00279\u0027,\n        } ;\n\n\n    /**\n     * Returns a {@code String} object representing the\n     * specified integer. The argument is converted to signed decimal\n     * representation and returned as a string, exactly as if the\n     * argument and radix 10 were given as arguments to the {@link\n     * #toString(int, int)} method.\n     *\n     * @param   i   an integer to be converted.\n     * @return  a string representation of the argument in base\u0026nbsp;10.\n     */\n    @IntrinsicCandidate\n    public static String toString(int i) {\n        int size \u003d stringSize(i);\n        if (COMPACT_STRINGS) {\n            byte[] buf \u003d new byte[size];\n            getChars(i, size, buf);\n            return new String(buf, LATIN1);\n        } else {\n            byte[] buf \u003d new byte[size * 2];\n            StringUTF16.getChars(i, size, buf);\n            return new String(buf, UTF16);\n        }\n    }\n\n    /**\n     * Returns a string representation of the argument as an unsigned\n     * decimal value.\n     *\n     * The argument is converted to unsigned decimal representation\n     * and returned as a string exactly as if the argument and radix\n     * 10 were given as arguments to the {@link #toUnsignedString(int,\n     * int)} method.\n     *\n     * @param   i  an integer to be converted to an unsigned string.\n     * @return  an unsigned string representation of the argument.\n     * @see     #toUnsignedString(int, int)\n     * @since 1.8\n     */\n    public static String toUnsignedString(int i) {\n        return Long.toString(toUnsignedLong(i));\n    }\n\n    /**\n     * Places characters representing the integer i into the\n     * character array buf. The characters are placed into\n     * the buffer backwards starting with the least significant\n     * digit at the specified index (exclusive), and working\n     * backwards from there.\n     *\n     * @implNote This method converts positive inputs into negative\n     * values, to cover the Integer.MIN_VALUE case. Converting otherwise\n     * (negative to positive) will expose -Integer.MIN_VALUE that overflows\n     * integer.\n     *\n     * @param i     value to convert\n     * @param index next index, after the least significant digit\n     * @param buf   target buffer, Latin1-encoded\n     * @return index of the most significant digit or minus sign, if present\n     */\n    static int getChars(int i, int index, byte[] buf) {\n        int q, r;\n        int charPos \u003d index;\n\n        boolean negative \u003d i \u003c 0;\n        if (!negative) {\n            i \u003d -i;\n        }\n\n        // Generate two digits per iteration\n        while (i \u003c\u003d -100) {\n            q \u003d i / 100;\n            r \u003d (q * 100) - i;\n            i \u003d q;\n            buf[--charPos] \u003d DigitOnes[r];\n            buf[--charPos] \u003d DigitTens[r];\n        }\n\n        // We know there are at most two digits left at this point.\n        q \u003d i / 10;\n        r \u003d (q * 10) - i;\n        buf[--charPos] \u003d (byte)(\u00270\u0027 + r);\n\n        // Whatever left is the remaining digit.\n        if (q \u003c 0) {\n            buf[--charPos] \u003d (byte)(\u00270\u0027 - q);\n        }\n\n        if (negative) {\n            buf[--charPos] \u003d (byte)\u0027-\u0027;\n        }\n        return charPos;\n    }\n\n    // Left here for compatibility reasons, see JDK-8143900.\n    static final int [] sizeTable \u003d { 9, 99, 999, 9999, 99999, 999999, 9999999,\n                                      99999999, 999999999, Integer.MAX_VALUE };\n\n    /**\n     * Returns the string representation size for a given int value.\n     *\n     * @param x int value\n     * @return string size\n     *\n     * @implNote There are other ways to compute this: e.g. binary search,\n     * but values are biased heavily towards zero, and therefore linear search\n     * wins. The iteration results are also routinely inlined in the generated\n     * code after loop unrolling.\n     */\n    static int stringSize(int x) {\n        int d \u003d 1;\n        if (x \u003e\u003d 0) {\n            d \u003d 0;\n            x \u003d -x;\n        }\n        int p \u003d -10;\n        for (int i \u003d 1; i \u003c 10; i++) {\n            if (x \u003e p)\n                return i + d;\n            p \u003d 10 * p;\n        }\n        return 10 + d;\n    }\n\n    /**\n     * Parses the string argument as a signed integer in the radix\n     * specified by the second argument. The characters in the string\n     * must all be digits of the specified radix (as determined by\n     * whether {@link java.lang.Character#digit(char, int)} returns a\n     * nonnegative value), except that the first character may be an\n     * ASCII minus sign {@code \u0027-\u0027} ({@code \u0027\\u005Cu002D\u0027}) to\n     * indicate a negative value or an ASCII plus sign {@code \u0027+\u0027}\n     * ({@code \u0027\\u005Cu002B\u0027}) to indicate a positive value. The\n     * resulting integer value is returned.\n     *\n     * \u003cp\u003eAn exception of type {@code NumberFormatException} is\n     * thrown if any of the following situations occurs:\n     * \u003cul\u003e\n     * \u003cli\u003eThe first argument is {@code null} or is a string of\n     * length zero.\n     *\n     * \u003cli\u003eThe radix is either smaller than\n     * {@link java.lang.Character#MIN_RADIX} or\n     * larger than {@link java.lang.Character#MAX_RADIX}.\n     *\n     * \u003cli\u003eAny character of the string is not a digit of the specified\n     * radix, except that the first character may be a minus sign\n     * {@code \u0027-\u0027} ({@code \u0027\\u005Cu002D\u0027}) or plus sign\n     * {@code \u0027+\u0027} ({@code \u0027\\u005Cu002B\u0027}) provided that the\n     * string is longer than length 1.\n     *\n     * \u003cli\u003eThe value represented by the string is not a value of type\n     * {@code int}.\n     * \u003c/ul\u003e\n     *\n     * \u003cp\u003eExamples:\n     * \u003cblockquote\u003e\u003cpre\u003e\n     * parseInt(\"0\", 10) returns 0\n     * parseInt(\"473\", 10) returns 473\n     * parseInt(\"+42\", 10) returns 42\n     * parseInt(\"-0\", 10) returns 0\n     * parseInt(\"-FF\", 16) returns -255\n     * parseInt(\"1100110\", 2) returns 102\n     * parseInt(\"2147483647\", 10) returns 2147483647\n     * parseInt(\"-2147483648\", 10) returns -2147483648\n     * parseInt(\"2147483648\", 10) throws a NumberFormatException\n     * parseInt(\"99\", 8) throws a NumberFormatException\n     * parseInt(\"Kona\", 10) throws a NumberFormatException\n     * parseInt(\"Kona\", 27) returns 411787\n     * \u003c/pre\u003e\u003c/blockquote\u003e\n     *\n     * @param      s   the {@code String} containing the integer\n     *                  representation to be parsed\n     * @param      radix   the radix to be used while parsing {@code s}.\n     * @return     the integer represented by the string argument in the\n     *             specified radix.\n     * @throws     NumberFormatException if the {@code String}\n     *             does not contain a parsable {@code int}.\n     */\n    public static int parseInt(String s, int radix)\n                throws NumberFormatException\n    {\n        /*\n         * WARNING: This method may be invoked early during VM initialization\n         * before IntegerCache is initialized. Care must be taken to not use\n         * the valueOf method.\n         */\n\n        if (s \u003d\u003d null) {\n            throw new NumberFormatException(\"Cannot parse null string\");\n        }\n\n        if (radix \u003c Character.MIN_RADIX) {\n            throw new NumberFormatException(\"radix \" + radix +\n                                            \" less than Character.MIN_RADIX\");\n        }\n\n        if (radix \u003e Character.MAX_RADIX) {\n            throw new NumberFormatException(\"radix \" + radix +\n                                            \" greater than Character.MAX_RADIX\");\n        }\n\n        boolean negative \u003d false;\n        int i \u003d 0, len \u003d s.length();\n        int limit \u003d -Integer.MAX_VALUE;\n\n        if (len \u003e 0) {\n            char firstChar \u003d s.charAt(0);\n            if (firstChar \u003c \u00270\u0027) { // Possible leading \"+\" or \"-\"\n                if (firstChar \u003d\u003d \u0027-\u0027) {\n                    negative \u003d true;\n                    limit \u003d Integer.MIN_VALUE;\n                } else if (firstChar !\u003d \u0027+\u0027) {\n                    throw NumberFormatException.forInputString(s, radix);\n                }\n\n                if (len \u003d\u003d 1) { // Cannot have lone \"+\" or \"-\"\n                    throw NumberFormatException.forInputString(s, radix);\n                }\n                i++;\n            }\n            int multmin \u003d limit / radix;\n            int result \u003d 0;\n            while (i \u003c len) {\n                // Accumulating negatively avoids surprises near MAX_VALUE\n                int digit \u003d Character.digit(s.charAt(i++), radix);\n                if (digit \u003c 0 || result \u003c multmin) {\n                    throw NumberFormatException.forInputString(s, radix);\n                }\n                result *\u003d radix;\n                if (result \u003c limit + digit) {\n                    throw NumberFormatException.forInputString(s, radix);\n                }\n                result -\u003d digit;\n            }\n            return negative ? result : -result;\n        } else {\n            throw NumberFormatException.forInputString(s, radix);\n        }\n    }\n\n    /**\n     * Parses the {@link CharSequence} argument as a signed {@code int} in the\n     * specified {@code radix}, beginning at the specified {@code beginIndex}\n     * and extending to {@code endIndex - 1}.\n     *\n     * \u003cp\u003eThe method does not take steps to guard against the\n     * {@code CharSequence} being mutated while parsing.\n     *\n     * @param      s   the {@code CharSequence} containing the {@code int}\n     *                  representation to be parsed\n     * @param      beginIndex   the beginning index, inclusive.\n     * @param      endIndex     the ending index, exclusive.\n     * @param      radix   the radix to be used while parsing {@code s}.\n     * @return     the signed {@code int} represented by the subsequence in\n     *             the specified radix.\n     * @throws     NullPointerException  if {@code s} is null.\n     * @throws     IndexOutOfBoundsException  if {@code beginIndex} is\n     *             negative, or if {@code beginIndex} is greater than\n     *             {@code endIndex} or if {@code endIndex} is greater than\n     *             {@code s.length()}.\n     * @throws     NumberFormatException  if the {@code CharSequence} does not\n     *             contain a parsable {@code int} in the specified\n     *             {@code radix}, or if {@code radix} is either smaller than\n     *             {@link java.lang.Character#MIN_RADIX} or larger than\n     *             {@link java.lang.Character#MAX_RADIX}.\n     * @since  9\n     */\n    public static int parseInt(CharSequence s, int beginIndex, int endIndex, int radix)\n                throws NumberFormatException {\n        Objects.requireNonNull(s);\n\n        if (beginIndex \u003c 0 || beginIndex \u003e endIndex || endIndex \u003e s.length()) {\n            throw new IndexOutOfBoundsException();\n        }\n        if (radix \u003c Character.MIN_RADIX) {\n            throw new NumberFormatException(\"radix \" + radix +\n                                            \" less than Character.MIN_RADIX\");\n        }\n        if (radix \u003e Character.MAX_RADIX) {\n            throw new NumberFormatException(\"radix \" + radix +\n                                            \" greater than Character.MAX_RADIX\");\n        }\n\n        boolean negative \u003d false;\n        int i \u003d beginIndex;\n        int limit \u003d -Integer.MAX_VALUE;\n\n        if (i \u003c endIndex) {\n            char firstChar \u003d s.charAt(i);\n            if (firstChar \u003c \u00270\u0027) { // Possible leading \"+\" or \"-\"\n                if (firstChar \u003d\u003d \u0027-\u0027) {\n                    negative \u003d true;\n                    limit \u003d Integer.MIN_VALUE;\n                } else if (firstChar !\u003d \u0027+\u0027) {\n                    throw NumberFormatException.forCharSequence(s, beginIndex,\n                            endIndex, i);\n                }\n                i++;\n                if (i \u003d\u003d endIndex) { // Cannot have lone \"+\" or \"-\"\n                    throw NumberFormatException.forCharSequence(s, beginIndex,\n                            endIndex, i);\n                }\n            }\n            int multmin \u003d limit / radix;\n            int result \u003d 0;\n            while (i \u003c endIndex) {\n                // Accumulating negatively avoids surprises near MAX_VALUE\n                int digit \u003d Character.digit(s.charAt(i), radix);\n                if (digit \u003c 0 || result \u003c multmin) {\n                    throw NumberFormatException.forCharSequence(s, beginIndex,\n                            endIndex, i);\n                }\n                result *\u003d radix;\n                if (result \u003c limit + digit) {\n                    throw NumberFormatException.forCharSequence(s, beginIndex,\n                            endIndex, i);\n                }\n                i++;\n                result -\u003d digit;\n            }\n            return negative ? result : -result;\n        } else {\n            throw NumberFormatException.forInputString(\"\", radix);\n        }\n    }\n\n    /**\n     * Parses the string argument as a signed decimal integer. The\n     * characters in the string must all be decimal digits, except\n     * that the first character may be an ASCII minus sign {@code \u0027-\u0027}\n     * ({@code \u0027\\u005Cu002D\u0027}) to indicate a negative value or an\n     * ASCII plus sign {@code \u0027+\u0027} ({@code \u0027\\u005Cu002B\u0027}) to\n     * indicate a positive value. The resulting integer value is\n     * returned, exactly as if the argument and the radix 10 were\n     * given as arguments to the {@link #parseInt(java.lang.String,\n     * int)} method.\n     *\n     * @param s    a {@code String} containing the {@code int}\n     *             representation to be parsed\n     * @return     the integer value represented by the argument in decimal.\n     * @throws     NumberFormatException  if the string does not contain a\n     *               parsable integer.\n     */\n    public static int parseInt(String s) throws NumberFormatException {\n        return parseInt(s,10);\n    }\n\n    /**\n     * Parses the string argument as an unsigned integer in the radix\n     * specified by the second argument.  An unsigned integer maps the\n     * values usually associated with negative numbers to positive\n     * numbers larger than {@code MAX_VALUE}.\n     *\n     * The characters in the string must all be digits of the\n     * specified radix (as determined by whether {@link\n     * java.lang.Character#digit(char, int)} returns a nonnegative\n     * value), except that the first character may be an ASCII plus\n     * sign {@code \u0027+\u0027} ({@code \u0027\\u005Cu002B\u0027}). The resulting\n     * integer value is returned.\n     *\n     * \u003cp\u003eAn exception of type {@code NumberFormatException} is\n     * thrown if any of the following situations occurs:\n     * \u003cul\u003e\n     * \u003cli\u003eThe first argument is {@code null} or is a string of\n     * length zero.\n     *\n     * \u003cli\u003eThe radix is either smaller than\n     * {@link java.lang.Character#MIN_RADIX} or\n     * larger than {@link java.lang.Character#MAX_RADIX}.\n     *\n     * \u003cli\u003eAny character of the string is not a digit of the specified\n     * radix, except that the first character may be a plus sign\n     * {@code \u0027+\u0027} ({@code \u0027\\u005Cu002B\u0027}) provided that the\n     * string is longer than length 1.\n     *\n     * \u003cli\u003eThe value represented by the string is larger than the\n     * largest unsigned {@code int}, 2\u003csup\u003e32\u003c/sup\u003e-1.\n     *\n     * \u003c/ul\u003e\n     *\n     *\n     * @param      s   the {@code String} containing the unsigned integer\n     *                  representation to be parsed\n     * @param      radix   the radix to be used while parsing {@code s}.\n     * @return     the integer represented by the string argument in the\n     *             specified radix.\n     * @throws     NumberFormatException if the {@code String}\n     *             does not contain a parsable {@code int}.\n     * @since 1.8\n     */\n    public static int parseUnsignedInt(String s, int radix)\n                throws NumberFormatException {\n        if (s \u003d\u003d null)  {\n            throw new NumberFormatException(\"Cannot parse null string\");\n        }\n\n        int len \u003d s.length();\n        if (len \u003e 0) {\n            char firstChar \u003d s.charAt(0);\n            if (firstChar \u003d\u003d \u0027-\u0027) {\n                throw new\n                    NumberFormatException(String.format(\"Illegal leading minus sign \" +\n                                                       \"on unsigned string %s.\", s));\n            } else {\n                if (len \u003c\u003d 5 || // Integer.MAX_VALUE in Character.MAX_RADIX is 6 digits\n                    (radix \u003d\u003d 10 \u0026\u0026 len \u003c\u003d 9) ) { // Integer.MAX_VALUE in base 10 is 10 digits\n                    return parseInt(s, radix);\n                } else {\n                    long ell \u003d Long.parseLong(s, radix);\n                    if ((ell \u0026 0xffff_ffff_0000_0000L) \u003d\u003d 0) {\n                        return (int) ell;\n                    } else {\n                        throw new\n                            NumberFormatException(String.format(\"String value %s exceeds \" +\n                                                                \"range of unsigned int.\", s));\n                    }\n                }\n            }\n        } else {\n            throw NumberFormatException.forInputString(s, radix);\n        }\n    }\n\n    /**\n     * Parses the {@link CharSequence} argument as an unsigned {@code int} in\n     * the specified {@code radix}, beginning at the specified\n     * {@code beginIndex} and extending to {@code endIndex - 1}.\n     *\n     * \u003cp\u003eThe method does not take steps to guard against the\n     * {@code CharSequence} being mutated while parsing.\n     *\n     * @param      s   the {@code CharSequence} containing the unsigned\n     *                 {@code int} representation to be parsed\n     * @param      beginIndex   the beginning index, inclusive.\n     * @param      endIndex     the ending index, exclusive.\n     * @param      radix   the radix to be used while parsing {@code s}.\n     * @return     the unsigned {@code int} represented by the subsequence in\n     *             the specified radix.\n     * @throws     NullPointerException  if {@code s} is null.\n     * @throws     IndexOutOfBoundsException  if {@code beginIndex} is\n     *             negative, or if {@code beginIndex} is greater than\n     *             {@code endIndex} or if {@code endIndex} is greater than\n     *             {@code s.length()}.\n     * @throws     NumberFormatException  if the {@code CharSequence} does not\n     *             contain a parsable unsigned {@code int} in the specified\n     *             {@code radix}, or if {@code radix} is either smaller than\n     *             {@link java.lang.Character#MIN_RADIX} or larger than\n     *             {@link java.lang.Character#MAX_RADIX}.\n     * @since  9\n     */\n    public static int parseUnsignedInt(CharSequence s, int beginIndex, int endIndex, int radix)\n                throws NumberFormatException {\n        Objects.requireNonNull(s);\n\n        if (beginIndex \u003c 0 || beginIndex \u003e endIndex || endIndex \u003e s.length()) {\n            throw new IndexOutOfBoundsException();\n        }\n        int start \u003d beginIndex, len \u003d endIndex - beginIndex;\n\n        if (len \u003e 0) {\n            char firstChar \u003d s.charAt(start);\n            if (firstChar \u003d\u003d \u0027-\u0027) {\n                throw new\n                    NumberFormatException(String.format(\"Illegal leading minus sign \" +\n                                                       \"on unsigned string %s.\", s));\n            } else {\n                if (len \u003c\u003d 5 || // Integer.MAX_VALUE in Character.MAX_RADIX is 6 digits\n                        (radix \u003d\u003d 10 \u0026\u0026 len \u003c\u003d 9)) { // Integer.MAX_VALUE in base 10 is 10 digits\n                    return parseInt(s, start, start + len, radix);\n                } else {\n                    long ell \u003d Long.parseLong(s, start, start + len, radix);\n                    if ((ell \u0026 0xffff_ffff_0000_0000L) \u003d\u003d 0) {\n                        return (int) ell;\n                    } else {\n                        throw new\n                            NumberFormatException(String.format(\"String value %s exceeds \" +\n                                                                \"range of unsigned int.\", s));\n                    }\n                }\n            }\n        } else {\n            throw new NumberFormatException(\"\");\n        }\n    }\n\n    /**\n     * Parses the string argument as an unsigned decimal integer. The\n     * characters in the string must all be decimal digits, except\n     * that the first character may be an ASCII plus sign {@code\n     * \u0027+\u0027} ({@code \u0027\\u005Cu002B\u0027}). The resulting integer value\n     * is returned, exactly as if the argument and the radix 10 were\n     * given as arguments to the {@link\n     * #parseUnsignedInt(java.lang.String, int)} method.\n     *\n     * @param s   a {@code String} containing the unsigned {@code int}\n     *            representation to be parsed\n     * @return    the unsigned integer value represented by the argument in decimal.\n     * @throws    NumberFormatException  if the string does not contain a\n     *            parsable unsigned integer.\n     * @since 1.8\n     */\n    public static int parseUnsignedInt(String s) throws NumberFormatException {\n        return parseUnsignedInt(s, 10);\n    }\n\n    /**\n     * Returns an {@code Integer} object holding the value\n     * extracted from the specified {@code String} when parsed\n     * with the radix given by the second argument. The first argument\n     * is interpreted as representing a signed integer in the radix\n     * specified by the second argument, exactly as if the arguments\n     * were given to the {@link #parseInt(java.lang.String, int)}\n     * method. The result is an {@code Integer} object that\n     * represents the integer value specified by the string.\n     *\n     * \u003cp\u003eIn other words, this method returns an {@code Integer}\n     * object equal to the value of:\n     *\n     * \u003cblockquote\u003e\n     *  {@code new Integer(Integer.parseInt(s, radix))}\n     * \u003c/blockquote\u003e\n     *\n     * @param      s   the string to be parsed.\n     * @param      radix the radix to be used in interpreting {@code s}\n     * @return     an {@code Integer} object holding the value\n     *             represented by the string argument in the specified\n     *             radix.\n     * @throws    NumberFormatException if the {@code String}\n     *            does not contain a parsable {@code int}.\n     */\n    public static Integer valueOf(String s, int radix) throws NumberFormatException {\n        return Integer.valueOf(parseInt(s,radix));\n    }\n\n    /**\n     * Returns an {@code Integer} object holding the\n     * value of the specified {@code String}. The argument is\n     * interpreted as representing a signed decimal integer, exactly\n     * as if the argument were given to the {@link\n     * #parseInt(java.lang.String)} method. The result is an\n     * {@code Integer} object that represents the integer value\n     * specified by the string.\n     *\n     * \u003cp\u003eIn other words, this method returns an {@code Integer}\n     * object equal to the value of:\n     *\n     * \u003cblockquote\u003e\n     *  {@code new Integer(Integer.parseInt(s))}\n     * \u003c/blockquote\u003e\n     *\n     * @param      s   the string to be parsed.\n     * @return     an {@code Integer} object holding the value\n     *             represented by the string argument.\n     * @throws     NumberFormatException  if the string cannot be parsed\n     *             as an integer.\n     */\n    public static Integer valueOf(String s) throws NumberFormatException {\n        return Integer.valueOf(parseInt(s, 10));\n    }\n\n    /**\n     * Cache to support the object identity semantics of autoboxing for values between\n     * -128 and 127 (inclusive) as required by JLS.\n     *\n     * The cache is initialized on first usage.  The size of the cache\n     * may be controlled by the {@code -XX:AutoBoxCacheMax\u003d\u003csize\u003e} option.\n     * During VM initialization, java.lang.Integer.IntegerCache.high property\n     * may be set and saved in the private system properties in the\n     * jdk.internal.misc.VM class.\n     *\n     * WARNING: The cache is archived with CDS and reloaded from the shared\n     * archive at runtime. The archived cache (Integer[]) and Integer objects\n     * reside in the closed archive heap regions. Care should be taken when\n     * changing the implementation and the cache array should not be assigned\n     * with new Integer object(s) after initialization.\n     */\n\n    private static class IntegerCache {\n        static final int low \u003d -128;\n        static final int high;\n        static final Integer[] cache;\n        static Integer[] archivedCache;\n\n        static {\n            // high value may be configured by property\n            int h \u003d 127;\n            String integerCacheHighPropValue \u003d\n                VM.getSavedProperty(\"java.lang.Integer.IntegerCache.high\");\n            if (integerCacheHighPropValue !\u003d null) {\n                try {\n                    h \u003d Math.max(parseInt(integerCacheHighPropValue), 127);\n                    // Maximum array size is Integer.MAX_VALUE\n                    h \u003d Math.min(h, Integer.MAX_VALUE - (-low) -1);\n                } catch( NumberFormatException nfe) {\n                    // If the property cannot be parsed into an int, ignore it.\n                }\n            }\n            high \u003d h;\n\n            // Load IntegerCache.archivedCache from archive, if possible\n            CDS.initializeFromArchive(IntegerCache.class);\n            int size \u003d (high - low) + 1;\n\n            // Use the archived cache if it exists and is large enough\n            if (archivedCache \u003d\u003d null || size \u003e archivedCache.length) {\n                Integer[] c \u003d new Integer[size];\n                int j \u003d low;\n                for(int i \u003d 0; i \u003c c.length; i++) {\n                    c[i] \u003d new Integer(j++);\n                }\n                archivedCache \u003d c;\n            }\n            cache \u003d archivedCache;\n            // range [-128, 127] must be interned (JLS7 5.1.7)\n            assert IntegerCache.high \u003e\u003d 127;\n        }\n\n        private IntegerCache() {}\n    }\n\n    /**\n     * Returns an {@code Integer} instance representing the specified\n     * {@code int} value.  If a new {@code Integer} instance is not\n     * required, this method should generally be used in preference to\n     * the constructor {@link #Integer(int)}, as this method is likely\n     * to yield significantly better space and time performance by\n     * caching frequently requested values.\n     *\n     * This method will always cache values in the range -128 to 127,\n     * inclusive, and may cache other values outside of this range.\n     *\n     * @param  i an {@code int} value.\n     * @return an {@code Integer} instance representing {@code i}.\n     * @since  1.5\n     */\n    @IntrinsicCandidate\n    public static Integer valueOf(int i) {\n        if (i \u003e\u003d IntegerCache.low \u0026\u0026 i \u003c\u003d IntegerCache.high)\n            return IntegerCache.cache[i + (-IntegerCache.low)];\n        return new Integer(i);\n    }\n\n    /**\n     * The value of the {@code Integer}.\n     *\n     * @serial\n     */\n    private final int value;\n\n    /**\n     * Constructs a newly allocated {@code Integer} object that\n     * represents the specified {@code int} value.\n     *\n     * @param   value   the value to be represented by the\n     *                  {@code Integer} object.\n     *\n     * @deprecated\n     * It is rarely appropriate to use this constructor. The static factory\n     * {@link #valueOf(int)} is generally a better choice, as it is\n     * likely to yield significantly better space and time performance.\n     */\n    @Deprecated(since\u003d\"9\", forRemoval \u003d true)\n    public Integer(int value) {\n        this.value \u003d value;\n    }\n\n    /**\n     * Constructs a newly allocated {@code Integer} object that\n     * represents the {@code int} value indicated by the\n     * {@code String} parameter. The string is converted to an\n     * {@code int} value in exactly the manner used by the\n     * {@code parseInt} method for radix 10.\n     *\n     * @param   s   the {@code String} to be converted to an {@code Integer}.\n     * @throws      NumberFormatException if the {@code String} does not\n     *              contain a parsable integer.\n     *\n     * @deprecated\n     * It is rarely appropriate to use this constructor.\n     * Use {@link #parseInt(String)} to convert a string to a\n     * {@code int} primitive, or use {@link #valueOf(String)}\n     * to convert a string to an {@code Integer} object.\n     */\n    @Deprecated(since\u003d\"9\", forRemoval \u003d true)\n    public Integer(String s) throws NumberFormatException {\n        this.value \u003d parseInt(s, 10);\n    }\n\n    /**\n     * Returns the value of this {@code Integer} as a {@code byte}\n     * after a narrowing primitive conversion.\n     * @jls 5.1.3 Narrowing Primitive Conversion\n     */\n    public byte byteValue() {\n        return (byte)value;\n    }\n\n    /**\n     * Returns the value of this {@code Integer} as a {@code short}\n     * after a narrowing primitive conversion.\n     * @jls 5.1.3 Narrowing Primitive Conversion\n     */\n    public short shortValue() {\n        return (short)value;\n    }\n\n    /**\n     * Returns the value of this {@code Integer} as an\n     * {@code int}.\n     */\n    @IntrinsicCandidate\n    public int intValue() {\n        return value;\n    }\n\n    /**\n     * Returns the value of this {@code Integer} as a {@code long}\n     * after a widening primitive conversion.\n     * @jls 5.1.2 Widening Primitive Conversion\n     * @see Integer#toUnsignedLong(int)\n     */\n    public long longValue() {\n        return (long)value;\n    }\n\n    /**\n     * Returns the value of this {@code Integer} as a {@code float}\n     * after a widening primitive conversion.\n     * @jls 5.1.2 Widening Primitive Conversion\n     */\n    public float floatValue() {\n        return (float)value;\n    }\n\n    /**\n     * Returns the value of this {@code Integer} as a {@code double}\n     * after a widening primitive conversion.\n     * @jls 5.1.2 Widening Primitive Conversion\n     */\n    public double doubleValue() {\n        return (double)value;\n    }\n\n    /**\n     * Returns a {@code String} object representing this\n     * {@code Integer}\u0027s value. The value is converted to signed\n     * decimal representation and returned as a string, exactly as if\n     * the integer value were given as an argument to the {@link\n     * java.lang.Integer#toString(int)} method.\n     *\n     * @return  a string representation of the value of this object in\n     *          base\u0026nbsp;10.\n     */\n    public String toString() {\n        return toString(value);\n    }\n\n    /**\n     * Returns a hash code for this {@code Integer}.\n     *\n     * @return  a hash code value for this object, equal to the\n     *          primitive {@code int} value represented by this\n     *          {@code Integer} object.\n     */\n    @Override\n    public int hashCode() {\n        return Integer.hashCode(value);\n    }\n\n    /**\n     * Returns a hash code for an {@code int} value; compatible with\n     * {@code Integer.hashCode()}.\n     *\n     * @param value the value to hash\n     * @since 1.8\n     *\n     * @return a hash code value for an {@code int} value.\n     */\n    public static int hashCode(int value) {\n        return value;\n    }\n\n    /**\n     * Compares this object to the specified object.  The result is\n     * {@code true} if and only if the argument is not\n     * {@code null} and is an {@code Integer} object that\n     * contains the same {@code int} value as this object.\n     *\n     * @param   obj   the object to compare with.\n     * @return  {@code true} if the objects are the same;\n     *          {@code false} otherwise.\n     */\n    public boolean equals(Object obj) {\n        if (obj instanceof Integer) {\n            return value \u003d\u003d ((Integer)obj).intValue();\n        }\n        return false;\n    }\n\n    /**\n     * Determines the integer value of the system property with the\n     * specified name.\n     *\n     * \u003cp\u003eThe first argument is treated as the name of a system\n     * property.  System properties are accessible through the {@link\n     * java.lang.System#getProperty(java.lang.String)} method. The\n     * string value of this property is then interpreted as an integer\n     * value using the grammar supported by {@link Integer#decode decode} and\n     * an {@code Integer} object representing this value is returned.\n     *\n     * \u003cp\u003eIf there is no property with the specified name, if the\n     * specified name is empty or {@code null}, or if the property\n     * does not have the correct numeric format, then {@code null} is\n     * returned.\n     *\n     * \u003cp\u003eIn other words, this method returns an {@code Integer}\n     * object equal to the value of:\n     *\n     * \u003cblockquote\u003e\n     *  {@code getInteger(nm, null)}\n     * \u003c/blockquote\u003e\n     *\n     * @param   nm   property name.\n     * @return  the {@code Integer} value of the property.\n     * @throws  SecurityException for the same reasons as\n     *          {@link System#getProperty(String) System.getProperty}\n     * @see     java.lang.System#getProperty(java.lang.String)\n     * @see     java.lang.System#getProperty(java.lang.String, java.lang.String)\n     */\n    public static Integer getInteger(String nm) {\n        return getInteger(nm, null);\n    }\n\n    /**\n     * Determines the integer value of the system property with the\n     * specified name.\n     *\n     * \u003cp\u003eThe first argument is treated as the name of a system\n     * property.  System properties are accessible through the {@link\n     * java.lang.System#getProperty(java.lang.String)} method. The\n     * string value of this property is then interpreted as an integer\n     * value using the grammar supported by {@link Integer#decode decode} and\n     * an {@code Integer} object representing this value is returned.\n     *\n     * \u003cp\u003eThe second argument is the default value. An {@code Integer} object\n     * that represents the value of the second argument is returned if there\n     * is no property of the specified name, if the property does not have\n     * the correct numeric format, or if the specified name is empty or\n     * {@code null}.\n     *\n     * \u003cp\u003eIn other words, this method returns an {@code Integer} object\n     * equal to the value of:\n     *\n     * \u003cblockquote\u003e\n     *  {@code getInteger(nm, new Integer(val))}\n     * \u003c/blockquote\u003e\n     *\n     * but in practice it may be implemented in a manner such as:\n     *\n     * \u003cblockquote\u003e\u003cpre\u003e\n     * Integer result \u003d getInteger(nm, null);\n     * return (result \u003d\u003d null) ? new Integer(val) : result;\n     * \u003c/pre\u003e\u003c/blockquote\u003e\n     *\n     * to avoid the unnecessary allocation of an {@code Integer}\n     * object when the default value is not needed.\n     *\n     * @param   nm   property name.\n     * @param   val   default value.\n     * @return  the {@code Integer} value of the property.\n     * @throws  SecurityException for the same reasons as\n     *          {@link System#getProperty(String) System.getProperty}\n     * @see     java.lang.System#getProperty(java.lang.String)\n     * @see     java.lang.System#getProperty(java.lang.String, java.lang.String)\n     */\n    public static Integer getInteger(String nm, int val) {\n        Integer result \u003d getInteger(nm, null);\n        return (result \u003d\u003d null) ? Integer.valueOf(val) : result;\n    }\n\n    /**\n     * Returns the integer value of the system property with the\n     * specified name.  The first argument is treated as the name of a\n     * system property.  System properties are accessible through the\n     * {@link java.lang.System#getProperty(java.lang.String)} method.\n     * The string value of this property is then interpreted as an\n     * integer value, as per the {@link Integer#decode decode} method,\n     * and an {@code Integer} object representing this value is\n     * returned; in summary:\n     *\n     * \u003cul\u003e\u003cli\u003eIf the property value begins with the two ASCII characters\n     *         {@code 0x} or the ASCII character {@code #}, not\n     *      followed by a minus sign, then the rest of it is parsed as a\n     *      hexadecimal integer exactly as by the method\n     *      {@link #valueOf(java.lang.String, int)} with radix 16.\n     * \u003cli\u003eIf the property value begins with the ASCII character\n     *     {@code 0} followed by another character, it is parsed as an\n     *     octal integer exactly as by the method\n     *     {@link #valueOf(java.lang.String, int)} with radix 8.\n     * \u003cli\u003eOtherwise, the property value is parsed as a decimal integer\n     * exactly as by the method {@link #valueOf(java.lang.String, int)}\n     * with radix 10.\n     * \u003c/ul\u003e\n     *\n     * \u003cp\u003eThe second argument is the default value. The default value is\n     * returned if there is no property of the specified name, if the\n     * property does not have the correct numeric format, or if the\n     * specified name is empty or {@code null}.\n     *\n     * @param   nm   property name.\n     * @param   val   default value.\n     * @return  the {@code Integer} value of the property.\n     * @throws  SecurityException for the same reasons as\n     *          {@link System#getProperty(String) System.getProperty}\n     * @see     System#getProperty(java.lang.String)\n     * @see     System#getProperty(java.lang.String, java.lang.String)\n     */\n    public static Integer getInteger(String nm, Integer val) {\n        String v \u003d null;\n        try {\n            v \u003d System.getProperty(nm);\n        } catch (IllegalArgumentException | NullPointerException e) {\n        }\n        if (v !\u003d null) {\n            try {\n                return Integer.decode(v);\n            } catch (NumberFormatException e) {\n            }\n        }\n        return val;\n    }\n\n    /**\n     * Decodes a {@code String} into an {@code Integer}.\n     * Accepts decimal, hexadecimal, and octal numbers given\n     * by the following grammar:\n     *\n     * \u003cblockquote\u003e\n     * \u003cdl\u003e\n     * \u003cdt\u003e\u003ci\u003eDecodableString:\u003c/i\u003e\n     * \u003cdd\u003e\u003ci\u003eSign\u003csub\u003eopt\u003c/sub\u003e DecimalNumeral\u003c/i\u003e\n     * \u003cdd\u003e\u003ci\u003eSign\u003csub\u003eopt\u003c/sub\u003e\u003c/i\u003e {@code 0x} \u003ci\u003eHexDigits\u003c/i\u003e\n     * \u003cdd\u003e\u003ci\u003eSign\u003csub\u003eopt\u003c/sub\u003e\u003c/i\u003e {@code 0X} \u003ci\u003eHexDigits\u003c/i\u003e\n     * \u003cdd\u003e\u003ci\u003eSign\u003csub\u003eopt\u003c/sub\u003e\u003c/i\u003e {@code #} \u003ci\u003eHexDigits\u003c/i\u003e\n     * \u003cdd\u003e\u003ci\u003eSign\u003csub\u003eopt\u003c/sub\u003e\u003c/i\u003e {@code 0} \u003ci\u003eOctalDigits\u003c/i\u003e\n     *\n     * \u003cdt\u003e\u003ci\u003eSign:\u003c/i\u003e\n     * \u003cdd\u003e{@code -}\n     * \u003cdd\u003e{@code +}\n     * \u003c/dl\u003e\n     * \u003c/blockquote\u003e\n     *\n     * \u003ci\u003eDecimalNumeral\u003c/i\u003e, \u003ci\u003eHexDigits\u003c/i\u003e, and \u003ci\u003eOctalDigits\u003c/i\u003e\n     * are as defined in section {@jls 3.10.1} of\n     * \u003ccite\u003eThe Java Language Specification\u003c/cite\u003e,\n     * except that underscores are not accepted between digits.\n     *\n     * \u003cp\u003eThe sequence of characters following an optional\n     * sign and/or radix specifier (\"{@code 0x}\", \"{@code 0X}\",\n     * \"{@code #}\", or leading zero) is parsed as by the {@code\n     * Integer.parseInt} method with the indicated radix (10, 16, or\n     * 8).  This sequence of characters must represent a positive\n     * value or a {@link NumberFormatException} will be thrown.  The\n     * result is negated if first character of the specified {@code\n     * String} is the minus sign.  No whitespace characters are\n     * permitted in the {@code String}.\n     *\n     * @param     nm the {@code String} to decode.\n     * @return    an {@code Integer} object holding the {@code int}\n     *             value represented by {@code nm}\n     * @throws    NumberFormatException  if the {@code String} does not\n     *            contain a parsable integer.\n     * @see java.lang.Integer#parseInt(java.lang.String, int)\n     */\n    public static Integer decode(String nm) throws NumberFormatException {\n        int radix \u003d 10;\n        int index \u003d 0;\n        boolean negative \u003d false;\n        Integer result;\n\n        if (nm.isEmpty())\n            throw new NumberFormatException(\"Zero length string\");\n        char firstChar \u003d nm.charAt(0);\n        // Handle sign, if present\n        if (firstChar \u003d\u003d \u0027-\u0027) {\n            negative \u003d true;\n            index++;\n        } else if (firstChar \u003d\u003d \u0027+\u0027)\n            index++;\n\n        // Handle radix specifier, if present\n        if (nm.startsWith(\"0x\", index) || nm.startsWith(\"0X\", index)) {\n            index +\u003d 2;\n            radix \u003d 16;\n        }\n        else if (nm.startsWith(\"#\", index)) {\n            index ++;\n            radix \u003d 16;\n        }\n        else if (nm.startsWith(\"0\", index) \u0026\u0026 nm.length() \u003e 1 + index) {\n            index ++;\n            radix \u003d 8;\n        }\n\n        if (nm.startsWith(\"-\", index) || nm.startsWith(\"+\", index))\n            throw new NumberFormatException(\"Sign character in wrong position\");\n\n        try {\n            result \u003d Integer.valueOf(nm.substring(index), radix);\n            result \u003d negative ? Integer.valueOf(-result.intValue()) : result;\n        } catch (NumberFormatException e) {\n            // If number is Integer.MIN_VALUE, we\u0027ll end up here. The next line\n            // handles this case, and causes any genuine format error to be\n            // rethrown.\n            String constant \u003d negative ? (\"-\" + nm.substring(index))\n                                       : nm.substring(index);\n            result \u003d Integer.valueOf(constant, radix);\n        }\n        return result;\n    }\n\n    /**\n     * Compares two {@code Integer} objects numerically.\n     *\n     * @param   anotherInteger   the {@code Integer} to be compared.\n     * @return  the value {@code 0} if this {@code Integer} is\n     *          equal to the argument {@code Integer}; a value less than\n     *          {@code 0} if this {@code Integer} is numerically less\n     *          than the argument {@code Integer}; and a value greater\n     *          than {@code 0} if this {@code Integer} is numerically\n     *           greater than the argument {@code Integer} (signed\n     *           comparison).\n     * @since   1.2\n     */\n    public int compareTo(Integer anotherInteger) {\n        return compare(this.value, anotherInteger.value);\n    }\n\n    /**\n     * Compares two {@code int} values numerically.\n     * The value returned is identical to what would be returned by:\n     * \u003cpre\u003e\n     *    Integer.valueOf(x).compareTo(Integer.valueOf(y))\n     * \u003c/pre\u003e\n     *\n     * @param  x the first {@code int} to compare\n     * @param  y the second {@code int} to compare\n     * @return the value {@code 0} if {@code x \u003d\u003d y};\n     *         a value less than {@code 0} if {@code x \u003c y}; and\n     *         a value greater than {@code 0} if {@code x \u003e y}\n     * @since 1.7\n     */\n    public static int compare(int x, int y) {\n        return (x \u003c y) ? -1 : ((x \u003d\u003d y) ? 0 : 1);\n    }\n\n    /**\n     * Compares two {@code int} values numerically treating the values\n     * as unsigned.\n     *\n     * @param  x the first {@code int} to compare\n     * @param  y the second {@code int} to compare\n     * @return the value {@code 0} if {@code x \u003d\u003d y}; a value less\n     *         than {@code 0} if {@code x \u003c y} as unsigned values; and\n     *         a value greater than {@code 0} if {@code x \u003e y} as\n     *         unsigned values\n     * @since 1.8\n     */\n    public static int compareUnsigned(int x, int y) {\n        return compare(x + MIN_VALUE, y + MIN_VALUE);\n    }\n\n    /**\n     * Converts the argument to a {@code long} by an unsigned\n     * conversion.  In an unsigned conversion to a {@code long}, the\n     * high-order 32 bits of the {@code long} are zero and the\n     * low-order 32 bits are equal to the bits of the integer\n     * argument.\n     *\n     * Consequently, zero and positive {@code int} values are mapped\n     * to a numerically equal {@code long} value and negative {@code\n     * int} values are mapped to a {@code long} value equal to the\n     * input plus 2\u003csup\u003e32\u003c/sup\u003e.\n     *\n     * @param  x the value to convert to an unsigned {@code long}\n     * @return the argument converted to {@code long} by an unsigned\n     *         conversion\n     * @since 1.8\n     */\n    public static long toUnsignedLong(int x) {\n        return ((long) x) \u0026 0xffffffffL;\n    }\n\n    /**\n     * Returns the unsigned quotient of dividing the first argument by\n     * the second where each argument and the result is interpreted as\n     * an unsigned value.\n     *\n     * \u003cp\u003eNote that in two\u0027s complement arithmetic, the three other\n     * basic arithmetic operations of add, subtract, and multiply are\n     * bit-wise identical if the two operands are regarded as both\n     * being signed or both being unsigned.  Therefore separate {@code\n     * addUnsigned}, etc. methods are not provided.\n     *\n     * @param dividend the value to be divided\n     * @param divisor the value doing the dividing\n     * @return the unsigned quotient of the first argument divided by\n     * the second argument\n     * @see #remainderUnsigned\n     * @since 1.8\n     */\n    public static int divideUnsigned(int dividend, int divisor) {\n        // In lieu of tricky code, for now just use long arithmetic.\n        return (int)(toUnsignedLong(dividend) / toUnsignedLong(divisor));\n    }\n\n    /**\n     * Returns the unsigned remainder from dividing the first argument\n     * by the second where each argument and the result is interpreted\n     * as an unsigned value.\n     *\n     * @param dividend the value to be divided\n     * @param divisor the value doing the dividing\n     * @return the unsigned remainder of the first argument divided by\n     * the second argument\n     * @see #divideUnsigned\n     * @since 1.8\n     */\n    public static int remainderUnsigned(int dividend, int divisor) {\n        // In lieu of tricky code, for now just use long arithmetic.\n        return (int)(toUnsignedLong(dividend) % toUnsignedLong(divisor));\n    }\n\n\n    // Bit twiddling\n\n    /**\n     * The number of bits used to represent an {@code int} value in two\u0027s\n     * complement binary form.\n     *\n     * @since 1.5\n     */\n    @Native public static final int SIZE \u003d 32;\n\n    /**\n     * The number of bytes used to represent an {@code int} value in two\u0027s\n     * complement binary form.\n     *\n     * @since 1.8\n     */\n    public static final int BYTES \u003d SIZE / Byte.SIZE;\n\n    /**\n     * Returns an {@code int} value with at most a single one-bit, in the\n     * position of the highest-order (\"leftmost\") one-bit in the specified\n     * {@code int} value.  Returns zero if the specified value has no\n     * one-bits in its two\u0027s complement binary representation, that is, if it\n     * is equal to zero.\n     *\n     * @param i the value whose highest one bit is to be computed\n     * @return an {@code int} value with a single one-bit, in the position\n     *     of the highest-order one-bit in the specified value, or zero if\n     *     the specified value is itself equal to zero.\n     * @since 1.5\n     */\n    public static int highestOneBit(int i) {\n        return i \u0026 (MIN_VALUE \u003e\u003e\u003e numberOfLeadingZeros(i));\n    }\n\n    /**\n     * Returns an {@code int} value with at most a single one-bit, in the\n     * position of the lowest-order (\"rightmost\") one-bit in the specified\n     * {@code int} value.  Returns zero if the specified value has no\n     * one-bits in its two\u0027s complement binary representation, that is, if it\n     * is equal to zero.\n     *\n     * @param i the value whose lowest one bit is to be computed\n     * @return an {@code int} value with a single one-bit, in the position\n     *     of the lowest-order one-bit in the specified value, or zero if\n     *     the specified value is itself equal to zero.\n     * @since 1.5\n     */\n    public static int lowestOneBit(int i) {\n        // HD, Section 2-1\n        return i \u0026 -i;\n    }\n\n    /**\n     * Returns the number of zero bits preceding the highest-order\n     * (\"leftmost\") one-bit in the two\u0027s complement binary representation\n     * of the specified {@code int} value.  Returns 32 if the\n     * specified value has no one-bits in its two\u0027s complement representation,\n     * in other words if it is equal to zero.\n     *\n     * \u003cp\u003eNote that this method is closely related to the logarithm base 2.\n     * For all positive {@code int} values x:\n     * \u003cul\u003e\n     * \u003cli\u003efloor(log\u003csub\u003e2\u003c/sub\u003e(x)) \u003d {@code 31 - numberOfLeadingZeros(x)}\n     * \u003cli\u003eceil(log\u003csub\u003e2\u003c/sub\u003e(x)) \u003d {@code 32 - numberOfLeadingZeros(x - 1)}\n     * \u003c/ul\u003e\n     *\n     * @param i the value whose number of leading zeros is to be computed\n     * @return the number of zero bits preceding the highest-order\n     *     (\"leftmost\") one-bit in the two\u0027s complement binary representation\n     *     of the specified {@code int} value, or 32 if the value\n     *     is equal to zero.\n     * @since 1.5\n     */\n    @IntrinsicCandidate\n    public static int numberOfLeadingZeros(int i) {\n        // HD, Count leading 0\u0027s\n        if (i \u003c\u003d 0)\n            return i \u003d\u003d 0 ? 32 : 0;\n        int n \u003d 31;\n        if (i \u003e\u003d 1 \u003c\u003c 16) { n -\u003d 16; i \u003e\u003e\u003e\u003d 16; }\n        if (i \u003e\u003d 1 \u003c\u003c  8) { n -\u003d  8; i \u003e\u003e\u003e\u003d  8; }\n        if (i \u003e\u003d 1 \u003c\u003c  4) { n -\u003d  4; i \u003e\u003e\u003e\u003d  4; }\n        if (i \u003e\u003d 1 \u003c\u003c  2) { n -\u003d  2; i \u003e\u003e\u003e\u003d  2; }\n        return n - (i \u003e\u003e\u003e 1);\n    }\n\n    /**\n     * Returns the number of zero bits following the lowest-order (\"rightmost\")\n     * one-bit in the two\u0027s complement binary representation of the specified\n     * {@code int} value.  Returns 32 if the specified value has no\n     * one-bits in its two\u0027s complement representation, in other words if it is\n     * equal to zero.\n     *\n     * @param i the value whose number of trailing zeros is to be computed\n     * @return the number of zero bits following the lowest-order (\"rightmost\")\n     *     one-bit in the two\u0027s complement binary representation of the\n     *     specified {@code int} value, or 32 if the value is equal\n     *     to zero.\n     * @since 1.5\n     */\n    @IntrinsicCandidate\n    public static int numberOfTrailingZeros(int i) {\n        // HD, Count trailing 0\u0027s\n        i \u003d ~i \u0026 (i - 1);\n        if (i \u003c\u003d 0) return i \u0026 32;\n        int n \u003d 1;\n        if (i \u003e 1 \u003c\u003c 16) { n +\u003d 16; i \u003e\u003e\u003e\u003d 16; }\n        if (i \u003e 1 \u003c\u003c  8) { n +\u003d  8; i \u003e\u003e\u003e\u003d  8; }\n        if (i \u003e 1 \u003c\u003c  4) { n +\u003d  4; i \u003e\u003e\u003e\u003d  4; }\n        if (i \u003e 1 \u003c\u003c  2) { n +\u003d  2; i \u003e\u003e\u003e\u003d  2; }\n        return n + (i \u003e\u003e\u003e 1);\n    }\n\n    /**\n     * Returns the number of one-bits in the two\u0027s complement binary\n     * representation of the specified {@code int} value.  This function is\n     * sometimes referred to as the \u003ci\u003epopulation count\u003c/i\u003e.\n     *\n     * @param i the value whose bits are to be counted\n     * @return the number of one-bits in the two\u0027s complement binary\n     *     representation of the specified {@code int} value.\n     * @since 1.5\n     */\n    @IntrinsicCandidate\n    public static int bitCount(int i) {\n        // HD, Figure 5-2\n        i \u003d i - ((i \u003e\u003e\u003e 1) \u0026 0x55555555);\n        i \u003d (i \u0026 0x33333333) + ((i \u003e\u003e\u003e 2) \u0026 0x33333333);\n        i \u003d (i + (i \u003e\u003e\u003e 4)) \u0026 0x0f0f0f0f;\n        i \u003d i + (i \u003e\u003e\u003e 8);\n        i \u003d i + (i \u003e\u003e\u003e 16);\n        return i \u0026 0x3f;\n    }\n\n    /**\n     * Returns the value obtained by rotating the two\u0027s complement binary\n     * representation of the specified {@code int} value left by the\n     * specified number of bits.  (Bits shifted out of the left hand, or\n     * high-order, side reenter on the right, or low-order.)\n     *\n     * \u003cp\u003eNote that left rotation with a negative distance is equivalent to\n     * right rotation: {@code rotateLeft(val, -distance) \u003d\u003d rotateRight(val,\n     * distance)}.  Note also that rotation by any multiple of 32 is a\n     * no-op, so all but the last five bits of the rotation distance can be\n     * ignored, even if the distance is negative: {@code rotateLeft(val,\n     * distance) \u003d\u003d rotateLeft(val, distance \u0026 0x1F)}.\n     *\n     * @param i the value whose bits are to be rotated left\n     * @param distance the number of bit positions to rotate left\n     * @return the value obtained by rotating the two\u0027s complement binary\n     *     representation of the specified {@code int} value left by the\n     *     specified number of bits.\n     * @since 1.5\n     */\n    public static int rotateLeft(int i, int distance) {\n        return (i \u003c\u003c distance) | (i \u003e\u003e\u003e -distance);\n    }\n\n    /**\n     * Returns the value obtained by rotating the two\u0027s complement binary\n     * representation of the specified {@code int} value right by the\n     * specified number of bits.  (Bits shifted out of the right hand, or\n     * low-order, side reenter on the left, or high-order.)\n     *\n     * \u003cp\u003eNote that right rotation with a negative distance is equivalent to\n     * left rotation: {@code rotateRight(val, -distance) \u003d\u003d rotateLeft(val,\n     * distance)}.  Note also that rotation by any multiple of 32 is a\n     * no-op, so all but the last five bits of the rotation distance can be\n     * ignored, even if the distance is negative: {@code rotateRight(val,\n     * distance) \u003d\u003d rotateRight(val, distance \u0026 0x1F)}.\n     *\n     * @param i the value whose bits are to be rotated right\n     * @param distance the number of bit positions to rotate right\n     * @return the value obtained by rotating the two\u0027s complement binary\n     *     representation of the specified {@code int} value right by the\n     *     specified number of bits.\n     * @since 1.5\n     */\n    public static int rotateRight(int i, int distance) {\n        return (i \u003e\u003e\u003e distance) | (i \u003c\u003c -distance);\n    }\n\n    /**\n     * Returns the value obtained by reversing the order of the bits in the\n     * two\u0027s complement binary representation of the specified {@code int}\n     * value.\n     *\n     * @param i the value to be reversed\n     * @return the value obtained by reversing order of the bits in the\n     *     specified {@code int} value.\n     * @since 1.5\n     */\n    public static int reverse(int i) {\n        // HD, Figure 7-1\n        i \u003d (i \u0026 0x55555555) \u003c\u003c 1 | (i \u003e\u003e\u003e 1) \u0026 0x55555555;\n        i \u003d (i \u0026 0x33333333) \u003c\u003c 2 | (i \u003e\u003e\u003e 2) \u0026 0x33333333;\n        i \u003d (i \u0026 0x0f0f0f0f) \u003c\u003c 4 | (i \u003e\u003e\u003e 4) \u0026 0x0f0f0f0f;\n\n        return reverseBytes(i);\n    }\n\n    /**\n     * Returns the signum function of the specified {@code int} value.  (The\n     * return value is -1 if the specified value is negative; 0 if the\n     * specified value is zero; and 1 if the specified value is positive.)\n     *\n     * @param i the value whose signum is to be computed\n     * @return the signum function of the specified {@code int} value.\n     * @since 1.5\n     */\n    public static int signum(int i) {\n        // HD, Section 2-7\n        return (i \u003e\u003e 31) | (-i \u003e\u003e\u003e 31);\n    }\n\n    /**\n     * Returns the value obtained by reversing the order of the bytes in the\n     * two\u0027s complement representation of the specified {@code int} value.\n     *\n     * @param i the value whose bytes are to be reversed\n     * @return the value obtained by reversing the bytes in the specified\n     *     {@code int} value.\n     * @since 1.5\n     */\n    @IntrinsicCandidate\n    public static int reverseBytes(int i) {\n        return (i \u003c\u003c 24)            |\n               ((i \u0026 0xff00) \u003c\u003c 8)  |\n               ((i \u003e\u003e\u003e 8) \u0026 0xff00) |\n               (i \u003e\u003e\u003e 24);\n    }\n\n    /**\n     * Adds two integers together as per the + operator.\n     *\n     * @param a the first operand\n     * @param b the second operand\n     * @return the sum of {@code a} and {@code b}\n     * @see java.util.function.BinaryOperator\n     * @since 1.8\n     */\n    public static int sum(int a, int b) {\n        return a + b;\n    }\n\n    /**\n     * Returns the greater of two {@code int} values\n     * as if by calling {@link Math#max(int, int) Math.max}.\n     *\n     * @param a the first operand\n     * @param b the second operand\n     * @return the greater of {@code a} and {@code b}\n     * @see java.util.function.BinaryOperator\n     * @since 1.8\n     */\n    public static int max(int a, int b) {\n        return Math.max(a, b);\n    }\n\n    /**\n     * Returns the smaller of two {@code int} values\n     * as if by calling {@link Math#min(int, int) Math.min}.\n     *\n     * @param a the first operand\n     * @param b the second operand\n     * @return the smaller of {@code a} and {@code b}\n     * @see java.util.function.BinaryOperator\n     * @since 1.8\n     */\n    public static int min(int a, int b) {\n        return Math.min(a, b);\n    }\n\n    /**\n     * Returns an {@link Optional} containing the nominal descriptor for this\n     * instance, which is the instance itself.\n     *\n     * @return an {@link Optional} describing the {@linkplain Integer} instance\n     * @since 12\n     */\n    @Override\n    public Optional\u003cInteger\u003e describeConstable() {\n        return Optional.of(this);\n    }\n\n    /**\n     * Resolves this instance as a {@link ConstantDesc}, the result of which is\n     * the instance itself.\n     *\n     * @param lookup ignored\n     * @return the {@linkplain Integer} instance\n     * @since 12\n     */\n    @Override\n    public Integer resolveConstantDesc(MethodHandles.Lookup lookup) {\n        return this;\n    }\n\n    /** use serialVersionUID from JDK 1.0.2 for interoperability */\n    @java.io.Serial\n    @Native private static final long serialVersionUID \u003d 1360826667806852920L;\n}\n"
    }
  }
}
java.lang.IllegalArgumentException: Illegal character in opaque part at index 188: jar:file:///C:/Users/Vinicius/AppData/Local/Coursier/cache/arc/https/github.com/adoptium/temurin17-binaries/releases/download/jdk-17%2B35/OpenJDK17-jdk_x64_windows_hotspot_17_35.zip/jdk-17 35/lib/src.zip!/java.base/java/lang/Integer.java
	at java.base/java.net.URI.create(URI.java:906)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:178)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.$anonfun$toAbsolutePath$3(MtagsEnrichments.scala:175)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.withTryDecode$1(MtagsEnrichments.scala:153)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:175)
	at scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:756)
	at scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:753)
	at scala.meta.internal.metals.WorkspaceLspService.didOpen(WorkspaceLspService.scala:388)
	at scala.meta.metals.lsp.DelegatingScalaService.didOpen(DelegatingScalaService.scala:39)
	at jdk.internal.reflect.GeneratedMethodAccessor23.invoke(Unknown Source)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:568)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$recursiveFindRpcMethods$0(GenericEndpoint.java:65)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.notify(GenericEndpoint.java:160)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleNotification(RemoteEndpoint.java:231)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:198)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:185)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:97)
	at org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:114)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:539)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.base/java.lang.Thread.run(Thread.java:833)
Caused by: java.net.URISyntaxException: Illegal character in opaque part at index 188: jar:file:///C:/Users/Vinicius/AppData/Local/Coursier/cache/arc/https/github.com/adoptium/temurin17-binaries/releases/download/jdk-17%2B35/OpenJDK17-jdk_x64_windows_hotspot_17_35.zip/jdk-17 35/lib/src.zip!/java.base/java/lang/Integer.java
	at java.base/java.net.URI$Parser.fail(URI.java:2974)
	at java.base/java.net.URI$Parser.checkChars(URI.java:3145)
	at java.base/java.net.URI$Parser.parse(URI.java:3181)
	at java.base/java.net.URI.<init>(URI.java:623)
	at java.base/java.net.URI.create(URI.java:904)
	... 23 more

jul. 19, 2024 1:42:12 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleNotification
ADVERTÊNCIA: Notification threw an exception: {
  "jsonrpc": "2.0",
  "method": "textDocument/didClose",
  "params": {
    "textDocument": {
      "uri": "jar:file%3A///C%3A/Users/Vinicius/AppData/Local/Coursier/cache/arc/https/github.com/adoptium/temurin17-binaries/releases/download/jdk-17%25252B35/OpenJDK17-jdk_x64_windows_hotspot_17_35.zip/jdk-17%2B35/lib/src.zip%21/java.base/java/lang/Integer.java"
    }
  }
}
java.lang.IllegalArgumentException: Illegal character in opaque part at index 188: jar:file:///C:/Users/Vinicius/AppData/Local/Coursier/cache/arc/https/github.com/adoptium/temurin17-binaries/releases/download/jdk-17%2B35/OpenJDK17-jdk_x64_windows_hotspot_17_35.zip/jdk-17 35/lib/src.zip!/java.base/java/lang/Integer.java
	at java.base/java.net.URI.create(URI.java:906)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:178)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.$anonfun$toAbsolutePath$3(MtagsEnrichments.scala:175)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.withTryDecode$1(MtagsEnrichments.scala:153)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:175)
	at scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:756)
	at scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:753)
	at scala.meta.internal.metals.WorkspaceLspService.didClose(WorkspaceLspService.scala:407)
	at scala.meta.metals.lsp.DelegatingScalaService.didClose(DelegatingScalaService.scala:53)
	at jdk.internal.reflect.GeneratedMethodAccessor26.invoke(Unknown Source)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:568)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$recursiveFindRpcMethods$0(GenericEndpoint.java:65)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.notify(GenericEndpoint.java:160)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleNotification(RemoteEndpoint.java:231)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:198)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:185)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:97)
	at org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:114)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:539)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.base/java.lang.Thread.run(Thread.java:833)
Caused by: java.net.URISyntaxException: Illegal character in opaque part at index 188: jar:file:///C:/Users/Vinicius/AppData/Local/Coursier/cache/arc/https/github.com/adoptium/temurin17-binaries/releases/download/jdk-17%2B35/OpenJDK17-jdk_x64_windows_hotspot_17_35.zip/jdk-17 35/lib/src.zip!/java.base/java/lang/Integer.java
	at java.base/java.net.URI$Parser.fail(URI.java:2974)
	at java.base/java.net.URI$Parser.checkChars(URI.java:3145)
	at java.base/java.net.URI$Parser.parse(URI.java:3181)
	at java.base/java.net.URI.<init>(URI.java:623)
	at java.base/java.net.URI.create(URI.java:904)
	... 23 more

jul. 19, 2024 1:42:12 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleNotification
ADVERTÊNCIA: Notification threw an exception: {
  "jsonrpc": "2.0",
  "method": "textDocument/didOpen",
  "params": {
    "textDocument": {
      "uri": "jar:file%3A///C%3A/Users/Vinicius/AppData/Local/Coursier/cache/arc/https/github.com/adoptium/temurin17-binaries/releases/download/jdk-17%25252B35/OpenJDK17-jdk_x64_windows_hotspot_17_35.zip/jdk-17%2B35/lib/src.zip%21/java.base/java/lang/Integer.java",
      "languageId": "java",
      "version": 1,
      "text": "/*\n * Copyright (c) 1994, 2021, Oracle and/or its affiliates. All rights reserved.\n * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n *\n * This code is free software; you can redistribute it and/or modify it\n * under the terms of the GNU General Public License version 2 only, as\n * published by the Free Software Foundation.  Oracle designates this\n * particular file as subject to the \"Classpath\" exception as provided\n * by Oracle in the LICENSE file that accompanied this code.\n *\n * This code is distributed in the hope that it will be useful, but WITHOUT\n * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n * version 2 for more details (a copy is included in the LICENSE file that\n * accompanied this code).\n *\n * You should have received a copy of the GNU General Public License version\n * 2 along with this work; if not, write to the Free Software Foundation,\n * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n *\n * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n * or visit www.oracle.com if you need additional information or have any\n * questions.\n */\n\npackage java.lang;\n\nimport java.lang.annotation.Native;\nimport java.lang.invoke.MethodHandles;\nimport java.lang.constant.Constable;\nimport java.lang.constant.ConstantDesc;\nimport java.util.Objects;\nimport java.util.Optional;\n\nimport jdk.internal.misc.CDS;\nimport jdk.internal.misc.VM;\nimport jdk.internal.vm.annotation.IntrinsicCandidate;\n\nimport static java.lang.String.COMPACT_STRINGS;\nimport static java.lang.String.LATIN1;\nimport static java.lang.String.UTF16;\n\n/**\n * The {@code Integer} class wraps a value of the primitive type\n * {@code int} in an object. An object of type {@code Integer}\n * contains a single field whose type is {@code int}.\n *\n * \u003cp\u003eIn addition, this class provides several methods for converting\n * an {@code int} to a {@code String} and a {@code String} to an\n * {@code int}, as well as other constants and methods useful when\n * dealing with an {@code int}.\n *\n * \u003cp\u003eThis is a \u003ca href\u003d\"{@docRoot}/java.base/java/lang/doc-files/ValueBased.html\"\u003evalue-based\u003c/a\u003e\n * class; programmers should treat instances that are\n * {@linkplain #equals(Object) equal} as interchangeable and should not\n * use instances for synchronization, or unpredictable behavior may\n * occur. For example, in a future release, synchronization may fail.\n *\n * \u003cp\u003eImplementation note: The implementations of the \"bit twiddling\"\n * methods (such as {@link #highestOneBit(int) highestOneBit} and\n * {@link #numberOfTrailingZeros(int) numberOfTrailingZeros}) are\n * based on material from Henry S. Warren, Jr.\u0027s \u003ci\u003eHacker\u0027s\n * Delight\u003c/i\u003e, (Addison Wesley, 2002).\n *\n * @author  Lee Boynton\n * @author  Arthur van Hoff\n * @author  Josh Bloch\n * @author  Joseph D. Darcy\n * @since 1.0\n */\n@jdk.internal.ValueBased\npublic final class Integer extends Number\n        implements Comparable\u003cInteger\u003e, Constable, ConstantDesc {\n    /**\n     * A constant holding the minimum value an {@code int} can\n     * have, -2\u003csup\u003e31\u003c/sup\u003e.\n     */\n    @Native public static final int   MIN_VALUE \u003d 0x80000000;\n\n    /**\n     * A constant holding the maximum value an {@code int} can\n     * have, 2\u003csup\u003e31\u003c/sup\u003e-1.\n     */\n    @Native public static final int   MAX_VALUE \u003d 0x7fffffff;\n\n    /**\n     * The {@code Class} instance representing the primitive type\n     * {@code int}.\n     *\n     * @since   1.1\n     */\n    @SuppressWarnings(\"unchecked\")\n    public static final Class\u003cInteger\u003e  TYPE \u003d (Class\u003cInteger\u003e) Class.getPrimitiveClass(\"int\");\n\n    /**\n     * All possible chars for representing a number as a String\n     */\n    static final char[] digits \u003d {\n        \u00270\u0027 , \u00271\u0027 , \u00272\u0027 , \u00273\u0027 , \u00274\u0027 , \u00275\u0027 ,\n        \u00276\u0027 , \u00277\u0027 , \u00278\u0027 , \u00279\u0027 , \u0027a\u0027 , \u0027b\u0027 ,\n        \u0027c\u0027 , \u0027d\u0027 , \u0027e\u0027 , \u0027f\u0027 , \u0027g\u0027 , \u0027h\u0027 ,\n        \u0027i\u0027 , \u0027j\u0027 , \u0027k\u0027 , \u0027l\u0027 , \u0027m\u0027 , \u0027n\u0027 ,\n        \u0027o\u0027 , \u0027p\u0027 , \u0027q\u0027 , \u0027r\u0027 , \u0027s\u0027 , \u0027t\u0027 ,\n        \u0027u\u0027 , \u0027v\u0027 , \u0027w\u0027 , \u0027x\u0027 , \u0027y\u0027 , \u0027z\u0027\n    };\n\n    /**\n     * Returns a string representation of the first argument in the\n     * radix specified by the second argument.\n     *\n     * \u003cp\u003eIf the radix is smaller than {@code Character.MIN_RADIX}\n     * or larger than {@code Character.MAX_RADIX}, then the radix\n     * {@code 10} is used instead.\n     *\n     * \u003cp\u003eIf the first argument is negative, the first element of the\n     * result is the ASCII minus character {@code \u0027-\u0027}\n     * ({@code \u0027\\u005Cu002D\u0027}). If the first argument is not\n     * negative, no sign character appears in the result.\n     *\n     * \u003cp\u003eThe remaining characters of the result represent the magnitude\n     * of the first argument. If the magnitude is zero, it is\n     * represented by a single zero character {@code \u00270\u0027}\n     * ({@code \u0027\\u005Cu0030\u0027}); otherwise, the first character of\n     * the representation of the magnitude will not be the zero\n     * character.  The following ASCII characters are used as digits:\n     *\n     * \u003cblockquote\u003e\n     *   {@code 0123456789abcdefghijklmnopqrstuvwxyz}\n     * \u003c/blockquote\u003e\n     *\n     * These are {@code \u0027\\u005Cu0030\u0027} through\n     * {@code \u0027\\u005Cu0039\u0027} and {@code \u0027\\u005Cu0061\u0027} through\n     * {@code \u0027\\u005Cu007A\u0027}. If {@code radix} is\n     * \u003cvar\u003eN\u003c/var\u003e, then the first \u003cvar\u003eN\u003c/var\u003e of these characters\n     * are used as radix-\u003cvar\u003eN\u003c/var\u003e digits in the order shown. Thus,\n     * the digits for hexadecimal (radix 16) are\n     * {@code 0123456789abcdef}. If uppercase letters are\n     * desired, the {@link java.lang.String#toUpperCase()} method may\n     * be called on the result:\n     *\n     * \u003cblockquote\u003e\n     *  {@code Integer.toString(n, 16).toUpperCase()}\n     * \u003c/blockquote\u003e\n     *\n     * @param   i       an integer to be converted to a string.\n     * @param   radix   the radix to use in the string representation.\n     * @return  a string representation of the argument in the specified radix.\n     * @see     java.lang.Character#MAX_RADIX\n     * @see     java.lang.Character#MIN_RADIX\n     */\n    public static String toString(int i, int radix) {\n        if (radix \u003c Character.MIN_RADIX || radix \u003e Character.MAX_RADIX)\n            radix \u003d 10;\n\n        /* Use the faster version */\n        if (radix \u003d\u003d 10) {\n            return toString(i);\n        }\n\n        if (COMPACT_STRINGS) {\n            byte[] buf \u003d new byte[33];\n            boolean negative \u003d (i \u003c 0);\n            int charPos \u003d 32;\n\n            if (!negative) {\n                i \u003d -i;\n            }\n\n            while (i \u003c\u003d -radix) {\n                buf[charPos--] \u003d (byte)digits[-(i % radix)];\n                i \u003d i / radix;\n            }\n            buf[charPos] \u003d (byte)digits[-i];\n\n            if (negative) {\n                buf[--charPos] \u003d \u0027-\u0027;\n            }\n\n            return StringLatin1.newString(buf, charPos, (33 - charPos));\n        }\n        return toStringUTF16(i, radix);\n    }\n\n    private static String toStringUTF16(int i, int radix) {\n        byte[] buf \u003d new byte[33 * 2];\n        boolean negative \u003d (i \u003c 0);\n        int charPos \u003d 32;\n        if (!negative) {\n            i \u003d -i;\n        }\n        while (i \u003c\u003d -radix) {\n            StringUTF16.putChar(buf, charPos--, digits[-(i % radix)]);\n            i \u003d i / radix;\n        }\n        StringUTF16.putChar(buf, charPos, digits[-i]);\n\n        if (negative) {\n            StringUTF16.putChar(buf, --charPos, \u0027-\u0027);\n        }\n        return StringUTF16.newString(buf, charPos, (33 - charPos));\n    }\n\n    /**\n     * Returns a string representation of the first argument as an\n     * unsigned integer value in the radix specified by the second\n     * argument.\n     *\n     * \u003cp\u003eIf the radix is smaller than {@code Character.MIN_RADIX}\n     * or larger than {@code Character.MAX_RADIX}, then the radix\n     * {@code 10} is used instead.\n     *\n     * \u003cp\u003eNote that since the first argument is treated as an unsigned\n     * value, no leading sign character is printed.\n     *\n     * \u003cp\u003eIf the magnitude is zero, it is represented by a single zero\n     * character {@code \u00270\u0027} ({@code \u0027\\u005Cu0030\u0027}); otherwise,\n     * the first character of the representation of the magnitude will\n     * not be the zero character.\n     *\n     * \u003cp\u003eThe behavior of radixes and the characters used as digits\n     * are the same as {@link #toString(int, int) toString}.\n     *\n     * @param   i       an integer to be converted to an unsigned string.\n     * @param   radix   the radix to use in the string representation.\n     * @return  an unsigned string representation of the argument in the specified radix.\n     * @see     #toString(int, int)\n     * @since 1.8\n     */\n    public static String toUnsignedString(int i, int radix) {\n        return Long.toUnsignedString(toUnsignedLong(i), radix);\n    }\n\n    /**\n     * Returns a string representation of the integer argument as an\n     * unsigned integer in base\u0026nbsp;16.\n     *\n     * \u003cp\u003eThe unsigned integer value is the argument plus 2\u003csup\u003e32\u003c/sup\u003e\n     * if the argument is negative; otherwise, it is equal to the\n     * argument.  This value is converted to a string of ASCII digits\n     * in hexadecimal (base\u0026nbsp;16) with no extra leading\n     * {@code 0}s.\n     *\n     * \u003cp\u003eThe value of the argument can be recovered from the returned\n     * string {@code s} by calling {@link\n     * Integer#parseUnsignedInt(String, int)\n     * Integer.parseUnsignedInt(s, 16)}.\n     *\n     * \u003cp\u003eIf the unsigned magnitude is zero, it is represented by a\n     * single zero character {@code \u00270\u0027} ({@code \u0027\\u005Cu0030\u0027});\n     * otherwise, the first character of the representation of the\n     * unsigned magnitude will not be the zero character. The\n     * following characters are used as hexadecimal digits:\n     *\n     * \u003cblockquote\u003e\n     *  {@code 0123456789abcdef}\n     * \u003c/blockquote\u003e\n     *\n     * These are the characters {@code \u0027\\u005Cu0030\u0027} through\n     * {@code \u0027\\u005Cu0039\u0027} and {@code \u0027\\u005Cu0061\u0027} through\n     * {@code \u0027\\u005Cu0066\u0027}. If uppercase letters are\n     * desired, the {@link java.lang.String#toUpperCase()} method may\n     * be called on the result:\n     *\n     * \u003cblockquote\u003e\n     *  {@code Integer.toHexString(n).toUpperCase()}\n     * \u003c/blockquote\u003e\n     *\n     * @apiNote\n     * The {@link java.util.HexFormat} class provides formatting and parsing\n     * of byte arrays and primitives to return a string or adding to an {@link Appendable}.\n     * {@code HexFormat} formats and parses uppercase or lowercase hexadecimal characters,\n     * with leading zeros and for byte arrays includes for each byte\n     * a delimiter, prefix, and suffix.\n     *\n     * @param   i   an integer to be converted to a string.\n     * @return  the string representation of the unsigned integer value\n     *          represented by the argument in hexadecimal (base\u0026nbsp;16).\n     * @see java.util.HexFormat\n     * @see #parseUnsignedInt(String, int)\n     * @see #toUnsignedString(int, int)\n     * @since   1.0.2\n     */\n    public static String toHexString(int i) {\n        return toUnsignedString0(i, 4);\n    }\n\n    /**\n     * Returns a string representation of the integer argument as an\n     * unsigned integer in base\u0026nbsp;8.\n     *\n     * \u003cp\u003eThe unsigned integer value is the argument plus 2\u003csup\u003e32\u003c/sup\u003e\n     * if the argument is negative; otherwise, it is equal to the\n     * argument.  This value is converted to a string of ASCII digits\n     * in octal (base\u0026nbsp;8) with no extra leading {@code 0}s.\n     *\n     * \u003cp\u003eThe value of the argument can be recovered from the returned\n     * string {@code s} by calling {@link\n     * Integer#parseUnsignedInt(String, int)\n     * Integer.parseUnsignedInt(s, 8)}.\n     *\n     * \u003cp\u003eIf the unsigned magnitude is zero, it is represented by a\n     * single zero character {@code \u00270\u0027} ({@code \u0027\\u005Cu0030\u0027});\n     * otherwise, the first character of the representation of the\n     * unsigned magnitude will not be the zero character. The\n     * following characters are used as octal digits:\n     *\n     * \u003cblockquote\u003e\n     * {@code 01234567}\n     * \u003c/blockquote\u003e\n     *\n     * These are the characters {@code \u0027\\u005Cu0030\u0027} through\n     * {@code \u0027\\u005Cu0037\u0027}.\n     *\n     * @param   i   an integer to be converted to a string.\n     * @return  the string representation of the unsigned integer value\n     *          represented by the argument in octal (base\u0026nbsp;8).\n     * @see #parseUnsignedInt(String, int)\n     * @see #toUnsignedString(int, int)\n     * @since   1.0.2\n     */\n    public static String toOctalString(int i) {\n        return toUnsignedString0(i, 3);\n    }\n\n    /**\n     * Returns a string representation of the integer argument as an\n     * unsigned integer in base\u0026nbsp;2.\n     *\n     * \u003cp\u003eThe unsigned integer value is the argument plus 2\u003csup\u003e32\u003c/sup\u003e\n     * if the argument is negative; otherwise it is equal to the\n     * argument.  This value is converted to a string of ASCII digits\n     * in binary (base\u0026nbsp;2) with no extra leading {@code 0}s.\n     *\n     * \u003cp\u003eThe value of the argument can be recovered from the returned\n     * string {@code s} by calling {@link\n     * Integer#parseUnsignedInt(String, int)\n     * Integer.parseUnsignedInt(s, 2)}.\n     *\n     * \u003cp\u003eIf the unsigned magnitude is zero, it is represented by a\n     * single zero character {@code \u00270\u0027} ({@code \u0027\\u005Cu0030\u0027});\n     * otherwise, the first character of the representation of the\n     * unsigned magnitude will not be the zero character. The\n     * characters {@code \u00270\u0027} ({@code \u0027\\u005Cu0030\u0027}) and {@code\n     * \u00271\u0027} ({@code \u0027\\u005Cu0031\u0027}) are used as binary digits.\n     *\n     * @param   i   an integer to be converted to a string.\n     * @return  the string representation of the unsigned integer value\n     *          represented by the argument in binary (base\u0026nbsp;2).\n     * @see #parseUnsignedInt(String, int)\n     * @see #toUnsignedString(int, int)\n     * @since   1.0.2\n     */\n    public static String toBinaryString(int i) {\n        return toUnsignedString0(i, 1);\n    }\n\n    /**\n     * Convert the integer to an unsigned number.\n     */\n    private static String toUnsignedString0(int val, int shift) {\n        // assert shift \u003e 0 \u0026\u0026 shift \u003c\u003d5 : \"Illegal shift value\";\n        int mag \u003d Integer.SIZE - Integer.numberOfLeadingZeros(val);\n        int chars \u003d Math.max(((mag + (shift - 1)) / shift), 1);\n        if (COMPACT_STRINGS) {\n            byte[] buf \u003d new byte[chars];\n            formatUnsignedInt(val, shift, buf, chars);\n            return new String(buf, LATIN1);\n        } else {\n            byte[] buf \u003d new byte[chars * 2];\n            formatUnsignedIntUTF16(val, shift, buf, chars);\n            return new String(buf, UTF16);\n        }\n    }\n\n    /**\n     * Format an {@code int} (treated as unsigned) into a byte buffer (LATIN1 version). If\n     * {@code len} exceeds the formatted ASCII representation of {@code val},\n     * {@code buf} will be padded with leading zeroes.\n     *\n     * @param val the unsigned int to format\n     * @param shift the log2 of the base to format in (4 for hex, 3 for octal, 1 for binary)\n     * @param buf the byte buffer to write to\n     * @param len the number of characters to write\n     */\n    private static void formatUnsignedInt(int val, int shift, byte[] buf, int len) {\n        int charPos \u003d len;\n        int radix \u003d 1 \u003c\u003c shift;\n        int mask \u003d radix - 1;\n        do {\n            buf[--charPos] \u003d (byte)Integer.digits[val \u0026 mask];\n            val \u003e\u003e\u003e\u003d shift;\n        } while (charPos \u003e 0);\n    }\n\n    /**\n     * Format an {@code int} (treated as unsigned) into a byte buffer (UTF16 version). If\n     * {@code len} exceeds the formatted ASCII representation of {@code val},\n     * {@code buf} will be padded with leading zeroes.\n     *\n     * @param val the unsigned int to format\n     * @param shift the log2 of the base to format in (4 for hex, 3 for octal, 1 for binary)\n     * @param buf the byte buffer to write to\n     * @param len the number of characters to write\n     */\n    private static void formatUnsignedIntUTF16(int val, int shift, byte[] buf, int len) {\n        int charPos \u003d len;\n        int radix \u003d 1 \u003c\u003c shift;\n        int mask \u003d radix - 1;\n        do {\n            StringUTF16.putChar(buf, --charPos, Integer.digits[val \u0026 mask]);\n            val \u003e\u003e\u003e\u003d shift;\n        } while (charPos \u003e 0);\n    }\n\n    static final byte[] DigitTens \u003d {\n        \u00270\u0027, \u00270\u0027, \u00270\u0027, \u00270\u0027, \u00270\u0027, \u00270\u0027, \u00270\u0027, \u00270\u0027, \u00270\u0027, \u00270\u0027,\n        \u00271\u0027, \u00271\u0027, \u00271\u0027, \u00271\u0027, \u00271\u0027, \u00271\u0027, \u00271\u0027, \u00271\u0027, \u00271\u0027, \u00271\u0027,\n        \u00272\u0027, \u00272\u0027, \u00272\u0027, \u00272\u0027, \u00272\u0027, \u00272\u0027, \u00272\u0027, \u00272\u0027, \u00272\u0027, \u00272\u0027,\n        \u00273\u0027, \u00273\u0027, \u00273\u0027, \u00273\u0027, \u00273\u0027, \u00273\u0027, \u00273\u0027, \u00273\u0027, \u00273\u0027, \u00273\u0027,\n        \u00274\u0027, \u00274\u0027, \u00274\u0027, \u00274\u0027, \u00274\u0027, \u00274\u0027, \u00274\u0027, \u00274\u0027, \u00274\u0027, \u00274\u0027,\n        \u00275\u0027, \u00275\u0027, \u00275\u0027, \u00275\u0027, \u00275\u0027, \u00275\u0027, \u00275\u0027, \u00275\u0027, \u00275\u0027, \u00275\u0027,\n        \u00276\u0027, \u00276\u0027, \u00276\u0027, \u00276\u0027, \u00276\u0027, \u00276\u0027, \u00276\u0027, \u00276\u0027, \u00276\u0027, \u00276\u0027,\n        \u00277\u0027, \u00277\u0027, \u00277\u0027, \u00277\u0027, \u00277\u0027, \u00277\u0027, \u00277\u0027, \u00277\u0027, \u00277\u0027, \u00277\u0027,\n        \u00278\u0027, \u00278\u0027, \u00278\u0027, \u00278\u0027, \u00278\u0027, \u00278\u0027, \u00278\u0027, \u00278\u0027, \u00278\u0027, \u00278\u0027,\n        \u00279\u0027, \u00279\u0027, \u00279\u0027, \u00279\u0027, \u00279\u0027, \u00279\u0027, \u00279\u0027, \u00279\u0027, \u00279\u0027, \u00279\u0027,\n        } ;\n\n    static final byte[] DigitOnes \u003d {\n        \u00270\u0027, \u00271\u0027, \u00272\u0027, \u00273\u0027, \u00274\u0027, \u00275\u0027, \u00276\u0027, \u00277\u0027, \u00278\u0027, \u00279\u0027,\n        \u00270\u0027, \u00271\u0027, \u00272\u0027, \u00273\u0027, \u00274\u0027, \u00275\u0027, \u00276\u0027, \u00277\u0027, \u00278\u0027, \u00279\u0027,\n        \u00270\u0027, \u00271\u0027, \u00272\u0027, \u00273\u0027, \u00274\u0027, \u00275\u0027, \u00276\u0027, \u00277\u0027, \u00278\u0027, \u00279\u0027,\n        \u00270\u0027, \u00271\u0027, \u00272\u0027, \u00273\u0027, \u00274\u0027, \u00275\u0027, \u00276\u0027, \u00277\u0027, \u00278\u0027, \u00279\u0027,\n        \u00270\u0027, \u00271\u0027, \u00272\u0027, \u00273\u0027, \u00274\u0027, \u00275\u0027, \u00276\u0027, \u00277\u0027, \u00278\u0027, \u00279\u0027,\n        \u00270\u0027, \u00271\u0027, \u00272\u0027, \u00273\u0027, \u00274\u0027, \u00275\u0027, \u00276\u0027, \u00277\u0027, \u00278\u0027, \u00279\u0027,\n        \u00270\u0027, \u00271\u0027, \u00272\u0027, \u00273\u0027, \u00274\u0027, \u00275\u0027, \u00276\u0027, \u00277\u0027, \u00278\u0027, \u00279\u0027,\n        \u00270\u0027, \u00271\u0027, \u00272\u0027, \u00273\u0027, \u00274\u0027, \u00275\u0027, \u00276\u0027, \u00277\u0027, \u00278\u0027, \u00279\u0027,\n        \u00270\u0027, \u00271\u0027, \u00272\u0027, \u00273\u0027, \u00274\u0027, \u00275\u0027, \u00276\u0027, \u00277\u0027, \u00278\u0027, \u00279\u0027,\n        \u00270\u0027, \u00271\u0027, \u00272\u0027, \u00273\u0027, \u00274\u0027, \u00275\u0027, \u00276\u0027, \u00277\u0027, \u00278\u0027, \u00279\u0027,\n        } ;\n\n\n    /**\n     * Returns a {@code String} object representing the\n     * specified integer. The argument is converted to signed decimal\n     * representation and returned as a string, exactly as if the\n     * argument and radix 10 were given as arguments to the {@link\n     * #toString(int, int)} method.\n     *\n     * @param   i   an integer to be converted.\n     * @return  a string representation of the argument in base\u0026nbsp;10.\n     */\n    @IntrinsicCandidate\n    public static String toString(int i) {\n        int size \u003d stringSize(i);\n        if (COMPACT_STRINGS) {\n            byte[] buf \u003d new byte[size];\n            getChars(i, size, buf);\n            return new String(buf, LATIN1);\n        } else {\n            byte[] buf \u003d new byte[size * 2];\n            StringUTF16.getChars(i, size, buf);\n            return new String(buf, UTF16);\n        }\n    }\n\n    /**\n     * Returns a string representation of the argument as an unsigned\n     * decimal value.\n     *\n     * The argument is converted to unsigned decimal representation\n     * and returned as a string exactly as if the argument and radix\n     * 10 were given as arguments to the {@link #toUnsignedString(int,\n     * int)} method.\n     *\n     * @param   i  an integer to be converted to an unsigned string.\n     * @return  an unsigned string representation of the argument.\n     * @see     #toUnsignedString(int, int)\n     * @since 1.8\n     */\n    public static String toUnsignedString(int i) {\n        return Long.toString(toUnsignedLong(i));\n    }\n\n    /**\n     * Places characters representing the integer i into the\n     * character array buf. The characters are placed into\n     * the buffer backwards starting with the least significant\n     * digit at the specified index (exclusive), and working\n     * backwards from there.\n     *\n     * @implNote This method converts positive inputs into negative\n     * values, to cover the Integer.MIN_VALUE case. Converting otherwise\n     * (negative to positive) will expose -Integer.MIN_VALUE that overflows\n     * integer.\n     *\n     * @param i     value to convert\n     * @param index next index, after the least significant digit\n     * @param buf   target buffer, Latin1-encoded\n     * @return index of the most significant digit or minus sign, if present\n     */\n    static int getChars(int i, int index, byte[] buf) {\n        int q, r;\n        int charPos \u003d index;\n\n        boolean negative \u003d i \u003c 0;\n        if (!negative) {\n            i \u003d -i;\n        }\n\n        // Generate two digits per iteration\n        while (i \u003c\u003d -100) {\n            q \u003d i / 100;\n            r \u003d (q * 100) - i;\n            i \u003d q;\n            buf[--charPos] \u003d DigitOnes[r];\n            buf[--charPos] \u003d DigitTens[r];\n        }\n\n        // We know there are at most two digits left at this point.\n        q \u003d i / 10;\n        r \u003d (q * 10) - i;\n        buf[--charPos] \u003d (byte)(\u00270\u0027 + r);\n\n        // Whatever left is the remaining digit.\n        if (q \u003c 0) {\n            buf[--charPos] \u003d (byte)(\u00270\u0027 - q);\n        }\n\n        if (negative) {\n            buf[--charPos] \u003d (byte)\u0027-\u0027;\n        }\n        return charPos;\n    }\n\n    // Left here for compatibility reasons, see JDK-8143900.\n    static final int [] sizeTable \u003d { 9, 99, 999, 9999, 99999, 999999, 9999999,\n                                      99999999, 999999999, Integer.MAX_VALUE };\n\n    /**\n     * Returns the string representation size for a given int value.\n     *\n     * @param x int value\n     * @return string size\n     *\n     * @implNote There are other ways to compute this: e.g. binary search,\n     * but values are biased heavily towards zero, and therefore linear search\n     * wins. The iteration results are also routinely inlined in the generated\n     * code after loop unrolling.\n     */\n    static int stringSize(int x) {\n        int d \u003d 1;\n        if (x \u003e\u003d 0) {\n            d \u003d 0;\n            x \u003d -x;\n        }\n        int p \u003d -10;\n        for (int i \u003d 1; i \u003c 10; i++) {\n            if (x \u003e p)\n                return i + d;\n            p \u003d 10 * p;\n        }\n        return 10 + d;\n    }\n\n    /**\n     * Parses the string argument as a signed integer in the radix\n     * specified by the second argument. The characters in the string\n     * must all be digits of the specified radix (as determined by\n     * whether {@link java.lang.Character#digit(char, int)} returns a\n     * nonnegative value), except that the first character may be an\n     * ASCII minus sign {@code \u0027-\u0027} ({@code \u0027\\u005Cu002D\u0027}) to\n     * indicate a negative value or an ASCII plus sign {@code \u0027+\u0027}\n     * ({@code \u0027\\u005Cu002B\u0027}) to indicate a positive value. The\n     * resulting integer value is returned.\n     *\n     * \u003cp\u003eAn exception of type {@code NumberFormatException} is\n     * thrown if any of the following situations occurs:\n     * \u003cul\u003e\n     * \u003cli\u003eThe first argument is {@code null} or is a string of\n     * length zero.\n     *\n     * \u003cli\u003eThe radix is either smaller than\n     * {@link java.lang.Character#MIN_RADIX} or\n     * larger than {@link java.lang.Character#MAX_RADIX}.\n     *\n     * \u003cli\u003eAny character of the string is not a digit of the specified\n     * radix, except that the first character may be a minus sign\n     * {@code \u0027-\u0027} ({@code \u0027\\u005Cu002D\u0027}) or plus sign\n     * {@code \u0027+\u0027} ({@code \u0027\\u005Cu002B\u0027}) provided that the\n     * string is longer than length 1.\n     *\n     * \u003cli\u003eThe value represented by the string is not a value of type\n     * {@code int}.\n     * \u003c/ul\u003e\n     *\n     * \u003cp\u003eExamples:\n     * \u003cblockquote\u003e\u003cpre\u003e\n     * parseInt(\"0\", 10) returns 0\n     * parseInt(\"473\", 10) returns 473\n     * parseInt(\"+42\", 10) returns 42\n     * parseInt(\"-0\", 10) returns 0\n     * parseInt(\"-FF\", 16) returns -255\n     * parseInt(\"1100110\", 2) returns 102\n     * parseInt(\"2147483647\", 10) returns 2147483647\n     * parseInt(\"-2147483648\", 10) returns -2147483648\n     * parseInt(\"2147483648\", 10) throws a NumberFormatException\n     * parseInt(\"99\", 8) throws a NumberFormatException\n     * parseInt(\"Kona\", 10) throws a NumberFormatException\n     * parseInt(\"Kona\", 27) returns 411787\n     * \u003c/pre\u003e\u003c/blockquote\u003e\n     *\n     * @param      s   the {@code String} containing the integer\n     *                  representation to be parsed\n     * @param      radix   the radix to be used while parsing {@code s}.\n     * @return     the integer represented by the string argument in the\n     *             specified radix.\n     * @throws     NumberFormatException if the {@code String}\n     *             does not contain a parsable {@code int}.\n     */\n    public static int parseInt(String s, int radix)\n                throws NumberFormatException\n    {\n        /*\n         * WARNING: This method may be invoked early during VM initialization\n         * before IntegerCache is initialized. Care must be taken to not use\n         * the valueOf method.\n         */\n\n        if (s \u003d\u003d null) {\n            throw new NumberFormatException(\"Cannot parse null string\");\n        }\n\n        if (radix \u003c Character.MIN_RADIX) {\n            throw new NumberFormatException(\"radix \" + radix +\n                                            \" less than Character.MIN_RADIX\");\n        }\n\n        if (radix \u003e Character.MAX_RADIX) {\n            throw new NumberFormatException(\"radix \" + radix +\n                                            \" greater than Character.MAX_RADIX\");\n        }\n\n        boolean negative \u003d false;\n        int i \u003d 0, len \u003d s.length();\n        int limit \u003d -Integer.MAX_VALUE;\n\n        if (len \u003e 0) {\n            char firstChar \u003d s.charAt(0);\n            if (firstChar \u003c \u00270\u0027) { // Possible leading \"+\" or \"-\"\n                if (firstChar \u003d\u003d \u0027-\u0027) {\n                    negative \u003d true;\n                    limit \u003d Integer.MIN_VALUE;\n                } else if (firstChar !\u003d \u0027+\u0027) {\n                    throw NumberFormatException.forInputString(s, radix);\n                }\n\n                if (len \u003d\u003d 1) { // Cannot have lone \"+\" or \"-\"\n                    throw NumberFormatException.forInputString(s, radix);\n                }\n                i++;\n            }\n            int multmin \u003d limit / radix;\n            int result \u003d 0;\n            while (i \u003c len) {\n                // Accumulating negatively avoids surprises near MAX_VALUE\n                int digit \u003d Character.digit(s.charAt(i++), radix);\n                if (digit \u003c 0 || result \u003c multmin) {\n                    throw NumberFormatException.forInputString(s, radix);\n                }\n                result *\u003d radix;\n                if (result \u003c limit + digit) {\n                    throw NumberFormatException.forInputString(s, radix);\n                }\n                result -\u003d digit;\n            }\n            return negative ? result : -result;\n        } else {\n            throw NumberFormatException.forInputString(s, radix);\n        }\n    }\n\n    /**\n     * Parses the {@link CharSequence} argument as a signed {@code int} in the\n     * specified {@code radix}, beginning at the specified {@code beginIndex}\n     * and extending to {@code endIndex - 1}.\n     *\n     * \u003cp\u003eThe method does not take steps to guard against the\n     * {@code CharSequence} being mutated while parsing.\n     *\n     * @param      s   the {@code CharSequence} containing the {@code int}\n     *                  representation to be parsed\n     * @param      beginIndex   the beginning index, inclusive.\n     * @param      endIndex     the ending index, exclusive.\n     * @param      radix   the radix to be used while parsing {@code s}.\n     * @return     the signed {@code int} represented by the subsequence in\n     *             the specified radix.\n     * @throws     NullPointerException  if {@code s} is null.\n     * @throws     IndexOutOfBoundsException  if {@code beginIndex} is\n     *             negative, or if {@code beginIndex} is greater than\n     *             {@code endIndex} or if {@code endIndex} is greater than\n     *             {@code s.length()}.\n     * @throws     NumberFormatException  if the {@code CharSequence} does not\n     *             contain a parsable {@code int} in the specified\n     *             {@code radix}, or if {@code radix} is either smaller than\n     *             {@link java.lang.Character#MIN_RADIX} or larger than\n     *             {@link java.lang.Character#MAX_RADIX}.\n     * @since  9\n     */\n    public static int parseInt(CharSequence s, int beginIndex, int endIndex, int radix)\n                throws NumberFormatException {\n        Objects.requireNonNull(s);\n\n        if (beginIndex \u003c 0 || beginIndex \u003e endIndex || endIndex \u003e s.length()) {\n            throw new IndexOutOfBoundsException();\n        }\n        if (radix \u003c Character.MIN_RADIX) {\n            throw new NumberFormatException(\"radix \" + radix +\n                                            \" less than Character.MIN_RADIX\");\n        }\n        if (radix \u003e Character.MAX_RADIX) {\n            throw new NumberFormatException(\"radix \" + radix +\n                                            \" greater than Character.MAX_RADIX\");\n        }\n\n        boolean negative \u003d false;\n        int i \u003d beginIndex;\n        int limit \u003d -Integer.MAX_VALUE;\n\n        if (i \u003c endIndex) {\n            char firstChar \u003d s.charAt(i);\n            if (firstChar \u003c \u00270\u0027) { // Possible leading \"+\" or \"-\"\n                if (firstChar \u003d\u003d \u0027-\u0027) {\n                    negative \u003d true;\n                    limit \u003d Integer.MIN_VALUE;\n                } else if (firstChar !\u003d \u0027+\u0027) {\n                    throw NumberFormatException.forCharSequence(s, beginIndex,\n                            endIndex, i);\n                }\n                i++;\n                if (i \u003d\u003d endIndex) { // Cannot have lone \"+\" or \"-\"\n                    throw NumberFormatException.forCharSequence(s, beginIndex,\n                            endIndex, i);\n                }\n            }\n            int multmin \u003d limit / radix;\n            int result \u003d 0;\n            while (i \u003c endIndex) {\n                // Accumulating negatively avoids surprises near MAX_VALUE\n                int digit \u003d Character.digit(s.charAt(i), radix);\n                if (digit \u003c 0 || result \u003c multmin) {\n                    throw NumberFormatException.forCharSequence(s, beginIndex,\n                            endIndex, i);\n                }\n                result *\u003d radix;\n                if (result \u003c limit + digit) {\n                    throw NumberFormatException.forCharSequence(s, beginIndex,\n                            endIndex, i);\n                }\n                i++;\n                result -\u003d digit;\n            }\n            return negative ? result : -result;\n        } else {\n            throw NumberFormatException.forInputString(\"\", radix);\n        }\n    }\n\n    /**\n     * Parses the string argument as a signed decimal integer. The\n     * characters in the string must all be decimal digits, except\n     * that the first character may be an ASCII minus sign {@code \u0027-\u0027}\n     * ({@code \u0027\\u005Cu002D\u0027}) to indicate a negative value or an\n     * ASCII plus sign {@code \u0027+\u0027} ({@code \u0027\\u005Cu002B\u0027}) to\n     * indicate a positive value. The resulting integer value is\n     * returned, exactly as if the argument and the radix 10 were\n     * given as arguments to the {@link #parseInt(java.lang.String,\n     * int)} method.\n     *\n     * @param s    a {@code String} containing the {@code int}\n     *             representation to be parsed\n     * @return     the integer value represented by the argument in decimal.\n     * @throws     NumberFormatException  if the string does not contain a\n     *               parsable integer.\n     */\n    public static int parseInt(String s) throws NumberFormatException {\n        return parseInt(s,10);\n    }\n\n    /**\n     * Parses the string argument as an unsigned integer in the radix\n     * specified by the second argument.  An unsigned integer maps the\n     * values usually associated with negative numbers to positive\n     * numbers larger than {@code MAX_VALUE}.\n     *\n     * The characters in the string must all be digits of the\n     * specified radix (as determined by whether {@link\n     * java.lang.Character#digit(char, int)} returns a nonnegative\n     * value), except that the first character may be an ASCII plus\n     * sign {@code \u0027+\u0027} ({@code \u0027\\u005Cu002B\u0027}). The resulting\n     * integer value is returned.\n     *\n     * \u003cp\u003eAn exception of type {@code NumberFormatException} is\n     * thrown if any of the following situations occurs:\n     * \u003cul\u003e\n     * \u003cli\u003eThe first argument is {@code null} or is a string of\n     * length zero.\n     *\n     * \u003cli\u003eThe radix is either smaller than\n     * {@link java.lang.Character#MIN_RADIX} or\n     * larger than {@link java.lang.Character#MAX_RADIX}.\n     *\n     * \u003cli\u003eAny character of the string is not a digit of the specified\n     * radix, except that the first character may be a plus sign\n     * {@code \u0027+\u0027} ({@code \u0027\\u005Cu002B\u0027}) provided that the\n     * string is longer than length 1.\n     *\n     * \u003cli\u003eThe value represented by the string is larger than the\n     * largest unsigned {@code int}, 2\u003csup\u003e32\u003c/sup\u003e-1.\n     *\n     * \u003c/ul\u003e\n     *\n     *\n     * @param      s   the {@code String} containing the unsigned integer\n     *                  representation to be parsed\n     * @param      radix   the radix to be used while parsing {@code s}.\n     * @return     the integer represented by the string argument in the\n     *             specified radix.\n     * @throws     NumberFormatException if the {@code String}\n     *             does not contain a parsable {@code int}.\n     * @since 1.8\n     */\n    public static int parseUnsignedInt(String s, int radix)\n                throws NumberFormatException {\n        if (s \u003d\u003d null)  {\n            throw new NumberFormatException(\"Cannot parse null string\");\n        }\n\n        int len \u003d s.length();\n        if (len \u003e 0) {\n            char firstChar \u003d s.charAt(0);\n            if (firstChar \u003d\u003d \u0027-\u0027) {\n                throw new\n                    NumberFormatException(String.format(\"Illegal leading minus sign \" +\n                                                       \"on unsigned string %s.\", s));\n            } else {\n                if (len \u003c\u003d 5 || // Integer.MAX_VALUE in Character.MAX_RADIX is 6 digits\n                    (radix \u003d\u003d 10 \u0026\u0026 len \u003c\u003d 9) ) { // Integer.MAX_VALUE in base 10 is 10 digits\n                    return parseInt(s, radix);\n                } else {\n                    long ell \u003d Long.parseLong(s, radix);\n                    if ((ell \u0026 0xffff_ffff_0000_0000L) \u003d\u003d 0) {\n                        return (int) ell;\n                    } else {\n                        throw new\n                            NumberFormatException(String.format(\"String value %s exceeds \" +\n                                                                \"range of unsigned int.\", s));\n                    }\n                }\n            }\n        } else {\n            throw NumberFormatException.forInputString(s, radix);\n        }\n    }\n\n    /**\n     * Parses the {@link CharSequence} argument as an unsigned {@code int} in\n     * the specified {@code radix}, beginning at the specified\n     * {@code beginIndex} and extending to {@code endIndex - 1}.\n     *\n     * \u003cp\u003eThe method does not take steps to guard against the\n     * {@code CharSequence} being mutated while parsing.\n     *\n     * @param      s   the {@code CharSequence} containing the unsigned\n     *                 {@code int} representation to be parsed\n     * @param      beginIndex   the beginning index, inclusive.\n     * @param      endIndex     the ending index, exclusive.\n     * @param      radix   the radix to be used while parsing {@code s}.\n     * @return     the unsigned {@code int} represented by the subsequence in\n     *             the specified radix.\n     * @throws     NullPointerException  if {@code s} is null.\n     * @throws     IndexOutOfBoundsException  if {@code beginIndex} is\n     *             negative, or if {@code beginIndex} is greater than\n     *             {@code endIndex} or if {@code endIndex} is greater than\n     *             {@code s.length()}.\n     * @throws     NumberFormatException  if the {@code CharSequence} does not\n     *             contain a parsable unsigned {@code int} in the specified\n     *             {@code radix}, or if {@code radix} is either smaller than\n     *             {@link java.lang.Character#MIN_RADIX} or larger than\n     *             {@link java.lang.Character#MAX_RADIX}.\n     * @since  9\n     */\n    public static int parseUnsignedInt(CharSequence s, int beginIndex, int endIndex, int radix)\n                throws NumberFormatException {\n        Objects.requireNonNull(s);\n\n        if (beginIndex \u003c 0 || beginIndex \u003e endIndex || endIndex \u003e s.length()) {\n            throw new IndexOutOfBoundsException();\n        }\n        int start \u003d beginIndex, len \u003d endIndex - beginIndex;\n\n        if (len \u003e 0) {\n            char firstChar \u003d s.charAt(start);\n            if (firstChar \u003d\u003d \u0027-\u0027) {\n                throw new\n                    NumberFormatException(String.format(\"Illegal leading minus sign \" +\n                                                       \"on unsigned string %s.\", s));\n            } else {\n                if (len \u003c\u003d 5 || // Integer.MAX_VALUE in Character.MAX_RADIX is 6 digits\n                        (radix \u003d\u003d 10 \u0026\u0026 len \u003c\u003d 9)) { // Integer.MAX_VALUE in base 10 is 10 digits\n                    return parseInt(s, start, start + len, radix);\n                } else {\n                    long ell \u003d Long.parseLong(s, start, start + len, radix);\n                    if ((ell \u0026 0xffff_ffff_0000_0000L) \u003d\u003d 0) {\n                        return (int) ell;\n                    } else {\n                        throw new\n                            NumberFormatException(String.format(\"String value %s exceeds \" +\n                                                                \"range of unsigned int.\", s));\n                    }\n                }\n            }\n        } else {\n            throw new NumberFormatException(\"\");\n        }\n    }\n\n    /**\n     * Parses the string argument as an unsigned decimal integer. The\n     * characters in the string must all be decimal digits, except\n     * that the first character may be an ASCII plus sign {@code\n     * \u0027+\u0027} ({@code \u0027\\u005Cu002B\u0027}). The resulting integer value\n     * is returned, exactly as if the argument and the radix 10 were\n     * given as arguments to the {@link\n     * #parseUnsignedInt(java.lang.String, int)} method.\n     *\n     * @param s   a {@code String} containing the unsigned {@code int}\n     *            representation to be parsed\n     * @return    the unsigned integer value represented by the argument in decimal.\n     * @throws    NumberFormatException  if the string does not contain a\n     *            parsable unsigned integer.\n     * @since 1.8\n     */\n    public static int parseUnsignedInt(String s) throws NumberFormatException {\n        return parseUnsignedInt(s, 10);\n    }\n\n    /**\n     * Returns an {@code Integer} object holding the value\n     * extracted from the specified {@code String} when parsed\n     * with the radix given by the second argument. The first argument\n     * is interpreted as representing a signed integer in the radix\n     * specified by the second argument, exactly as if the arguments\n     * were given to the {@link #parseInt(java.lang.String, int)}\n     * method. The result is an {@code Integer} object that\n     * represents the integer value specified by the string.\n     *\n     * \u003cp\u003eIn other words, this method returns an {@code Integer}\n     * object equal to the value of:\n     *\n     * \u003cblockquote\u003e\n     *  {@code new Integer(Integer.parseInt(s, radix))}\n     * \u003c/blockquote\u003e\n     *\n     * @param      s   the string to be parsed.\n     * @param      radix the radix to be used in interpreting {@code s}\n     * @return     an {@code Integer} object holding the value\n     *             represented by the string argument in the specified\n     *             radix.\n     * @throws    NumberFormatException if the {@code String}\n     *            does not contain a parsable {@code int}.\n     */\n    public static Integer valueOf(String s, int radix) throws NumberFormatException {\n        return Integer.valueOf(parseInt(s,radix));\n    }\n\n    /**\n     * Returns an {@code Integer} object holding the\n     * value of the specified {@code String}. The argument is\n     * interpreted as representing a signed decimal integer, exactly\n     * as if the argument were given to the {@link\n     * #parseInt(java.lang.String)} method. The result is an\n     * {@code Integer} object that represents the integer value\n     * specified by the string.\n     *\n     * \u003cp\u003eIn other words, this method returns an {@code Integer}\n     * object equal to the value of:\n     *\n     * \u003cblockquote\u003e\n     *  {@code new Integer(Integer.parseInt(s))}\n     * \u003c/blockquote\u003e\n     *\n     * @param      s   the string to be parsed.\n     * @return     an {@code Integer} object holding the value\n     *             represented by the string argument.\n     * @throws     NumberFormatException  if the string cannot be parsed\n     *             as an integer.\n     */\n    public static Integer valueOf(String s) throws NumberFormatException {\n        return Integer.valueOf(parseInt(s, 10));\n    }\n\n    /**\n     * Cache to support the object identity semantics of autoboxing for values between\n     * -128 and 127 (inclusive) as required by JLS.\n     *\n     * The cache is initialized on first usage.  The size of the cache\n     * may be controlled by the {@code -XX:AutoBoxCacheMax\u003d\u003csize\u003e} option.\n     * During VM initialization, java.lang.Integer.IntegerCache.high property\n     * may be set and saved in the private system properties in the\n     * jdk.internal.misc.VM class.\n     *\n     * WARNING: The cache is archived with CDS and reloaded from the shared\n     * archive at runtime. The archived cache (Integer[]) and Integer objects\n     * reside in the closed archive heap regions. Care should be taken when\n     * changing the implementation and the cache array should not be assigned\n     * with new Integer object(s) after initialization.\n     */\n\n    private static class IntegerCache {\n        static final int low \u003d -128;\n        static final int high;\n        static final Integer[] cache;\n        static Integer[] archivedCache;\n\n        static {\n            // high value may be configured by property\n            int h \u003d 127;\n            String integerCacheHighPropValue \u003d\n                VM.getSavedProperty(\"java.lang.Integer.IntegerCache.high\");\n            if (integerCacheHighPropValue !\u003d null) {\n                try {\n                    h \u003d Math.max(parseInt(integerCacheHighPropValue), 127);\n                    // Maximum array size is Integer.MAX_VALUE\n                    h \u003d Math.min(h, Integer.MAX_VALUE - (-low) -1);\n                } catch( NumberFormatException nfe) {\n                    // If the property cannot be parsed into an int, ignore it.\n                }\n            }\n            high \u003d h;\n\n            // Load IntegerCache.archivedCache from archive, if possible\n            CDS.initializeFromArchive(IntegerCache.class);\n            int size \u003d (high - low) + 1;\n\n            // Use the archived cache if it exists and is large enough\n            if (archivedCache \u003d\u003d null || size \u003e archivedCache.length) {\n                Integer[] c \u003d new Integer[size];\n                int j \u003d low;\n                for(int i \u003d 0; i \u003c c.length; i++) {\n                    c[i] \u003d new Integer(j++);\n                }\n                archivedCache \u003d c;\n            }\n            cache \u003d archivedCache;\n            // range [-128, 127] must be interned (JLS7 5.1.7)\n            assert IntegerCache.high \u003e\u003d 127;\n        }\n\n        private IntegerCache() {}\n    }\n\n    /**\n     * Returns an {@code Integer} instance representing the specified\n     * {@code int} value.  If a new {@code Integer} instance is not\n     * required, this method should generally be used in preference to\n     * the constructor {@link #Integer(int)}, as this method is likely\n     * to yield significantly better space and time performance by\n     * caching frequently requested values.\n     *\n     * This method will always cache values in the range -128 to 127,\n     * inclusive, and may cache other values outside of this range.\n     *\n     * @param  i an {@code int} value.\n     * @return an {@code Integer} instance representing {@code i}.\n     * @since  1.5\n     */\n    @IntrinsicCandidate\n    public static Integer valueOf(int i) {\n        if (i \u003e\u003d IntegerCache.low \u0026\u0026 i \u003c\u003d IntegerCache.high)\n            return IntegerCache.cache[i + (-IntegerCache.low)];\n        return new Integer(i);\n    }\n\n    /**\n     * The value of the {@code Integer}.\n     *\n     * @serial\n     */\n    private final int value;\n\n    /**\n     * Constructs a newly allocated {@code Integer} object that\n     * represents the specified {@code int} value.\n     *\n     * @param   value   the value to be represented by the\n     *                  {@code Integer} object.\n     *\n     * @deprecated\n     * It is rarely appropriate to use this constructor. The static factory\n     * {@link #valueOf(int)} is generally a better choice, as it is\n     * likely to yield significantly better space and time performance.\n     */\n    @Deprecated(since\u003d\"9\", forRemoval \u003d true)\n    public Integer(int value) {\n        this.value \u003d value;\n    }\n\n    /**\n     * Constructs a newly allocated {@code Integer} object that\n     * represents the {@code int} value indicated by the\n     * {@code String} parameter. The string is converted to an\n     * {@code int} value in exactly the manner used by the\n     * {@code parseInt} method for radix 10.\n     *\n     * @param   s   the {@code String} to be converted to an {@code Integer}.\n     * @throws      NumberFormatException if the {@code String} does not\n     *              contain a parsable integer.\n     *\n     * @deprecated\n     * It is rarely appropriate to use this constructor.\n     * Use {@link #parseInt(String)} to convert a string to a\n     * {@code int} primitive, or use {@link #valueOf(String)}\n     * to convert a string to an {@code Integer} object.\n     */\n    @Deprecated(since\u003d\"9\", forRemoval \u003d true)\n    public Integer(String s) throws NumberFormatException {\n        this.value \u003d parseInt(s, 10);\n    }\n\n    /**\n     * Returns the value of this {@code Integer} as a {@code byte}\n     * after a narrowing primitive conversion.\n     * @jls 5.1.3 Narrowing Primitive Conversion\n     */\n    public byte byteValue() {\n        return (byte)value;\n    }\n\n    /**\n     * Returns the value of this {@code Integer} as a {@code short}\n     * after a narrowing primitive conversion.\n     * @jls 5.1.3 Narrowing Primitive Conversion\n     */\n    public short shortValue() {\n        return (short)value;\n    }\n\n    /**\n     * Returns the value of this {@code Integer} as an\n     * {@code int}.\n     */\n    @IntrinsicCandidate\n    public int intValue() {\n        return value;\n    }\n\n    /**\n     * Returns the value of this {@code Integer} as a {@code long}\n     * after a widening primitive conversion.\n     * @jls 5.1.2 Widening Primitive Conversion\n     * @see Integer#toUnsignedLong(int)\n     */\n    public long longValue() {\n        return (long)value;\n    }\n\n    /**\n     * Returns the value of this {@code Integer} as a {@code float}\n     * after a widening primitive conversion.\n     * @jls 5.1.2 Widening Primitive Conversion\n     */\n    public float floatValue() {\n        return (float)value;\n    }\n\n    /**\n     * Returns the value of this {@code Integer} as a {@code double}\n     * after a widening primitive conversion.\n     * @jls 5.1.2 Widening Primitive Conversion\n     */\n    public double doubleValue() {\n        return (double)value;\n    }\n\n    /**\n     * Returns a {@code String} object representing this\n     * {@code Integer}\u0027s value. The value is converted to signed\n     * decimal representation and returned as a string, exactly as if\n     * the integer value were given as an argument to the {@link\n     * java.lang.Integer#toString(int)} method.\n     *\n     * @return  a string representation of the value of this object in\n     *          base\u0026nbsp;10.\n     */\n    public String toString() {\n        return toString(value);\n    }\n\n    /**\n     * Returns a hash code for this {@code Integer}.\n     *\n     * @return  a hash code value for this object, equal to the\n     *          primitive {@code int} value represented by this\n     *          {@code Integer} object.\n     */\n    @Override\n    public int hashCode() {\n        return Integer.hashCode(value);\n    }\n\n    /**\n     * Returns a hash code for an {@code int} value; compatible with\n     * {@code Integer.hashCode()}.\n     *\n     * @param value the value to hash\n     * @since 1.8\n     *\n     * @return a hash code value for an {@code int} value.\n     */\n    public static int hashCode(int value) {\n        return value;\n    }\n\n    /**\n     * Compares this object to the specified object.  The result is\n     * {@code true} if and only if the argument is not\n     * {@code null} and is an {@code Integer} object that\n     * contains the same {@code int} value as this object.\n     *\n     * @param   obj   the object to compare with.\n     * @return  {@code true} if the objects are the same;\n     *          {@code false} otherwise.\n     */\n    public boolean equals(Object obj) {\n        if (obj instanceof Integer) {\n            return value \u003d\u003d ((Integer)obj).intValue();\n        }\n        return false;\n    }\n\n    /**\n     * Determines the integer value of the system property with the\n     * specified name.\n     *\n     * \u003cp\u003eThe first argument is treated as the name of a system\n     * property.  System properties are accessible through the {@link\n     * java.lang.System#getProperty(java.lang.String)} method. The\n     * string value of this property is then interpreted as an integer\n     * value using the grammar supported by {@link Integer#decode decode} and\n     * an {@code Integer} object representing this value is returned.\n     *\n     * \u003cp\u003eIf there is no property with the specified name, if the\n     * specified name is empty or {@code null}, or if the property\n     * does not have the correct numeric format, then {@code null} is\n     * returned.\n     *\n     * \u003cp\u003eIn other words, this method returns an {@code Integer}\n     * object equal to the value of:\n     *\n     * \u003cblockquote\u003e\n     *  {@code getInteger(nm, null)}\n     * \u003c/blockquote\u003e\n     *\n     * @param   nm   property name.\n     * @return  the {@code Integer} value of the property.\n     * @throws  SecurityException for the same reasons as\n     *          {@link System#getProperty(String) System.getProperty}\n     * @see     java.lang.System#getProperty(java.lang.String)\n     * @see     java.lang.System#getProperty(java.lang.String, java.lang.String)\n     */\n    public static Integer getInteger(String nm) {\n        return getInteger(nm, null);\n    }\n\n    /**\n     * Determines the integer value of the system property with the\n     * specified name.\n     *\n     * \u003cp\u003eThe first argument is treated as the name of a system\n     * property.  System properties are accessible through the {@link\n     * java.lang.System#getProperty(java.lang.String)} method. The\n     * string value of this property is then interpreted as an integer\n     * value using the grammar supported by {@link Integer#decode decode} and\n     * an {@code Integer} object representing this value is returned.\n     *\n     * \u003cp\u003eThe second argument is the default value. An {@code Integer} object\n     * that represents the value of the second argument is returned if there\n     * is no property of the specified name, if the property does not have\n     * the correct numeric format, or if the specified name is empty or\n     * {@code null}.\n     *\n     * \u003cp\u003eIn other words, this method returns an {@code Integer} object\n     * equal to the value of:\n     *\n     * \u003cblockquote\u003e\n     *  {@code getInteger(nm, new Integer(val))}\n     * \u003c/blockquote\u003e\n     *\n     * but in practice it may be implemented in a manner such as:\n     *\n     * \u003cblockquote\u003e\u003cpre\u003e\n     * Integer result \u003d getInteger(nm, null);\n     * return (result \u003d\u003d null) ? new Integer(val) : result;\n     * \u003c/pre\u003e\u003c/blockquote\u003e\n     *\n     * to avoid the unnecessary allocation of an {@code Integer}\n     * object when the default value is not needed.\n     *\n     * @param   nm   property name.\n     * @param   val   default value.\n     * @return  the {@code Integer} value of the property.\n     * @throws  SecurityException for the same reasons as\n     *          {@link System#getProperty(String) System.getProperty}\n     * @see     java.lang.System#getProperty(java.lang.String)\n     * @see     java.lang.System#getProperty(java.lang.String, java.lang.String)\n     */\n    public static Integer getInteger(String nm, int val) {\n        Integer result \u003d getInteger(nm, null);\n        return (result \u003d\u003d null) ? Integer.valueOf(val) : result;\n    }\n\n    /**\n     * Returns the integer value of the system property with the\n     * specified name.  The first argument is treated as the name of a\n     * system property.  System properties are accessible through the\n     * {@link java.lang.System#getProperty(java.lang.String)} method.\n     * The string value of this property is then interpreted as an\n     * integer value, as per the {@link Integer#decode decode} method,\n     * and an {@code Integer} object representing this value is\n     * returned; in summary:\n     *\n     * \u003cul\u003e\u003cli\u003eIf the property value begins with the two ASCII characters\n     *         {@code 0x} or the ASCII character {@code #}, not\n     *      followed by a minus sign, then the rest of it is parsed as a\n     *      hexadecimal integer exactly as by the method\n     *      {@link #valueOf(java.lang.String, int)} with radix 16.\n     * \u003cli\u003eIf the property value begins with the ASCII character\n     *     {@code 0} followed by another character, it is parsed as an\n     *     octal integer exactly as by the method\n     *     {@link #valueOf(java.lang.String, int)} with radix 8.\n     * \u003cli\u003eOtherwise, the property value is parsed as a decimal integer\n     * exactly as by the method {@link #valueOf(java.lang.String, int)}\n     * with radix 10.\n     * \u003c/ul\u003e\n     *\n     * \u003cp\u003eThe second argument is the default value. The default value is\n     * returned if there is no property of the specified name, if the\n     * property does not have the correct numeric format, or if the\n     * specified name is empty or {@code null}.\n     *\n     * @param   nm   property name.\n     * @param   val   default value.\n     * @return  the {@code Integer} value of the property.\n     * @throws  SecurityException for the same reasons as\n     *          {@link System#getProperty(String) System.getProperty}\n     * @see     System#getProperty(java.lang.String)\n     * @see     System#getProperty(java.lang.String, java.lang.String)\n     */\n    public static Integer getInteger(String nm, Integer val) {\n        String v \u003d null;\n        try {\n            v \u003d System.getProperty(nm);\n        } catch (IllegalArgumentException | NullPointerException e) {\n        }\n        if (v !\u003d null) {\n            try {\n                return Integer.decode(v);\n            } catch (NumberFormatException e) {\n            }\n        }\n        return val;\n    }\n\n    /**\n     * Decodes a {@code String} into an {@code Integer}.\n     * Accepts decimal, hexadecimal, and octal numbers given\n     * by the following grammar:\n     *\n     * \u003cblockquote\u003e\n     * \u003cdl\u003e\n     * \u003cdt\u003e\u003ci\u003eDecodableString:\u003c/i\u003e\n     * \u003cdd\u003e\u003ci\u003eSign\u003csub\u003eopt\u003c/sub\u003e DecimalNumeral\u003c/i\u003e\n     * \u003cdd\u003e\u003ci\u003eSign\u003csub\u003eopt\u003c/sub\u003e\u003c/i\u003e {@code 0x} \u003ci\u003eHexDigits\u003c/i\u003e\n     * \u003cdd\u003e\u003ci\u003eSign\u003csub\u003eopt\u003c/sub\u003e\u003c/i\u003e {@code 0X} \u003ci\u003eHexDigits\u003c/i\u003e\n     * \u003cdd\u003e\u003ci\u003eSign\u003csub\u003eopt\u003c/sub\u003e\u003c/i\u003e {@code #} \u003ci\u003eHexDigits\u003c/i\u003e\n     * \u003cdd\u003e\u003ci\u003eSign\u003csub\u003eopt\u003c/sub\u003e\u003c/i\u003e {@code 0} \u003ci\u003eOctalDigits\u003c/i\u003e\n     *\n     * \u003cdt\u003e\u003ci\u003eSign:\u003c/i\u003e\n     * \u003cdd\u003e{@code -}\n     * \u003cdd\u003e{@code +}\n     * \u003c/dl\u003e\n     * \u003c/blockquote\u003e\n     *\n     * \u003ci\u003eDecimalNumeral\u003c/i\u003e, \u003ci\u003eHexDigits\u003c/i\u003e, and \u003ci\u003eOctalDigits\u003c/i\u003e\n     * are as defined in section {@jls 3.10.1} of\n     * \u003ccite\u003eThe Java Language Specification\u003c/cite\u003e,\n     * except that underscores are not accepted between digits.\n     *\n     * \u003cp\u003eThe sequence of characters following an optional\n     * sign and/or radix specifier (\"{@code 0x}\", \"{@code 0X}\",\n     * \"{@code #}\", or leading zero) is parsed as by the {@code\n     * Integer.parseInt} method with the indicated radix (10, 16, or\n     * 8).  This sequence of characters must represent a positive\n     * value or a {@link NumberFormatException} will be thrown.  The\n     * result is negated if first character of the specified {@code\n     * String} is the minus sign.  No whitespace characters are\n     * permitted in the {@code String}.\n     *\n     * @param     nm the {@code String} to decode.\n     * @return    an {@code Integer} object holding the {@code int}\n     *             value represented by {@code nm}\n     * @throws    NumberFormatException  if the {@code String} does not\n     *            contain a parsable integer.\n     * @see java.lang.Integer#parseInt(java.lang.String, int)\n     */\n    public static Integer decode(String nm) throws NumberFormatException {\n        int radix \u003d 10;\n        int index \u003d 0;\n        boolean negative \u003d false;\n        Integer result;\n\n        if (nm.isEmpty())\n            throw new NumberFormatException(\"Zero length string\");\n        char firstChar \u003d nm.charAt(0);\n        // Handle sign, if present\n        if (firstChar \u003d\u003d \u0027-\u0027) {\n            negative \u003d true;\n            index++;\n        } else if (firstChar \u003d\u003d \u0027+\u0027)\n            index++;\n\n        // Handle radix specifier, if present\n        if (nm.startsWith(\"0x\", index) || nm.startsWith(\"0X\", index)) {\n            index +\u003d 2;\n            radix \u003d 16;\n        }\n        else if (nm.startsWith(\"#\", index)) {\n            index ++;\n            radix \u003d 16;\n        }\n        else if (nm.startsWith(\"0\", index) \u0026\u0026 nm.length() \u003e 1 + index) {\n            index ++;\n            radix \u003d 8;\n        }\n\n        if (nm.startsWith(\"-\", index) || nm.startsWith(\"+\", index))\n            throw new NumberFormatException(\"Sign character in wrong position\");\n\n        try {\n            result \u003d Integer.valueOf(nm.substring(index), radix);\n            result \u003d negative ? Integer.valueOf(-result.intValue()) : result;\n        } catch (NumberFormatException e) {\n            // If number is Integer.MIN_VALUE, we\u0027ll end up here. The next line\n            // handles this case, and causes any genuine format error to be\n            // rethrown.\n            String constant \u003d negative ? (\"-\" + nm.substring(index))\n                                       : nm.substring(index);\n            result \u003d Integer.valueOf(constant, radix);\n        }\n        return result;\n    }\n\n    /**\n     * Compares two {@code Integer} objects numerically.\n     *\n     * @param   anotherInteger   the {@code Integer} to be compared.\n     * @return  the value {@code 0} if this {@code Integer} is\n     *          equal to the argument {@code Integer}; a value less than\n     *          {@code 0} if this {@code Integer} is numerically less\n     *          than the argument {@code Integer}; and a value greater\n     *          than {@code 0} if this {@code Integer} is numerically\n     *           greater than the argument {@code Integer} (signed\n     *           comparison).\n     * @since   1.2\n     */\n    public int compareTo(Integer anotherInteger) {\n        return compare(this.value, anotherInteger.value);\n    }\n\n    /**\n     * Compares two {@code int} values numerically.\n     * The value returned is identical to what would be returned by:\n     * \u003cpre\u003e\n     *    Integer.valueOf(x).compareTo(Integer.valueOf(y))\n     * \u003c/pre\u003e\n     *\n     * @param  x the first {@code int} to compare\n     * @param  y the second {@code int} to compare\n     * @return the value {@code 0} if {@code x \u003d\u003d y};\n     *         a value less than {@code 0} if {@code x \u003c y}; and\n     *         a value greater than {@code 0} if {@code x \u003e y}\n     * @since 1.7\n     */\n    public static int compare(int x, int y) {\n        return (x \u003c y) ? -1 : ((x \u003d\u003d y) ? 0 : 1);\n    }\n\n    /**\n     * Compares two {@code int} values numerically treating the values\n     * as unsigned.\n     *\n     * @param  x the first {@code int} to compare\n     * @param  y the second {@code int} to compare\n     * @return the value {@code 0} if {@code x \u003d\u003d y}; a value less\n     *         than {@code 0} if {@code x \u003c y} as unsigned values; and\n     *         a value greater than {@code 0} if {@code x \u003e y} as\n     *         unsigned values\n     * @since 1.8\n     */\n    public static int compareUnsigned(int x, int y) {\n        return compare(x + MIN_VALUE, y + MIN_VALUE);\n    }\n\n    /**\n     * Converts the argument to a {@code long} by an unsigned\n     * conversion.  In an unsigned conversion to a {@code long}, the\n     * high-order 32 bits of the {@code long} are zero and the\n     * low-order 32 bits are equal to the bits of the integer\n     * argument.\n     *\n     * Consequently, zero and positive {@code int} values are mapped\n     * to a numerically equal {@code long} value and negative {@code\n     * int} values are mapped to a {@code long} value equal to the\n     * input plus 2\u003csup\u003e32\u003c/sup\u003e.\n     *\n     * @param  x the value to convert to an unsigned {@code long}\n     * @return the argument converted to {@code long} by an unsigned\n     *         conversion\n     * @since 1.8\n     */\n    public static long toUnsignedLong(int x) {\n        return ((long) x) \u0026 0xffffffffL;\n    }\n\n    /**\n     * Returns the unsigned quotient of dividing the first argument by\n     * the second where each argument and the result is interpreted as\n     * an unsigned value.\n     *\n     * \u003cp\u003eNote that in two\u0027s complement arithmetic, the three other\n     * basic arithmetic operations of add, subtract, and multiply are\n     * bit-wise identical if the two operands are regarded as both\n     * being signed or both being unsigned.  Therefore separate {@code\n     * addUnsigned}, etc. methods are not provided.\n     *\n     * @param dividend the value to be divided\n     * @param divisor the value doing the dividing\n     * @return the unsigned quotient of the first argument divided by\n     * the second argument\n     * @see #remainderUnsigned\n     * @since 1.8\n     */\n    public static int divideUnsigned(int dividend, int divisor) {\n        // In lieu of tricky code, for now just use long arithmetic.\n        return (int)(toUnsignedLong(dividend) / toUnsignedLong(divisor));\n    }\n\n    /**\n     * Returns the unsigned remainder from dividing the first argument\n     * by the second where each argument and the result is interpreted\n     * as an unsigned value.\n     *\n     * @param dividend the value to be divided\n     * @param divisor the value doing the dividing\n     * @return the unsigned remainder of the first argument divided by\n     * the second argument\n     * @see #divideUnsigned\n     * @since 1.8\n     */\n    public static int remainderUnsigned(int dividend, int divisor) {\n        // In lieu of tricky code, for now just use long arithmetic.\n        return (int)(toUnsignedLong(dividend) % toUnsignedLong(divisor));\n    }\n\n\n    // Bit twiddling\n\n    /**\n     * The number of bits used to represent an {@code int} value in two\u0027s\n     * complement binary form.\n     *\n     * @since 1.5\n     */\n    @Native public static final int SIZE \u003d 32;\n\n    /**\n     * The number of bytes used to represent an {@code int} value in two\u0027s\n     * complement binary form.\n     *\n     * @since 1.8\n     */\n    public static final int BYTES \u003d SIZE / Byte.SIZE;\n\n    /**\n     * Returns an {@code int} value with at most a single one-bit, in the\n     * position of the highest-order (\"leftmost\") one-bit in the specified\n     * {@code int} value.  Returns zero if the specified value has no\n     * one-bits in its two\u0027s complement binary representation, that is, if it\n     * is equal to zero.\n     *\n     * @param i the value whose highest one bit is to be computed\n     * @return an {@code int} value with a single one-bit, in the position\n     *     of the highest-order one-bit in the specified value, or zero if\n     *     the specified value is itself equal to zero.\n     * @since 1.5\n     */\n    public static int highestOneBit(int i) {\n        return i \u0026 (MIN_VALUE \u003e\u003e\u003e numberOfLeadingZeros(i));\n    }\n\n    /**\n     * Returns an {@code int} value with at most a single one-bit, in the\n     * position of the lowest-order (\"rightmost\") one-bit in the specified\n     * {@code int} value.  Returns zero if the specified value has no\n     * one-bits in its two\u0027s complement binary representation, that is, if it\n     * is equal to zero.\n     *\n     * @param i the value whose lowest one bit is to be computed\n     * @return an {@code int} value with a single one-bit, in the position\n     *     of the lowest-order one-bit in the specified value, or zero if\n     *     the specified value is itself equal to zero.\n     * @since 1.5\n     */\n    public static int lowestOneBit(int i) {\n        // HD, Section 2-1\n        return i \u0026 -i;\n    }\n\n    /**\n     * Returns the number of zero bits preceding the highest-order\n     * (\"leftmost\") one-bit in the two\u0027s complement binary representation\n     * of the specified {@code int} value.  Returns 32 if the\n     * specified value has no one-bits in its two\u0027s complement representation,\n     * in other words if it is equal to zero.\n     *\n     * \u003cp\u003eNote that this method is closely related to the logarithm base 2.\n     * For all positive {@code int} values x:\n     * \u003cul\u003e\n     * \u003cli\u003efloor(log\u003csub\u003e2\u003c/sub\u003e(x)) \u003d {@code 31 - numberOfLeadingZeros(x)}\n     * \u003cli\u003eceil(log\u003csub\u003e2\u003c/sub\u003e(x)) \u003d {@code 32 - numberOfLeadingZeros(x - 1)}\n     * \u003c/ul\u003e\n     *\n     * @param i the value whose number of leading zeros is to be computed\n     * @return the number of zero bits preceding the highest-order\n     *     (\"leftmost\") one-bit in the two\u0027s complement binary representation\n     *     of the specified {@code int} value, or 32 if the value\n     *     is equal to zero.\n     * @since 1.5\n     */\n    @IntrinsicCandidate\n    public static int numberOfLeadingZeros(int i) {\n        // HD, Count leading 0\u0027s\n        if (i \u003c\u003d 0)\n            return i \u003d\u003d 0 ? 32 : 0;\n        int n \u003d 31;\n        if (i \u003e\u003d 1 \u003c\u003c 16) { n -\u003d 16; i \u003e\u003e\u003e\u003d 16; }\n        if (i \u003e\u003d 1 \u003c\u003c  8) { n -\u003d  8; i \u003e\u003e\u003e\u003d  8; }\n        if (i \u003e\u003d 1 \u003c\u003c  4) { n -\u003d  4; i \u003e\u003e\u003e\u003d  4; }\n        if (i \u003e\u003d 1 \u003c\u003c  2) { n -\u003d  2; i \u003e\u003e\u003e\u003d  2; }\n        return n - (i \u003e\u003e\u003e 1);\n    }\n\n    /**\n     * Returns the number of zero bits following the lowest-order (\"rightmost\")\n     * one-bit in the two\u0027s complement binary representation of the specified\n     * {@code int} value.  Returns 32 if the specified value has no\n     * one-bits in its two\u0027s complement representation, in other words if it is\n     * equal to zero.\n     *\n     * @param i the value whose number of trailing zeros is to be computed\n     * @return the number of zero bits following the lowest-order (\"rightmost\")\n     *     one-bit in the two\u0027s complement binary representation of the\n     *     specified {@code int} value, or 32 if the value is equal\n     *     to zero.\n     * @since 1.5\n     */\n    @IntrinsicCandidate\n    public static int numberOfTrailingZeros(int i) {\n        // HD, Count trailing 0\u0027s\n        i \u003d ~i \u0026 (i - 1);\n        if (i \u003c\u003d 0) return i \u0026 32;\n        int n \u003d 1;\n        if (i \u003e 1 \u003c\u003c 16) { n +\u003d 16; i \u003e\u003e\u003e\u003d 16; }\n        if (i \u003e 1 \u003c\u003c  8) { n +\u003d  8; i \u003e\u003e\u003e\u003d  8; }\n        if (i \u003e 1 \u003c\u003c  4) { n +\u003d  4; i \u003e\u003e\u003e\u003d  4; }\n        if (i \u003e 1 \u003c\u003c  2) { n +\u003d  2; i \u003e\u003e\u003e\u003d  2; }\n        return n + (i \u003e\u003e\u003e 1);\n    }\n\n    /**\n     * Returns the number of one-bits in the two\u0027s complement binary\n     * representation of the specified {@code int} value.  This function is\n     * sometimes referred to as the \u003ci\u003epopulation count\u003c/i\u003e.\n     *\n     * @param i the value whose bits are to be counted\n     * @return the number of one-bits in the two\u0027s complement binary\n     *     representation of the specified {@code int} value.\n     * @since 1.5\n     */\n    @IntrinsicCandidate\n    public static int bitCount(int i) {\n        // HD, Figure 5-2\n        i \u003d i - ((i \u003e\u003e\u003e 1) \u0026 0x55555555);\n        i \u003d (i \u0026 0x33333333) + ((i \u003e\u003e\u003e 2) \u0026 0x33333333);\n        i \u003d (i + (i \u003e\u003e\u003e 4)) \u0026 0x0f0f0f0f;\n        i \u003d i + (i \u003e\u003e\u003e 8);\n        i \u003d i + (i \u003e\u003e\u003e 16);\n        return i \u0026 0x3f;\n    }\n\n    /**\n     * Returns the value obtained by rotating the two\u0027s complement binary\n     * representation of the specified {@code int} value left by the\n     * specified number of bits.  (Bits shifted out of the left hand, or\n     * high-order, side reenter on the right, or low-order.)\n     *\n     * \u003cp\u003eNote that left rotation with a negative distance is equivalent to\n     * right rotation: {@code rotateLeft(val, -distance) \u003d\u003d rotateRight(val,\n     * distance)}.  Note also that rotation by any multiple of 32 is a\n     * no-op, so all but the last five bits of the rotation distance can be\n     * ignored, even if the distance is negative: {@code rotateLeft(val,\n     * distance) \u003d\u003d rotateLeft(val, distance \u0026 0x1F)}.\n     *\n     * @param i the value whose bits are to be rotated left\n     * @param distance the number of bit positions to rotate left\n     * @return the value obtained by rotating the two\u0027s complement binary\n     *     representation of the specified {@code int} value left by the\n     *     specified number of bits.\n     * @since 1.5\n     */\n    public static int rotateLeft(int i, int distance) {\n        return (i \u003c\u003c distance) | (i \u003e\u003e\u003e -distance);\n    }\n\n    /**\n     * Returns the value obtained by rotating the two\u0027s complement binary\n     * representation of the specified {@code int} value right by the\n     * specified number of bits.  (Bits shifted out of the right hand, or\n     * low-order, side reenter on the left, or high-order.)\n     *\n     * \u003cp\u003eNote that right rotation with a negative distance is equivalent to\n     * left rotation: {@code rotateRight(val, -distance) \u003d\u003d rotateLeft(val,\n     * distance)}.  Note also that rotation by any multiple of 32 is a\n     * no-op, so all but the last five bits of the rotation distance can be\n     * ignored, even if the distance is negative: {@code rotateRight(val,\n     * distance) \u003d\u003d rotateRight(val, distance \u0026 0x1F)}.\n     *\n     * @param i the value whose bits are to be rotated right\n     * @param distance the number of bit positions to rotate right\n     * @return the value obtained by rotating the two\u0027s complement binary\n     *     representation of the specified {@code int} value right by the\n     *     specified number of bits.\n     * @since 1.5\n     */\n    public static int rotateRight(int i, int distance) {\n        return (i \u003e\u003e\u003e distance) | (i \u003c\u003c -distance);\n    }\n\n    /**\n     * Returns the value obtained by reversing the order of the bits in the\n     * two\u0027s complement binary representation of the specified {@code int}\n     * value.\n     *\n     * @param i the value to be reversed\n     * @return the value obtained by reversing order of the bits in the\n     *     specified {@code int} value.\n     * @since 1.5\n     */\n    public static int reverse(int i) {\n        // HD, Figure 7-1\n        i \u003d (i \u0026 0x55555555) \u003c\u003c 1 | (i \u003e\u003e\u003e 1) \u0026 0x55555555;\n        i \u003d (i \u0026 0x33333333) \u003c\u003c 2 | (i \u003e\u003e\u003e 2) \u0026 0x33333333;\n        i \u003d (i \u0026 0x0f0f0f0f) \u003c\u003c 4 | (i \u003e\u003e\u003e 4) \u0026 0x0f0f0f0f;\n\n        return reverseBytes(i);\n    }\n\n    /**\n     * Returns the signum function of the specified {@code int} value.  (The\n     * return value is -1 if the specified value is negative; 0 if the\n     * specified value is zero; and 1 if the specified value is positive.)\n     *\n     * @param i the value whose signum is to be computed\n     * @return the signum function of the specified {@code int} value.\n     * @since 1.5\n     */\n    public static int signum(int i) {\n        // HD, Section 2-7\n        return (i \u003e\u003e 31) | (-i \u003e\u003e\u003e 31);\n    }\n\n    /**\n     * Returns the value obtained by reversing the order of the bytes in the\n     * two\u0027s complement representation of the specified {@code int} value.\n     *\n     * @param i the value whose bytes are to be reversed\n     * @return the value obtained by reversing the bytes in the specified\n     *     {@code int} value.\n     * @since 1.5\n     */\n    @IntrinsicCandidate\n    public static int reverseBytes(int i) {\n        return (i \u003c\u003c 24)            |\n               ((i \u0026 0xff00) \u003c\u003c 8)  |\n               ((i \u003e\u003e\u003e 8) \u0026 0xff00) |\n               (i \u003e\u003e\u003e 24);\n    }\n\n    /**\n     * Adds two integers together as per the + operator.\n     *\n     * @param a the first operand\n     * @param b the second operand\n     * @return the sum of {@code a} and {@code b}\n     * @see java.util.function.BinaryOperator\n     * @since 1.8\n     */\n    public static int sum(int a, int b) {\n        return a + b;\n    }\n\n    /**\n     * Returns the greater of two {@code int} values\n     * as if by calling {@link Math#max(int, int) Math.max}.\n     *\n     * @param a the first operand\n     * @param b the second operand\n     * @return the greater of {@code a} and {@code b}\n     * @see java.util.function.BinaryOperator\n     * @since 1.8\n     */\n    public static int max(int a, int b) {\n        return Math.max(a, b);\n    }\n\n    /**\n     * Returns the smaller of two {@code int} values\n     * as if by calling {@link Math#min(int, int) Math.min}.\n     *\n     * @param a the first operand\n     * @param b the second operand\n     * @return the smaller of {@code a} and {@code b}\n     * @see java.util.function.BinaryOperator\n     * @since 1.8\n     */\n    public static int min(int a, int b) {\n        return Math.min(a, b);\n    }\n\n    /**\n     * Returns an {@link Optional} containing the nominal descriptor for this\n     * instance, which is the instance itself.\n     *\n     * @return an {@link Optional} describing the {@linkplain Integer} instance\n     * @since 12\n     */\n    @Override\n    public Optional\u003cInteger\u003e describeConstable() {\n        return Optional.of(this);\n    }\n\n    /**\n     * Resolves this instance as a {@link ConstantDesc}, the result of which is\n     * the instance itself.\n     *\n     * @param lookup ignored\n     * @return the {@linkplain Integer} instance\n     * @since 12\n     */\n    @Override\n    public Integer resolveConstantDesc(MethodHandles.Lookup lookup) {\n        return this;\n    }\n\n    /** use serialVersionUID from JDK 1.0.2 for interoperability */\n    @java.io.Serial\n    @Native private static final long serialVersionUID \u003d 1360826667806852920L;\n}\n"
    }
  }
}
java.lang.IllegalArgumentException: Illegal character in opaque part at index 188: jar:file:///C:/Users/Vinicius/AppData/Local/Coursier/cache/arc/https/github.com/adoptium/temurin17-binaries/releases/download/jdk-17%2B35/OpenJDK17-jdk_x64_windows_hotspot_17_35.zip/jdk-17 35/lib/src.zip!/java.base/java/lang/Integer.java
	at java.base/java.net.URI.create(URI.java:906)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:178)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.$anonfun$toAbsolutePath$3(MtagsEnrichments.scala:175)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.withTryDecode$1(MtagsEnrichments.scala:153)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:175)
	at scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:756)
	at scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:753)
	at scala.meta.internal.metals.WorkspaceLspService.didOpen(WorkspaceLspService.scala:388)
	at scala.meta.metals.lsp.DelegatingScalaService.didOpen(DelegatingScalaService.scala:39)
	at jdk.internal.reflect.GeneratedMethodAccessor23.invoke(Unknown Source)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:568)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$recursiveFindRpcMethods$0(GenericEndpoint.java:65)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.notify(GenericEndpoint.java:160)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleNotification(RemoteEndpoint.java:231)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:198)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:185)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:97)
	at org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:114)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:539)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.base/java.lang.Thread.run(Thread.java:833)
Caused by: java.net.URISyntaxException: Illegal character in opaque part at index 188: jar:file:///C:/Users/Vinicius/AppData/Local/Coursier/cache/arc/https/github.com/adoptium/temurin17-binaries/releases/download/jdk-17%2B35/OpenJDK17-jdk_x64_windows_hotspot_17_35.zip/jdk-17 35/lib/src.zip!/java.base/java/lang/Integer.java
	at java.base/java.net.URI$Parser.fail(URI.java:2974)
	at java.base/java.net.URI$Parser.checkChars(URI.java:3145)
	at java.base/java.net.URI$Parser.parse(URI.java:3181)
	at java.base/java.net.URI.<init>(URI.java:623)
	at java.base/java.net.URI.create(URI.java:904)
	... 23 more

jul. 19, 2024 1:42:12 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleNotification
ADVERTÊNCIA: Notification threw an exception: {
  "jsonrpc": "2.0",
  "method": "textDocument/didClose",
  "params": {
    "textDocument": {
      "uri": "jar:file%3A///C%3A/Users/Vinicius/AppData/Local/Coursier/cache/arc/https/github.com/adoptium/temurin17-binaries/releases/download/jdk-17%25252B35/OpenJDK17-jdk_x64_windows_hotspot_17_35.zip/jdk-17%2B35/lib/src.zip%21/java.base/java/lang/Integer.java"
    }
  }
}
java.lang.IllegalArgumentException: Illegal character in opaque part at index 188: jar:file:///C:/Users/Vinicius/AppData/Local/Coursier/cache/arc/https/github.com/adoptium/temurin17-binaries/releases/download/jdk-17%2B35/OpenJDK17-jdk_x64_windows_hotspot_17_35.zip/jdk-17 35/lib/src.zip!/java.base/java/lang/Integer.java
	at java.base/java.net.URI.create(URI.java:906)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:178)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.$anonfun$toAbsolutePath$3(MtagsEnrichments.scala:175)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.withTryDecode$1(MtagsEnrichments.scala:153)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:175)
	at scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:756)
	at scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:753)
	at scala.meta.internal.metals.WorkspaceLspService.didClose(WorkspaceLspService.scala:407)
	at scala.meta.metals.lsp.DelegatingScalaService.didClose(DelegatingScalaService.scala:53)
	at jdk.internal.reflect.GeneratedMethodAccessor26.invoke(Unknown Source)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:568)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$recursiveFindRpcMethods$0(GenericEndpoint.java:65)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.notify(GenericEndpoint.java:160)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleNotification(RemoteEndpoint.java:231)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:198)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:185)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:97)
	at org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:114)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:539)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.base/java.lang.Thread.run(Thread.java:833)
Caused by: java.net.URISyntaxException: Illegal character in opaque part at index 188: jar:file:///C:/Users/Vinicius/AppData/Local/Coursier/cache/arc/https/github.com/adoptium/temurin17-binaries/releases/download/jdk-17%2B35/OpenJDK17-jdk_x64_windows_hotspot_17_35.zip/jdk-17 35/lib/src.zip!/java.base/java/lang/Integer.java
	at java.base/java.net.URI$Parser.fail(URI.java:2974)
	at java.base/java.net.URI$Parser.checkChars(URI.java:3145)
	at java.base/java.net.URI$Parser.parse(URI.java:3181)
	at java.base/java.net.URI.<init>(URI.java:623)
	at java.base/java.net.URI.create(URI.java:904)
	... 23 more

2024.07.19 13:42:13 INFO  compiling root (2 scala sources)
2024.07.19 13:42:13 INFO  time: compiled root in 0.19s
jul. 19, 2024 1:42:15 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
ADVERTÊNCIA: Unmatched cancel notification for request id 8552
jul. 19, 2024 1:42:21 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
ADVERTÊNCIA: Unmatched cancel notification for request id 8560
2024.07.19 13:42:29 INFO  compiling root (2 scala sources)
2024.07.19 13:42:29 INFO  time: compiled root in 0.21s
2024.07.19 13:42:37 INFO  compiling root (2 scala sources)
2024.07.19 13:42:37 INFO  time: compiled root in 0.2s
2024.07.19 13:42:39 WARN  Attempt to organize your imports failed. It looks like you have compilation issues causing your semanticdb to be stale. Ensure everything is compiling and try again.
2024.07.19 13:42:39 INFO  compiling root (2 scala sources)
2024.07.19 13:42:39 INFO  time: compiled root in 0.2s
2024.07.19 13:42:40 WARN  Using indexes to guess the definition of teste
2024.07.19 13:42:41 INFO  compiling root (2 scala sources)
2024.07.19 13:42:41 INFO  time: compiled root in 0.18s
jul. 19, 2024 1:43:11 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
ADVERTÊNCIA: Unmatched cancel notification for request id 8623
2024.07.19 13:43:11 INFO  compiling root (2 scala sources)
2024.07.19 13:43:11 INFO  time: compiled root in 0.2s
2024.07.19 13:43:35 INFO  compiling root (2 scala sources)
2024.07.19 13:43:35 INFO  time: compiled root in 0.2s
2024.07.19 13:44:26 INFO  compiling root (2 scala sources)
2024.07.19 13:44:26 INFO  time: compiled root in 0.45s
2024.07.19 13:44:28 INFO  compiling root (2 scala sources)
2024.07.19 13:44:28 INFO  time: compiled root in 0.17s
2024.07.19 13:44:33 INFO  compiling root (2 scala sources)
2024.07.19 13:44:33 INFO  time: compiled root in 0.18s
2024.07.19 13:44:36 INFO  compiling root (2 scala sources)
2024.07.19 13:44:36 INFO  time: compiled root in 0.18s
2024.07.19 13:44:55 INFO  compiling root (2 scala sources)
2024.07.19 13:44:55 INFO  time: compiled root in 0.2s
jul. 19, 2024 1:44:59 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
ADVERTÊNCIA: Unmatched cancel notification for request id 8906
2024.07.19 13:45:03 INFO  compiling root (2 scala sources)
2024.07.19 13:45:03 INFO  time: compiled root in 0.19s
jul. 19, 2024 1:45:15 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
ADVERTÊNCIA: Unmatched cancel notification for request id 8949
2024.07.19 13:45:15 INFO  compiling root (2 scala sources)
2024.07.19 13:45:15 INFO  time: compiled root in 0.32s
jul. 19, 2024 1:45:16 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
ADVERTÊNCIA: Unmatched cancel notification for request id 8960
jul. 19, 2024 1:45:16 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
ADVERTÊNCIA: Unmatched cancel notification for request id 8968
2024.07.19 13:45:20 INFO  compiling root (2 scala sources)
2024.07.19 13:45:20 INFO  time: compiled root in 0.21s
jul. 19, 2024 1:45:21 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
ADVERTÊNCIA: Unmatched cancel notification for request id 8993
2024.07.19 13:45:23 INFO  Can not organize imports if file has error
2024.07.19 13:45:23 INFO  compiling root (2 scala sources)
2024.07.19 13:45:23 INFO  time: compiled root in 0.12s
2024.07.19 13:45:30 INFO  Can not organize imports if file has error
2024.07.19 13:45:30 INFO  compiling root (2 scala sources)
2024.07.19 13:45:30 INFO  time: compiled root in 0.2s
2024.07.19 13:45:34 INFO  Can not organize imports if file has error
2024.07.19 13:45:34 INFO  compiling root (2 scala sources)
2024.07.19 13:45:34 INFO  time: compiled root in 0.18s
2024.07.19 13:45:36 INFO  Can not organize imports if file has error
2024.07.19 13:45:36 INFO  compiling root (2 scala sources)
2024.07.19 13:45:36 INFO  time: compiled root in 0.2s
2024.07.19 13:45:41 INFO  Can not organize imports if file has error
2024.07.19 13:45:41 INFO  compiling root (2 scala sources)
2024.07.19 13:45:41 INFO  time: compiled root in 0.19s
2024.07.19 13:45:43 INFO  compiling root (2 scala sources)
2024.07.19 13:45:43 INFO  time: compiled root in 0.25s
jul. 19, 2024 1:45:46 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
ADVERTÊNCIA: Unmatched cancel notification for request id 9144
2024.07.19 13:45:46 INFO  compiling root (2 scala sources)
2024.07.19 13:45:46 INFO  time: compiled root in 0.21s
2024.07.19 13:45:46 INFO  compiling root (2 scala sources)
2024.07.19 13:45:46 INFO  time: compiled root in 0.16s
2024.07.19 13:45:56 INFO  Can not organize imports if file has error
2024.07.19 13:45:56 INFO  compiling root (2 scala sources)
2024.07.19 13:45:56 INFO  time: compiled root in 0.17s
2024.07.19 13:46:06 INFO  Can not organize imports if file has error
2024.07.19 13:46:06 INFO  compiling root (2 scala sources)
2024.07.19 13:46:06 INFO  time: compiled root in 0.18s
2024.07.19 13:46:13 INFO  Can not organize imports if file has error
2024.07.19 13:46:13 INFO  compiling root (2 scala sources)
2024.07.19 13:46:14 INFO  time: compiled root in 1.14s
2024.07.19 13:46:17 INFO  compiling root-test (1 scala source)
2024.07.19 13:46:19 INFO  time: compiled root-test in 1.56s
jul. 19, 2024 1:48:48 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
ADVERTÊNCIA: Unmatched cancel notification for request id 9488
jul. 19, 2024 1:48:50 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
ADVERTÊNCIA: Unmatched cancel notification for request id 9496
jul. 19, 2024 1:48:51 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
ADVERTÊNCIA: Unmatched cancel notification for request id 9505
jul. 19, 2024 1:48:51 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
ADVERTÊNCIA: Unmatched cancel notification for request id 9513
jul. 19, 2024 1:48:52 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
ADVERTÊNCIA: Unmatched cancel notification for request id 9521
jul. 19, 2024 1:48:53 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
ADVERTÊNCIA: Unmatched cancel notification for request id 9529
jul. 19, 2024 1:48:57 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
ADVERTÊNCIA: Unmatched cancel notification for request id 9537
jul. 19, 2024 1:48:58 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
ADVERTÊNCIA: Unmatched cancel notification for request id 9546
jul. 19, 2024 1:48:58 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
ADVERTÊNCIA: Unmatched cancel notification for request id 9554
2024.07.19 13:53:19 INFO  compiling root-test (1 scala source)
2024.07.19 13:53:19 INFO  time: compiled root-test in 0.22s
2024.07.19 13:53:33 INFO  Can not organize imports if file has error
2024.07.19 13:57:00 INFO  compiling root-test (1 scala source)
2024.07.19 13:57:00 INFO  time: compiled root-test in 0.26s
2024.07.19 13:57:09 INFO  Can not organize imports if file has error
2024.07.19 13:57:09 INFO  compiling root-test (1 scala source)
2024.07.19 13:57:10 INFO  time: compiled root-test in 1.47s
2024.07.19 13:57:51 INFO  compiling root-test (1 scala source)
2024.07.19 13:57:52 INFO  time: compiled root-test in 1.12s
2024.07.19 13:57:59 INFO  compiling root-test (1 scala source)
2024.07.19 13:58:00 INFO  time: compiled root-test in 1.07s
jul. 19, 2024 1:58:21 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
ADVERTÊNCIA: Unmatched cancel notification for request id 10209
jul. 19, 2024 1:58:23 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
ADVERTÊNCIA: Unmatched cancel notification for request id 10217
jul. 19, 2024 1:58:24 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
ADVERTÊNCIA: Unmatched cancel notification for request id 10225
jul. 19, 2024 1:58:25 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
ADVERTÊNCIA: Unmatched cancel notification for request id 10233
jul. 19, 2024 1:58:25 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
ADVERTÊNCIA: Unmatched cancel notification for request id 10241
jul. 19, 2024 1:58:39 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
ADVERTÊNCIA: Unmatched cancel notification for request id 10251
jul. 19, 2024 1:58:47 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
ADVERTÊNCIA: Unmatched cancel notification for request id 10268
jul. 19, 2024 1:58:52 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
ADVERTÊNCIA: Unmatched cancel notification for request id 10285
jul. 19, 2024 1:58:52 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
ADVERTÊNCIA: Unmatched cancel notification for request id 10293
jul. 19, 2024 1:58:53 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
ADVERTÊNCIA: Unmatched cancel notification for request id 10301
jul. 19, 2024 1:58:55 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
ADVERTÊNCIA: Unmatched cancel notification for request id 10309
jul. 19, 2024 1:58:55 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
ADVERTÊNCIA: Unmatched cancel notification for request id 10317
jul. 19, 2024 1:59:00 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
ADVERTÊNCIA: Unmatched cancel notification for request id 10327
jul. 19, 2024 1:59:01 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
ADVERTÊNCIA: Unmatched cancel notification for request id 10335
jul. 19, 2024 1:59:15 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
ADVERTÊNCIA: Unmatched cancel notification for request id 10348
jul. 19, 2024 1:59:18 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
ADVERTÊNCIA: Unmatched cancel notification for request id 10362
jul. 19, 2024 1:59:40 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
ADVERTÊNCIA: Unmatched cancel notification for request id 10372
2024.07.19 13:59:48 INFO  compiling root (1 scala source)
2024.07.19 13:59:49 INFO  time: compiled root in 1.03s
2024.07.19 13:59:53 INFO  compiling root (1 scala source)
2024.07.19 13:59:53 INFO  time: compiled root in 0.9s
2024.07.19 14:00:00 INFO  compiling root (1 scala source)
2024.07.19 14:00:00 INFO  time: compiled root in 0.18s
2024.07.19 14:00:04 INFO  Can not organize imports if file has error
jul. 19, 2024 2:03:03 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
ADVERTÊNCIA: Unmatched cancel notification for request id 10688
jul. 19, 2024 2:03:27 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
ADVERTÊNCIA: Unmatched cancel notification for request id 10702
jul. 19, 2024 2:03:27 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
ADVERTÊNCIA: Unmatched cancel notification for request id 10710
jul. 19, 2024 2:03:33 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
ADVERTÊNCIA: Unmatched cancel notification for request id 10719
jul. 19, 2024 2:03:34 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
ADVERTÊNCIA: Unmatched cancel notification for request id 10727
jul. 19, 2024 2:04:05 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
ADVERTÊNCIA: Unmatched cancel notification for request id 10759
jul. 19, 2024 2:04:10 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
ADVERTÊNCIA: Unmatched cancel notification for request id 10771
jul. 19, 2024 2:04:11 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
ADVERTÊNCIA: Unmatched cancel notification for request id 10779
jul. 19, 2024 2:04:16 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
ADVERTÊNCIA: Unmatched cancel notification for request id 10790
jul. 19, 2024 2:04:17 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
ADVERTÊNCIA: Unmatched cancel notification for request id 10799
jul. 19, 2024 2:04:20 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
ADVERTÊNCIA: Unmatched cancel notification for request id 10807
jul. 19, 2024 2:04:21 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
ADVERTÊNCIA: Unmatched cancel notification for request id 10816
jul. 19, 2024 2:04:22 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
ADVERTÊNCIA: Unmatched cancel notification for request id 10824
jul. 19, 2024 2:04:24 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
ADVERTÊNCIA: Unmatched cancel notification for request id 10833
jul. 19, 2024 2:04:25 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
ADVERTÊNCIA: Unmatched cancel notification for request id 10841
jul. 19, 2024 2:04:26 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
ADVERTÊNCIA: Unmatched cancel notification for request id 10850
jul. 19, 2024 2:04:28 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
ADVERTÊNCIA: Unmatched cancel notification for request id 10858
jul. 19, 2024 2:04:33 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
ADVERTÊNCIA: Unmatched cancel notification for request id 10868
jul. 19, 2024 2:04:35 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
ADVERTÊNCIA: Unmatched cancel notification for request id 10876
jul. 19, 2024 2:11:08 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
ADVERTÊNCIA: Unmatched cancel notification for request id 10976
jul. 19, 2024 2:11:09 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
ADVERTÊNCIA: Unmatched cancel notification for request id 10984
jul. 19, 2024 2:11:09 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
ADVERTÊNCIA: Unmatched cancel notification for request id 10992
jul. 19, 2024 2:11:14 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
ADVERTÊNCIA: Unmatched cancel notification for request id 11000
jul. 19, 2024 2:11:17 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
ADVERTÊNCIA: Unmatched cancel notification for request id 11008
jul. 19, 2024 2:11:18 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
ADVERTÊNCIA: Unmatched cancel notification for request id 11016
jul. 19, 2024 2:11:18 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
ADVERTÊNCIA: Unmatched cancel notification for request id 11024
jul. 19, 2024 2:11:19 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
ADVERTÊNCIA: Unmatched cancel notification for request id 11032
jul. 19, 2024 2:11:25 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
ADVERTÊNCIA: Unmatched cancel notification for request id 11043
jul. 19, 2024 2:11:41 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
ADVERTÊNCIA: Unmatched cancel notification for request id 11051
jul. 19, 2024 2:11:42 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
ADVERTÊNCIA: Unmatched cancel notification for request id 11057
jul. 19, 2024 2:11:43 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
ADVERTÊNCIA: Unmatched cancel notification for request id 11065
jul. 19, 2024 2:11:45 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
ADVERTÊNCIA: Unmatched cancel notification for request id 11073
jul. 19, 2024 2:11:52 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
ADVERTÊNCIA: Unmatched cancel notification for request id 11083
jul. 19, 2024 2:11:52 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
ADVERTÊNCIA: Unmatched cancel notification for request id 11091
jul. 19, 2024 2:11:59 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
ADVERTÊNCIA: Unmatched cancel notification for request id 11101
jul. 19, 2024 2:12:00 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
ADVERTÊNCIA: Unmatched cancel notification for request id 11109
jul. 19, 2024 2:12:01 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
ADVERTÊNCIA: Unmatched cancel notification for request id 11117
jul. 19, 2024 2:12:51 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
ADVERTÊNCIA: Unmatched cancel notification for request id 11146
jul. 19, 2024 2:12:57 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
ADVERTÊNCIA: Unmatched cancel notification for request id 11154
jul. 19, 2024 2:12:58 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
ADVERTÊNCIA: Unmatched cancel notification for request id 11162
jul. 19, 2024 2:13:01 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
ADVERTÊNCIA: Unmatched cancel notification for request id 11170
jul. 19, 2024 2:13:02 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
ADVERTÊNCIA: Unmatched cancel notification for request id 11178
jul. 19, 2024 2:13:04 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
ADVERTÊNCIA: Unmatched cancel notification for request id 11186
jul. 19, 2024 2:13:05 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
ADVERTÊNCIA: Unmatched cancel notification for request id 11194
jul. 19, 2024 2:13:06 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
ADVERTÊNCIA: Unmatched cancel notification for request id 11202
2024.07.19 14:13:36 INFO  compiling root (1 scala source)
2024.07.19 14:13:37 INFO  time: compiled root in 1.19s
jul. 19, 2024 2:13:43 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
ADVERTÊNCIA: Unmatched cancel notification for request id 11303
jul. 19, 2024 2:13:45 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
ADVERTÊNCIA: Unmatched cancel notification for request id 11311
2024.07.19 14:14:28 INFO  compiling root (1 scala source)
2024.07.19 14:14:28 INFO  time: compiled root in 0.93s
2024.07.19 14:15:04 INFO  compiling root (1 scala source)
2024.07.19 14:15:04 INFO  time: compiled root in 0.17s
something's wrong: no file:///C:/Users/Vinicius/UnB/FLanguage/src/main/scala/br/unb/cic/flang/MonadState.scala in br.unb.cic.flang.MonadState.package.S2[<error>]RangePosition(file:///C:/Users/Vinicius/UnB/FLanguage/src/main/scala/br/unb/cic/flang/MonadState.scala, 455, 455, 460)
2024.07.19 14:15:07 INFO  Can not organize imports if file has error
2024.07.19 14:15:07 INFO  compiling root (1 scala source)
2024.07.19 14:15:07 INFO  time: compiled root in 0.2s
jul. 19, 2024 2:15:08 PM scala.meta.internal.pc.CompilerAccess retryWithCleanCompiler
INFORMAÇÕES: compiler crashed due to an error in the Scala compiler, retrying with new compiler instance.
jul. 19, 2024 2:15:08 PM scala.meta.internal.pc.CompilerAccess handleError
GRAVE: A severe compiler error occurred, full details of the error can be found in the error report C:\Users\Vinicius\UnB\FLanguage\.metals\.reports\metals-full\2024-07-19\r_compiler-error_(root)_14-15-08-846.md
2024.07.19 14:15:10 INFO  Can not organize imports if file has error
2024.07.19 14:15:10 INFO  compiling root (1 scala source)
2024.07.19 14:15:10 INFO  time: compiled root in 0.13s
2024.07.19 14:15:10 INFO  Can not organize imports if file has error
2024.07.19 14:15:10 INFO  compiling root (1 scala source)
2024.07.19 14:15:12 INFO  time: compiled root in 0.93s
jul. 19, 2024 2:15:16 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
ADVERTÊNCIA: Unmatched cancel notification for request id 11591
2024.07.19 14:15:25 INFO  compiling root (1 scala source)
2024.07.19 14:15:25 INFO  time: compiled root in 0.86s
jul. 19, 2024 2:15:44 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
ADVERTÊNCIA: Unmatched cancel notification for request id 11682
jul. 19, 2024 2:15:46 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
ADVERTÊNCIA: Unmatched cancel notification for request id 11690
jul. 19, 2024 2:15:48 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
ADVERTÊNCIA: Unmatched cancel notification for request id 11698
jul. 19, 2024 2:15:48 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
ADVERTÊNCIA: Unmatched cancel notification for request id 11706
jul. 19, 2024 2:15:51 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
ADVERTÊNCIA: Unmatched cancel notification for request id 11714
jul. 19, 2024 2:16:11 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
ADVERTÊNCIA: Unmatched cancel notification for request id 11734
jul. 19, 2024 2:16:12 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
ADVERTÊNCIA: Unmatched cancel notification for request id 11742
jul. 19, 2024 2:16:20 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
ADVERTÊNCIA: Unmatched cancel notification for request id 11753
jul. 19, 2024 2:16:23 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
ADVERTÊNCIA: Unmatched cancel notification for request id 11761
jul. 19, 2024 2:16:25 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
ADVERTÊNCIA: Unmatched cancel notification for request id 11769
2024.07.19 14:16:30 INFO  compiling root (1 scala source)
2024.07.19 14:16:30 INFO  time: compiled root in 0.28s
2024.07.19 14:16:45 WARN  Using indexes to guess the definition of stt
2024.07.19 14:16:45 WARN  Using indexes to guess the definition of stt
2024.07.19 14:16:45 INFO  Can not organize imports if file has error
2024.07.19 14:16:45 INFO  compiling root (1 scala source)
2024.07.19 14:16:45 INFO  time: compiled root in 0.2s
2024.07.19 14:16:48 WARN  Using indexes to guess the definition of A
2024.07.19 14:16:50 INFO  Can not organize imports if file has error
2024.07.19 14:16:50 INFO  compiling root (1 scala source)
2024.07.19 14:16:50 INFO  time: compiled root in 0.18s
2024.07.19 14:16:57 INFO  Can not organize imports if file has error
2024.07.19 14:16:57 INFO  compiling root (1 scala source)
2024.07.19 14:16:57 INFO  time: compiled root in 0.2s
jul. 19, 2024 2:16:58 PM scala.meta.internal.pc.CompilerAccess retryWithCleanCompiler
INFORMAÇÕES: compiler crashed due to an error in the Scala compiler, retrying with new compiler instance.
jul. 19, 2024 2:16:58 PM scala.meta.internal.pc.CompilerAccess handleError
GRAVE: A severe compiler error occurred, full details of the error can be found in the error report C:\Users\Vinicius\UnB\FLanguage\.metals\.reports\metals-full\2024-07-19\r_compiler-error_(root)_14-16-58-503.md
jul. 19, 2024 2:16:59 PM scala.meta.internal.pc.CompilerAccess retryWithCleanCompiler
INFORMAÇÕES: compiler crashed due to an error in the Scala compiler, retrying with new compiler instance.
jul. 19, 2024 2:16:59 PM scala.meta.internal.pc.CompilerAccess handleError
GRAVE: A severe compiler error occurred, full details of the error can be found in the error report C:\Users\Vinicius\UnB\FLanguage\.metals\.reports\metals-full\2024-07-19\r_compiler-error_(root)_14-16-59-819.md
2024.07.19 14:17:07 INFO  Can not organize imports if file has error
2024.07.19 14:17:07 INFO  compiling root (1 scala source)
2024.07.19 14:17:07 INFO  time: compiled root in 0.22s
jul. 19, 2024 2:17:09 PM scala.meta.internal.pc.CompilerAccess retryWithCleanCompiler
INFORMAÇÕES: compiler crashed due to an error in the Scala compiler, retrying with new compiler instance.
jul. 19, 2024 2:17:09 PM scala.meta.internal.pc.CompilerAccess handleError
GRAVE: A severe compiler error occurred, full details of the error can be found in the error report C:\Users\Vinicius\UnB\FLanguage\.metals\.reports\metals-full\2024-07-19\r_compiler-error_(root)_14-17-09-421.md
jul. 19, 2024 2:17:09 PM scala.meta.internal.pc.CompilerAccess retryWithCleanCompiler
INFORMAÇÕES: compiler crashed due to an error in the Scala compiler, retrying with new compiler instance.
jul. 19, 2024 2:17:10 PM scala.meta.internal.pc.CompilerAccess handleError
GRAVE: A severe compiler error occurred, full details of the error can be found in the error report C:\Users\Vinicius\UnB\FLanguage\.metals\.reports\metals-full\2024-07-19\r_compiler-error_(root)_14-17-10-034.md
jul. 19, 2024 2:17:10 PM scala.meta.internal.pc.CompilerAccess retryWithCleanCompiler
INFORMAÇÕES: compiler crashed due to an error in the Scala compiler, retrying with new compiler instance.
jul. 19, 2024 2:17:10 PM scala.meta.internal.pc.CompilerAccess handleError
GRAVE: A severe compiler error occurred, full details of the error can be found in the error report C:\Users\Vinicius\UnB\FLanguage\.metals\.reports\metals-full\2024-07-19\r_compiler-error_(root)_14-17-10-631.md
jul. 19, 2024 2:17:13 PM scala.meta.internal.pc.CompilerAccess retryWithCleanCompiler
INFORMAÇÕES: compiler crashed due to an error in the Scala compiler, retrying with new compiler instance.
jul. 19, 2024 2:17:13 PM scala.meta.internal.pc.CompilerAccess handleError
GRAVE: A severe compiler error occurred, full details of the error can be found in the error report C:\Users\Vinicius\UnB\FLanguage\.metals\.reports\metals-full\2024-07-19\r_compiler-error_(root)_14-17-13-973.md
jul. 19, 2024 2:17:15 PM scala.meta.internal.pc.CompilerAccess retryWithCleanCompiler
INFORMAÇÕES: compiler crashed due to an error in the Scala compiler, retrying with new compiler instance.
jul. 19, 2024 2:17:15 PM scala.meta.internal.pc.CompilerAccess handleError
GRAVE: A severe compiler error occurred, full details of the error can be found in the error report C:\Users\Vinicius\UnB\FLanguage\.metals\.reports\metals-full\2024-07-19\r_compiler-error_(root)_14-17-15-240.md
jul. 19, 2024 2:17:15 PM scala.meta.internal.pc.CompilerAccess retryWithCleanCompiler
INFORMAÇÕES: compiler crashed due to an error in the Scala compiler, retrying with new compiler instance.
jul. 19, 2024 2:17:15 PM scala.meta.internal.pc.CompilerAccess handleError
GRAVE: A severe compiler error occurred, full details of the error can be found in the error report C:\Users\Vinicius\UnB\FLanguage\.metals\.reports\metals-full\2024-07-19\r_compiler-error_(root)_14-17-15-848.md
jul. 19, 2024 2:17:16 PM scala.meta.internal.pc.CompilerAccess retryWithCleanCompiler
INFORMAÇÕES: compiler crashed due to an error in the Scala compiler, retrying with new compiler instance.
jul. 19, 2024 2:17:16 PM scala.meta.internal.pc.CompilerAccess handleError
GRAVE: A severe compiler error occurred, full details of the error can be found in the error report C:\Users\Vinicius\UnB\FLanguage\.metals\.reports\metals-full\2024-07-19\r_compiler-error_(root)_14-17-16-453.md
jul. 19, 2024 2:17:23 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
ADVERTÊNCIA: Unmatched cancel notification for request id 11935
jul. 19, 2024 2:17:24 PM scala.meta.internal.pc.CompilerAccess retryWithCleanCompiler
INFORMAÇÕES: compiler crashed due to an error in the Scala compiler, retrying with new compiler instance.
jul. 19, 2024 2:17:24 PM scala.meta.internal.pc.CompilerAccess handleError
GRAVE: A severe compiler error occurred, full details of the error can be found in the error report C:\Users\Vinicius\UnB\FLanguage\.metals\.reports\metals-full\2024-07-19\r_compiler-error_(root)_14-17-24-696.md
jul. 19, 2024 2:17:25 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
ADVERTÊNCIA: Unmatched cancel notification for request id 11943
jul. 19, 2024 2:17:29 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
ADVERTÊNCIA: Unmatched cancel notification for request id 11951
jul. 19, 2024 2:17:29 PM scala.meta.internal.pc.CompilerAccess retryWithCleanCompiler
INFORMAÇÕES: compiler crashed due to an error in the Scala compiler, retrying with new compiler instance.
jul. 19, 2024 2:17:29 PM scala.meta.internal.pc.CompilerAccess handleError
GRAVE: A severe compiler error occurred, full details of the error can be found in the error report C:\Users\Vinicius\UnB\FLanguage\.metals\.reports\metals-full\2024-07-19\r_compiler-error_(root)_14-17-29-988.md
jul. 19, 2024 2:17:30 PM scala.meta.internal.pc.CompilerAccess retryWithCleanCompiler
INFORMAÇÕES: compiler crashed due to an error in the Scala compiler, retrying with new compiler instance.
jul. 19, 2024 2:17:30 PM scala.meta.internal.pc.CompilerAccess handleError
GRAVE: A severe compiler error occurred, full details of the error can be found in the error report C:\Users\Vinicius\UnB\FLanguage\.metals\.reports\metals-full\2024-07-19\r_compiler-error_(root)_14-17-30-801.md
jul. 19, 2024 2:17:31 PM scala.meta.internal.pc.CompilerAccess retryWithCleanCompiler
INFORMAÇÕES: compiler crashed due to an error in the Scala compiler, retrying with new compiler instance.
jul. 19, 2024 2:17:31 PM scala.meta.internal.pc.CompilerAccess handleError
GRAVE: A severe compiler error occurred, full details of the error can be found in the error report C:\Users\Vinicius\UnB\FLanguage\.metals\.reports\metals-full\2024-07-19\r_compiler-error_(root)_14-17-31-644.md
jul. 19, 2024 2:17:32 PM scala.meta.internal.pc.CompilerAccess retryWithCleanCompiler
INFORMAÇÕES: compiler crashed due to an error in the Scala compiler, retrying with new compiler instance.
jul. 19, 2024 2:17:32 PM scala.meta.internal.pc.CompilerAccess handleError
GRAVE: A severe compiler error occurred, full details of the error can be found in the error report C:\Users\Vinicius\UnB\FLanguage\.metals\.reports\metals-full\2024-07-19\r_compiler-error_(root)_14-17-32-792.md
jul. 19, 2024 2:17:35 PM scala.meta.internal.pc.CompilerAccess retryWithCleanCompiler
INFORMAÇÕES: compiler crashed due to an error in the Scala compiler, retrying with new compiler instance.
jul. 19, 2024 2:17:35 PM scala.meta.internal.pc.CompilerAccess handleError
GRAVE: A severe compiler error occurred, full details of the error can be found in the error report C:\Users\Vinicius\UnB\FLanguage\.metals\.reports\metals-full\2024-07-19\r_compiler-error_(root)_14-17-35-789.md
2024.07.19 14:17:39 INFO  Can not organize imports if file has error
2024.07.19 14:17:39 INFO  compiling root (1 scala source)
2024.07.19 14:17:39 INFO  time: compiled root in 0.22s
2024.07.19 14:17:49 INFO  Can not organize imports if file has error
2024.07.19 14:17:49 INFO  compiling root (1 scala source)
2024.07.19 14:17:49 INFO  time: compiled root in 0.12s
2024.07.19 14:17:53 INFO  Can not organize imports if file has error
2024.07.19 14:17:53 INFO  compiling root (1 scala source)
2024.07.19 14:17:53 INFO  time: compiled root in 0.18s
jul. 19, 2024 2:17:56 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
ADVERTÊNCIA: Unmatched cancel notification for request id 12069
jul. 19, 2024 2:17:59 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
ADVERTÊNCIA: Unmatched cancel notification for request id 12077
jul. 19, 2024 2:18:01 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
ADVERTÊNCIA: Unmatched cancel notification for request id 12086
jul. 19, 2024 2:18:02 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
ADVERTÊNCIA: Unmatched cancel notification for request id 12094
2024.07.19 14:18:05 INFO  Can not organize imports if file has error
2024.07.19 14:18:05 INFO  compiling root (1 scala source)
2024.07.19 14:18:05 INFO  time: compiled root in 0.2s
jul. 19, 2024 2:18:24 PM scala.meta.internal.pc.CompilerAccess retryWithCleanCompiler
INFORMAÇÕES: compiler crashed due to an error in the Scala compiler, retrying with new compiler instance.
jul. 19, 2024 2:18:25 PM scala.meta.internal.pc.CompilerAccess handleError
GRAVE: A severe compiler error occurred, full details of the error can be found in the error report C:\Users\Vinicius\UnB\FLanguage\.metals\.reports\metals-full\2024-07-19\r_compiler-error_(root)_14-18-25-098.md
something's wrong: no file:///C:/Users/Vinicius/UnB/FLanguage/src/main/scala/br/unb/cic/flang/MonadState.scala in br.unb.cic.flang.MonadState.package.S2[<error>]RangePosition(file:///C:/Users/Vinicius/UnB/FLanguage/src/main/scala/br/unb/cic/flang/MonadState.scala, 452, 452, 464)
2024.07.19 14:18:57 INFO  Can not organize imports if file has error
2024.07.19 14:18:57 INFO  compiling root (1 scala source)
2024.07.19 14:18:57 INFO  time: compiled root in 0.18s
2024.07.19 14:19:04 INFO  Can not organize imports if file has error
2024.07.19 14:19:04 INFO  compiling root (1 scala source)
2024.07.19 14:19:04 INFO  time: compiled root in 0.19s
jul. 19, 2024 2:19:23 PM scala.meta.internal.pc.CompilerAccess retryWithCleanCompiler
INFORMAÇÕES: compiler crashed due to an error in the Scala compiler, retrying with new compiler instance.
jul. 19, 2024 2:19:23 PM scala.meta.internal.pc.CompilerAccess handleError
GRAVE: A severe compiler error occurred, full details of the error can be found in the error report C:\Users\Vinicius\UnB\FLanguage\.metals\.reports\metals-full\2024-07-19\r_compiler-error_(root)_14-19-23-974.md
jul. 19, 2024 2:19:26 PM scala.meta.internal.pc.CompilerAccess retryWithCleanCompiler
INFORMAÇÕES: compiler crashed due to an error in the Scala compiler, retrying with new compiler instance.
jul. 19, 2024 2:19:26 PM scala.meta.internal.pc.CompilerAccess handleError
GRAVE: A severe compiler error occurred, full details of the error can be found in the error report C:\Users\Vinicius\UnB\FLanguage\.metals\.reports\metals-full\2024-07-19\r_compiler-error_(root)_14-19-26-625.md
jul. 19, 2024 2:19:29 PM scala.meta.internal.pc.CompilerAccess retryWithCleanCompiler
INFORMAÇÕES: compiler crashed due to an error in the Scala compiler, retrying with new compiler instance.
jul. 19, 2024 2:19:30 PM scala.meta.internal.pc.CompilerAccess handleError
GRAVE: A severe compiler error occurred, full details of the error can be found in the error report C:\Users\Vinicius\UnB\FLanguage\.metals\.reports\metals-full\2024-07-19\r_compiler-error_(root)_14-19-30-289.md
jul. 19, 2024 2:19:30 PM scala.meta.internal.pc.CompilerAccess retryWithCleanCompiler
INFORMAÇÕES: compiler crashed due to an error in the Scala compiler, retrying with new compiler instance.
jul. 19, 2024 2:19:31 PM scala.meta.internal.pc.CompilerAccess handleError
GRAVE: A severe compiler error occurred, full details of the error can be found in the error report C:\Users\Vinicius\UnB\FLanguage\.metals\.reports\metals-full\2024-07-19\r_compiler-error_(root)_14-19-31-223.md
jul. 19, 2024 2:19:37 PM scala.meta.internal.pc.CompilerAccess retryWithCleanCompiler
INFORMAÇÕES: compiler crashed due to an error in the Scala compiler, retrying with new compiler instance.
jul. 19, 2024 2:19:38 PM scala.meta.internal.pc.CompilerAccess handleError
GRAVE: A severe compiler error occurred, full details of the error can be found in the error report C:\Users\Vinicius\UnB\FLanguage\.metals\.reports\metals-full\2024-07-19\r_compiler-error_(root)_14-19-38-245.md
jul. 19, 2024 2:19:39 PM scala.meta.internal.pc.CompilerAccess retryWithCleanCompiler
INFORMAÇÕES: compiler crashed due to an error in the Scala compiler, retrying with new compiler instance.
jul. 19, 2024 2:19:40 PM scala.meta.internal.pc.CompilerAccess handleError
GRAVE: A severe compiler error occurred, full details of the error can be found in the error report C:\Users\Vinicius\UnB\FLanguage\.metals\.reports\metals-full\2024-07-19\r_compiler-error_(root)_14-19-40-203.md
jul. 19, 2024 2:19:42 PM scala.meta.internal.pc.CompilerAccess retryWithCleanCompiler
INFORMAÇÕES: compiler crashed due to an error in the Scala compiler, retrying with new compiler instance.
2024.07.19 14:19:42 INFO  Can not organize imports if file has error
jul. 19, 2024 2:19:42 PM scala.meta.internal.pc.CompilerAccess handleError
GRAVE: A severe compiler error occurred, full details of the error can be found in the error report C:\Users\Vinicius\UnB\FLanguage\.metals\.reports\metals-full\2024-07-19\r_compiler-error_(root)_14-19-42-464.md
2024.07.19 14:19:42 INFO  compiling root (1 scala source)
2024.07.19 14:19:42 INFO  time: compiled root in 0.19s
2024.07.19 14:19:49 INFO  Can not organize imports if file has error
2024.07.19 14:19:49 INFO  compiling root (1 scala source)
2024.07.19 14:19:49 INFO  time: compiled root in 0.2s
2024.07.19 14:19:54 INFO  Can not organize imports if file has error
2024.07.19 14:19:54 INFO  compiling root (1 scala source)
2024.07.19 14:19:55 INFO  time: compiled root in 1.12s
jul. 19, 2024 2:23:50 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
ADVERTÊNCIA: Unmatched cancel notification for request id 12519
jul. 19, 2024 2:23:51 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
ADVERTÊNCIA: Unmatched cancel notification for request id 12527
jul. 19, 2024 2:23:52 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
ADVERTÊNCIA: Unmatched cancel notification for request id 12536
jul. 19, 2024 2:23:54 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
ADVERTÊNCIA: Unmatched cancel notification for request id 12544
jul. 19, 2024 2:24:00 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
ADVERTÊNCIA: Unmatched cancel notification for request id 12553
jul. 19, 2024 2:24:07 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
ADVERTÊNCIA: Unmatched cancel notification for request id 12563
jul. 19, 2024 2:24:09 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
ADVERTÊNCIA: Unmatched cancel notification for request id 12572
jul. 19, 2024 2:27:14 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
ADVERTÊNCIA: Unmatched cancel notification for request id 12638
2024.07.19 14:27:40 INFO  compiling root (1 scala source)
2024.07.19 14:27:41 INFO  time: compiled root in 1.04s
2024.07.19 14:27:49 INFO  compiling root (1 scala source)
2024.07.19 14:27:49 INFO  time: compiled root in 0.19s
2024.07.19 14:27:51 INFO  Can not organize imports if file has error
2024.07.19 14:27:51 INFO  compiling root (1 scala source)
2024.07.19 14:27:51 INFO  time: compiled root in 0.21s
jul. 19, 2024 2:27:52 PM scala.meta.internal.pc.CompilerAccess retryWithCleanCompiler
INFORMAÇÕES: compiler crashed due to an error in the Scala compiler, retrying with new compiler instance.
jul. 19, 2024 2:27:52 PM scala.meta.internal.pc.CompilerAccess handleError
GRAVE: A severe compiler error occurred, full details of the error can be found in the error report C:\Users\Vinicius\UnB\FLanguage\.metals\.reports\metals-full\2024-07-19\r_compiler-error_(root)_14-27-52-775.md
jul. 19, 2024 2:27:58 PM scala.meta.internal.pc.CompilerAccess retryWithCleanCompiler
INFORMAÇÕES: compiler crashed due to an error in the Scala compiler, retrying with new compiler instance.
jul. 19, 2024 2:27:58 PM scala.meta.internal.pc.CompilerAccess handleError
GRAVE: A severe compiler error occurred, full details of the error can be found in the error report C:\Users\Vinicius\UnB\FLanguage\.metals\.reports\metals-full\2024-07-19\r_compiler-error_(root)_14-27-58-684.md
2024.07.19 14:28:00 INFO  Can not organize imports if file has error
2024.07.19 14:28:00 INFO  compiling root (1 scala source)
2024.07.19 14:28:00 INFO  time: compiled root in 0.18s
2024.07.19 14:28:01 WARN  Using indexes to guess the definition of S2
2024.07.19 14:28:01 INFO  Can not organize imports if file has error
2024.07.19 14:28:01 INFO  compiling root (1 scala source)
jul. 19, 2024 2:28:02 PM scala.meta.internal.pc.CompilerAccess retryWithCleanCompiler
INFORMAÇÕES: compiler crashed due to an error in the Scala compiler, retrying with new compiler instance.
2024.07.19 14:28:01 INFO  time: compiled root in 0.22s
jul. 19, 2024 2:28:02 PM scala.meta.internal.pc.CompilerAccess handleError
GRAVE: A severe compiler error occurred, full details of the error can be found in the error report C:\Users\Vinicius\UnB\FLanguage\.metals\.reports\metals-full\2024-07-19\r_compiler-error_(root)_14-28-02-295.md
jul. 19, 2024 2:28:02 PM scala.meta.internal.pc.CompilerAccess retryWithCleanCompiler
INFORMAÇÕES: compiler crashed due to an error in the Scala compiler, retrying with new compiler instance.
jul. 19, 2024 2:28:03 PM scala.meta.internal.pc.CompilerAccess handleError
GRAVE: A severe compiler error occurred, full details of the error can be found in the error report C:\Users\Vinicius\UnB\FLanguage\.metals\.reports\metals-full\2024-07-19\r_compiler-error_(root)_14-28-03-223.md
2024.07.19 14:28:11 INFO  Can not organize imports if file has error
2024.07.19 14:28:11 INFO  compiling root (1 scala source)
2024.07.19 14:28:11 INFO  time: compiled root in 0.2s
2024.07.19 14:28:18 INFO  Can not organize imports if file has error
2024.07.19 14:28:18 INFO  compiling root (1 scala source)
2024.07.19 14:28:18 INFO  time: compiled root in 0.2s
2024.07.19 14:28:21 INFO  Can not organize imports if file has error
2024.07.19 14:28:21 INFO  compiling root (1 scala source)
2024.07.19 14:28:21 INFO  time: compiled root in 0.23s
2024.07.19 14:29:20 INFO  Can not organize imports if file has error
2024.07.19 14:29:20 INFO  compiling root (1 scala source)
2024.07.19 14:29:20 INFO  time: compiled root in 0.22s
2024.07.19 14:29:45 INFO  Can not organize imports if file has error
2024.07.19 14:29:45 INFO  compiling root (1 scala source)
2024.07.19 14:29:45 INFO  time: compiled root in 0.2s
jul. 19, 2024 2:29:47 PM scala.meta.internal.pc.CompilerAccess retryWithCleanCompiler
INFORMAÇÕES: compiler crashed due to an error in the Scala compiler, retrying with new compiler instance.
jul. 19, 2024 2:29:47 PM scala.meta.internal.pc.CompilerAccess handleError
GRAVE: A severe compiler error occurred, full details of the error can be found in the error report C:\Users\Vinicius\UnB\FLanguage\.metals\.reports\metals-full\2024-07-19\r_compiler-error_(root)_14-29-47-571.md
jul. 19, 2024 2:29:51 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
ADVERTÊNCIA: Unmatched cancel notification for request id 13128
jul. 19, 2024 2:29:51 PM scala.meta.internal.pc.CompilerAccess retryWithCleanCompiler
INFORMAÇÕES: compiler crashed due to an error in the Scala compiler, retrying with new compiler instance.
jul. 19, 2024 2:29:51 PM scala.meta.internal.pc.CompilerAccess handleError
GRAVE: A severe compiler error occurred, full details of the error can be found in the error report C:\Users\Vinicius\UnB\FLanguage\.metals\.reports\metals-full\2024-07-19\r_compiler-error_(root)_14-29-51-528.md
something's wrong: no file:///C:/Users/Vinicius/UnB/FLanguage/src/main/scala/br/unb/cic/flang/MonadState.scala in br.unb.cic.flang.MonadState.package.S2[<error>]RangePosition(file:///C:/Users/Vinicius/UnB/FLanguage/src/main/scala/br/unb/cic/flang/MonadState.scala, 550, 550, 562)
something's wrong: no file:///C:/Users/Vinicius/UnB/FLanguage/src/main/scala/br/unb/cic/flang/MonadState.scala in br.unb.cic.flang.MonadState.package.S2[A]RangePosition(file:///C:/Users/Vinicius/UnB/FLanguage/src/main/scala/br/unb/cic/flang/MonadState.scala, 550, 550, 555)
2024.07.19 14:29:57 INFO  Can not organize imports if file has error
2024.07.19 14:29:57 INFO  compiling root (1 scala source)
2024.07.19 14:29:57 INFO  time: compiled root in 0.24s
jul. 19, 2024 2:30:12 PM scala.meta.internal.pc.CompilerAccess retryWithCleanCompiler
INFORMAÇÕES: compiler crashed due to an error in the Scala compiler, retrying with new compiler instance.
jul. 19, 2024 2:30:12 PM scala.meta.internal.pc.CompilerAccess handleError
GRAVE: A severe compiler error occurred, full details of the error can be found in the error report C:\Users\Vinicius\UnB\FLanguage\.metals\.reports\metals-full\2024-07-19\r_compiler-error_(root)_14-30-12-165.md
jul. 19, 2024 2:30:23 PM scala.meta.internal.pc.CompilerAccess retryWithCleanCompiler
INFORMAÇÕES: compiler crashed due to an error in the Scala compiler, retrying with new compiler instance.
2024.07.19 14:30:24 INFO  Can not organize imports if file has error
2024.07.19 14:30:24 INFO  compiling root (1 scala source)
jul. 19, 2024 2:30:24 PM scala.meta.internal.pc.CompilerAccess retryWithCleanCompiler
INFORMAÇÕES: compiler crashed due to an error in the Scala compiler, retrying with new compiler instance.
jul. 19, 2024 2:30:24 PM scala.meta.internal.pc.CompilerAccess handleError
GRAVE: A severe compiler error occurred, full details of the error can be found in the error report C:\Users\Vinicius\UnB\FLanguage\.metals\.reports\metals-full\2024-07-19\r_compiler-error_(root)_14-30-24-392.md
2024.07.19 14:30:24 INFO  time: compiled root in 0.28s
jul. 19, 2024 2:30:25 PM scala.meta.internal.pc.CompilerAccess retryWithCleanCompiler
INFORMAÇÕES: compiler crashed due to an error in the Scala compiler, retrying with new compiler instance.
jul. 19, 2024 2:30:25 PM scala.meta.internal.pc.CompilerAccess handleError
GRAVE: A severe compiler error occurred, full details of the error can be found in the error report C:\Users\Vinicius\UnB\FLanguage\.metals\.reports\metals-full\2024-07-19\r_compiler-error_(root)_14-30-25-355.md
jul. 19, 2024 2:30:27 PM scala.meta.internal.pc.CompilerAccess retryWithCleanCompiler
INFORMAÇÕES: compiler crashed due to an error in the Scala compiler, retrying with new compiler instance.
jul. 19, 2024 2:30:27 PM scala.meta.internal.pc.CompilerAccess handleError
GRAVE: A severe compiler error occurred, full details of the error can be found in the error report C:\Users\Vinicius\UnB\FLanguage\.metals\.reports\metals-full\2024-07-19\r_compiler-error_(root)_14-30-27-306.md
jul. 19, 2024 2:30:28 PM scala.meta.internal.pc.CompilerAccess retryWithCleanCompiler
INFORMAÇÕES: compiler crashed due to an error in the Scala compiler, retrying with new compiler instance.
2024.07.19 14:30:28 INFO  Can not organize imports if file has error
2024.07.19 14:30:28 INFO  compiling root (1 scala source)
jul. 19, 2024 2:30:28 PM scala.meta.internal.pc.CompilerAccess retryWithCleanCompiler
INFORMAÇÕES: compiler crashed due to an error in the Scala compiler, retrying with new compiler instance.
jul. 19, 2024 2:30:28 PM scala.meta.internal.pc.CompilerAccess handleError
GRAVE: A severe compiler error occurred, full details of the error can be found in the error report C:\Users\Vinicius\UnB\FLanguage\.metals\.reports\metals-full\2024-07-19\r_compiler-error_(root)_14-30-28-840.md
2024.07.19 14:30:28 INFO  time: compiled root in 0.26s
2024.07.19 14:30:45 INFO  Can not organize imports if file has error
2024.07.19 14:30:45 INFO  compiling root (1 scala source)
2024.07.19 14:30:45 INFO  time: compiled root in 0.2s
jul. 19, 2024 2:30:59 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
ADVERTÊNCIA: Unmatched cancel notification for request id 13356
jul. 19, 2024 2:31:09 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
ADVERTÊNCIA: Unmatched cancel notification for request id 13383
2024.07.19 14:31:31 WARN  Using indexes to guess the definition of S2
2024.07.19 14:31:31 WARN  Using indexes to guess the definition of step1
2024.07.19 14:32:27 INFO  Can not organize imports if file has error
2024.07.19 14:32:27 INFO  compiling root (1 scala source)
2024.07.19 14:32:27 INFO  time: compiled root in 0.2s
2024.07.19 14:32:36 INFO  Can not organize imports if file has error
2024.07.19 14:32:36 INFO  compiling root (1 scala source)
2024.07.19 14:32:36 INFO  time: compiled root in 0.19s
2024.07.19 14:32:48 INFO  Can not organize imports if file has error
2024.07.19 14:32:48 INFO  compiling root (1 scala source)
2024.07.19 14:32:48 INFO  time: compiled root in 0.19s
2024.07.19 14:32:51 INFO  Can not organize imports if file has error
2024.07.19 14:32:51 INFO  compiling root (1 scala source)
2024.07.19 14:32:51 INFO  time: compiled root in 0.19s
2024.07.19 14:32:58 INFO  Can not organize imports if file has error
2024.07.19 14:32:58 INFO  compiling root (1 scala source)
2024.07.19 14:32:58 INFO  time: compiled root in 0.2s
2024.07.19 14:33:00 INFO  Can not organize imports if file has error
2024.07.19 14:33:00 INFO  compiling root (1 scala source)
2024.07.19 14:33:00 INFO  time: compiled root in 0.26s
2024.07.19 14:33:20 INFO  Can not organize imports if file has error
2024.07.19 14:33:20 INFO  compiling root (1 scala source)
2024.07.19 14:33:20 INFO  time: compiled root in 0.98s
2024.07.19 14:34:48 INFO  compiling root (1 scala source)
2024.07.19 14:34:48 INFO  time: compiled root in 0.92s
2024.07.19 14:34:51 INFO  compiling root (1 scala source)
2024.07.19 14:34:52 INFO  time: compiled root in 1.13s
jul. 19, 2024 2:34:57 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
ADVERTÊNCIA: Unmatched cancel notification for request id 13984
jul. 19, 2024 2:34:59 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
ADVERTÊNCIA: Unmatched cancel notification for request id 13992
jul. 19, 2024 2:35:12 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
ADVERTÊNCIA: Unmatched cancel notification for request id 14015
jul. 19, 2024 2:35:13 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
ADVERTÊNCIA: Unmatched cancel notification for request id 14023
jul. 19, 2024 2:35:16 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
ADVERTÊNCIA: Unmatched cancel notification for request id 14032
jul. 19, 2024 2:35:18 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
ADVERTÊNCIA: Unmatched cancel notification for request id 14040
2024.07.19 14:35:34 INFO  compiling root (1 scala source)
2024.07.19 14:35:34 INFO  time: compiled root in 0.92s
jul. 19, 2024 2:37:37 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
ADVERTÊNCIA: Unmatched cancel notification for request id 14414
2024.07.19 14:38:03 INFO  compiling root (1 scala source)
2024.07.19 14:38:03 INFO  time: compiled root in 0.21s
2024.07.19 14:38:12 INFO  Can not organize imports if file has error
2024.07.19 14:38:12 INFO  compiling root (1 scala source)
2024.07.19 14:38:12 INFO  time: compiled root in 0.21s
2024.07.19 14:38:15 INFO  Can not organize imports if file has error
2024.07.19 14:38:15 INFO  compiling root (1 scala source)
2024.07.19 14:38:15 INFO  time: compiled root in 0.23s
jul. 19, 2024 2:38:36 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
ADVERTÊNCIA: Unmatched cancel notification for request id 14595
2024.07.19 14:38:39 INFO  Can not organize imports if file has error
2024.07.19 14:38:39 INFO  compiling root (1 scala source)
2024.07.19 14:38:39 INFO  time: compiled root in 0.14s
2024.07.19 14:38:40 INFO  Can not organize imports if file has error
2024.07.19 14:38:40 INFO  compiling root (1 scala source)
2024.07.19 14:38:40 INFO  time: compiled root in 0.1s
2024.07.19 14:40:04 INFO  Can not organize imports if file has error
2024.07.19 14:40:04 INFO  compiling root (1 scala source)
2024.07.19 14:40:05 INFO  time: compiled root in 1s
2024.07.19 14:40:39 INFO  compiling root (1 scala source)
2024.07.19 14:40:39 INFO  time: compiled root in 0.99s
jul. 19, 2024 2:41:28 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
ADVERTÊNCIA: Unmatched cancel notification for request id 14849
jul. 19, 2024 2:41:29 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
ADVERTÊNCIA: Unmatched cancel notification for request id 14857
jul. 19, 2024 2:41:30 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
ADVERTÊNCIA: Unmatched cancel notification for request id 14866
jul. 19, 2024 2:41:30 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
ADVERTÊNCIA: Unmatched cancel notification for request id 14874
2024.07.19 14:41:45 INFO  compiling root (1 scala source)
2024.07.19 14:41:45 INFO  time: compiled root in 0.18s
2024.07.19 14:41:47 INFO  Can not organize imports if file has error
jul. 19, 2024 2:43:18 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
ADVERTÊNCIA: Unmatched cancel notification for request id 14989
jul. 19, 2024 2:43:26 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
ADVERTÊNCIA: Unmatched cancel notification for request id 14997
jul. 19, 2024 2:43:26 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
ADVERTÊNCIA: Unmatched cancel notification for request id 15006
jul. 19, 2024 2:43:27 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
ADVERTÊNCIA: Unmatched cancel notification for request id 15014
jul. 19, 2024 2:47:35 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
ADVERTÊNCIA: Unmatched cancel notification for request id 15032
jul. 19, 2024 2:47:37 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
ADVERTÊNCIA: Unmatched cancel notification for request id 15040
jul. 19, 2024 2:48:19 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
ADVERTÊNCIA: Unmatched cancel notification for request id 15053
jul. 19, 2024 2:48:20 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
ADVERTÊNCIA: Unmatched cancel notification for request id 15061
jul. 19, 2024 2:48:21 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
ADVERTÊNCIA: Unmatched cancel notification for request id 15070
jul. 19, 2024 2:48:21 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
ADVERTÊNCIA: Unmatched cancel notification for request id 15078
2024.07.19 18:12:36 INFO  compiling root (1 scala source)
2024.07.19 18:12:38 INFO  time: compiled root in 2.34s
2024.07.19 18:13:54 INFO  compiling root (1 scala source)
2024.07.19 18:13:54 INFO  time: compiled root in 0.21s
2024.07.19 18:13:58 INFO  Can not organize imports if file has error
2024.07.19 18:13:58 INFO  compiling root (1 scala source)
2024.07.19 18:13:59 INFO  time: compiled root in 1.09s
2024.07.19 18:14:19 INFO  compiling root-test (1 scala source)
2024.07.19 18:14:20 INFO  time: compiled root-test in 1.24s
2024.07.19 18:15:28 INFO  compiling root-test (1 scala source)
2024.07.19 18:15:30 INFO  time: compiled root-test in 1.01s
2024.07.19 18:15:33 INFO  compiling root-test (1 scala source)
2024.07.19 18:15:34 INFO  time: compiled root-test in 1.05s
jul. 19, 2024 6:16:00 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
ADVERTÊNCIA: Unmatched cancel notification for request id 15661
2024.07.19 18:16:37 INFO  compiling root (1 scala source)
2024.07.19 18:16:37 INFO  time: compiled root in 0.42s
2024.07.19 18:16:38 INFO  Can not organize imports if file has error
2024.07.19 18:16:37 INFO  compiling root (1 scala source)
2024.07.19 18:16:37 INFO  time: compiled root in 0.2s
2024.07.19 18:17:27 INFO  Can not organize imports if file has error
2024.07.19 18:17:27 INFO  compiling root (1 scala source)
2024.07.19 18:17:27 INFO  time: compiled root in 0.87s
2024.07.19 18:17:48 INFO  compiling root-test (1 scala source)
2024.07.19 18:17:49 INFO  time: compiled root-test in 1.19s
2024.07.19 18:17:57 INFO  compiling root-test (1 scala source)
2024.07.19 18:17:57 INFO  time: compiled root-test in 0.97s
jul. 19, 2024 6:18:23 PM scala.meta.internal.pc.CompilerAccess handleError
GRAVE: A severe compiler error occurred, full details of the error can be found in the error report C:\Users\Vinicius\UnB\FLanguage\.metals\.reports\metals-full\2024-07-19\r_compiler-error_(root)_18-18-23-554.md
2024.07.19 18:18:23 ERROR TextDocument.uri not found: src/main/scala/br/unb/cic/flang/Interpreter2.scala
scala.meta.internal.metals.ScalafixProvider$ScalafixRunException: TextDocument.uri not found: src/main/scala/br/unb/cic/flang/Interpreter2.scala
	at scala.meta.internal.metals.ScalafixProvider.$anonfun$runScalafixRules$2(ScalafixProvider.scala:130)
	at scala.concurrent.impl.Promise$Transformation.run(Promise.scala:470)
	at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.lang.Thread.run(Thread.java:833)

jul. 19, 2024 6:18:23 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint fallbackResponseError
GRAVE: Internal error: scala.meta.internal.metals.ScalafixProvider$ScalafixRunException: TextDocument.uri not found: src/main/scala/br/unb/cic/flang/Interpreter2.scala
java.util.concurrent.CompletionException: scala.meta.internal.metals.ScalafixProvider$ScalafixRunException: TextDocument.uri not found: src/main/scala/br/unb/cic/flang/Interpreter2.scala
	at java.base/java.util.concurrent.CompletableFuture.encodeThrowable(CompletableFuture.java:332)
	at java.base/java.util.concurrent.CompletableFuture.completeThrowable(CompletableFuture.java:347)
	at java.base/java.util.concurrent.CompletableFuture$UniAccept.tryFire(CompletableFuture.java:708)
	at java.base/java.util.concurrent.CompletableFuture.postComplete(CompletableFuture.java:510)
	at java.base/java.util.concurrent.CompletableFuture.completeExceptionally(CompletableFuture.java:2162)
	at scala.meta.internal.metals.CancelTokens$.$anonfun$future$1(CancelTokens.scala:40)
	at scala.meta.internal.metals.CancelTokens$.$anonfun$future$1$adapted(CancelTokens.scala:38)
	at scala.concurrent.impl.Promise$Transformation.run(Promise.scala:484)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.base/java.lang.Thread.run(Thread.java:833)
Caused by: scala.meta.internal.metals.ScalafixProvider$ScalafixRunException: TextDocument.uri not found: src/main/scala/br/unb/cic/flang/Interpreter2.scala
	at scala.meta.internal.metals.ScalafixProvider.$anonfun$runScalafixRules$2(ScalafixProvider.scala:130)
	at scala.concurrent.impl.Promise$Transformation.run(Promise.scala:470)
	... 3 more

2024.07.19 18:18:23 INFO  compiling root (1 scala source)
2024.07.19 18:18:23 INFO  time: compiled root in 0.13s
jul. 19, 2024 6:18:25 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
ADVERTÊNCIA: Unmatched cancel notification for request id 15908
2024.07.19 18:18:26 INFO  Can not organize imports if file has error
2024.07.19 18:18:26 INFO  compiling root (1 scala source)
2024.07.19 18:18:26 INFO  time: compiled root in 0.15s
2024.07.19 18:18:32 INFO  Can not organize imports if file has error
2024.07.19 18:18:32 INFO  compiling root (1 scala source)
2024.07.19 18:18:32 INFO  time: compiled root in 0.14s
2024.07.19 18:18:36 INFO  Can not organize imports if file has error
2024.07.19 18:18:36 INFO  compiling root (1 scala source)
2024.07.19 18:18:36 INFO  time: compiled root in 0.69s
2024.07.19 18:18:52 INFO  compiling root (1 scala source)
2024.07.19 18:18:52 INFO  time: compiled root in 0.82s
jul. 19, 2024 6:19:02 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
ADVERTÊNCIA: Unmatched cancel notification for request id 16063
2024.07.19 18:19:04 INFO  compiling root-test (1 scala source)
2024.07.19 18:19:04 WARN  Could not load snapshot text for C:\Users\Vinicius\UnB\FLanguage\src\test\scala\br\unb\cic\flang\MonadTest.scala
2024.07.19 18:19:05 WARN  Could not load snapshot text for C:\Users\Vinicius\UnB\FLanguage\src\test\scala\br\unb\cic\flang\MonadTest.scala
2024.07.19 18:19:06 INFO  Deduplicating compilation of root-test from bsp client 'Metals 1.3.3' (since 5h 56m 28.215s)
2024.07.19 18:19:06 INFO  compiling root-test (1 scala source)
2024.07.19 18:19:06 INFO  time: compiled root-test in 0.16s
2024.07.19 18:19:06 INFO  compiling root-test (1 scala source)
2024.07.19 18:19:07 INFO  time: compiled root-test in 0.58s
2024.07.19 18:19:27 INFO  compiling root-test (1 scala source)
2024.07.19 18:19:27 INFO  time: compiled root-test in 0.93s
2024.07.19 18:19:41 INFO  compiling root-test (1 scala source)
2024.07.19 18:19:41 INFO  time: compiled root-test in 0.22s
2024.07.19 18:21:14 INFO  compiling root (2 scala sources)
2024.07.19 18:21:14 INFO  time: compiled root in 0.15s
2024.07.19 18:21:32 INFO  Can not organize imports if file has error
2024.07.19 18:21:32 INFO  compiling root (2 scala sources)
2024.07.19 18:21:32 INFO  time: compiled root in 0.2s
jul. 19, 2024 6:21:32 PM scala.meta.internal.pc.CompilerAccess retryWithCleanCompiler
INFORMAÇÕES: compiler crashed due to an error in the Scala compiler, retrying with new compiler instance.
jul. 19, 2024 6:21:32 PM scala.meta.internal.pc.CompilerAccess handleError
GRAVE: A severe compiler error occurred, full details of the error can be found in the error report C:\Users\Vinicius\UnB\FLanguage\.metals\.reports\metals-full\2024-07-19\r_compiler-error_(root)_18-21-32-983.md
jul. 19, 2024 6:21:33 PM scala.meta.internal.pc.CompilerAccess retryWithCleanCompiler
INFORMAÇÕES: compiler crashed due to an error in the Scala compiler, retrying with new compiler instance.
jul. 19, 2024 6:21:34 PM scala.meta.internal.pc.CompilerAccess handleError
GRAVE: A severe compiler error occurred, full details of the error can be found in the error report C:\Users\Vinicius\UnB\FLanguage\.metals\.reports\metals-full\2024-07-19\r_compiler-error_(root)_18-21-34-057.md
jul. 19, 2024 6:21:34 PM scala.meta.internal.pc.CompilerAccess retryWithCleanCompiler
INFORMAÇÕES: compiler crashed due to an error in the Scala compiler, retrying with new compiler instance.
jul. 19, 2024 6:21:35 PM scala.meta.internal.pc.CompilerAccess handleError
GRAVE: A severe compiler error occurred, full details of the error can be found in the error report C:\Users\Vinicius\UnB\FLanguage\.metals\.reports\metals-full\2024-07-19\r_compiler-error_(root)_18-21-35-049.md
2024.07.19 18:21:36 INFO  Can not organize imports if file has error
jul. 19, 2024 6:21:36 PM scala.meta.internal.pc.CompilerAccess retryWithCleanCompiler
INFORMAÇÕES: compiler crashed due to an error in the Scala compiler, retrying with new compiler instance.
2024.07.19 18:21:37 INFO  compiling root (2 scala sources)
jul. 19, 2024 6:21:37 PM scala.meta.internal.pc.CompilerAccess handleError
GRAVE: A severe compiler error occurred, full details of the error can be found in the error report C:\Users\Vinicius\UnB\FLanguage\.metals\.reports\metals-full\2024-07-19\r_compiler-error_(root)_18-21-37-104.md
2024.07.19 18:21:37 INFO  time: compiled root in 0.26s
2024.07.19 18:21:50 INFO  Can not organize imports if file has error
2024.07.19 18:21:50 INFO  compiling root (2 scala sources)
2024.07.19 18:21:50 INFO  time: compiled root in 0.16s
jul. 19, 2024 6:22:01 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
ADVERTÊNCIA: Unmatched cancel notification for request id 16527
jul. 19, 2024 6:22:05 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
ADVERTÊNCIA: Unmatched cancel notification for request id 16535
2024.07.19 18:22:07 INFO  Can not organize imports if file has error
2024.07.19 18:22:07 INFO  compiling root (2 scala sources)
2024.07.19 18:22:07 INFO  time: compiled root in 0.2s
Exception in thread "pool-7-thread-2" java.lang.InterruptedException
	at scala.meta.internal.metals.FutureCancelToken.checkCanceled(FutureCancelToken.scala:29)
	at scala.meta.internal.pc.CompilerAccess.$anonfun$onCompilerJobQueue$1(CompilerAccess.scala:243)
	at scala.meta.internal.pc.CompilerJobQueue$Job.run(CompilerJobQueue.scala:152)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.base/java.lang.Thread.run(Thread.java:833)
jul. 19, 2024 6:22:18 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
ADVERTÊNCIA: Unmatched cancel notification for request id 16587
jul. 19, 2024 6:22:26 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
ADVERTÊNCIA: Unmatched cancel notification for request id 16595
jul. 19, 2024 6:22:28 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
ADVERTÊNCIA: Unmatched cancel notification for request id 16604
jul. 19, 2024 6:22:33 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
ADVERTÊNCIA: Unmatched cancel notification for request id 16614
jul. 19, 2024 6:22:33 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
ADVERTÊNCIA: Unmatched cancel notification for request id 16623
jul. 19, 2024 6:22:34 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
ADVERTÊNCIA: Unmatched cancel notification for request id 16631
jul. 19, 2024 6:22:35 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
ADVERTÊNCIA: Unmatched cancel notification for request id 16640
jul. 19, 2024 6:22:37 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
ADVERTÊNCIA: Unmatched cancel notification for request id 16648
jul. 19, 2024 6:23:25 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
ADVERTÊNCIA: Unmatched cancel notification for request id 16741
jul. 19, 2024 6:23:25 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
ADVERTÊNCIA: Unmatched cancel notification for request id 16745
jul. 19, 2024 6:23:26 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
ADVERTÊNCIA: Unmatched cancel notification for request id 16753
2024.07.19 18:24:02 INFO  Can not organize imports if file has error
2024.07.19 18:24:02 INFO  compiling root (2 scala sources)
2024.07.19 18:24:02 INFO  time: compiled root in 0.83s
2024.07.19 18:24:04 INFO  compiling root (2 scala sources)
2024.07.19 18:24:04 INFO  time: compiled root in 0.39s
jul. 19, 2024 6:24:08 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
ADVERTÊNCIA: Unmatched cancel notification for request id 16830
2024.07.19 18:24:08 INFO  compiling root-test (1 scala source)
2024.07.19 18:24:08 INFO  time: compiled root-test in 0.41s
2024.07.19 18:24:14 INFO  Can not organize imports if file has error
2024.07.19 18:24:14 INFO  compiling root-test (1 scala source)
2024.07.19 18:24:14 INFO  time: compiled root-test in 0.91s
2024.07.19 18:24:23 INFO  compiling root-test (1 scala source)
2024.07.19 18:24:23 INFO  time: compiled root-test in 0.9s
jul. 19, 2024 6:24:58 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
ADVERTÊNCIA: Unmatched cancel notification for request id 16985
jul. 19, 2024 6:25:05 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
ADVERTÊNCIA: Unmatched cancel notification for request id 17007
jul. 19, 2024 6:25:08 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
ADVERTÊNCIA: Unmatched cancel notification for request id 17016
jul. 19, 2024 6:25:12 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
ADVERTÊNCIA: Unmatched cancel notification for request id 17028
2024.07.19 18:25:21 INFO  compiling root (2 scala sources)
2024.07.19 18:25:21 INFO  time: compiled root in 0.92s
jul. 19, 2024 6:25:23 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
ADVERTÊNCIA: Unmatched cancel notification for request id 17073
2024.07.19 18:25:23 INFO  compiling root-test (1 scala source)
2024.07.19 18:25:23 INFO  time: compiled root-test in 0.3s
2024.07.19 18:25:36 INFO  Can not organize imports if file has error
2024.07.19 18:25:36 INFO  compiling root-test (1 scala source)
2024.07.19 18:25:36 INFO  time: compiled root-test in 0.92s
jul. 19, 2024 6:25:49 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
ADVERTÊNCIA: Unmatched cancel notification for request id 17185
2024.07.19 18:25:59 INFO  compiling root (2 scala sources)
2024.07.19 18:26:00 INFO  time: compiled root in 1.18s
jul. 19, 2024 6:26:00 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
ADVERTÊNCIA: Unmatched cancel notification for request id 17210
jul. 19, 2024 6:26:07 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
ADVERTÊNCIA: Unmatched cancel notification for request id 17250
2024.07.19 18:26:09 INFO  compiling root (2 scala sources)
2024.07.19 18:26:09 INFO  time: compiled root in 0.87s
2024.07.19 18:26:35 INFO  compiling root-test (1 scala source)
2024.07.19 18:26:35 INFO  time: compiled root-test in 0.21s
2024.07.19 18:26:38 INFO  Can not organize imports if file has error
2024.07.19 18:26:38 INFO  compiling root-test (1 scala source)
2024.07.19 18:26:38 INFO  time: compiled root-test in 0.95s
2024.07.19 18:26:43 INFO  compiling root-test (1 scala source)
2024.07.19 18:26:43 INFO  time: compiled root-test in 0.89s
2024.07.19 18:26:56 INFO  compiling root-test (1 scala source)
2024.07.19 18:26:57 INFO  time: compiled root-test in 1.16s
2024.07.19 18:27:04 INFO  compiling root-test (1 scala source)
2024.07.19 18:27:04 INFO  time: compiled root-test in 0.97s
jul. 19, 2024 6:27:11 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
ADVERTÊNCIA: Unmatched cancel notification for request id 17472
2024.07.19 18:27:31 INFO  compiling root (2 scala sources)
2024.07.19 18:27:31 INFO  time: compiled root in 0.19s
2024.07.19 18:28:06 WARN  Using indexes to guess the definition of eval
2024.07.19 18:28:24 INFO  Can not organize imports if file has error
2024.07.19 18:28:24 INFO  compiling root (2 scala sources)
2024.07.19 18:28:24 INFO  time: compiled root in 0.13s
2024.07.19 18:28:35 WARN  Using indexes to guess the definition of eval
2024.07.19 18:28:36 INFO  Can not organize imports if file has error
2024.07.19 18:28:36 INFO  compiling root (2 scala sources)
2024.07.19 18:28:36 INFO  time: compiled root in 0.18s
2024.07.19 18:29:14 INFO  Can not organize imports if file has error
2024.07.19 18:29:15 INFO  compiling root (2 scala sources)
2024.07.19 18:29:15 INFO  time: compiled root in 0.98s
2024.07.19 18:29:33 INFO  compiling root-test (1 scala source)
2024.07.19 18:29:33 INFO  time: compiled root-test in 0.26s
2024.07.19 18:29:42 WARN  Using indexes to guess the definition of eval
2024.07.19 18:29:42 WARN  Using indexes to guess the definition of runState
jul. 19, 2024 6:29:42 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
ADVERTÊNCIA: Unmatched cancel notification for request id 17947
2024.07.19 18:29:44 INFO  Can not organize imports if file has error
2024.07.19 18:29:44 INFO  compiling root-test (1 scala source)
2024.07.19 18:29:44 INFO  time: compiled root-test in 0.96s
2024.07.19 18:30:31 INFO  compiling root-test (1 scala source)
2024.07.19 18:30:31 INFO  time: compiled root-test in 0.95s
jul. 19, 2024 6:30:47 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
ADVERTÊNCIA: Unmatched cancel notification for request id 18040
jul. 19, 2024 6:30:48 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
ADVERTÊNCIA: Unmatched cancel notification for request id 18048
jul. 19, 2024 6:30:49 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
ADVERTÊNCIA: Unmatched cancel notification for request id 18056
jul. 19, 2024 6:31:03 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
ADVERTÊNCIA: Unmatched cancel notification for request id 18072
jul. 19, 2024 6:31:04 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
ADVERTÊNCIA: Unmatched cancel notification for request id 18080
jul. 19, 2024 6:31:19 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
ADVERTÊNCIA: Unmatched cancel notification for request id 18089
jul. 19, 2024 6:31:20 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
ADVERTÊNCIA: Unmatched cancel notification for request id 18097
jul. 19, 2024 6:31:21 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
ADVERTÊNCIA: Unmatched cancel notification for request id 18105
2024.07.19 18:31:23 INFO  compiling root-test (1 scala source)
2024.07.19 18:31:24 INFO  time: compiled root-test in 1.24s
jul. 19, 2024 6:31:29 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
ADVERTÊNCIA: Unmatched cancel notification for request id 18132
jul. 19, 2024 6:31:47 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
ADVERTÊNCIA: Unmatched cancel notification for request id 18152
jul. 19, 2024 6:31:50 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
ADVERTÊNCIA: Unmatched cancel notification for request id 18162
jul. 19, 2024 6:31:51 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
ADVERTÊNCIA: Unmatched cancel notification for request id 18170
2024.07.19 18:31:54 INFO  compiling root (2 scala sources)
2024.07.19 18:31:54 INFO  time: compiled root in 0.24s
2024.07.19 18:32:12 INFO  Can not organize imports if file has error
2024.07.19 18:32:12 INFO  compiling root (2 scala sources)
2024.07.19 18:32:12 INFO  time: compiled root in 0.29s
2024.07.19 18:32:16 INFO  Can not organize imports if file has error
2024.07.19 18:32:16 INFO  compiling root (2 scala sources)
2024.07.19 18:32:16 INFO  time: compiled root in 0.21s
2024.07.19 18:32:19 INFO  Can not organize imports if file has error
2024.07.19 18:32:19 INFO  compiling root (2 scala sources)
2024.07.19 18:32:19 INFO  time: compiled root in 0.17s
2024.07.19 18:32:22 INFO  Can not organize imports if file has error
2024.07.19 18:32:22 INFO  compiling root (2 scala sources)
2024.07.19 18:32:22 INFO  time: compiled root in 0.96s
2024.07.19 18:32:29 INFO  compiling root-test (1 scala source)
2024.07.19 18:32:29 INFO  time: compiled root-test in 0.22s
2024.07.19 18:32:35 INFO  Can not organize imports if file has error
2024.07.19 18:32:35 INFO  compiling root-test (1 scala source)
2024.07.19 18:32:35 INFO  time: compiled root-test in 0.28s
jul. 19, 2024 6:32:38 PM scala.meta.internal.pc.CompilerAccess retryWithCleanCompiler
INFORMAÇÕES: compiler crashed due to an error in the Scala compiler, retrying with new compiler instance.
jul. 19, 2024 6:32:38 PM scala.meta.internal.pc.CompilerAccess handleError
GRAVE: A severe compiler error occurred, full details of the error can be found in the error report C:\Users\Vinicius\UnB\FLanguage\.metals\.reports\metals-full\2024-07-19\r_compiler-error_(root-test)_18-32-38-158.md
jul. 19, 2024 6:32:38 PM scala.meta.internal.pc.CompilerAccess retryWithCleanCompiler
INFORMAÇÕES: compiler crashed due to an error in the Scala compiler, retrying with new compiler instance.
jul. 19, 2024 6:32:38 PM scala.meta.internal.pc.CompilerAccess handleError
GRAVE: A severe compiler error occurred, full details of the error can be found in the error report C:\Users\Vinicius\UnB\FLanguage\.metals\.reports\metals-full\2024-07-19\r_compiler-error_(root-test)_18-32-38-770.md
jul. 19, 2024 6:32:40 PM scala.meta.internal.pc.CompilerAccess retryWithCleanCompiler
INFORMAÇÕES: compiler crashed due to an error in the Scala compiler, retrying with new compiler instance.
jul. 19, 2024 6:32:40 PM scala.meta.internal.pc.CompilerAccess handleError
GRAVE: A severe compiler error occurred, full details of the error can be found in the error report C:\Users\Vinicius\UnB\FLanguage\.metals\.reports\metals-full\2024-07-19\r_compiler-error_(root-test)_18-32-40-574.md
2024.07.19 18:32:41 INFO  Can not organize imports if file has error
jul. 19, 2024 6:32:41 PM scala.meta.internal.pc.CompilerAccess retryWithCleanCompiler
INFORMAÇÕES: compiler crashed due to an error in the Scala compiler, retrying with new compiler instance.
2024.07.19 18:32:41 INFO  compiling root-test (1 scala source)
jul. 19, 2024 6:32:41 PM scala.meta.internal.pc.CompilerAccess handleError
GRAVE: A severe compiler error occurred, full details of the error can be found in the error report C:\Users\Vinicius\UnB\FLanguage\.metals\.reports\metals-full\2024-07-19\r_compiler-error_(root-test)_18-32-41-348.md
2024.07.19 18:32:41 INFO  time: compiled root-test in 0.98s
2024.07.19 18:32:49 INFO  compiling root-test (1 scala source)
2024.07.19 18:32:49 INFO  time: compiled root-test in 0.96s
jul. 19, 2024 6:32:54 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
ADVERTÊNCIA: Unmatched cancel notification for request id 18448
2024.07.19 18:33:59 INFO  compiling root (2 scala sources)
2024.07.19 18:33:59 INFO  time: compiled root in 0.22s
jul. 19, 2024 6:34:08 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
ADVERTÊNCIA: Unmatched cancel notification for request id 18537
2024.07.19 18:34:45 INFO  compiling root (2 scala sources)
2024.07.19 18:34:45 INFO  time: compiled root in 0.17s
2024.07.19 18:34:56 INFO  Can not organize imports if file has error
2024.07.19 18:34:56 INFO  Can not organize imports if file has error
2024.07.19 18:34:56 INFO  compiling root (2 scala sources)
2024.07.19 18:34:56 INFO  time: compiled root in 0.23s
2024.07.19 18:34:56 INFO  compiling root (2 scala sources)
2024.07.19 18:34:56 INFO  time: compiled root in 0.43s
2024.07.19 18:34:57 WARN  Attempt to organize your imports failed. It looks like you have compilation issues causing your semanticdb to be stale. Ensure everything is compiling and try again.
2024.07.19 18:34:56 INFO  compiling root (2 scala sources)
2024.07.19 18:34:56 INFO  time: compiled root in 0.19s
jul. 19, 2024 6:35:20 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
ADVERTÊNCIA: Unmatched cancel notification for request id 18716
jul. 19, 2024 6:35:24 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
ADVERTÊNCIA: Unmatched cancel notification for request id 18724
jul. 19, 2024 6:35:46 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
ADVERTÊNCIA: Unmatched cancel notification for request id 18733
jul. 19, 2024 6:35:48 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
ADVERTÊNCIA: Unmatched cancel notification for request id 18741
2024.07.19 18:36:16 INFO  compiling root (2 scala sources)
2024.07.19 18:36:16 INFO  time: compiled root in 0.22s
jul. 19, 2024 6:36:17 PM scala.meta.internal.pc.CompilerAccess retryWithCleanCompiler
INFORMAÇÕES: compiler crashed due to an error in the Scala compiler, retrying with new compiler instance.
jul. 19, 2024 6:36:17 PM scala.meta.internal.pc.CompilerAccess handleError
GRAVE: A severe compiler error occurred, full details of the error can be found in the error report C:\Users\Vinicius\UnB\FLanguage\.metals\.reports\metals-full\2024-07-19\r_compiler-error_(root)_18-36-17-377.md
jul. 19, 2024 6:36:18 PM scala.meta.internal.pc.CompilerAccess retryWithCleanCompiler
INFORMAÇÕES: compiler crashed due to an error in the Scala compiler, retrying with new compiler instance.
jul. 19, 2024 6:36:18 PM scala.meta.internal.pc.CompilerAccess handleError
GRAVE: A severe compiler error occurred, full details of the error can be found in the error report C:\Users\Vinicius\UnB\FLanguage\.metals\.reports\metals-full\2024-07-19\r_compiler-error_(root)_18-36-18-457.md
jul. 19, 2024 6:36:21 PM scala.meta.internal.pc.CompilerAccess retryWithCleanCompiler
INFORMAÇÕES: compiler crashed due to an error in the Scala compiler, retrying with new compiler instance.
jul. 19, 2024 6:36:21 PM scala.meta.internal.pc.CompilerAccess handleError
GRAVE: A severe compiler error occurred, full details of the error can be found in the error report C:\Users\Vinicius\UnB\FLanguage\.metals\.reports\metals-full\2024-07-19\r_compiler-error_(root)_18-36-21-867.md
jul. 19, 2024 6:36:22 PM scala.meta.internal.pc.CompilerAccess retryWithCleanCompiler
INFORMAÇÕES: compiler crashed due to an error in the Scala compiler, retrying with new compiler instance.
jul. 19, 2024 6:36:23 PM scala.meta.internal.pc.CompilerAccess handleError
GRAVE: A severe compiler error occurred, full details of the error can be found in the error report C:\Users\Vinicius\UnB\FLanguage\.metals\.reports\metals-full\2024-07-19\r_compiler-error_(root)_18-36-23-162.md
2024.07.19 18:36:23 INFO  Can not organize imports if file has error
2024.07.19 18:36:23 INFO  compiling root (2 scala sources)
2024.07.19 18:36:23 INFO  time: compiled root in 0.21s
2024.07.19 18:36:30 INFO  compiling root (2 scala sources)
2024.07.19 18:36:30 INFO  time: compiled root in 0.23s
jul. 19, 2024 6:36:31 PM scala.meta.internal.pc.CompilerAccess retryWithCleanCompiler
INFORMAÇÕES: compiler crashed due to an error in the Scala compiler, retrying with new compiler instance.
jul. 19, 2024 6:36:31 PM scala.meta.internal.pc.CompilerAccess handleError
GRAVE: A severe compiler error occurred, full details of the error can be found in the error report C:\Users\Vinicius\UnB\FLanguage\.metals\.reports\metals-full\2024-07-19\r_compiler-error_(root)_18-36-31-645.md
jul. 19, 2024 6:36:31 PM scala.meta.internal.pc.CompilerAccess retryWithCleanCompiler
INFORMAÇÕES: compiler crashed due to an error in the Scala compiler, retrying with new compiler instance.
jul. 19, 2024 6:36:32 PM scala.meta.internal.pc.CompilerAccess handleError
GRAVE: A severe compiler error occurred, full details of the error can be found in the error report C:\Users\Vinicius\UnB\FLanguage\.metals\.reports\metals-full\2024-07-19\r_compiler-error_(root)_18-36-32-164.md
jul. 19, 2024 6:36:32 PM scala.meta.internal.pc.CompilerAccess retryWithCleanCompiler
INFORMAÇÕES: compiler crashed due to an error in the Scala compiler, retrying with new compiler instance.
jul. 19, 2024 6:36:32 PM scala.meta.internal.pc.CompilerAccess handleError
GRAVE: A severe compiler error occurred, full details of the error can be found in the error report C:\Users\Vinicius\UnB\FLanguage\.metals\.reports\metals-full\2024-07-19\r_compiler-error_(root)_18-36-32-673.md
jul. 19, 2024 6:36:33 PM scala.meta.internal.pc.CompilerAccess retryWithCleanCompiler
INFORMAÇÕES: compiler crashed due to an error in the Scala compiler, retrying with new compiler instance.
jul. 19, 2024 6:36:33 PM scala.meta.internal.pc.CompilerAccess handleError
GRAVE: A severe compiler error occurred, full details of the error can be found in the error report C:\Users\Vinicius\UnB\FLanguage\.metals\.reports\metals-full\2024-07-19\r_compiler-error_(root)_18-36-33-353.md
jul. 19, 2024 6:36:34 PM scala.meta.internal.pc.CompilerAccess retryWithCleanCompiler
INFORMAÇÕES: compiler crashed due to an error in the Scala compiler, retrying with new compiler instance.
jul. 19, 2024 6:36:35 PM scala.meta.internal.pc.CompilerAccess handleError
GRAVE: A severe compiler error occurred, full details of the error can be found in the error report C:\Users\Vinicius\UnB\FLanguage\.metals\.reports\metals-full\2024-07-19\r_compiler-error_(root)_18-36-35-308.md
jul. 19, 2024 6:36:36 PM scala.meta.internal.pc.CompilerAccess retryWithCleanCompiler
INFORMAÇÕES: compiler crashed due to an error in the Scala compiler, retrying with new compiler instance.
jul. 19, 2024 6:36:37 PM scala.meta.internal.pc.CompilerAccess handleError
GRAVE: A severe compiler error occurred, full details of the error can be found in the error report C:\Users\Vinicius\UnB\FLanguage\.metals\.reports\metals-full\2024-07-19\r_compiler-error_(root)_18-36-37-094.md
jul. 19, 2024 6:36:41 PM scala.meta.internal.pc.CompilerAccess retryWithCleanCompiler
INFORMAÇÕES: compiler crashed due to an error in the Scala compiler, retrying with new compiler instance.
jul. 19, 2024 6:36:41 PM scala.meta.internal.pc.CompilerAccess handleError
GRAVE: A severe compiler error occurred, full details of the error can be found in the error report C:\Users\Vinicius\UnB\FLanguage\.metals\.reports\metals-full\2024-07-19\r_compiler-error_(root)_18-36-41-690.md
jul. 19, 2024 6:36:43 PM scala.meta.internal.pc.CompilerAccess retryWithCleanCompiler
INFORMAÇÕES: compiler crashed due to an error in the Scala compiler, retrying with new compiler instance.
jul. 19, 2024 6:36:44 PM scala.meta.internal.pc.CompilerAccess handleError
GRAVE: A severe compiler error occurred, full details of the error can be found in the error report C:\Users\Vinicius\UnB\FLanguage\.metals\.reports\metals-full\2024-07-19\r_compiler-error_(root)_18-36-44-183.md
jul. 19, 2024 6:36:45 PM scala.meta.internal.pc.CompilerAccess retryWithCleanCompiler
INFORMAÇÕES: compiler crashed due to an error in the Scala compiler, retrying with new compiler instance.
jul. 19, 2024 6:36:45 PM scala.meta.internal.pc.CompilerAccess handleError
GRAVE: A severe compiler error occurred, full details of the error can be found in the error report C:\Users\Vinicius\UnB\FLanguage\.metals\.reports\metals-full\2024-07-19\r_compiler-error_(root)_18-36-45-481.md
jul. 19, 2024 6:36:47 PM scala.meta.internal.pc.CompilerAccess retryWithCleanCompiler
INFORMAÇÕES: compiler crashed due to an error in the Scala compiler, retrying with new compiler instance.
jul. 19, 2024 6:36:47 PM scala.meta.internal.pc.CompilerAccess handleError
GRAVE: A severe compiler error occurred, full details of the error can be found in the error report C:\Users\Vinicius\UnB\FLanguage\.metals\.reports\metals-full\2024-07-19\r_compiler-error_(root)_18-36-47-388.md
jul. 19, 2024 6:36:47 PM scala.meta.internal.pc.CompilerAccess retryWithCleanCompiler
INFORMAÇÕES: compiler crashed due to an error in the Scala compiler, retrying with new compiler instance.
jul. 19, 2024 6:36:48 PM scala.meta.internal.pc.CompilerAccess handleError
GRAVE: A severe compiler error occurred, full details of the error can be found in the error report C:\Users\Vinicius\UnB\FLanguage\.metals\.reports\metals-full\2024-07-19\r_compiler-error_(root)_18-36-48-051.md
jul. 19, 2024 6:36:52 PM scala.meta.internal.pc.CompilerAccess retryWithCleanCompiler
INFORMAÇÕES: compiler crashed due to an error in the Scala compiler, retrying with new compiler instance.
jul. 19, 2024 6:36:52 PM scala.meta.internal.pc.CompilerAccess handleError
GRAVE: A severe compiler error occurred, full details of the error can be found in the error report C:\Users\Vinicius\UnB\FLanguage\.metals\.reports\metals-full\2024-07-19\r_compiler-error_(root)_18-36-52-509.md
jul. 19, 2024 6:36:53 PM scala.meta.internal.pc.CompilerAccess retryWithCleanCompiler
INFORMAÇÕES: compiler crashed due to an error in the Scala compiler, retrying with new compiler instance.
jul. 19, 2024 6:36:53 PM scala.meta.internal.pc.CompilerAccess handleError
GRAVE: A severe compiler error occurred, full details of the error can be found in the error report C:\Users\Vinicius\UnB\FLanguage\.metals\.reports\metals-full\2024-07-19\r_compiler-error_(root)_18-36-53-622.md
jul. 19, 2024 6:37:32 PM scala.meta.internal.pc.CompilerAccess retryWithCleanCompiler
INFORMAÇÕES: compiler crashed due to an error in the Scala compiler, retrying with new compiler instance.
2024.07.19 18:37:32 INFO  Can not organize imports if file has error
2024.07.19 18:37:32 INFO  compiling root (2 scala sources)
2024.07.19 18:37:32 INFO  time: compiled root in 0.26s
jul. 19, 2024 6:37:32 PM scala.meta.internal.pc.CompilerAccess handleError
GRAVE: A severe compiler error occurred, full details of the error can be found in the error report C:\Users\Vinicius\UnB\FLanguage\.metals\.reports\metals-full\2024-07-19\r_compiler-error_(root)_18-37-32-822.md
jul. 19, 2024 6:38:19 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
ADVERTÊNCIA: Unmatched cancel notification for request id 18943
Exception in thread "pool-7-thread-3" java.lang.InterruptedException
	at scala.meta.internal.metals.FutureCancelToken.checkCanceled(FutureCancelToken.scala:29)
	at scala.meta.internal.pc.CompilerAccess.$anonfun$onCompilerJobQueue$1(CompilerAccess.scala:243)
	at scala.meta.internal.pc.CompilerJobQueue$Job.run(CompilerJobQueue.scala:152)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.base/java.lang.Thread.run(Thread.java:833)
2024.07.19 18:44:38 WARN  Using indexes to guess the definition of get
2024.07.19 18:44:38 WARN  Using indexes to guess the definition of get
jul. 19, 2024 6:44:38 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
ADVERTÊNCIA: Unmatched cancel notification for request id 19226
jul. 19, 2024 6:44:38 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
ADVERTÊNCIA: Unmatched cancel notification for request id 19231
2024.07.19 18:44:38 INFO  compiling root (2 scala sources)
2024.07.19 18:44:38 INFO  time: compiled root in 0.26s
2024.07.19 18:44:40 WARN  Attempt to organize your imports failed. It looks like you have compilation issues causing your semanticdb to be stale. Ensure everything is compiling and try again.
2024.07.19 18:44:40 INFO  compiling root (2 scala sources)
2024.07.19 18:44:40 INFO  time: compiled root in 0.26s
2024.07.19 18:44:42 INFO  compiling root (2 scala sources)
2024.07.19 18:44:42 INFO  time: compiled root in 0.21s
2024.07.19 18:44:52 INFO  Can not organize imports if file has error
2024.07.19 18:44:52 INFO  compiling root (2 scala sources)
2024.07.19 18:44:52 INFO  time: compiled root in 0.21s
2024.07.19 18:45:02 INFO  compiling root (2 scala sources)
2024.07.19 18:45:02 INFO  time: compiled root in 0.29s
2024.07.19 18:45:30 INFO  compiling root (2 scala sources)
2024.07.19 18:45:30 INFO  time: compiled root in 0.27s
2024.07.19 18:47:24 INFO  compiling root (2 scala sources)
2024.07.19 18:47:24 INFO  time: compiled root in 0.2s
2024.07.19 18:47:25 WARN  Attempt to organize your imports failed. It looks like you have compilation issues causing your semanticdb to be stale. Ensure everything is compiling and try again.
2024.07.19 18:47:25 INFO  compiling root (2 scala sources)
2024.07.19 18:47:25 INFO  time: compiled root in 0.24s
2024.07.19 18:47:27 INFO  compiling root (2 scala sources)
2024.07.19 18:47:27 INFO  time: compiled root in 0.29s
2024.07.19 18:47:27 INFO  compiling root (2 scala sources)
2024.07.19 18:47:28 INFO  time: compiled root in 0.21s
2024.07.19 18:47:29 INFO  compiling root (2 scala sources)
2024.07.19 18:47:29 INFO  time: compiled root in 0.26s
2024.07.19 18:47:32 INFO  compiling root (2 scala sources)
2024.07.19 18:47:32 INFO  time: compiled root in 0.38s
jul. 19, 2024 6:47:35 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
ADVERTÊNCIA: Unmatched cancel notification for request id 19569
2024.07.19 18:47:35 INFO  compiling root (2 scala sources)
2024.07.19 18:47:35 INFO  time: compiled root in 0.24s
2024.07.19 18:47:38 INFO  compiling root (2 scala sources)
2024.07.19 18:47:38 INFO  time: compiled root in 0.37s
2024.07.19 18:47:40 INFO  compiling root (2 scala sources)
2024.07.19 18:47:40 INFO  time: compiled root in 0.28s
2024.07.19 18:47:44 INFO  compiling root (2 scala sources)
2024.07.19 18:47:44 INFO  time: compiled root in 0.38s
2024.07.19 18:47:45 INFO  compiling root (2 scala sources)
2024.07.19 18:47:45 INFO  time: compiled root in 0.3s
2024.07.19 18:47:54 INFO  compiling root (2 scala sources)
2024.07.19 18:47:54 INFO  time: compiled root in 0.36s
2024.07.19 18:47:57 INFO  Can not organize imports if file has error
2024.07.19 18:47:57 INFO  compiling root (2 scala sources)
2024.07.19 18:47:58 INFO  time: compiled root in 1.25s
2024.07.19 18:47:58 INFO  compiling root-test (1 scala source)
2024.07.19 18:47:58 INFO  time: compiled root-test in 0.32s
2024.07.19 18:48:08 INFO  Can not organize imports if file has error
2024.07.19 18:48:08 INFO  compiling root-test (1 scala source)
2024.07.19 18:48:08 INFO  time: compiled root-test in 0.3s
2024.07.19 18:48:11 INFO  Can not organize imports if file has error
2024.07.19 18:48:11 INFO  compiling root-test (1 scala source)
2024.07.19 18:48:11 INFO  time: compiled root-test in 0.26s
2024.07.19 18:48:14 INFO  Can not organize imports if file has error
2024.07.19 18:48:14 INFO  compiling root-test (1 scala source)
2024.07.19 18:48:15 INFO  time: compiled root-test in 1.21s
jul. 19, 2024 6:48:26 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
ADVERTÊNCIA: Unmatched cancel notification for request id 19739
jul. 19, 2024 6:48:28 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
ADVERTÊNCIA: Unmatched cancel notification for request id 19757
2024.07.19 18:49:02 INFO  compiling root (2 scala sources)
2024.07.19 18:49:02 INFO  time: compiled root in 0.98s
2024.07.19 18:49:12 INFO  compiling root-test (1 scala source)
2024.07.19 18:49:13 INFO  time: compiled root-test in 1.06s
jul. 19, 2024 6:52:21 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
ADVERTÊNCIA: Unmatched cancel notification for request id 19874
jul. 19, 2024 6:52:32 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
ADVERTÊNCIA: Unmatched cancel notification for request id 19879
jul. 19, 2024 6:58:04 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
ADVERTÊNCIA: Unmatched cancel notification for request id 20521
2024.07.19 19:00:44 ERROR Failed to tokenize input for semantic tokens for C:\Users\Vinicius\UnB\FLanguage\src\test\scala\br\unb\cic\flang\MonadTest.scala
scala.meta.tokenizers.TokenizeException: <input>:51: error: unclosed string literal
    declareVar("initialState)
               ^
	at scala.meta.internal.tokenizers.Reporter.syntaxError(Reporter.scala:23)
	at scala.meta.internal.tokenizers.Reporter.syntaxError$(Reporter.scala:23)
	at scala.meta.internal.tokenizers.Reporter$$anon$1.syntaxError(Reporter.scala:32)
	at scala.meta.internal.tokenizers.Reporter.syntaxError(Reporter.scala:25)
	at scala.meta.internal.tokenizers.Reporter.syntaxError$(Reporter.scala:25)
	at scala.meta.internal.tokenizers.Reporter$$anon$1.syntaxError(Reporter.scala:32)
	at scala.meta.internal.tokenizers.LegacyScanner.getStringLit(LegacyScanner.scala:509)
	at scala.meta.internal.tokenizers.LegacyScanner.fetchDoubleQuote$1(LegacyScanner.scala:361)
	at scala.meta.internal.tokenizers.LegacyScanner.fetchToken(LegacyScanner.scala:363)
	at scala.meta.internal.tokenizers.LegacyScanner.nextToken(LegacyScanner.scala:201)
	at scala.meta.internal.tokenizers.LegacyScanner.foreach(LegacyScanner.scala:912)
	at scala.meta.internal.tokenizers.ScalametaTokenizer.uncachedTokenize(ScalametaTokenizer.scala:23)
	at scala.meta.internal.tokenizers.ScalametaTokenizer.$anonfun$tokenize$1(ScalametaTokenizer.scala:17)
	at scala.collection.concurrent.TrieMap.getOrElseUpdate(TrieMap.scala:960)
	at scala.meta.internal.tokenizers.ScalametaTokenizer.tokenize(ScalametaTokenizer.scala:17)
	at scala.meta.internal.tokenizers.ScalametaTokenizer$$anon$2.apply(ScalametaTokenizer.scala:322)
	at scala.meta.tokenizers.Api$XtensionTokenizeDialectInput.tokenize(Api.scala:22)
	at scala.meta.tokenizers.Api$XtensionTokenizeInputLike.tokenize(Api.scala:13)
	at scala.meta.internal.metals.SemanticTokensProvider$.getTokens(SemanticTokensProvider.scala:30)
	at scala.meta.internal.metals.SemanticTokensProvider$.provide(SemanticTokensProvider.scala:89)
	at scala.meta.internal.metals.Compilers.$anonfun$semanticTokens$3(Compilers.scala:545)
	at scala.concurrent.impl.Promise$Transformation.run(Promise.scala:467)
	at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.lang.Thread.run(Thread.java:833)

2024.07.19 19:00:45 ERROR Failed to tokenize input for semantic tokens for C:\Users\Vinicius\UnB\FLanguage\src\test\scala\br\unb\cic\flang\MonadTest.scala
scala.meta.tokenizers.TokenizeException: <input>:51: error: unclosed string literal
    declareVar("xinitialState)
               ^
	at scala.meta.internal.tokenizers.Reporter.syntaxError(Reporter.scala:23)
	at scala.meta.internal.tokenizers.Reporter.syntaxError$(Reporter.scala:23)
	at scala.meta.internal.tokenizers.Reporter$$anon$1.syntaxError(Reporter.scala:32)
	at scala.meta.internal.tokenizers.Reporter.syntaxError(Reporter.scala:25)
	at scala.meta.internal.tokenizers.Reporter.syntaxError$(Reporter.scala:25)
	at scala.meta.internal.tokenizers.Reporter$$anon$1.syntaxError(Reporter.scala:32)
	at scala.meta.internal.tokenizers.LegacyScanner.getStringLit(LegacyScanner.scala:509)
	at scala.meta.internal.tokenizers.LegacyScanner.fetchDoubleQuote$1(LegacyScanner.scala:361)
	at scala.meta.internal.tokenizers.LegacyScanner.fetchToken(LegacyScanner.scala:363)
	at scala.meta.internal.tokenizers.LegacyScanner.nextToken(LegacyScanner.scala:201)
	at scala.meta.internal.tokenizers.LegacyScanner.foreach(LegacyScanner.scala:912)
	at scala.meta.internal.tokenizers.ScalametaTokenizer.uncachedTokenize(ScalametaTokenizer.scala:23)
	at scala.meta.internal.tokenizers.ScalametaTokenizer.$anonfun$tokenize$1(ScalametaTokenizer.scala:17)
	at scala.collection.concurrent.TrieMap.getOrElseUpdate(TrieMap.scala:960)
	at scala.meta.internal.tokenizers.ScalametaTokenizer.tokenize(ScalametaTokenizer.scala:17)
	at scala.meta.internal.tokenizers.ScalametaTokenizer$$anon$2.apply(ScalametaTokenizer.scala:322)
	at scala.meta.tokenizers.Api$XtensionTokenizeDialectInput.tokenize(Api.scala:22)
	at scala.meta.tokenizers.Api$XtensionTokenizeInputLike.tokenize(Api.scala:13)
	at scala.meta.internal.metals.SemanticTokensProvider$.getTokens(SemanticTokensProvider.scala:30)
	at scala.meta.internal.metals.SemanticTokensProvider$.provide(SemanticTokensProvider.scala:89)
	at scala.meta.internal.metals.Compilers.$anonfun$semanticTokens$3(Compilers.scala:545)
	at scala.concurrent.impl.Promise$Transformation.run(Promise.scala:467)
	at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.lang.Thread.run(Thread.java:833)

2024.07.19 19:00:58 INFO  compiling root-test (1 scala source)
2024.07.19 19:00:59 INFO  time: compiled root-test in 1.24s
2024.07.19 19:01:03 INFO  compiling root-test (1 scala source)
2024.07.19 19:01:04 INFO  time: compiled root-test in 1.12s
2024.07.19 19:01:14 INFO  compiling root-test (1 scala source)
2024.07.19 19:01:14 INFO  time: compiled root-test in 0.95s
2024.07.19 19:01:30 INFO  compiling root-test (1 scala source)
2024.07.19 19:01:31 INFO  time: compiled root-test in 1.01s
2024.07.19 19:01:57 INFO  compiling root-test (1 scala source)
2024.07.19 19:01:59 INFO  time: compiled root-test in 1.32s
2024.07.19 19:02:49 INFO  compiling root-test (1 scala source)
2024.07.19 19:02:49 INFO  time: compiled root-test in 0.23s
jul. 19, 2024 7:02:51 PM scala.meta.internal.pc.CompilerAccess retryWithCleanCompiler
INFORMAÇÕES: compiler crashed due to an error in the Scala compiler, retrying with new compiler instance.
jul. 19, 2024 7:02:51 PM scala.meta.internal.pc.CompilerAccess handleError
GRAVE: A severe compiler error occurred, full details of the error can be found in the error report C:\Users\Vinicius\UnB\FLanguage\.metals\.reports\metals-full\2024-07-19\r_compiler-error_(root-test)_19-02-51-843.md
jul. 19, 2024 7:02:52 PM scala.meta.internal.pc.CompilerAccess retryWithCleanCompiler
INFORMAÇÕES: compiler crashed due to an error in the Scala compiler, retrying with new compiler instance.
jul. 19, 2024 7:02:53 PM scala.meta.internal.pc.CompilerAccess handleError
GRAVE: A severe compiler error occurred, full details of the error can be found in the error report C:\Users\Vinicius\UnB\FLanguage\.metals\.reports\metals-full\2024-07-19\r_compiler-error_(root-test)_19-02-53-026.md
jul. 19, 2024 7:02:53 PM scala.meta.internal.pc.CompilerAccess retryWithCleanCompiler
INFORMAÇÕES: compiler crashed due to an error in the Scala compiler, retrying with new compiler instance.
jul. 19, 2024 7:02:53 PM scala.meta.internal.pc.CompilerAccess handleError
GRAVE: A severe compiler error occurred, full details of the error can be found in the error report C:\Users\Vinicius\UnB\FLanguage\.metals\.reports\metals-full\2024-07-19\r_compiler-error_(root-test)_19-02-53-955.md
2024.07.19 19:02:55 INFO  Can not organize imports if file has error
2024.07.19 19:02:55 INFO  compiling root-test (1 scala source)
2024.07.19 19:02:56 INFO  time: compiled root-test in 1.35s
2024.07.19 19:03:08 INFO  compiling root-test (1 scala source)
2024.07.19 19:03:08 INFO  time: compiled root-test in 0.98s
2024.07.19 19:03:36 INFO  compiling root-test (1 scala source)
2024.07.19 19:03:37 INFO  time: compiled root-test in 1.03s
2024.07.19 19:03:41 INFO  compiling root-test (1 scala source)
2024.07.19 19:03:42 INFO  time: compiled root-test in 1.29s
2024.07.19 19:03:45 INFO  compiling root-test (1 scala source)
2024.07.19 19:03:46 INFO  time: compiled root-test in 1.11s
2024.07.19 19:03:49 INFO  compiling root-test (1 scala source)
2024.07.19 19:03:49 INFO  time: compiled root-test in 0.99s
2024.07.19 19:03:50 INFO  compiling root-test (1 scala source)
2024.07.19 19:03:50 INFO  time: compiled root-test in 0.52s
jul. 19, 2024 7:03:59 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
ADVERTÊNCIA: Unmatched cancel notification for request id 21937
2024.07.19 19:04:22 INFO  compiling root-test (1 scala source)
2024.07.19 19:04:23 INFO  time: compiled root-test in 1.02s
2024.07.19 19:05:47 INFO  compiling root-test (1 scala source)
2024.07.19 19:05:48 INFO  time: compiled root-test in 1.03s
2024.07.19 19:06:19 INFO  compiling root-test (1 scala source)
2024.07.19 19:06:19 INFO  time: compiled root-test in 0.28s
2024.07.19 19:06:22 INFO  compiling root-test (1 scala source)
2024.07.19 19:06:22 INFO  time: compiled root-test in 0.28s
jul. 19, 2024 7:06:25 PM scala.meta.internal.pc.CompilerAccess retryWithCleanCompiler
INFORMAÇÕES: compiler crashed due to an error in the Scala compiler, retrying with new compiler instance.
jul. 19, 2024 7:06:25 PM scala.meta.internal.pc.CompilerAccess handleError
GRAVE: A severe compiler error occurred, full details of the error can be found in the error report C:\Users\Vinicius\UnB\FLanguage\.metals\.reports\metals-full\2024-07-19\r_compiler-error_(root-test)_19-06-25-746.md
jul. 19, 2024 7:06:26 PM scala.meta.internal.pc.CompilerAccess retryWithCleanCompiler
INFORMAÇÕES: compiler crashed due to an error in the Scala compiler, retrying with new compiler instance.
jul. 19, 2024 7:06:26 PM scala.meta.internal.pc.CompilerAccess handleError
GRAVE: A severe compiler error occurred, full details of the error can be found in the error report C:\Users\Vinicius\UnB\FLanguage\.metals\.reports\metals-full\2024-07-19\r_compiler-error_(root-test)_19-06-26-521.md
jul. 19, 2024 7:06:26 PM scala.meta.internal.pc.CompilerAccess retryWithCleanCompiler
INFORMAÇÕES: compiler crashed due to an error in the Scala compiler, retrying with new compiler instance.
jul. 19, 2024 7:06:26 PM scala.meta.internal.pc.CompilerAccess handleError
GRAVE: A severe compiler error occurred, full details of the error can be found in the error report C:\Users\Vinicius\UnB\FLanguage\.metals\.reports\metals-full\2024-07-19\r_compiler-error_(root-test)_19-06-26-768.md
jul. 19, 2024 7:06:26 PM scala.meta.internal.pc.CompilerAccess retryWithCleanCompiler
INFORMAÇÕES: compiler crashed due to an error in the Scala compiler, retrying with new compiler instance.
jul. 19, 2024 7:06:27 PM scala.meta.internal.pc.CompilerAccess handleError
GRAVE: A severe compiler error occurred, full details of the error can be found in the error report C:\Users\Vinicius\UnB\FLanguage\.metals\.reports\metals-full\2024-07-19\r_compiler-error_(root-test)_19-06-27-068.md
2024.07.19 19:06:34 INFO  compiling root-test (1 scala source)
jul. 19, 2024 7:06:34 PM scala.meta.internal.pc.CompilerAccess retryWithCleanCompiler
INFORMAÇÕES: compiler crashed due to an error in the Scala compiler, retrying with new compiler instance.
2024.07.19 19:06:34 INFO  time: compiled root-test in 0.44s
jul. 19, 2024 7:06:34 PM scala.meta.internal.pc.CompilerAccess handleError
GRAVE: A severe compiler error occurred, full details of the error can be found in the error report C:\Users\Vinicius\UnB\FLanguage\.metals\.reports\metals-full\2024-07-19\r_compiler-error_(root-test)_19-06-34-524.md
jul. 19, 2024 7:06:34 PM scala.meta.internal.pc.CompilerAccess retryWithCleanCompiler
INFORMAÇÕES: compiler crashed due to an error in the Scala compiler, retrying with new compiler instance.
jul. 19, 2024 7:06:34 PM scala.meta.internal.pc.CompilerAccess handleError
GRAVE: A severe compiler error occurred, full details of the error can be found in the error report C:\Users\Vinicius\UnB\FLanguage\.metals\.reports\metals-full\2024-07-19\r_compiler-error_(root-test)_19-06-34-914.md
jul. 19, 2024 7:06:35 PM scala.meta.internal.pc.CompilerAccess retryWithCleanCompiler
INFORMAÇÕES: compiler crashed due to an error in the Scala compiler, retrying with new compiler instance.
jul. 19, 2024 7:06:35 PM scala.meta.internal.pc.CompilerAccess handleError
GRAVE: A severe compiler error occurred, full details of the error can be found in the error report C:\Users\Vinicius\UnB\FLanguage\.metals\.reports\metals-full\2024-07-19\r_compiler-error_(root-test)_19-06-35-337.md
2024.07.19 19:06:38 INFO  Can not organize imports if file has error
jul. 19, 2024 7:06:38 PM scala.meta.internal.pc.CompilerAccess retryWithCleanCompiler
INFORMAÇÕES: compiler crashed due to an error in the Scala compiler, retrying with new compiler instance.
2024.07.19 19:06:38 INFO  compiling root-test (1 scala source)
jul. 19, 2024 7:06:38 PM scala.meta.internal.pc.CompilerAccess handleError
GRAVE: A severe compiler error occurred, full details of the error can be found in the error report C:\Users\Vinicius\UnB\FLanguage\.metals\.reports\metals-full\2024-07-19\r_compiler-error_(root-test)_19-06-38-850.md
2024.07.19 19:06:40 INFO  time: compiled root-test in 1.44s
2024.07.19 19:06:43 INFO  compiling root-test (1 scala source)
2024.07.19 19:06:44 INFO  time: compiled root-test in 1.01s
2024.07.19 19:06:53 INFO  compiling root-test (1 scala source)
2024.07.19 19:06:55 INFO  time: compiled root-test in 1.35s
2024.07.19 19:07:34 INFO  compiling root (2 scala sources)
2024.07.19 19:07:34 INFO  time: compiled root in 0.22s
2024.07.19 19:08:12 INFO  Can not organize imports if file has error
2024.07.19 19:08:12 INFO  compiling root (2 scala sources)
2024.07.19 19:08:12 INFO  time: compiled root in 0.13s
2024.07.19 19:08:19 INFO  Can not organize imports if file has error
2024.07.19 19:08:19 INFO  compiling root (2 scala sources)
2024.07.19 19:08:19 INFO  time: compiled root in 0.25s
2024.07.19 19:09:43 INFO  Can not organize imports if file has error
2024.07.19 19:09:43 INFO  compiling root (2 scala sources)
2024.07.19 19:09:43 INFO  time: compiled root in 0.2s
2024.07.19 19:11:28 INFO  Can not organize imports if file has error
2024.07.19 19:11:28 INFO  compiling root (2 scala sources)
2024.07.19 19:11:28 INFO  time: compiled root in 0.25s
2024.07.19 19:11:37 INFO  Can not organize imports if file has error
2024.07.19 19:11:37 INFO  compiling root (2 scala sources)
2024.07.19 19:11:37 INFO  time: compiled root in 0.3s
2024.07.19 19:11:40 INFO  Can not organize imports if file has error
2024.07.19 19:11:40 INFO  compiling root (2 scala sources)
2024.07.19 19:11:41 INFO  time: compiled root in 1.1s
2024.07.19 19:12:27 INFO  compiling root (2 scala sources)
2024.07.19 19:12:27 INFO  time: compiled root in 0.93s
2024.07.19 19:12:30 WARN  Using indexes to guess the definition of eval
2024.07.19 19:12:30 INFO  compiling root (2 scala sources)
2024.07.19 19:12:30 INFO  time: compiled root in 0.26s
2024.07.19 19:12:52 INFO  Can not organize imports if file has error
2024.07.19 19:12:53 INFO  compiling root (2 scala sources)
2024.07.19 19:12:53 WARN  Using indexes to guess the definition of arg
2024.07.19 19:12:53 INFO  time: compiled root in 0.17s
2024.07.19 19:13:00 INFO  Can not organize imports if file has error
2024.07.19 19:13:00 INFO  compiling root (2 scala sources)
2024.07.19 19:13:00 INFO  time: compiled root in 0.17s
2024.07.19 19:13:02 INFO  Can not organize imports if file has error
2024.07.19 19:13:02 INFO  compiling root (2 scala sources)
2024.07.19 19:13:02 INFO  time: compiled root in 0.14s
2024.07.19 19:13:13 INFO  Can not organize imports if file has error
2024.07.19 19:13:13 INFO  compiling root (2 scala sources)
2024.07.19 19:13:13 INFO  time: compiled root in 0.15s
2024.07.19 19:13:46 INFO  Can not organize imports if file has error
2024.07.19 19:13:47 INFO  compiling root (2 scala sources)
2024.07.19 19:13:47 INFO  time: compiled root in 0.16s
2024.07.19 19:14:35 INFO  Can not organize imports if file has error
2024.07.19 19:14:35 INFO  compiling root (2 scala sources)
2024.07.19 19:14:35 INFO  time: compiled root in 0.15s
2024.07.19 19:14:55 WARN  Using indexes to guess the definition of declareVar
2024.07.19 19:14:55 WARN  Using indexes to guess the definition of get
2024.07.19 19:14:55 WARN  Using indexes to guess the definition of put
2024.07.19 19:14:58 WARN  Using indexes to guess the definition of arg
2024.07.19 19:15:01 WARN  Using indexes to guess the definition of put
2024.07.19 19:15:01 WARN  Using indexes to guess the definition of put
2024.07.19 19:15:03 INFO  Can not organize imports if file has error
2024.07.19 19:15:03 INFO  compiling root (2 scala sources)
2024.07.19 19:15:03 INFO  time: compiled root in 0.14s
2024.07.19 19:15:18 WARN  Using indexes to guess the definition of eval
2024.07.19 19:15:19 WARN  Using indexes to guess the definition of bind
2024.07.19 19:15:19 WARN  Using indexes to guess the definition of get
2024.07.19 19:15:19 WARN  Using indexes to guess the definition of get
2024.07.19 19:15:19 WARN  Using indexes to guess the definition of arg
2024.07.19 19:15:19 WARN  Using indexes to guess the definition of eval
jul. 19, 2024 7:15:19 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
ADVERTÊNCIA: Unmatched cancel notification for request id 23748
2024.07.19 19:15:19 WARN  Using indexes to guess the definition of eval
2024.07.19 19:15:20 INFO  Can not organize imports if file has error
2024.07.19 19:15:20 INFO  compiling root (2 scala sources)
2024.07.19 19:15:20 INFO  time: compiled root in 0.14s
jul. 19, 2024 7:15:55 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
ADVERTÊNCIA: Unmatched cancel notification for request id 23779
2024.07.19 19:15:56 INFO  Can not organize imports if file has error
2024.07.19 19:15:56 INFO  compiling root (2 scala sources)
2024.07.19 19:15:56 INFO  time: compiled root in 0.15s
2024.07.19 19:16:05 INFO  Can not organize imports if file has error
2024.07.19 19:16:05 INFO  compiling root (2 scala sources)
2024.07.19 19:16:05 INFO  time: compiled root in 0.25s
2024.07.19 19:16:08 INFO  Can not organize imports if file has error
2024.07.19 19:16:08 INFO  compiling root (2 scala sources)
2024.07.19 19:16:08 INFO  time: compiled root in 0.16s
2024.07.19 19:16:09 WARN  Using indexes to guess the definition of lookup
2024.07.19 19:16:09 WARN  Using indexes to guess the definition of lookup
2024.07.19 19:16:10 WARN  Using indexes to guess the definition of lookup
2024.07.19 19:16:10 WARN  Using indexes to guess the definition of lookup
2024.07.19 19:16:10 INFO  Can not organize imports if file has error
2024.07.19 19:16:10 INFO  compiling root (2 scala sources)
2024.07.19 19:16:10 INFO  time: compiled root in 0.23s
jul. 19, 2024 7:16:29 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
ADVERTÊNCIA: Unmatched cancel notification for request id 23887
2024.07.19 19:16:33 INFO  Can not organize imports if file has error
2024.07.19 19:16:33 INFO  compiling root (2 scala sources)
2024.07.19 19:16:33 INFO  time: compiled root in 0.15s
2024.07.19 19:16:33 INFO  Can not organize imports if file has error
2024.07.19 19:16:33 INFO  compiling root (2 scala sources)
2024.07.19 19:16:35 INFO  time: compiled root in 0.97s
2024.07.19 19:16:35 INFO  compiling root (2 scala sources)
2024.07.19 19:16:36 INFO  time: compiled root in 0.43s
2024.07.19 19:16:46 INFO  compiling root (2 scala sources)
2024.07.19 19:16:46 INFO  time: compiled root in 0.94s
2024.07.19 19:16:50 INFO  compiling root (2 scala sources)
2024.07.19 19:16:50 INFO  time: compiled root in 0.96s
2024.07.19 19:16:54 INFO  compiling root (2 scala sources)
2024.07.19 19:16:55 INFO  Deduplicating compilation of root from bsp client 'Metals 1.3.3' (since 6h 54m 17.699s)
2024.07.19 19:16:55 INFO  compiling root (2 scala sources)
2024.07.19 19:16:55 INFO  time: compiled root in 0.11s
2024.07.19 19:16:55 INFO  compiling root (2 scala sources)
2024.07.19 19:16:55 WARN  Could not load snapshot text for C:\Users\Vinicius\UnB\FLanguage\src\main\scala\br\unb\cic\flang\Interpreter2.scala
2024.07.19 19:16:55 INFO  time: compiled root in 0.42s
2024.07.19 19:17:08 INFO  compiling root-test (1 scala source)
2024.07.19 19:17:08 INFO  time: compiled root-test in 0.27s
jul. 19, 2024 7:17:11 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
ADVERTÊNCIA: Unmatched cancel notification for request id 24083
2024.07.19 19:17:16 INFO  Can not organize imports if file has error
2024.07.19 19:17:16 INFO  compiling root-test (1 scala source)
2024.07.19 19:17:16 INFO  time: compiled root-test in 0.26s
2024.07.19 19:17:18 INFO  Can not organize imports if file has error
2024.07.19 19:17:18 INFO  compiling root-test (1 scala source)
2024.07.19 19:17:18 INFO  time: compiled root-test in 0.27s
2024.07.19 19:17:30 INFO  Can not organize imports if file has error
2024.07.19 19:17:30 INFO  compiling root-test (1 scala source)
2024.07.19 19:17:30 INFO  time: compiled root-test in 0.26s
2024.07.19 19:17:39 WARN  Using indexes to guess the definition of declarations
2024.07.19 19:17:41 WARN  Using indexes to guess the definition of eval
2024.07.19 19:17:44 INFO  Can not organize imports if file has error
2024.07.19 19:17:44 INFO  compiling root-test (1 scala source)
2024.07.19 19:17:46 INFO  time: compiled root-test in 1.08s
2024.07.19 19:18:05 INFO  compiling root-test (1 scala source)
2024.07.19 19:18:06 INFO  time: compiled root-test in 1.04s
2024.07.19 19:18:40 INFO  compiling root-test (1 scala source)
2024.07.19 19:18:40 INFO  time: compiled root-test in 0.99s
jul. 19, 2024 7:21:16 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
ADVERTÊNCIA: Unmatched cancel notification for request id 24432
2024.07.19 19:21:17 INFO  compiling root (2 scala sources)
2024.07.19 19:21:17 INFO  time: compiled root in 0.98s
2024.07.19 19:21:24 INFO  compiling root (2 scala sources)
2024.07.19 19:21:25 INFO  time: compiled root in 1.01s
2024.07.19 19:21:39 INFO  compiling root (2 scala sources)
2024.07.19 19:21:39 INFO  time: compiled root in 0.95s
jul. 19, 2024 7:22:47 PM scala.meta.internal.pc.CompilerAccess handleError
GRAVE: A severe compiler error occurred, full details of the error can be found in the error report C:\Users\Vinicius\UnB\FLanguage\.metals\.reports\metals-full\2024-07-19\r_compiler-error_(root)_19-22-47-423.md
2024.07.19 19:22:47 ERROR TextDocument.uri not found: src/main/scala/br/unb/cic/flang/MonadState.scala
scala.meta.internal.metals.ScalafixProvider$ScalafixRunException: TextDocument.uri not found: src/main/scala/br/unb/cic/flang/MonadState.scala
	at scala.meta.internal.metals.ScalafixProvider.$anonfun$runScalafixRules$2(ScalafixProvider.scala:130)
	at scala.concurrent.impl.Promise$Transformation.run(Promise.scala:470)
	at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.lang.Thread.run(Thread.java:833)

jul. 19, 2024 7:22:47 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint fallbackResponseError
GRAVE: Internal error: scala.meta.internal.metals.ScalafixProvider$ScalafixRunException: TextDocument.uri not found: src/main/scala/br/unb/cic/flang/MonadState.scala
java.util.concurrent.CompletionException: scala.meta.internal.metals.ScalafixProvider$ScalafixRunException: TextDocument.uri not found: src/main/scala/br/unb/cic/flang/MonadState.scala
	at java.base/java.util.concurrent.CompletableFuture.encodeThrowable(CompletableFuture.java:332)
	at java.base/java.util.concurrent.CompletableFuture.completeThrowable(CompletableFuture.java:347)
	at java.base/java.util.concurrent.CompletableFuture$UniAccept.tryFire(CompletableFuture.java:708)
	at java.base/java.util.concurrent.CompletableFuture.postComplete(CompletableFuture.java:510)
	at java.base/java.util.concurrent.CompletableFuture.completeExceptionally(CompletableFuture.java:2162)
	at scala.meta.internal.metals.CancelTokens$.$anonfun$future$1(CancelTokens.scala:40)
	at scala.meta.internal.metals.CancelTokens$.$anonfun$future$1$adapted(CancelTokens.scala:38)
	at scala.concurrent.impl.Promise$Transformation.run(Promise.scala:484)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.base/java.lang.Thread.run(Thread.java:833)
Caused by: scala.meta.internal.metals.ScalafixProvider$ScalafixRunException: TextDocument.uri not found: src/main/scala/br/unb/cic/flang/MonadState.scala
	at scala.meta.internal.metals.ScalafixProvider.$anonfun$runScalafixRules$2(ScalafixProvider.scala:130)
	at scala.concurrent.impl.Promise$Transformation.run(Promise.scala:470)
	... 3 more

2024.07.19 19:22:47 INFO  compiling root (2 scala sources)
2024.07.19 19:22:47 INFO  time: compiled root in 0.41s
2024.07.19 19:22:56 INFO  Can not organize imports if file has error
2024.07.19 19:22:56 INFO  compiling root (2 scala sources)
2024.07.19 19:22:57 INFO  time: compiled root in 1s
2024.07.19 19:22:58 INFO  compiling root-test (1 scala source)
2024.07.19 19:22:58 INFO  time: compiled root-test in 0.44s
2024.07.19 19:22:59 INFO  Can not organize imports if file has error
2024.07.19 19:22:58 INFO  compiling root-test (1 scala source)
2024.07.19 19:22:58 INFO  time: compiled root-test in 0.27s
2024.07.19 19:23:23 INFO  Can not organize imports if file has error
2024.07.19 19:23:23 INFO  compiling root-test (1 scala source)
2024.07.19 19:23:23 INFO  time: compiled root-test in 0.27s
2024.07.19 19:23:33 INFO  Can not organize imports if file has error
2024.07.19 19:23:34 INFO  compiling root-test (1 scala source)
2024.07.19 19:23:34 INFO  time: compiled root-test in 0.27s
2024.07.19 19:23:43 INFO  Can not organize imports if file has error
2024.07.19 19:23:43 INFO  compiling root-test (1 scala source)
2024.07.19 19:23:44 INFO  time: compiled root-test in 1.09s
2024.07.19 19:23:58 INFO  compiling root-test (1 scala source)
2024.07.19 19:23:59 INFO  time: compiled root-test in 1.03s
jul. 19, 2024 7:24:20 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
ADVERTÊNCIA: Unmatched cancel notification for request id 25089
jul. 19, 2024 7:24:21 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
ADVERTÊNCIA: Unmatched cancel notification for request id 25097
jul. 19, 2024 7:24:24 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
ADVERTÊNCIA: Unmatched cancel notification for request id 25116
jul. 19, 2024 7:24:24 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
ADVERTÊNCIA: Unmatched cancel notification for request id 25124
jul. 19, 2024 7:24:33 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
ADVERTÊNCIA: Unmatched cancel notification for request id 25162
jul. 19, 2024 7:24:40 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
ADVERTÊNCIA: Unmatched cancel notification for request id 25204
jul. 19, 2024 7:24:41 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
ADVERTÊNCIA: Unmatched cancel notification for request id 25213
jul. 19, 2024 7:24:53 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
ADVERTÊNCIA: Unmatched cancel notification for request id 25267
jul. 19, 2024 7:24:54 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
ADVERTÊNCIA: Unmatched cancel notification for request id 25275
2024.07.19 19:25:17 INFO  compiling root-test (1 scala source)
2024.07.19 19:25:17 INFO  time: compiled root-test in 0.26s
2024.07.19 19:25:28 INFO  Can not organize imports if file has error
2024.07.19 19:25:28 INFO  compiling root-test (1 scala source)
2024.07.19 19:25:28 INFO  time: compiled root-test in 0.28s
2024.07.19 19:25:34 INFO  Can not organize imports if file has error
2024.07.19 19:25:34 INFO  compiling root-test (1 scala source)
2024.07.19 19:25:35 INFO  time: compiled root-test in 1.28s
jul. 19, 2024 7:25:49 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
ADVERTÊNCIA: Unmatched cancel notification for request id 25484
jul. 19, 2024 7:25:55 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
ADVERTÊNCIA: Unmatched cancel notification for request id 25493
2024.07.19 19:26:13 INFO  compiling root (4 scala sources)
2024.07.19 19:26:13 INFO  Deduplicating compilation of root from bsp client 'Metals 1.3.3' (since 7h 3m 35.363s)
2024.07.19 19:26:13 INFO  compiling root (4 scala sources)
2024.07.19 19:26:14 INFO  time: compiled root in 1.71s
2024.07.19 19:26:14 INFO  Deduplicating compilation of root from bsp client 'Metals 1.3.3' (since 7h 3m 37.136s)
2024.07.19 19:26:15 ERROR Stale SemanticDB
--- C:\Users\Vinicius\UnB\FLanguage\.metals\.tmp\src\test\scala\br\unb\cic\flang\InterpreterTest.scala-ondisk-md5-fingerprint
+++ C:\Users\Vinicius\UnB\FLanguage\.metals\.tmp\src\test\scala\br\unb\cic\flang\InterpreterTest.scala-semanticdb-md5-fingerprint
@@ -1,1 +1,1 @@
-0940487F922A6290F0873CA4BE4720AE
+16317C0278FD614204A7BA463A787E00
scala.meta.internal.metals.ScalafixProvider$ScalafixRunException: Stale SemanticDB
--- C:\Users\Vinicius\UnB\FLanguage\.metals\.tmp\src\test\scala\br\unb\cic\flang\InterpreterTest.scala-ondisk-md5-fingerprint
+++ C:\Users\Vinicius\UnB\FLanguage\.metals\.tmp\src\test\scala\br\unb\cic\flang\InterpreterTest.scala-semanticdb-md5-fingerprint
@@ -1,1 +1,1 @@
-0940487F922A6290F0873CA4BE4720AE
+16317C0278FD614204A7BA463A787E00
	at scala.meta.internal.metals.ScalafixProvider.$anonfun$runScalafixRules$2(ScalafixProvider.scala:130)
	at scala.concurrent.impl.Promise$Transformation.run(Promise.scala:470)
	at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.lang.Thread.run(Thread.java:833)

2024.07.19 19:26:14 INFO  Deduplicating compilation of root from bsp client 'Metals 1.3.3' (since 7h 3m 37.594s)
2024.07.19 19:26:14 INFO  compiling root (2 scala sources)
2024.07.19 19:26:14 INFO  compiling root (2 scala sources)
2024.07.19 19:26:15 INFO  time: compiled root in 0.54s
2024.07.19 19:26:15 INFO  compiling root-test (2 scala sources)
2024.07.19 19:26:15 INFO  compiling root-test (2 scala sources)
2024.07.19 19:26:15 INFO  time: compiled root-test in 0.46s
2024.07.19 19:26:15 INFO  compiling root-test (2 scala sources)
2024.07.19 19:26:17 INFO  time: compiled root-test in 0.7s
2024.07.19 19:27:12 INFO  compiling root-test (1 scala source)
2024.07.19 19:27:13 INFO  time: compiled root-test in 1.01s
2024.07.19 19:27:18 INFO  compiling root-test (1 scala source)
2024.07.19 19:27:18 INFO  time: compiled root-test in 0.23s
2024.07.19 19:27:26 INFO  Can not organize imports if file has error
2024.07.19 19:27:26 INFO  compiling root-test (1 scala source)
2024.07.19 19:27:28 INFO  time: compiled root-test in 1.27s
jul. 19, 2024 7:27:29 PM scala.meta.internal.pc.CompilerAccess retryWithCleanCompiler
INFORMAÇÕES: compiler crashed due to an error in the Scala compiler, retrying with new compiler instance.
jul. 19, 2024 7:27:34 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
ADVERTÊNCIA: Unmatched cancel notification for request id 25800
jul. 19, 2024 7:27:35 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
ADVERTÊNCIA: Unmatched cancel notification for request id 25806
jul. 19, 2024 7:27:35 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
ADVERTÊNCIA: Unmatched cancel notification for request id 25814
jul. 19, 2024 7:27:35 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
ADVERTÊNCIA: Unmatched cancel notification for request id 25822
jul. 19, 2024 7:27:36 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
ADVERTÊNCIA: Unmatched cancel notification for request id 25830
jul. 19, 2024 7:27:38 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
ADVERTÊNCIA: Unmatched cancel notification for request id 25838
jul. 19, 2024 7:27:39 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
ADVERTÊNCIA: Unmatched cancel notification for request id 25846
jul. 19, 2024 7:27:39 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
ADVERTÊNCIA: Unmatched cancel notification for request id 25853
jul. 19, 2024 7:27:42 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
ADVERTÊNCIA: Unmatched cancel notification for request id 25869
2024.07.19 19:27:53 INFO  compiling root-test (1 scala source)
2024.07.19 19:27:53 INFO  time: compiled root-test in 1s
Exception in thread "pool-8-thread-2" java.lang.InterruptedException
	at scala.meta.internal.metals.FutureCancelToken.checkCanceled(FutureCancelToken.scala:29)
	at scala.meta.internal.pc.CompilerAccess.$anonfun$onCompilerJobQueue$1(CompilerAccess.scala:243)
	at scala.meta.internal.pc.CompilerJobQueue$Job.run(CompilerJobQueue.scala:152)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.base/java.lang.Thread.run(Thread.java:833)
2024.07.19 19:28:47 INFO  compiling root-test (1 scala source)
2024.07.19 19:28:47 INFO  time: compiled root-test in 0.93s
jul. 19, 2024 7:28:49 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
ADVERTÊNCIA: Unmatched cancel notification for request id 26160
2024.07.19 19:28:52 INFO  compiling root-test (1 scala source)
2024.07.19 19:28:52 INFO  time: compiled root-test in 0.89s
jul. 19, 2024 7:29:42 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
ADVERTÊNCIA: Unmatched cancel notification for request id 26309
2024.07.19 19:30:01 INFO  compiling root-test (1 scala source)
2024.07.19 19:30:01 INFO  time: compiled root-test in 0.23s
2024.07.19 19:30:23 INFO  Can not organize imports if file has error
2024.07.19 19:30:23 INFO  compiling root-test (1 scala source)
2024.07.19 19:30:23 INFO  time: compiled root-test in 0.23s
2024.07.19 19:30:31 INFO  Can not organize imports if file has error
2024.07.19 19:30:31 INFO  compiling root-test (1 scala source)
2024.07.19 19:30:31 INFO  time: compiled root-test in 0.23s
2024.07.19 19:30:32 WARN  Using indexes to guess the definition of pure
2024.07.19 19:30:35 INFO  Can not organize imports if file has error
2024.07.19 19:30:35 INFO  compiling root-test (1 scala source)
2024.07.19 19:30:35 INFO  time: compiled root-test in 0.3s
2024.07.19 19:30:39 INFO  compiling root-test (1 scala source)
2024.07.19 19:30:39 INFO  time: compiled root-test in 0.35s
2024.07.19 19:30:40 INFO  Can not organize imports if file has error
2024.07.19 19:30:40 INFO  compiling root-test (1 scala source)
2024.07.19 19:30:40 INFO  time: compiled root-test in 0.32s
2024.07.19 19:30:44 INFO  compiling root-test (1 scala source)
2024.07.19 19:30:44 INFO  time: compiled root-test in 0.28s
2024.07.19 19:30:49 INFO  Can not organize imports if file has error
2024.07.19 19:30:49 INFO  compiling root-test (1 scala source)
2024.07.19 19:30:49 INFO  time: compiled root-test in 0.24s
jul. 19, 2024 7:30:51 PM scala.meta.internal.pc.CompilerAccess retryWithCleanCompiler
INFORMAÇÕES: compiler crashed due to an error in the Scala compiler, retrying with new compiler instance.
jul. 19, 2024 7:30:51 PM scala.meta.internal.pc.CompilerAccess handleError
GRAVE: A severe compiler error occurred, full details of the error can be found in the error report C:\Users\Vinicius\UnB\FLanguage\.metals\.reports\metals-full\2024-07-19\r_compiler-error_(root-test)_19-30-51-623.md
jul. 19, 2024 7:30:52 PM scala.meta.internal.pc.CompilerAccess retryWithCleanCompiler
INFORMAÇÕES: compiler crashed due to an error in the Scala compiler, retrying with new compiler instance.
jul. 19, 2024 7:30:52 PM scala.meta.internal.pc.CompilerAccess handleError
GRAVE: A severe compiler error occurred, full details of the error can be found in the error report C:\Users\Vinicius\UnB\FLanguage\.metals\.reports\metals-full\2024-07-19\r_compiler-error_(root-test)_19-30-52-641.md
2024.07.19 19:30:53 INFO  Can not organize imports if file has error
2024.07.19 19:30:53 INFO  compiling root-test (1 scala source)
2024.07.19 19:30:53 INFO  time: compiled root-test in 0.94s
2024.07.19 19:30:56 INFO  compiling root-test (1 scala source)
2024.07.19 19:30:56 INFO  time: compiled root-test in 0.26s
2024.07.19 19:31:05 INFO  compiling root-test (1 scala source)
2024.07.19 19:31:05 INFO  time: compiled root-test in 0.39s
2024.07.19 19:31:23 INFO  compiling root-test (1 scala source)
2024.07.19 19:31:23 INFO  time: compiled root-test in 0.28s
2024.07.19 19:31:29 INFO  Can not organize imports if file has error
2024.07.19 19:31:29 INFO  compiling root-test (1 scala source)
2024.07.19 19:31:29 INFO  time: compiled root-test in 0.25s
2024.07.19 19:31:34 INFO  Can not organize imports if file has error
2024.07.19 19:31:34 INFO  compiling root-test (1 scala source)
2024.07.19 19:31:34 INFO  time: compiled root-test in 0.97s
2024.07.19 19:31:42 INFO  compiling root-test (1 scala source)
2024.07.19 19:31:44 INFO  time: compiled root-test in 1.31s
2024.07.19 19:31:46 INFO  compiling root-test (1 scala source)
2024.07.19 19:31:47 INFO  time: compiled root-test in 1.02s
2024.07.19 19:32:02 INFO  compiling root-test (1 scala source)
2024.07.19 19:32:02 INFO  time: compiled root-test in 0.96s
2024.07.19 19:32:09 INFO  compiling root-test (1 scala source)
2024.07.19 19:32:09 INFO  time: compiled root-test in 0.95s
jul. 19, 2024 7:32:10 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
ADVERTÊNCIA: Unmatched cancel notification for request id 26864
2024.07.19 19:32:38 INFO  compiling root-test (1 scala source)
2024.07.19 19:32:39 INFO  time: compiled root-test in 1.27s
2024.07.19 19:32:40 INFO  compiling root-test (1 scala source)
2024.07.19 19:32:40 INFO  time: compiled root-test in 0.94s
2024.07.19 19:32:44 INFO  compiling root-test (1 scala source)
2024.07.19 19:32:44 INFO  time: compiled root-test in 0.88s
2024.07.19 19:32:46 INFO  compiling root-test (1 scala source)
2024.07.19 19:32:46 INFO  time: compiled root-test in 0.94s
2024.07.19 19:32:48 INFO  compiling root-test (1 scala source)
2024.07.19 19:32:48 INFO  time: compiled root-test in 0.94s
2024.07.19 19:33:23 INFO  compiling root-test (1 scala source)
2024.07.19 19:33:23 INFO  time: compiled root-test in 0.24s
jul. 19, 2024 7:33:26 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
ADVERTÊNCIA: Unmatched cancel notification for request id 27172
jul. 19, 2024 7:33:28 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
ADVERTÊNCIA: Unmatched cancel notification for request id 27180
2024.07.19 19:33:28 INFO  compiling root-test (1 scala source)
2024.07.19 19:33:28 INFO  time: compiled root-test in 0.44s
2024.07.19 19:33:34 INFO  Can not organize imports if file has error
2024.07.19 19:33:34 INFO  compiling root-test (1 scala source)
2024.07.19 19:33:34 INFO  time: compiled root-test in 0.99s
2024.07.19 19:33:41 INFO  compiling root-test (1 scala source)
2024.07.19 19:33:41 INFO  time: compiled root-test in 0.95s
2024.07.19 19:33:46 INFO  compiling root-test (1 scala source)
2024.07.19 19:33:46 INFO  time: compiled root-test in 0.27s
2024.07.19 19:33:52 INFO  Can not organize imports if file has error
2024.07.19 19:33:52 INFO  compiling root-test (1 scala source)
2024.07.19 19:33:52 INFO  time: compiled root-test in 0.25s
2024.07.19 19:33:54 INFO  Can not organize imports if file has error
2024.07.19 19:33:54 INFO  compiling root-test (1 scala source)
2024.07.19 19:33:54 INFO  time: compiled root-test in 0.27s
jul. 19, 2024 7:34:15 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
ADVERTÊNCIA: Unmatched cancel notification for request id 27315
jul. 19, 2024 7:34:19 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
ADVERTÊNCIA: Unmatched cancel notification for request id 27326
2024.07.19 19:34:20 INFO  compiling root-test (1 scala source)
2024.07.19 19:34:20 INFO  time: compiled root-test in 0.37s
2024.07.19 19:34:23 INFO  Can not organize imports if file has error
2024.07.19 19:34:23 INFO  compiling root-test (1 scala source)
2024.07.19 19:34:23 INFO  time: compiled root-test in 0.24s
2024.07.19 19:34:25 INFO  compiling root-test (1 scala source)
2024.07.19 19:34:25 INFO  time: compiled root-test in 0.33s
2024.07.19 19:34:29 INFO  Can not organize imports if file has error
2024.07.19 19:34:29 INFO  compiling root-test (1 scala source)
2024.07.19 19:34:30 INFO  time: compiled root-test in 1.02s
2024.07.19 19:34:33 INFO  compiling root-test (1 scala source)
2024.07.19 19:34:33 INFO  time: compiled root-test in 0.95s
2024.07.19 19:34:41 INFO  compiling root-test (1 scala source)
2024.07.19 19:34:41 INFO  time: compiled root-test in 0.94s
jul. 19, 2024 7:35:52 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
ADVERTÊNCIA: Unmatched cancel notification for request id 27479
2024.07.19 19:35:52 INFO  compiling root-test (1 scala source)
2024.07.19 19:35:53 INFO  time: compiled root-test in 1.43s
2024.07.19 19:35:55 INFO  compiling root-test (1 scala source)
2024.07.19 19:35:55 INFO  time: compiled root-test in 0.96s
2024.07.19 19:36:07 INFO  compiling root-test (1 scala source)
2024.07.19 19:36:07 INFO  time: compiled root-test in 0.94s
2024.07.19 19:36:20 ERROR Failed to tokenize input for semantic tokens for C:\Users\Vinicius\UnB\FLanguage\src\test\scala\br\unb\cic\flang\MonadTest.scala
scala.meta.tokenizers.TokenizeException: <input>:27: error: unclosed string interpolation
  " should "s" in {
              ^
	at scala.meta.internal.tokenizers.Reporter.syntaxError(Reporter.scala:23)
	at scala.meta.internal.tokenizers.Reporter.syntaxError$(Reporter.scala:23)
	at scala.meta.internal.tokenizers.Reporter$$anon$1.syntaxError(Reporter.scala:32)
	at scala.meta.internal.tokenizers.Reporter.syntaxError(Reporter.scala:25)
	at scala.meta.internal.tokenizers.Reporter.syntaxError$(Reporter.scala:25)
	at scala.meta.internal.tokenizers.Reporter$$anon$1.syntaxError(Reporter.scala:32)
	at scala.meta.internal.tokenizers.LegacyScanner.getStringPart(LegacyScanner.scala:605)
	at scala.meta.internal.tokenizers.LegacyScanner.fetchDoubleQuote$1(LegacyScanner.scala:347)
	at scala.meta.internal.tokenizers.LegacyScanner.fetchToken(LegacyScanner.scala:363)
	at scala.meta.internal.tokenizers.LegacyScanner.nextToken(LegacyScanner.scala:201)
	at scala.meta.internal.tokenizers.LegacyScanner.foreach(LegacyScanner.scala:912)
	at scala.meta.internal.tokenizers.ScalametaTokenizer.uncachedTokenize(ScalametaTokenizer.scala:23)
	at scala.meta.internal.tokenizers.ScalametaTokenizer.$anonfun$tokenize$1(ScalametaTokenizer.scala:17)
	at scala.collection.concurrent.TrieMap.getOrElseUpdate(TrieMap.scala:960)
	at scala.meta.internal.tokenizers.ScalametaTokenizer.tokenize(ScalametaTokenizer.scala:17)
	at scala.meta.internal.tokenizers.ScalametaTokenizer$$anon$2.apply(ScalametaTokenizer.scala:322)
	at scala.meta.tokenizers.Api$XtensionTokenizeDialectInput.tokenize(Api.scala:22)
	at scala.meta.tokenizers.Api$XtensionTokenizeInputLike.tokenize(Api.scala:13)
	at scala.meta.internal.metals.SemanticTokensProvider$.getTokens(SemanticTokensProvider.scala:30)
	at scala.meta.internal.metals.SemanticTokensProvider$.provide(SemanticTokensProvider.scala:89)
	at scala.meta.internal.metals.Compilers.$anonfun$semanticTokens$3(Compilers.scala:545)
	at scala.concurrent.impl.Promise$Transformation.run(Promise.scala:467)
	at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.lang.Thread.run(Thread.java:833)

2024.07.19 19:36:22 INFO  compiling root-test (1 scala source)
2024.07.19 19:36:22 INFO  time: compiled root-test in 0.96s
2024.07.19 19:37:04 INFO  compiling root-test (1 scala source)
2024.07.19 19:37:05 INFO  time: compiled root-test in 1.02s
jul. 19, 2024 7:37:28 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
ADVERTÊNCIA: Unmatched cancel notification for request id 27603
2024.07.19 19:37:38 INFO  compiling root-test (1 scala source)
2024.07.19 19:37:38 INFO  time: compiled root-test in 0.94s
2024.07.19 19:38:54 INFO  compiling root-test (1 scala source)
2024.07.19 19:38:55 INFO  Deduplicating compilation of root-test from bsp client 'Metals 1.3.3' (since 7h 16m 18.068s)
2024.07.19 19:38:55 INFO  compiling root-test (1 scala source)
2024.07.19 19:38:55 INFO  time: compiled root-test in 0.22s
2024.07.19 19:39:46 ERROR Failed to tokenize input for semantic tokens for C:\Users\Vinicius\UnB\FLanguage\src\test\scala\br\unb\cic\flang\MonadTest.scala
scala.meta.tokenizers.TokenizeException: <input>:39: error: Invalid literal number, followed by identifier character
    res should be(List(1m))
                        ^
	at scala.meta.internal.tokenizers.Reporter.syntaxError(Reporter.scala:23)
	at scala.meta.internal.tokenizers.Reporter.syntaxError$(Reporter.scala:23)
	at scala.meta.internal.tokenizers.Reporter$$anon$1.syntaxError(Reporter.scala:32)
	at scala.meta.internal.tokenizers.Reporter.syntaxError(Reporter.scala:25)
	at scala.meta.internal.tokenizers.Reporter.syntaxError$(Reporter.scala:25)
	at scala.meta.internal.tokenizers.Reporter$$anon$1.syntaxError(Reporter.scala:32)
	at scala.meta.internal.tokenizers.LegacyScanner.checkNoLetter(LegacyScanner.scala:774)
	at scala.meta.internal.tokenizers.LegacyScanner.setNumberInteger$1(LegacyScanner.scala:796)
	at scala.meta.internal.tokenizers.LegacyScanner.getNumber(LegacyScanner.scala:811)
	at scala.meta.internal.tokenizers.LegacyScanner.fetchToken(LegacyScanner.scala:326)
	at scala.meta.internal.tokenizers.LegacyScanner.nextToken(LegacyScanner.scala:201)
	at scala.meta.internal.tokenizers.LegacyScanner.foreach(LegacyScanner.scala:912)
	at scala.meta.internal.tokenizers.ScalametaTokenizer.uncachedTokenize(ScalametaTokenizer.scala:23)
	at scala.meta.internal.tokenizers.ScalametaTokenizer.$anonfun$tokenize$1(ScalametaTokenizer.scala:17)
	at scala.collection.concurrent.TrieMap.getOrElseUpdate(TrieMap.scala:960)
	at scala.meta.internal.tokenizers.ScalametaTokenizer.tokenize(ScalametaTokenizer.scala:17)
	at scala.meta.internal.tokenizers.ScalametaTokenizer$$anon$2.apply(ScalametaTokenizer.scala:322)
	at scala.meta.tokenizers.Api$XtensionTokenizeDialectInput.tokenize(Api.scala:22)
	at scala.meta.tokenizers.Api$XtensionTokenizeInputLike.tokenize(Api.scala:13)
	at scala.meta.internal.metals.SemanticTokensProvider$.getTokens(SemanticTokensProvider.scala:30)
	at scala.meta.internal.metals.SemanticTokensProvider$.provide(SemanticTokensProvider.scala:89)
	at scala.meta.internal.metals.Compilers.$anonfun$semanticTokens$3(Compilers.scala:545)
	at scala.concurrent.impl.Promise$Transformation.run(Promise.scala:467)
	at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.lang.Thread.run(Thread.java:833)

2024.07.19 19:39:50 INFO  compiling root-test (1 scala source)
2024.07.19 19:39:50 INFO  time: compiled root-test in 0.98s
jul. 19, 2024 7:39:56 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
ADVERTÊNCIA: Unmatched cancel notification for request id 27956
jul. 19, 2024 7:39:59 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
ADVERTÊNCIA: Unmatched cancel notification for request id 27980
2024.07.19 19:40:13 INFO  compiling root-test (1 scala source)
2024.07.19 19:40:13 INFO  time: compiled root-test in 0.98s
jul. 19, 2024 7:40:25 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
ADVERTÊNCIA: Unmatched cancel notification for request id 28117
2024.07.19 19:40:28 INFO  compiling root-test (1 scala source)
2024.07.19 19:40:29 INFO  time: compiled root-test in 1.02s
2024.07.19 19:41:27 INFO  compiling root-test (1 scala source)
2024.07.19 19:41:28 INFO  time: compiled root-test in 1.44s
2024.07.19 19:42:44 INFO  compiling root-test (1 scala source)
2024.07.19 19:42:44 INFO  time: compiled root-test in 0.98s
2024.07.19 19:43:11 INFO  compiling root-test (1 scala source)
2024.07.19 19:43:11 INFO  time: compiled root-test in 0.95s
2024.07.19 19:43:18 INFO  compiling root-test (1 scala source)
2024.07.19 19:43:18 INFO  time: compiled root-test in 0.3s
2024.07.19 19:43:40 INFO  Can not organize imports if file has error
2024.07.19 19:43:40 INFO  compiling root-test (1 scala source)
2024.07.19 19:43:41 INFO  time: compiled root-test in 1.02s
2024.07.19 19:43:44 INFO  compiling root-test (1 scala source)
2024.07.19 19:43:44 INFO  time: compiled root-test in 0.94s
2024.07.19 19:43:52 INFO  compiling root-test (1 scala source)
2024.07.19 19:43:53 INFO  time: compiled root-test in 1.05s
2024.07.19 19:43:54 INFO  compiling root-test (1 scala source)
2024.07.19 19:43:54 INFO  time: compiled root-test in 0.94s
2024.07.19 19:44:01 INFO  compiling root-test (1 scala source)
2024.07.19 19:44:02 INFO  time: compiled root-test in 1.07s
2024.07.19 19:44:12 INFO  compiling root-test (1 scala source)
2024.07.19 19:44:12 INFO  time: compiled root-test in 0.25s
jul. 19, 2024 7:44:16 PM scala.meta.internal.pc.CompilerAccess retryWithCleanCompiler
INFORMAÇÕES: compiler crashed due to an error in the Scala compiler, retrying with new compiler instance.
jul. 19, 2024 7:44:16 PM scala.meta.internal.pc.CompilerAccess handleError
GRAVE: A severe compiler error occurred, full details of the error can be found in the error report C:\Users\Vinicius\UnB\FLanguage\.metals\.reports\metals-full\2024-07-19\r_compiler-error_(root-test)_19-44-16-861.md
jul. 19, 2024 7:44:17 PM scala.meta.internal.pc.CompilerAccess retryWithCleanCompiler
INFORMAÇÕES: compiler crashed due to an error in the Scala compiler, retrying with new compiler instance.
jul. 19, 2024 7:44:17 PM scala.meta.internal.pc.CompilerAccess retryWithCleanCompiler
INFORMAÇÕES: compiler crashed due to an error in the Scala compiler, retrying with new compiler instance.
jul. 19, 2024 7:44:17 PM scala.meta.internal.pc.CompilerAccess handleError
GRAVE: A severe compiler error occurred, full details of the error can be found in the error report C:\Users\Vinicius\UnB\FLanguage\.metals\.reports\metals-full\2024-07-19\r_compiler-error_(root-test)_19-44-17-738.md
2024.07.19 19:44:18 INFO  Can not organize imports if file has error
2024.07.19 19:44:18 INFO  compiling root-test (1 scala source)
2024.07.19 19:44:19 INFO  time: compiled root-test in 1.35s
2024.07.19 19:44:28 INFO  compiling root-test (1 scala source)
2024.07.19 19:44:29 INFO  time: compiled root-test in 1.11s
2024.07.19 19:44:33 INFO  compiling root-test (1 scala source)
2024.07.19 19:44:33 INFO  time: compiled root-test in 0.97s
jul. 19, 2024 7:44:38 PM scala.meta.internal.pc.CompilerAccess handleError
GRAVE: A severe compiler error occurred, full details of the error can be found in the error report C:\Users\Vinicius\UnB\FLanguage\.metals\.reports\metals-full\2024-07-19\r_compiler-error_(root-test)_19-44-38-899.md
2024.07.19 19:44:39 ERROR TextDocument.uri not found: src/test/scala/br/unb/cic/flang/MonadTest.scala
scala.meta.internal.metals.ScalafixProvider$ScalafixRunException: TextDocument.uri not found: src/test/scala/br/unb/cic/flang/MonadTest.scala
	at scala.meta.internal.metals.ScalafixProvider.$anonfun$runScalafixRules$2(ScalafixProvider.scala:130)
	at scala.concurrent.impl.Promise$Transformation.run(Promise.scala:470)
	at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.lang.Thread.run(Thread.java:833)

jul. 19, 2024 7:44:39 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint fallbackResponseError
GRAVE: Internal error: scala.meta.internal.metals.ScalafixProvider$ScalafixRunException: TextDocument.uri not found: src/test/scala/br/unb/cic/flang/MonadTest.scala
java.util.concurrent.CompletionException: scala.meta.internal.metals.ScalafixProvider$ScalafixRunException: TextDocument.uri not found: src/test/scala/br/unb/cic/flang/MonadTest.scala
	at java.base/java.util.concurrent.CompletableFuture.encodeThrowable(CompletableFuture.java:332)
	at java.base/java.util.concurrent.CompletableFuture.completeThrowable(CompletableFuture.java:347)
	at java.base/java.util.concurrent.CompletableFuture$UniAccept.tryFire(CompletableFuture.java:708)
	at java.base/java.util.concurrent.CompletableFuture.postComplete(CompletableFuture.java:510)
	at java.base/java.util.concurrent.CompletableFuture.completeExceptionally(CompletableFuture.java:2162)
	at scala.meta.internal.metals.CancelTokens$.$anonfun$future$1(CancelTokens.scala:40)
	at scala.meta.internal.metals.CancelTokens$.$anonfun$future$1$adapted(CancelTokens.scala:38)
	at scala.concurrent.impl.Promise$Transformation.run(Promise.scala:484)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.base/java.lang.Thread.run(Thread.java:833)
Caused by: scala.meta.internal.metals.ScalafixProvider$ScalafixRunException: TextDocument.uri not found: src/test/scala/br/unb/cic/flang/MonadTest.scala
	at scala.meta.internal.metals.ScalafixProvider.$anonfun$runScalafixRules$2(ScalafixProvider.scala:130)
	at scala.concurrent.impl.Promise$Transformation.run(Promise.scala:470)
	... 3 more

2024.07.19 19:44:39 INFO  compiling root-test (1 scala source)
2024.07.19 19:44:39 INFO  time: compiled root-test in 0.17s
jul. 19, 2024 7:44:39 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
ADVERTÊNCIA: Unmatched cancel notification for request id 28934
2024.07.19 19:44:41 INFO  Can not organize imports if file has error
2024.07.19 19:44:41 INFO  compiling root-test (1 scala source)
2024.07.19 19:44:41 INFO  Deduplicating compilation of root-test from bsp client 'Metals 1.3.3' (since 7h 22m 5.094s)
2024.07.19 19:44:41 INFO  compiling root-test (1 scala source)
2024.07.19 19:44:43 INFO  time: compiled root-test in 0.15s
2024.07.19 19:44:43 INFO  compiling root-test (1 scala source)
2024.07.19 19:44:43 WARN  Could not load snapshot text for C:\Users\Vinicius\UnB\FLanguage\src\test\scala\br\unb\cic\flang\MonadTest.scala
2024.07.19 19:44:43 INFO  time: compiled root-test in 0.54s
2024.07.19 19:44:45 INFO  compiling root-test (1 scala source)
2024.07.19 19:44:46 INFO  time: compiled root-test in 1.02s
jul. 19, 2024 7:44:53 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
ADVERTÊNCIA: Unmatched cancel notification for request id 28998
jul. 19, 2024 7:44:53 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
ADVERTÊNCIA: Unmatched cancel notification for request id 29006
jul. 19, 2024 7:44:53 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
ADVERTÊNCIA: Unmatched cancel notification for request id 29011
jul. 19, 2024 7:52:01 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
ADVERTÊNCIA: Unmatched cancel notification for request id 29042
2024.07.19 19:52:06 INFO  compiling root-test (1 scala source)
2024.07.19 19:52:08 INFO  time: compiled root-test in 1.36s
2024.07.19 19:52:11 INFO  compiling root-test (1 scala source)
2024.07.19 19:52:12 INFO  time: compiled root-test in 1.04s
2024.07.19 19:52:17 INFO  compiling root (2 scala sources)
2024.07.19 19:52:17 INFO  time: compiled root in 0.25s
2024.07.19 19:52:18 WARN  Could not load snapshot text for C:\Users\Vinicius\UnB\FLanguage\src\main\scala\br\unb\cic\flang\MonadState.scala
2024.07.19 19:52:20 WARN  Could not load snapshot text for C:\Users\Vinicius\UnB\FLanguage\src\main\scala\br\unb\cic\flang\MonadState.scala
2024.07.19 19:52:20 WARN  Could not load snapshot text for C:\Users\Vinicius\UnB\FLanguage\src\main\scala\br\unb\cic\flang\MonadState.scala
2024.07.19 19:52:20 WARN  Could not load snapshot text for C:\Users\Vinicius\UnB\FLanguage\src\main\scala\br\unb\cic\flang\MonadState.scala
2024.07.19 19:52:20 WARN  Could not load snapshot text for C:\Users\Vinicius\UnB\FLanguage\src\main\scala\br\unb\cic\flang\MonadState.scala
2024.07.19 19:52:21 WARN  Could not load snapshot text for C:\Users\Vinicius\UnB\FLanguage\src\main\scala\br\unb\cic\flang\MonadState.scala
2024.07.19 19:52:20 WARN  Could not load snapshot text for C:\Users\Vinicius\UnB\FLanguage\src\main\scala\br\unb\cic\flang\MonadState.scala
2024.07.19 19:52:20 WARN  Could not load snapshot text for C:\Users\Vinicius\UnB\FLanguage\src\main\scala\br\unb\cic\flang\MonadState.scala
2024.07.19 19:52:25 INFO  compiling root (2 scala sources)
2024.07.19 19:52:25 INFO  Deduplicating compilation of root from bsp client 'Metals 1.3.3' (since 7h 29m 47.728s)
2024.07.19 19:52:25 INFO  compiling root (2 scala sources)
2024.07.19 19:52:26 INFO  time: compiled root in 0.75s
2024.07.19 19:52:26 INFO  compiling root-test (1 scala source)
2024.07.19 19:52:26 INFO  compiling root-test (1 scala source)
2024.07.19 19:52:26 INFO  time: compiled root-test in 0.68s
jul. 19, 2024 7:53:01 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
ADVERTÊNCIA: Unmatched cancel notification for request id 29219
jul. 19, 2024 7:53:03 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
ADVERTÊNCIA: Unmatched cancel notification for request id 29228
jul. 19, 2024 7:53:04 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
ADVERTÊNCIA: Unmatched cancel notification for request id 29236
jul. 19, 2024 7:53:12 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
ADVERTÊNCIA: Unmatched cancel notification for request id 29275
jul. 19, 2024 7:53:12 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
ADVERTÊNCIA: Unmatched cancel notification for request id 29283
jul. 19, 2024 7:53:13 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
ADVERTÊNCIA: Unmatched cancel notification for request id 29291
jul. 19, 2024 7:53:13 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
ADVERTÊNCIA: Unmatched cancel notification for request id 29297
jul. 19, 2024 7:53:17 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
ADVERTÊNCIA: Unmatched cancel notification for request id 29319
jul. 19, 2024 7:53:18 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
ADVERTÊNCIA: Unmatched cancel notification for request id 29327
jul. 19, 2024 7:53:19 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
ADVERTÊNCIA: Unmatched cancel notification for request id 29335
jul. 19, 2024 7:53:25 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
ADVERTÊNCIA: Unmatched cancel notification for request id 29343
jul. 19, 2024 7:53:37 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
ADVERTÊNCIA: Unmatched cancel notification for request id 29351
jul. 19, 2024 7:53:46 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
ADVERTÊNCIA: Unmatched cancel notification for request id 29369
2024.07.19 19:53:54 INFO  compiling root (2 scala sources)
2024.07.19 19:53:55 INFO  time: compiled root in 1.01s
jul. 19, 2024 7:54:27 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
ADVERTÊNCIA: Unmatched cancel notification for request id 29451
2024.07.19 19:54:28 INFO  compiling root (2 scala sources)
2024.07.19 19:54:28 INFO  time: compiled root in 0.98s
jul. 19, 2024 7:54:45 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
ADVERTÊNCIA: Unmatched cancel notification for request id 29488
jul. 19, 2024 7:54:47 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
ADVERTÊNCIA: Unmatched cancel notification for request id 29503
jul. 19, 2024 7:54:48 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
ADVERTÊNCIA: Unmatched cancel notification for request id 29511
jul. 19, 2024 7:54:50 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
ADVERTÊNCIA: Unmatched cancel notification for request id 29525
jul. 19, 2024 7:55:06 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
ADVERTÊNCIA: Unmatched cancel notification for request id 29533
2024.07.19 19:55:06 INFO  compiling root-test (2 scala sources)
2024.07.19 19:55:08 INFO  time: compiled root-test in 1.33s
jul. 19, 2024 7:55:43 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
ADVERTÊNCIA: Unmatched cancel notification for request id 29546
jul. 19, 2024 7:55:51 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
ADVERTÊNCIA: Unmatched cancel notification for request id 29570
